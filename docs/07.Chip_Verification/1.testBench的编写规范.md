---
title: 01.testBench的编写规范
date: 2025-12-06 10:30:00
permalink: /pages/TB_01/
---

# Verilog TestBench 入门教程（超适合初学者）

## 一、为什么需要 TestBench？

在 FPGA/ASIC 的开发流程中，**TestBench 就是用来测试你写的 Verilog 模块的“仿真脚本”**。
 它的任务很简单：

- 给你的模块 **输入信号**
- 观察 **输出信号**
- 判断模块行为是否正确（用波形或打印）

不用上板，不用烧录，就能提前把 bug 查出来。

只要你写 RTL，就必须会写 TestBench。

------

# 二、TestBench 的基本框架

下面是一份最常见、最基础的 TestBench 模板，初学者只要理解这个结构，就能搞定 90% 的仿真需求。

```verilog
`timescale 1ns/1ps

module tb;

    // ========= 1. 声明信号（输入用 reg，输出用 wire） =========
    reg clk;
    reg rst_n;
    wire [3:0] out;

    // ========= 2. 实例化被测模块 (DUT) =========
    counter4 dut (
        .clk  (clk),
        .rst_n(rst_n),
        .out  (out)
    );

    // ========= 3. 时钟生成 =========
    initial begin
        clk = 0;
        forever #5 clk = ~clk;   // 10ns 一周期
    end

    // ========= 4. 激励任务（给输入信号） =========
    initial begin
        rst_n = 0;       // 上电复位
        #20;
        rst_n = 1;       // 释放复位

        // ……后续可以加更多测试序列

        #200 $finish;    // 结束仿真
    end

    // ========= 5. 可选：监控输出 =========
    initial begin
        $monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);
    end

endmodule
```

------

# 三、框架各个部分说明

下面我用最简单、最人话的解释，把每一步讲清楚。

------

## 1. `timescale`

```verilog
`timescale 1ns/1ps
```

表示：

- 仿真时间单位：1ns
- 时间精度：1ps（用于延迟取整）

这是仿真必写项。

------

## 2. 信号声明（TestBench 的输入用 reg，输出用 wire）

```verilog
reg clk;
reg rst_n;
wire [3:0] out;
```

为什么输入用 `reg`？
 因为 TestBench 自己要给这些信号赋值，赋值只能给 `reg`。

为什么输出用 `wire`？
 因为输出是 DUT 驱动的，不是 TestBench 驱动。

------

## 3. 实例化被测模块（DUT）

```verilog
counter4 dut (
    .clk  (clk),
    .rst_n(rst_n),
    .out  (out)
);
```

TestBench 最核心的一步：
 把你写的模块“放进测试环境里”。

------

## 4. 时钟生成

```verilog
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end
```

这段代码生成一个周期为 10ns 的时钟。
 基本是所有同步逻辑仿真必备。

------

## 5. 激励序列（给输入信号）

```verilog
initial begin
    rst_n = 0;
    #20;
    rst_n = 1;
    #200 $finish;
end
```

- 设置输入信号
- 等待一段时间（用 `#` 延迟）
- 继续设置下一组输入信号
- 最后用 `$finish` 结束仿真

这块就是“TestBench 的灵魂”：你给它什么输入，它就会在波形中跑出对应行为。

------

## 6. 监控打印（可选，但很有用）

```verilog
$monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);
```

波形能看得出来，但有时打印更方便。

------

# 四、完整示例：4 位同步计数器 + TestBench

下面来一个真正能跑的例子 —— 从 RTL 到 TestBench，初学者一看就懂。

------

## ① 计数器模块（counter4.v）

```verilog
module counter4(
    input clk,
    input rst_n,
    output reg [3:0] out
);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            out <= 0;
        else
            out <= out + 1;
    end

endmodule
```

------

## ② TestBench（tb_counter4.v）

```verilog
`timescale 1ns/1ps

module tb_counter4;

    reg clk;
    reg rst_n;
    wire [3:0] out;

    // 实例化DUT
    counter4 dut(
        .clk(clk),
        .rst_n(rst_n),
        .out(out)
    );

    // 时钟
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // 激励
    initial begin
        rst_n = 0;
        #20;
        rst_n = 1;

        // 运行 16 个计数周期
        #200;

        $finish;
    end

    // 监控输出
    initial begin
        $monitor("time=%0t  clk=%b  rst_n=%b  out=%d", 
                    $time, clk, rst_n, out);
    end

endmodule
```

------

# 五、波形应该长这样（逻辑上）

```verilog
rst_n:  _____-----------......
clk  : _-_-_-_-_-_-_-_-_-_....
out  : 0000 0001 0010 ... 1111 再回到 0000
```

只要你看到计数正常累加，就说明 DUT 正常。