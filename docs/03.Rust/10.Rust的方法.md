---
title: 10.Rust的方法
date: 2025-08-23 11:00:00
permalink: /pages/Rust_10/
---

---
title: 10.Rust的方法
date: 2025-08-23 14:00:00
permalink: /pages/Rust_10/
---

# Rust 的方法：让结构体会“做事”

Rust 的方法（methods）就像给结构体装上“功夫技能包”。我们把这些技能写在 `impl` 块里，让实例自己能“点名调用”，逻辑清晰又好用。

---

## 一、方法是什么？

- 方法看起来像函数，但定义在结构体（或枚举、trait）里。
- 它们的第一个参数总是 `self`（能是值、引用或可变引用）。
- 这样你可以通过 `instance.my_method()` 直接调用，就像让结构体自己做事。

源码里是这么写的：定义在 `impl` 块里，方法签名像这样：

```rust
impl TypeName {
    fn method_name(&self, other_arg: T) -> U { ... }
}
```

调用方式是：

```rust
my_instance.method_name(arg);
```

这比每次传 `my_instance` 更省心。

------

## 二、示例场景：点灯的 **LED**

假设我们有一个 `Led` 结构体，代表一盏 LED 灯：

```rust
struct Led { state: bool }

impl Led {
    /// 打开 LED
    fn turn_on(&mut self) {
        self.state = true;
        println!("LED is now ON");
    }

    /// 关闭 LED
    fn turn_off(&mut self) {
        self.state = false;
        println!("LED is now OFF");
    }

    /// 检查 LED 是否处于开启状态
    fn is_on(&self) -> bool {
        self.state
    }
}

fn main() {
    let mut led = Led { state: false };
    led.turn_on();
    println!("LED 当前状态：{}", led.is_on());
    led.turn_off();
}
```

这里有几个要点：

- `turn_on` 和 `turn_off` 使用 `&mut self`，因为它们改变了自己的状态。
- `is_on` 用 `&self`，只是读取，不动结构体内容。
- 调用方式统一用 `led.method()`，语义贴近人类语言：“让 led 做某事”。

------

## 三、方法与函数区别？

- **函数**：通常写在外面，需要明确传参，比如 `fn area(rect: &Rectangle) -> u32`。
- **方法**：写在 `impl` 里，有 `self` 参数，调用更自然，组织也更清晰。

这让代码逻辑像“面向对象”风格：先定义结构体，再赋能一系列方法。

------

## 四、方法签名细节

方法有三种常见签名方式：

1. `fn foo(&self)`
    —— 不改变结构体，只读取内部内容。
2. `fn foo(&mut self)`
    —— 可改变结构体内部状态。
3. `fn foo(self)`
    —— 消费结构体本身（少见），常用于把自己转成别的类型。

例如：

```rust
impl Led {
    fn destroy(self) {
        println!("LED destroyed, state was {}", self.state);
    }
}
```

使用后 `led` 就不能再用了。

------

## 五、关联函数（Associated Functions）：看起来像静态方法

如果不加 `self`，它就不是方法，而是“结构体自己的函数”（常用于创建新实例）：

```rust
impl Led {
    fn new_on() -> Self {
        Led { state: true }
    }
}
```

调用方式：

```rust
let led2 = Led::new_on();
```

像工厂函数，总在结构体里但不作用于实例。
