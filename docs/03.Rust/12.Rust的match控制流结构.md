---
title: 12.Rust的match控制流结构
date: 2025-08-24 06:00:00
permalink: /pages/Rust_12/
---

# Rust 的 `match` 控制流结构：比 `if/else` 更“走心”的分支写法

在 Rust 里，`match` 就像一台「值分类机」：它依次检查每个标签（模式），一旦“刚好合适”，就自动跳进对应处理逻辑里。比起 `if/else`，它更安全、更严谨，也让代码结构更清晰:contentReference[oaicite:0]{index=0}。

---

##  一、`match` 是什么

`match` 可以拿任意类型（尤其是枚举）来做分支判断，不局限于布尔值。用 `match` 能让编译器帮你确保每一种情况都写到了，不会漏。

形象比喻：想象你在自动分拣中心——每个分支是一个洞，值或数据“滑”过去，正好合适哪个洞，就进入哪个分支。

---

## 二、基础示例：枚举 + `match`

假设你有一套“宠物”分类：

```rust
enum Pet {
    Cat,
    Dog,
    Rabbit,
}

fn describe(p: Pet) -> &'static str {
    match p {
        Pet::Cat => "你抓到了一只喵喵～",
        Pet::Dog => "汪汪！一只G狗！",
        Pet::Rabbit => "蹦蹦的兔兔在这里~",
    }
}

fn main() {
    let p = Pet::Rabbit;
    println!("{}", describe(p));
}
```

- `match p` 把 p 的状态拿来对比标签；
- 每个 `=>` 后是该分支的处理结果；
- 你必须写全 `Cat`、`Dog`、`Rabbit` 三种，否则编译不通过。

## 三、多行分支写法

有时候分支逻辑不止一个动作，比如还要打印日志：

```rust
fn count_pet(p: Pet) -> u32 {
    match p {
        Pet::Cat => {
            println!("统计：捕获了一只猫咪");
            4
        }
        Pet::Dog => {
            println!("统计：捕获了一只狗狗");
            3
        }
        Pet::Rabbit => {
            println!("统计：兔兔跑得快");
            2
        }
    }
}
```

- 分支代码块里可以写一堆逻辑；
- 最后一行是被 return 的“值”。

------

## 四、为什么 `match` 更靠谱？

- **必须覆盖所有可能值**（穷尽检查），少了一个分支直接编译报错。
- **结构清晰**，各个分支整齐排列，读着更舒服。
- **灵活表达**，以后你会看到它能和复杂模式结合使用——简直是流程控制的王牌工具[doc.rust-lang.org](https://doc.rust-lang.org/book/ch06-02-match.html?utm_source=chatgpt.com)。

------

## 五、换个例子：辨识数字范围

假如你写个函数，根据数字区间给出评价：

```rust
fn rate(num: i32) -> &'static str {
    match num {
        0 => "零，不动弹",
        1..=5 => "小于等于五",
        6..=10 => "介于六和十之间",
        _ => "大于十",
    }
}
```

- `1..=5` 表示从 1 到 5（包含 5）；
- `_` 是“通配符”，匹配所有剩下的数。

这也体现了 `match` 的强大：区间、默认值一并搞定，写起来简洁又醒目。
