---
title: 15.Rust的Vector
date: 2025-08-28 22:00:00
permalink: /pages/Rust_15/
---

# Rust的Vector

在 Rust 里，如果要存放一系列同类型的元素，最常用的就是 **向量（Vector）**，对应的类型是 `Vec<T>`。它和 C 语言里的数组不同，不仅能存放数据，还能根据需要动态扩展，非常灵活。

## 一、定义向量

定义向量有几种方式：

```rust
// 创建一个空的 i32 类型向量
let mut v: Vec<i32> = Vec::new();

// 使用宏直接创建并初始化
let v = vec![1, 2, 3];
```

第一种方法需要显式声明类型，因为 `Vec::new()` 里没有数据，编译器推不出类型。
 第二种方法更常见，用 `vec![]` 宏直接生成。

------

## 二、向量的修改

向量是可以动态扩展的，常见操作有：

```rust
let mut numbers = Vec::new();
numbers.push(10);
numbers.push(20);
numbers.push(30);
```

这里用 `push` 往里添加元素。
 需要注意：要想修改，就得把向量定义成 `mut`。

------

## 三、访问元素

访问向量里的值有两种方式：

```rust
let v = vec![1, 2, 3, 4];

// 下标访问，直接取值
let third = &v[2];
println!("第三个元素是 {}", third);

// get 方法，更安全
match v.get(2) {
    Some(value) => println!("第三个元素是 {}", value),
    None => println!("没有这个元素"),
}
```

区别在于：

- `v[2]` 如果越界会直接 panic（程序崩溃）。
- `v.get(2)` 返回一个 `Option`，能优雅地处理越界情况。

------

## 四、遍历向量

向量里通常要用循环读取数据：

```rust
let v = vec![100, 200, 300];

// 不可变借用
for i in &v {
    println!("{}", i);
}

// 可变借用，可以修改里面的值
let mut v = vec![1, 2, 3];
for i in &mut v {
    *i += 10;
}
println!("{:?}", v);
```

这里的 `*i` 是解引用，把借用拿到的值修改后写回去。

------

## 五、向量和枚举

向量要求所有元素类型相同，如果想在一个向量里存不同类型，可以借助枚举：

```rust
enum Cell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    Cell::Int(42),
    Cell::Text(String::from("hello")),
    Cell::Float(3.14),
];
```

这样就能在一个 `Vec<Cell>` 里存放不同形式的数据。

## 六、Vector 的释放

Rust 的所有权机制会在向量离开作用域时自动释放内存，包括它里面的元素，不需要手动释放。这就是 Rust 带来的安全性。
