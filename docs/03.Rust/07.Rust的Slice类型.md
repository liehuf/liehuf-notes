---
title: 07.Rust的切片（Slice）
date: 2025-08-21 10:00:00
permalink: /pages/Rust_07/
---

# **Rust 的切片（Slice）**

## 一、切片是什么？

切片（*Slice*）可以理解为：**对集合中某一部分连续元素的引用**。  
比如你有一个大西瓜 🍉，切片就是“我只想要中间那几块”。你不会把整个西瓜搬走，而只是指明：“从第几刀到第几刀之间的那块，给我留着”。

在 Rust 中，切片往往出现在字符串或者数组这种顺序存储的数据结构里。  

一个例子：  

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];   // 从索引0到5（不包含5）
    let world = &s[6..11];  // 从索引6到11（不包含11）

    println!("{}, {}", hello, world);
}

```

上面的 `&s[0..5]` 和 `&s[6..11]` 就是切片。
 注意，切片不是拷贝数据，而是“借”了一部分区域的引用，经济又实惠。

---

## 二、切片的简写方式

切片的语法其实很直观：`[起始..结束]`，但是 Rust 很贴心，提供了多种写法：

```rust
let s = String::from("hello");

// 从头到 2
let slice1 = &s[..2];

// 从 3 到结尾
let slice2 = &s[3..];

// 整个字符串
let slice3 = &s[..];
```

这就好比点菜时：

- `[..2]` = “我要从头上切两片”；
- `[3..]` = “我要从第三片开始到最后”；
- `[..]` = “整个大盘子我都要”。

是不是瞬间有画面感了？(回答：有的，兄弟，有的，这样的画面还有八个！)

------

## 三、切片和字符串字面值

在 Rust 里，字符串字面值（比如 `"hello world"`）其实就是一个切片。
 这也是为什么你看到它的类型是 `&str`，而不是 `String`。

`String` 是堆上分配的可变字符串，而 `&str` 更轻量，本质上是对某段 UTF-8 数据的切片。

```rust
fn main() {
    let s: &str = "hello world";  // s 是一个切片
    println!("{}", s);
}
```

这就好比：

- `String` = 买下一整个蛋糕 🎂，想怎么切怎么切；
- `&str` = 已经切好的蛋糕片 🍰，你直接吃。

------

## 四、切片的威力：first_word 函数

假设我们要写一个函数，返回一句话中的第一个单词。
 如果不用切片，可能会陷入各种复制粘贴麻烦。
 但切片就很优雅：

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let s = String::from("hello world");

    let word = first_word(&s);

    println!("第一个单词是: {}", word);
}
```

思路很简单：

- 把字符串转成字节数组 `as_bytes()`；
- 一边遍历，一边找空格的位置；
- 找到后，直接返回从头到空格之前的那一片切片。

结果就是：`hello`。
 这里切片帮我们避免了数据的拷贝，直接“划块即用”。

------

## 五、小心使用切片

切片很好用，但要记住一点：**切片只是借用，不拥有数据**。
 所以：

- 切片的生命周期不能超过原始数据；
- 切片和原始数据之间要保持一致，不然会出大问题。

换句话说，你不能一边切着吃蛋糕，一边把蛋糕扔了，这样切片就没东西指向了。
