---
title: 06.Rust的引用和借用
date: 2025-08-20 21:00:00
permalink: /pages/Rust_06/
---

# **Rust 的引用和借用**

## 一、引用和借用的基本阐述



**引用**（*reference*）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。

定义并使用一个calculate_length` 函数，它以一个对象的引用作为参数而不是获取值的所有权：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

在上面的代码中， & 符号就是 **引用**，它们允许你使用值但不获取其所有权。

`&s1` 语法让我们创建一个**指向**值 `s1` 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。

---

我们将创建一个引用的行为称为 **借用**（*borrowing*），正如在日常生活中，我们借别人一样东西，迟早是要还的，因为我们没有那件物品的所有权。

同时需要注意，我们不能去修改借用的变量，那样不合法，也不道德。

## 二、可变引用

我们可以通过添加 **mut** 关键字的方式来让引用变得“**可变**”，修改一下代码：

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

这样就可以实现可变了！

---

不过，可变引用有一个很大的缺点，就是同一时间不能存在多个可变引用，或者不能存在可变引用和引用同时存在的情况。

这里，先阐述一下，引用的规则：

- 在任意给定时间，**要么**只能有一个可变引用，**要么**只能有多个不可变引用。
- 引用必须总是有效的。

正如此，下面的两种情况不合法：
```rust
    let mut s = String::from("hello");

    let r1 = &mut s;	// 两次可变引用，答煤油！
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
```



```rust
 let mut s = String::from("hello");

    let r1 = &s; // 没问题		
    let r2 = &s; // 没问题
    let r3 = &mut s; // 大问题，鱼与熊掌不可兼得

    println!("{}, {}, and {}", r1, r2, r3);
```

## 三、悬垂引用（Dangling References）

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个**悬垂指针**（*dangling pointer*）—— 指向可能已被分配给其他用途的内存位置的指针。

相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

简而言之，就是不能返回一个孤寡老人，下面的代码可以帮助理解：
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s	// s的生命周期结束，但是这个函数返回了s的指针？ 显然，十分有十一分的不合法！
}
```

