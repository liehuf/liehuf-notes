---
title: 05.Rust的所有权概念
date: 2025-08-19 12:00:00
permalink: /pages/Rust_05/
---

# Rust 的所有权概念

Rust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 Rust 安全性与效率关键的一步。  

---

## 所有权三原则

Rust 的所有权机制围绕三条核心规则：

1. 每一个值都有一个叫“所有者”的变量。  
2. 在同一时间，值只有一个所有者。  
3. 当所有者离开作用域，值会被自动释放（drop）。  

---

## 作用域与资源自动释放

作用域决定变量何时“消失”，从而决定资源何时释放，例如：

```rust
{
    let s = String::from("hello");
    // s 在此作用域内有效
}
// 出了作用域，s 被 drop，内存自动释放
```

这一行为像是给变量包了自动回收机制，无需显式调用释放函数。

## 栈与堆的区别

要理解所有权机制，需要先理解 **栈（stack）和堆（heap）** 的内存管理方式。

- **栈（Stack）**
  - 特点：存取速度快，后进先出（LIFO）。
  - 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。
  - 生命周期：作用域结束自动弹出，无需手动管理。
- **堆（Heap）**
  - 特点：存取灵活，但分配和回收开销更大。
  - 存放：大小未知或运行期才确定的数据，例如 `String`、`Vec`。
  - 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 Rust 自动释放。

对比示例：

```rust
let x = 10;                  // 存在栈上
let s = String::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据
```

这里的关键点：

- `x` 是整数，直接放在栈上，访问快，作用域结束就弹出。
- `s` 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 `"hi"` 字符串内容在堆上，释放时 Rust 会自动清理堆内存。

因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。

------

## 移动（Move）与非 Copy 类型

默认情况下，非 Copy 的类型会发生“所有权转移”（move）：

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被移动给 s2
// println!("{}", s1); // ❌ 编译错误：s1 无效
```

这意味着堆上的数据只有一个负责人，防止多个变量同时持有同一堆内存，避免错误释放或重复访问。

------

## Copy 类型与深度克隆（Clone）

对于简单类型（如整数、布尔等），它们实现了 `Copy` trait，可以直接复制，而不移动：

```rust
let x = 5;
let y = x; // x 是 Copy 类型，依然有效
println!("{}", x); // OK
```

如果你需要让非 Copy 类型（比如 `String`）也能被复制，你可以显示使用 `.clone()`：

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 深拷贝数据到 s2
println!("{}, {}", s1, s2); // 两者都有效
```

Clone 相当于自己写“备份”，性能开销需斟酌。([course.rs](https://course.rs/basic/ownership/ownership.html?utm_source=chatgpt.com), [cnblogs.com](https://www.cnblogs.com/traditional/p/15371794.html?utm_source=chatgpt.com))

------

## 拷贝与引用的对比（简明示例）

```rust
let s = String::from("rust");
let s2 = s;         // 移动：s 无效，s2 有所有权
let x = 42;
let y = x;          // Copy：x 仍然有效

let s = String::from("hi");
fn take_ownership(s: String) {
    println!("{}", s);
} // s 在此 drop

take_ownership(s);
// println!("{}", s); // 错误：已经失去所有权
```

总结：

- `move` 会让原变量失效（所有权转移）。
- `Copy` 类型不会。
- 要保留值，可用 `clone` 手动拷贝。