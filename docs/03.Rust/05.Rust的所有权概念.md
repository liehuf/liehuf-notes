---
title: 05.Rust的所有权概念
date: 2025-08-19 12:00:00
permalink: /pages/Rust_05/
---

# Rust 的所有权概念

Rust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 Rust 安全性与效率关键的一步。  

---

## 一、栈与堆的区别

要理解所有权机制，需要先理解 **栈（stack）和堆（heap）** 的内存管理方式。

- **栈（Stack）**
  - 特点：存取速度快，后进先出（LIFO）。
  - 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。
  - 生命周期：作用域结束自动弹出，无需手动管理。
- **堆（Heap）**
  - 特点：存取灵活，但分配和回收开销更大。
  - 存放：大小未知或运行期才确定的数据，例如 `String`、`Vec`。
  - 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 Rust 自动释放。

对比示例：

```rust
let x = 10;                  // 存在栈上
let s = String::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据
```

这里的关键点：

- `x` 是整数，直接放在栈上，访问快，作用域结束就弹出。
- `s` 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 `"hi"` 字符串内容在堆上，释放时 Rust 会自动清理堆内存。

因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。

------

## 二、所有权三原则

Rust 的所有权机制围绕三条核心规则：

1. 每一个值都有一个“==所有者==”(owner)。  
2. 在同一时间，值只有一个所有者。  
3. 当所有者离开作用域，值会被丢弃或者说==自动释放==（drop）。  

---

## 三、作用域与资源自动释放

作用域决定变量何时“消失”，从而决定资源何时释放，例如：

```rust
{
    let s = "hello";
    // s 在此作用域内有效
}
// 出了作用域，s 被 drop，内存自动释放
```

这一行为像是给变量包了自动回收机制，无需显式调用释放函数。

------

## 四、String类型

我们可以通过如下的代码创建一个String。

```rust
let mut s = String::from("hello, world!");
```

通常情况下，计算机不允许一个在运行之前不知道值或者在运行之后值会改变的变量被放到二进制文件之中，所以，我们使用==String==类型。

对于 `String` 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

- 必须在运行时向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法。

前一个部分由程序员自己完成，而后面一个部分，Rust会自己动，就比如：
```rust
{
	let s = String::from("hello");
	// 这里s有效    
}
// 这里s就失效了，因为作用域已经结束
```

