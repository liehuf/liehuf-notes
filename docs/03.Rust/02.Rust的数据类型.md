---
title: 02.Rust的数据类型
date: 2025-08-18 11:12:00
permalink: /pages/Rust_02/
---

# **Rust 的数据类型：给每个值找个“身份”**

在 Rust 中，每一个值都带着标签——类型（data type），告诉编译器怎么处理它。

这就是 Rust 的静态类型特性，让错误在编译期被挡在门外：contentReference[oaicite:0]{index=0}

---

##  1. 静态类型与类型推断

Rust 是静态类型语言，意味着所有变量的类型必须在 **编译时知道**。但你通常不用写在代码里，Rust 编译器会自动推断出来：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果不写 `: u32`，编译器会报错说无法推断类型，需要你给个明示才行。
## 2. 标量类型（Scalar Types）

标量类型代表单一数值或字符。主要有四类：

### 整型（Integer）

Rust 支持多种整型，每种定大小、有符号或无符号，含 `i8`, `u8`, …, `i128`, `u128`, 还有根据平台决定大小的 `isize` / `usize`。

| 类型                     | 用途说明             |
| ------------------------ | -------------------- |
| `i*`（*代表8、16、32...) | 有符号整数           |
| `u*`                     | 无符号整数           |
| `isize/usize`            | 用于索引，依平台不同 |

字面量写法也很灵活，比如 `66u8`、`3_000`、`0xee、`0b1010_0101` 等，直观易读

### 浮点型（Floating-Point）

Rust 有 `f32` 和 `f64`，默认的是 `f64`，因为现代 CPU 上运算速度差不离，但精度更高。

```rust
let x = 2.0;          // f64
let y: f32 = 3.0;     // f32，必须显式标注
```

### 数值运算（Computing）

Rust的所有类型数据都支持运算，整数的运算一般会有取舍。

```rust
    let sum = 5 + 10;	// 加法
    let difference = 95.5 - 4.3;	// 减法 
    let product = 4 * 30;	// 乘法
    let quotient = 56.7 / 32.2;	// 正常除法
    let truncated = -5 / 3; // 整除，结果为 -1
    let remainder = 43 % 5;	// 取余
```

### 布尔型（Boolean）

只有两个值：`true` / `false`，类型是 `bool`，占一个字节，与其他语言一样，用于控制流中的==条件表达式==。

```rust 
let t = true;
let f: bool = false;
```

### 字符型（Character）

Rust的字符型是非常^6^的，因为它使用的是Unicode编码，类型的大小为四个字节 (four bytes)，而不是传统的阿斯克码，所以，它可以表示任何字符，任何语言的字符！

我们用单引号声明 `char` 字面值，而与之相反的是，使用双引号声明字符串字面值。

```rust
// 以下字符型变量全是合法的
let c = 'c';
let z: char = 'ℤ'; 
let wink = '😉';
```



------

## 3. 复合类型（Compound Types）

Rust 有两个原生的复合类型：元组（tuple）和数组（array）。

- **元组（Tuple）**：类型可以不同，长度固定，用 `(a, b)` 定义，访问靠 `.0`, `.1`。
- **数组（Array）**：类型相同，长度固定，用 `[T; N]` 定义，访问靠索引。

它们是构建更复杂结构的基础，适合包裹多个相关值。

#### 3.1 元组（Tuple）

**定义**：元组把多种类型的若干值打包成一个整体，**长度固定**、**元素可异构**（各元素类型可不同）。

#### 3.1.1 创建与类型标注

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let mixed = ("ok", 3.14, true);
let single = (42,);     // 单元素元组：注意结尾的逗号
let not_tuple = (42);   // 这只是 42 本身，不是元组
```

> 工程要点：**单元素元组**必须带逗号 `(42,)`，否则就是普通值。

#### 3.1.2 解构（Destructuring）

```rust
let (x, y, z) = tup;  // 模式匹配式解构
println!("{x}, {y}, {z}");
```

- 解构会“按位”绑定新变量，**仍然整体所有权转移**（或拷贝，取决于元素是否 `Copy`）。

#### 3.1.3 索引访问

```rust
let a = tup.0;  // 500
let b = tup.1;  // 6.4
```

- **编译期**检查索引是否在范围内（超界直接编译失败）。

#### 3.1.4 单位类型（Unit Type）`()`

- `()` 是一个**特殊的 0 长度元组**，读作 *unit*。

- 含义：**“没有有意义的值”**，常见于函数不返回值的情况（返回 `()`），或语句表达式的值。

  ```rust
  let x = ();        // x 的类型是 ()
  fn log() { }       // 等价 fn log() -> () { }
  ```

### 3.2 数组（Array）

**定义**：数组是**同类型元素**、**长度固定**、**在栈上连续存储**的序列，类型写作 `[T; N]`。

> 工程要点：长度 `N` 是**类型**的一部分——`[u8; 3]` 与 `[u8; 4]` 是不同的类型。

#### 3.2.1 创建与类型标注

```rust
let a = [1, 2, 3, 4, 5];               // 推断为 [i32; 5]
let b: [i32; 3] = [10, 20, 30];        // 显式类型
let c = [0; 8];                         // 重复语法：等价 [0,0,0,0,0,0,0,0]
let empty: [u8; 0] = [];                // 零长数组也合法
```

#### 3.2.2 索引与边界检查

```rust
let first = a[0];
let last  = a[a.len() - 1];

// 越界会在**运行时 panic**
// let x = a[999]; // 运行时触发 “index out of bounds”
```

- Rust 对数组**索引运行时检查**，避免越界 UB（未定义行为）。
