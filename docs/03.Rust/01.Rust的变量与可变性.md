---
title: 01.Rust的变量与可变性
date: 2025-08-18 10:55:00
permalink: /pages/Rust_01/
---

# **Rust 的变量与可变性：设计安全的第一步**

Rust 与传统语言不同，它默认把所有变量锁住——不许轻易变。这种默认不可变设计帮你挡下 Pointer Bug 和数据竞态，是现代系统语言的本分。

---

##  1. 为什么变量默认不可变？

| 设计选择   | 优势                           | 说明                                                         |
| ---------- | ------------------------------ | ------------------------------------------------------------ |
| 默认不可变 | 消灭意外修改，代码更安全可推导 | Rust 编译器帮你保障“一旦设定，不会悄悄改变” :contentReference[oaicite:0]{index=0} |
| 显示可变   | 写意且受控，修改行为更加明确   | 必须写 `mut`，才能修改变量 :contentReference[oaicite:1]{index=1} |

比如：

```rust
let x = 1;
println!("x 是 {}", x);
x = 2; // 编译报错：cannot assign twice to immutable variable `x`
```

这是因为 x 默认不可变。改用：

```rust
let mut x = 5;
println!("x 是 {}", x);
x = 6; // OK，编译器允许
```

你把==“可变性”==明确标注出来，方便自己也方便团队理解。

## 2. 常量：永远静止的一块值

常量 (`const`) 与变量类似，但从来不可变，而且必须显式写类型，初始化值也只能是编译期已知的常量表达式：

```rust
const Pi: u32 = 3.1415926;
```

- **永久不变**，且不可加 `mut`。
- **类型必标注**，编译时代入计算结果。
- 在任何作用域都有效，适合定义全局不变参数。

## 3. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量

Rust 允许使用 `let` 重复定义变量名称，旧的就被“遮蔽”了。这与可变或常量不同，是创造新变量：

```rust
let x = 5;
let x = x + 1;         // x 变成 6
{
    let x = x * 2;     // 内部作用域里 x 是 12
    println!("内层 x = {x}");
}
println!("外层 x = {x}"); // x 回退为 6
```

遮蔽的好处：

- 不用 `mut`，还能变值；
- 支持改变类型，如把字符串变成数值，复用变量名更干净。 [doc.rust-lang.org](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html?utm_source=chatgpt.com)
