---
title: HDL01.Verilog HDL 时序电路的基本元件设计
date: 2025-08-13 16:00:00
permalink: /pages/Verilog_01/
---

# Verilog HDL：时序电路的基本元件设计

本文汇总并整理了常见的时序电路基本元件：触发器（D、T）、计数器、移位寄存器与序列/信号发生器的常用实现与设计要点。目标是给出工程友好的 Verilog 模块模板与设计注意事项，便于快速上手与复用。

**关键思想**：时序电路 = 组合逻辑 + 存储元件（触发器）。时钟边沿同步所有状态更新，复位策略（同步/异步）与时钟域设计决定可靠性与复杂度。

--

## 1. 基本触发器

### 1.1 D 触发器（基础版）

最常见的存储单元，时钟边沿把 `d` 采样到 `q` 并保持。

```verilog
module d_ff_basic (
    input  wire clk,
    input  wire data_in,
    output reg  q
);
    always @(posedge clk) begin
        q <= data_in;
    end
endmodule
```

### 1.2 同步复位与异步复位

- 同步复位（`rst_n` 在时钟边沿生效）：复位动作与数据更新对齐，行为更可预测，但需要等时钟。
- 异步复位（`rst_n` 立即生效）：快速清零，释放时需做去抖与同步以避免亚稳态。

示例：同步复位与异步复位的 DFF

```verilog
module d_ff_sync_rst (
    input  wire clk,
    input  wire rst_n,
    input  wire data_in,
    output reg  q
);
    always @(posedge clk) begin
        if (!rst_n)
            q <= 1'b0;
        else
            q <= data_in;
    end
endmodule

module d_ff_async_rst (
    input  wire clk,
    input  wire rst_n,
    input  wire data_in,
    output reg  q
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 1'b0;
        else
            q <= data_in;
    end
endmodule
```

> 设计要点：若使用异步复位，务必在复位释放后将重要信号做同步处理，避免亚稳态传播。

### 1.3 T 触发器

用于分频与计数，T=1 时翻转状态，T=0 时保持。

```verilog
module t_ff (
    input  wire clk,
    input  wire rst_n,
    input  wire T,
    output reg  q
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 1'b0;
        else if (T)
            q <= ~q;
    end
endmodule
```

--

## 2. 计数器

计数器是最常见的时序控制元件，可用于分频、延时、地址生成等。

### 2.1 一位二进制计数器（分频器）

```verilog
module counter_1bit (
    input  wire clk,
    output reg  Q
);
    always @(posedge clk) begin
        Q <= ~Q; // 分频 / 翻转
    end
endmodule
```

### 2.2 模 M 计数器

设计步骤：确定需要的位数 N（满足 $2^{N} > M$），计数到 M-1 后清零。

```verilog
module counter_modM #(
    parameter M = 10
) (
    input  wire clk,
    input  wire rst_n,
    output reg  [$clog2(M)-1:0] count
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            count <= 0;
        else if (count == M-1)
            count <= 0;
        else
            count <= count + 1;
    end
endmodule
```

> 注：在综合与时序分析时，避免把大宽度加法或比较放在异步路径上，尽量使用流水或分频级联来减轻组合逻辑负担。

--

## 3. 移位寄存器

移位寄存器用于数据延迟、串并转换、序列检测与生成等。

### 3.1 环形（循环）移位寄存器

```verilog
module shift_reg_ring (
    input  wire clk,
    input  wire rst_n,
    input  wire [3:0] D_init,
    output reg  [3:0] D
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            D <= D_init;
        else
            D <= {D[2:0], D[3]};
    end
endmodule
```

### 3.2 线性反馈移位寄存器（LFSR）

LFSR 是低资源的伪随机序列生成器，反馈函数取决于多项式。用于测试、加扰与随机化。

```verilog
module lfsr_4 (
    input  wire clk,
    input  wire rst_n,
    output reg [3:0] q
);
    wire feedback = q[3] ^ q[2]; // 示例反馈，具体多项式按需求选择
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 4'b0001;
        else
            q <= {q[2:0], feedback};
    end
endmodule
```

--

## 4. 序列 / 信号发生器

常见实现方式：移位寄存器型、反馈组合型（如 LFSR）、计数器型。选择依据为资源、序列长度与复杂度。

### 4.1 移位寄存器型（按位存储并移出）

```verilog
module seq_gen_shift #(
    parameter N = 8
) (
    input  wire clk,
    input  wire rst_n,
    input  wire [N-1:0] seq_init,
    output wire seq_out
);
    reg [N-1:0] shift_reg;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= seq_init;
        else
            shift_reg <= {shift_reg[N-2:0], shift_reg[N-1]};
    end
    assign seq_out = shift_reg[N-1];
endmodule
```

### 4.2 反馈组合型（以 LFSR 为例）

见前面 LFSR 示例。反馈型优点是用很少的触发器可产生很长的序列。

### 4.3 计数器型（查表输出）

适用于需要任意、非线性序列时：用计数器做地址，再用 case/ROM 输出序列位。

```verilog
module seq_gen_counter #(
    parameter M = 8
) (
    input  wire clk,
    input  wire rst_n,
    output reg  seq_out
);
    reg [$clog2(M)-1:0] cnt;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            cnt <= 0;
        else if (cnt == M-1)
            cnt <= 0;
        else
            cnt <= cnt + 1;
    end
    always @(*) begin
        case (cnt)
            0: seq_out = 1'b1;
            1: seq_out = 1'b0;
            2: seq_out = 1'b1;
            3: seq_out = 1'b1;
            4: seq_out = 1'b0;
            5: seq_out = 1'b0;
            6: seq_out = 1'b1;
            7: seq_out = 1'b1;
            default: seq_out = 1'b0;
        endcase
    end
endmodule
```

--

## 5. 设计要点小结

- 明确复位策略（同步 vs 异步），并对异步复位释放做同步处理。
- 将复杂的组合逻辑从时钟路径中剥离，必要时做流水或拆分时钟域。
- 使用参数化（`parameter`、`$clog2`）提高模块可复用性。
- LFSR 与移位寄存器适合低成本序列生成，计数器+查表适合任意序列。
