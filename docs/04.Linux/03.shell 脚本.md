---
title: 03.shell 脚本
date: 2025-09-28 10:00:00
permalink: /pages/Linux_03/
---

# Shell 脚本（Bash）

------

## 0. 约定与开头（shebang / 执行环境）

```shell
#!/usr/bin/env bash
set -euo pipefail
```

- `#!/usr/bin/env bash`：更可移植，按 `PATH` 找 bash；相比 `/bin/bash` 更适用于共享脚本。
- `set -euo pipefail`：
  - `-e`：任何命令返回非0则脚本退出（避免忽略错误）。
  - `-u`：未定义变量报错（避免拼写类 bug）。
  - `-o pipefail`：管道中任一命令失败时返回失败（对管道很重要）。

------

## 1. 变量（Var）：分类、命名规则与使用

### 1.1 变量的 “三类” 概念

- **系统变量（system variables）**：由操作系统/Shell 提供，通常大写，例如 `PATH`, `HOME`, `SHELL`, `UID`, `PWD`。
- **环境变量（environment variables）**：对当前 shell 及其子进程有效。通过 `export VAR=value` 设置/导出。
- **用户（shell）变量 / 局部变量**：仅在当前 shell（或函数）中有效，不会自动传递给子进程，通常不导出。

### 1.2 命名规则

- 只能包含字母、数字和下划线 `_`。
- 不能以数字开头（例如 `1var` 错误）。
- 推荐使用小写做脚本内部变量（例如 `log_file`），系统/环境变量仍用大写（`PATH`、`HOME`）。
- 避免覆盖已有 shell 变量（例如 `PATH`、`HOME`、`IFS` 等），如果需要，先了解其含义。

### 1.3 赋值与引用

```shell
name="ikun"        # 赋值（注意：等号两边不能有空格）
echo "$name"      # 引用（双引号推荐）
```

- 经过双引号 `"$var"` 的引用会保留空格并避免字段分裂。
- 单引号 `'...'` 会完全禁止变量替换；双引号 `"...""` 会允许替换但保留空格。

### 1.4 导出环境变量

```shell
export MYVAR="hello"
# 在当前 shell 中可见，并传递给子进程
```

查看环境变量：

- `env` 或 `printenv` 或 `export -p`

### 1.5 特殊/位置变量（常用）

- `$0`：脚本名
- `$1`, `$2`, ...：第 1、第 2 个参数
- `$#`：参数个数
- `"$@"`：按独立参数扩展（推荐循环时使用）
- `"$*"`：合并成一个字符串（通常不如 `"$@"` 安全）
- `$?`：上一个命令返回值（退出状态）
- `$$`：当前 shell 的 PID
- `$!`：上一个后台进程的 PID
- `$PWD` / `$OLDPWD`：当前/上一个目录
- `$UID`：当前用户 id

------

## 2. 变量扩展（parameter expansion）——强烈建议掌握

参数扩展极其强大，以 `${...}` 形式为主：

- `${var:-default}`：如果 `var` 未定义或为空，则返回 `default`（不赋值）。
- `${var:=default}`：如果 `var` 未定义或为空，则把 `default` 赋给 `var` 并返回它。
- `${var:+alt}`：如果 `var` 已定义且非空，返回 `alt`，否则返回空。
- `${var:?err}`：如果 `var` 未设置或为空，则打印 `err` 并退出（常用于必需变量检查）。
- `${#var}`：字符串长度。
- `${var:offset:length}`：子串（类似 Python 切片）。
- `${var#pattern}` / `${var##pattern}`：从左删最短/最长匹配（前缀）。
- `${var%pattern}` / `${var%%pattern}`：从右删最短/最长匹配（后缀）。
- `${var//search/replace}`：全局替换（字符串）。

示例：

```shell
: "${LOG_DIR:=/var/log/myapp}"  # 如果未设置则赋默认值
echo "${FILENAME%.*}"          # 去掉文件扩展名
```

------

## 3. 引号与命令替换（务必谨记）

- **单引号 `'...'`**：完全原样，不做变量替换。
- **双引号 `"...""`**：变量和命令替换会发生，但空格不会被分割。
- **无引号**：字段会被 word-splitting（按 IFS）和 glob（通配符）扩展——危险。
- **命令替换**：
  - `$(command)` 推荐（可嵌套、易读）
  - ``command`` 旧式语法，复杂时容易出错

例：

```shell
files="$(ls -1 *.log)"
echo "There are $(wc -l < "$file") lines in $file"
```

------

## 4. 数组（Bash 特性）

声明与访问：

```shell
declare -a arr=("one" "two" "three")
echo "${arr[0]}"         # one
echo "${arr[@]}"         # 所有元素（每个作为独立字段）
echo "${#arr[@]}"        # 元素个数
```

遍历：

```shell
for v in "${arr[@]}"; do
  echo "$v"
done
```

------

## 5. 算术计算

- 使用 `$(( ... ))` 或 `let`：

```shell
x=3
y=$(( x + 5 ))
count=$((count+1))
```

- 注意整数与浮点：Bash 本身只支持整数。浮点需用 `bc`、`awk` 或 `python`。

------

## 6. 条件判断：`[ ]` vs `[[ ]]` vs `test`

- `[ expr ]` 是 POSIX test，`[[ expr ]]` 是 bash 扩展（更强，支持正则运算符 `=~`，不需要大量转义）。
- 常用文件测试：
  - `-f file`：普通文件存在
  - `-d dir`：目录存在
  - `-r file`：可读、`-w` 可写、`-x` 可执行
- 字符串测试：
  - `-z str`：为空
  - `-n str`：非空
  - `str1 = str2` 或 `==`（在 `[[ ]]`）
- 数值测试：
  - `-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`
- 示例：

```shell
if [[ $name =~ ^[a-z][a-z0-9_]+$ ]]; then
  echo "valid"
fi
```

------

## 7. 循环、`break` 与 `continue`

### 循环结构

- `for var in list; do ... done`
- `while condition; do ... done`
- `until condition; do ... done`（直到条件为真时停止）

### `break` 与 `continue`

- `break`：跳出当前循环；`break N`：跳出 N 层嵌套循环（Bash 支持）。
- `continue`：跳到当前循环的下次迭代；`continue N`：跳过 N 层循环的当前迭代（通常用 `continue`）。

示例（嵌套循环 + break/continue）：

```shell
for i in {1..3}; do
  for j in {a..c}; do
    if [[ "$i$j" == "2b" ]]; then
      echo "found 2b -> break 2"
      break 2      # 跳出外层和内层
    fi
    if [[ "$j" == "a" ]]; then
      continue    # 内层继续下一次 j
    fi
    echo "$i $j"
  done
done
```

------

## 8. 函数（组织脚本逻辑的最好方式）

```shell
greet() {
  local name="$1"     # local 防止污染外部变量
  echo "Hello, $name"
}

result=$(greet "ikun")  # 函数可以 echo 输出作为返回值
```

- `return N`：返回整数退出码（0 表示成功）；想返回字符串用 `echo` 并捕获。

------

## 9. I/O、重定向、管道与 here-doc

- `>` 覆盖写；`>>` 追加写
- `2>` 单独重定向 stderr；`&>` 同时重定向 stdout/stderr（非 POSIX）
- `cmd1 | cmd2` 管道。使用 `set -o pipefail` 以确保管道失败传播。
- Here-doc：

```shell
cat <<'EOF' > file.txt
多行文本，变量不替换（因为用单引号）
EOF
```

------

## 10. `echo` vs `printf`

- `echo`：简单打印，行为随 shell 版本和 `-e` 标志不同（`\n`, `\t` 等）。
  - `echo -n`：不输出末尾换行
  - `echo -e`：解释转义（不总是可移植）
- `printf`：推荐用于可移植、格式化输出：

```shell
printf "Name: %s\tScore: %d\n" "Alice" 92
```

------

## 11. 错误处理、`trap` 与清理

- `trap 'handler' EXIT`：无论怎样退出都会执行 handler（可用于清理临时文件）。
- 捕获信号：

```shell
trap 'echo "Interrupted"; exit 2' INT TERM
```

------

## 12. 常用工具/安全建议（最佳实践）

- 在脚本头使用 `set -euo pipefail`。
- 使用双引号引用变量 `"$var"`。
- 对外部命令结果做检查（不要盲信成功）。
- 用 `mktemp` 创建临时文件，使用 `trap` 清理。
- 对输入参数做校验并提供 `usage()`。
- 对用户可见的信息用 `printf` 而非 `echo`（格式更稳定）。

------

## 13. 参数解析：`getopts`（推荐）示例

```shell
# getopt style parsing using getopts
while getopts ":f:k:h" opt; do
  case $opt in
    f) logfile="$OPTARG" ;;
    k) keyword="$OPTARG" ;;
    h) echo "usage..."; exit 0 ;;
    \?) printf "Invalid option -%s\n" "$OPTARG" ; exit 1 ;;
  esac
done
shift $((OPTIND-1))
```

------

## 14. 典型脚本模板（可拷贝到任何项目）

```shell
#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<EOF
Usage: $(basename "$0") -f logfile [-k keyword]
EOF
}

logfile=""
keyword="ERROR"

while getopts ":f:k:h" opt; do
  case $opt in
    f) logfile="$OPTARG" ;;
    k) keyword="$OPTARG" ;;
    h) usage; exit 0 ;;
    \?) echo "Invalid option -$OPTARG" >&2; usage; exit 1 ;;
  esac
done

if [[ -z "${logfile}" ]]; then
  echo "logfile required"
  usage
  exit 1
fi

trap 'echo "Cleaning up"; rm -f "$tmpfile"' EXIT

# main logic...
```

------

## 15. 综合实例（把上面要点都串起来） — `robust_log_tool.sh`

> 这是一个“工程化”脚本范例，演示变量（含默认/环境变量）、引用、函数、数组、循环、break/continue、trap、导出、`getopts`、`printf`、以及日志处理实战。

```shell
#!/usr/bin/env bash
set -euo pipefail

# 默认配置（可由环境变量覆盖）
: "${LOGFILE:=${1:-./app.log}}"
: "${ARCHIVE_DIR:=./log_archive}"
: "${SIZE_LIMIT:=1048576}"   # 1 MB default

usage() {
  cat <<EOF
Usage: $(basename "$0") [-f logfile] [-s size_limit_bytes]
Environment:
  LOGFILE    default: ./app.log or first positional arg
  ARCHIVE_DIR default: ./log_archive
EOF
}

# 参数解析（简单示例）
while getopts ":f:s:h" opt; do
  case $opt in
    f) LOGFILE="$OPTARG" ;;
    s) SIZE_LIMIT="$OPTARG" ;;
    h) usage; exit 0 ;;
    \?) echo "Invalid option -$OPTARG" >&2; usage; exit 1 ;;
  esac
done

# 依赖检查
command -v gzip >/dev/null 2>&1 || { echo "gzip required"; exit 1; }

# 函数：归档日志（如果过大）
archive_log() {
  local file="$1"
  local dir="$2"
  mkdir -p "$dir"
  local ts
  ts=$(date +"%Y%m%dT%H%M%S")
  local base
  base=$(basename "$file")
  mv "$file" "${dir}/${base}.${ts}"
  gzip -f "${dir}/${base}.${ts}"
  printf "Archived %s -> %s/%s.%s.gz\n" "$file" "$dir" "$base" "$ts"
}

# 函数：统计并打印基本信息
summarize_log() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    echo "No log file: $file"
    return 0
  fi
  printf "Summary for %s\n" "$file"
  printf "  Lines: %d\n" "$(wc -l < "$file")"
  printf "  ERROR: %d\n" "$(grep -c -E 'ERROR|error' "$file" || true)"
  printf "  WARN: %d\n" "$(grep -c -E 'WARN|warn|WARNING' "$file" || true)"
}

# 主逻辑：如果文件大于 SIZE_LIMIT 则归档
if [[ -f "$LOGFILE" ]]; then
  size=$(stat -c%s "$LOGFILE")
  if (( size > SIZE_LIMIT )); then
    archive_log "$LOGFILE" "$ARCHIVE_DIR"
    # 创建新的空文件
    : > "$LOGFILE"
  fi
fi

# 遍历日志，演示 break/continue：
# 找到第一个 ERROR 就停止（break），跳过 DEBUG lines（continue）
if [[ -f "$LOGFILE" ]]; then
  while IFS= read -r line; do
    # skip empty lines
    [[ -z "$line" ]] && continue
    # skip debug
    if [[ "$line" =~ DEBUG ]]; then
      continue
    fi
    echo "LINE: $line"
    if [[ "$line" =~ ERROR|error ]]; then
      echo "Found first error, stopping scan."
      break
    fi
  done < "$LOGFILE"
fi

# 最后打印摘要
summarize_log "$LOGFILE"
```

- 说明：
  - `: > "$LOGFILE"` 用来重建或清空文件（冒号是个 no-op command）。
  - `stat -c%s` 用于获取文件字节大小（Linux）。
  - `grep -c ... || true` 以防找不到匹配导致非0退出（因为 `set -e`）。