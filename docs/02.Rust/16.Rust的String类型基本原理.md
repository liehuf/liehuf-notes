---
title: 16.Rust的String类型基本原理
date: 2025-08-28 23:00:00
permalink: /pages/Rust_16/
---

# Rust 的 String 类型基础：为什么它既强大又狡猾？

Rust 的 `String` 可变又可增长，背后是 UTF-8，加上 Rust 注重安全，这玩意看似简单实则复杂。掌握它，你就能像撸 cursor 一样骄傲地“管住”自己的字符串，工程师体验极佳。

---

##  一、String 是什么？

- 核心语言只有一种“字符串 slice”类型：`str`，只能以 `&str` 的形式出现。
- `String` 是标准库提供的动态、可变、拥有所有权的 UTF-8 字符串，底层其实就是一个 `Vec<u8>`。
- 换句话说：**`String` = 动态字节数组 + UTF-8 智能**。

---

## 二、怎么创建 String？

```rust
let mut s = String::new(); // 空字符串

let s = "hello".to_string();            // 从 &str 转换
let s = String::from("hello, world");   // 一样的效果

```

这两种方式功能相同，喜欢风格选一种就好。

## 三、如何更新 String？

你想给它加内容，可以这么干：

```rust
let mut s = String::from("foo");
s.push_str("bar");  // 加字符串 slice
s.push('!');        // 加一个字符
```

你看这是在操作 `Vec<u8>`，只有你想追加时才真的改底层，效率杠杠的。

------

## 四、拼接要当心

拼字符串挺常见，但写得不小心就容易踩坑：

```rust
let a = String::from("Hello, ");
let b = String::from("world!");
let c = a + &b; // a 被移动掉，之后不能再用 a 了
```

别忘了加 `&b`，Rust 会把 `&String` 自动转成 `&str`（叫 deref coercion），但 `a` 会被消费掉 —— 这是效率和所有权设计的结果。

写得更清晰的方法是：

```rust
let c = format!("{a}-{b}-{a2}");
```

这样既不会动所有权，也更直观。

------

## 五、为什么不能像索引数组那样索引 String？

尝试下面代码，你会碰壁：

```rust
let s = String::from("你好");
let c = s[0]; // 直接索引会编译报错
```

原因在于：

- 字符不是整齐排列的，每个字符在 UTF-8 下字节长度不定；
- Rust 的索引期望 O(1) 访问，但为了找到一个字符，必须遍历到相应字节 —— 没法保证常数时间；
- 为防出 bug，索引被禁止写入内核。

------

## 六、如果你真的想访问字符怎么办？

明确告诉 Rust：我是按字符访问：

```rust
for c in "你好".chars() {
    println!("{c}");
}
```

如果你想看字节值：

```rust
for b in "你好".bytes() {
    println!("{b}");
}
```

两种表达方式清晰又安全。
