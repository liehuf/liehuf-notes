---
title: FPGA 03.我与 PWM 的爱恨情仇
date: 2026-02-05 12:00:00
permalink: /pages/FPGA_03/
---

本博客用于记录我在 FPGA 上学习、理解并最终“想通” PWM（脉冲宽度调制）的全过程。  
这不是一篇教程，而是一篇**阶段性认知总结**。

---

## 一、重新认识 PWM

PWM，全称 Pulse Width Modulation，中文叫**脉冲宽度调制**。

如果用一句工程味十足的话来说：

> PWM 本质上不是在“输出一个模拟量”，  
> 而是在**用时间比例来表达一个数值**。

为了更直观一点，可以想象一个尖叫鸡：

- 按下，它叫；
- 松手，它不叫。

如果我们把时间尺度拉得非常大，比如 100 秒：
- 按 30 秒、按 70 秒，对人来说几乎没有任何区别。

但如果把时间尺度缩小到 **1ms**：
- 300us 在叫，700us 不在叫；
- 和 700us 在叫，300us 不在叫，

那么宏观世界听到的“响度”显然不同。

这就是**时间尺度缩小后，脉冲宽度变化带来的“连续效果”**。  
声音如此，亮度如此，电机转速也是如此。

当“每个周期内按下的时间比例”缓慢变化时，  
你就会得到一个听起来（或看起来）像“呼吸”的效果——  
这就是所谓的 **呼吸灯 / 呼吸鸡**。

---

## 二、一个可复用的 PWM 模块

在彻底理解官方呼吸灯代码之后，我最终选择把 PWM **抽象成一个干净、可复用的模块**。

这个模块只做一件事：  
**根据占空比，输出 PWM 波形**。

```verilog
`timescale 1ns/1ns

// 极简、可复用的 PWM 发生器模块
module pwm_gen #(
    parameter CLK_FREQ = 50_000_000,  // 输入时钟频率（默认 50MHz）
    parameter PWM_FREQ = 1_000         // PWM 输出频率（默认 1kHz）
)(
    input  wire        clk,            // 系统时钟
    input  wire        rst_n,            // 低电平复位
    input  wire [9:0]  duty,            // 占空比（0~999，对应 0%~100%）
    output wire        pwm_out           // PWM 输出信号
);

    // PWM 周期内的时钟计数最大值
    localparam PWM_CNT_MAX = CLK_FREQ / PWM_FREQ - 1;

    reg [15:0] cnt;      // 时钟分频计数器
    reg [9:0]  pwm_cnt;  // PWM 周期内的比较计数器（0~999）

    // Step 1：时钟分频，产生 PWM 周期基准
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            cnt <= 16'd0;
        else if (cnt == PWM_CNT_MAX)
            cnt <= 16'd0;
        else
            cnt <= cnt + 1'b1;
    end

    // Step 2：PWM 周期内的计数（0~999）
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_cnt <= 10'd0;
        else if (cnt == PWM_CNT_MAX)
            pwm_cnt <= (pwm_cnt == 10'd999) ? 10'd0 : pwm_cnt + 1'b1;
    end

    // Step 3：核心逻辑 —— 时间比较生成 PWM
    assign pwm_out = (pwm_cnt < duty);

endmodule
```

该模块的特点：

- 默认生成 **1kHz PWM**
- `duty` 为输入，占空比 0~999
- 与具体“呼吸算法”解耦
- 可直接复用于 LED、电机、DAC 等场景

在我看来，这种模块更像是一个**工具**，
 而不是某块开发板的“展示性示例”。

## 三、踩坑与反思

写对代码，并不意味着实验一定能成功。

在这次实验中，我真实踩到的一个坑是：

> **FPGA 不同 IO BANK 的供电电压和 IO 标准是不同的。**

例如：

- LVCMOS12 对应 1.2V
- LVCMOS33 对应 3.3V

LED 能“亮”，并不代表电平标准是正确的。
 板子“看起来正常”，很多时候只是硬件足够宽容。

此外，这次也再次验证了一件事：

> 一旦实验现象不对，
>  就不能无条件相信任何一个模块、任何一段代码，
>  更不能迷信“看起来没问题”。

**逐层验证、逐级拆解，才是 FPGA 最朴素也最可靠的调试方式。**
