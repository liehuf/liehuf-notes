---
title: FPGA 04.串口通信
date: 2026-02-06 22:00:00
permalink: /pages/FPGA_04/
---

本文记录 FPGA 中 UART（串口通信）的最小实现与工程直觉，仅作为个人内化与复用素材，不追求教学完整性。

---

## 一、串口通信的本质

UART 的本质非常简单：

- **两根线**：TX（发送）、RX（接收）
- **无共享时钟**：完全异步
- **靠约定好的时间尺度通信（波特率）**

最常见的数据帧格式为 **10 bit**：

> 1 位起始位（低） + 8 位数据位（LSB 先行） + 1 位停止位（高）

### 关键工程事实

- **接收端必须处理异步问题**
  - 外部串口信号与 FPGA 系统时钟无关
  - 必须使用同步/缓冲手段规避亚稳态
- **发送端不关心对方是否接收到**
  - UART 没有应答机制
  - 只负责按时序把比特送出去

---

## 二、UART 接收模块（RX）

### 设计思路（只保留关键点）

- 对 `uart_rxd` 做 **两级同步**
- 检测 **起始位下降沿** 启动接收
- 用 **波特率计数器** 确定采样时刻
- 在 **bit 中点采样** 数据，保证稳定
- 接收完成后给出 **1 个周期的完成标志**

### 最小可复用 RX 模块

```verilog
/*
 * UART RX 最小实现
 * 8N1，无校验
 * SYS_CLK = 50MHz, UART_BPS = 115200（可参数化）
 */
module uart_rx(
    input            clk,
    input            rst_n,
    input            uart_rxd,
    output reg       uart_rx_finish,
    output reg [7:0] uart_rx_data
);

parameter SYS_CLK_FREQ = 50_000_000;
parameter UART_BPS     = 115200;
localparam BAUD_CNT_MAX = SYS_CLK_FREQ / UART_BPS;

reg [1:0]  uart_rxd_sync;
reg        work_en;
reg [3:0]  rx_bit_cnt;
reg [15:0] baud_cnt;
reg [7:0]  rx_data_reg;

wire start_flag = uart_rxd_sync[1] & ~uart_rxd_sync[0] & ~work_en;

// 输入同步
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        uart_rxd_sync <= 2'b11;
    else
        uart_rxd_sync <= {uart_rxd_sync[0], uart_rxd};
end

// 接收使能
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        work_en <= 1'b0;
    else if(start_flag)
        work_en <= 1'b1;
    else if(rx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX/2 - 1)
        work_en <= 1'b0;
end

// 波特率计数
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        baud_cnt <= 0;
    else if(work_en)
        baud_cnt <= (baud_cnt < BAUD_CNT_MAX - 1) ? baud_cnt + 1'b1 : 0;
    else
        baud_cnt <= 0;
end

// bit 计数
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        rx_bit_cnt <= 0;
    else if(work_en && baud_cnt == BAUD_CNT_MAX - 1)
        rx_bit_cnt <= rx_bit_cnt + 1'b1;
    else if(!work_en)
        rx_bit_cnt <= 0;
end

// 数据采样
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        rx_data_reg <= 0;
    else if(work_en && baud_cnt == BAUD_CNT_MAX/2 - 1) begin
        if(rx_bit_cnt >= 1 && rx_bit_cnt <= 8)
            rx_data_reg[rx_bit_cnt - 1] <= uart_rxd_sync[1];
    end
end

// 输出
always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        uart_rx_finish <= 1'b0;
        uart_rx_data   <= 8'd0;
    end else if(rx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX/2 - 1) begin
        uart_rx_finish <= 1'b1;
        uart_rx_data   <= rx_data_reg;
    end else
        uart_rx_finish <= 1'b0;
end

endmodule
```

## 三、UART 发送模块（TX）

### 设计思路

- 接收到发送请求后 **锁存数据**
- 按 **起始位 → 数据位 → 停止位** 顺序输出
- 用 `uart_tx_busy` 表示发送中状态

### 最小可复用 TX 模块

```verilog
/*
 * UART TX 最小实现
 * 8N1，无校验
 */
module uart_tx(
    input           clk,
    input           rst_n,
    input           uart_tx_req,
    input  [7:0]    uart_tx_data,
    output reg      uart_txd,
    output reg      uart_tx_busy
);

parameter SYS_CLK_FREQ = 50_000_000;
parameter UART_BPS     = 115200;
localparam BAUD_CNT_MAX = SYS_CLK_FREQ / UART_BPS;

reg [7:0]  tx_data_reg;
reg [3:0]  tx_bit_cnt;
reg [15:0] baud_cnt;

// 发送控制
always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        uart_tx_busy <= 1'b0;
        tx_data_reg  <= 8'd0;
    end else if(uart_tx_req) begin
        uart_tx_busy <= 1'b1;
        tx_data_reg  <= uart_tx_data;
    end else if(tx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX - 1)
        uart_tx_busy <= 1'b0;
end

// 波特率计数
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        baud_cnt <= 0;
    else if(uart_tx_busy)
        baud_cnt <= (baud_cnt < BAUD_CNT_MAX - 1) ? baud_cnt + 1'b1 : 0;
    else
        baud_cnt <= 0;
end

// bit 计数
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        tx_bit_cnt <= 0;
    else if(uart_tx_busy && baud_cnt == BAUD_CNT_MAX - 1)
        tx_bit_cnt <= tx_bit_cnt + 1'b1;
    else if(!uart_tx_busy)
        tx_bit_cnt <= 0;
end

// 串行输出
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        uart_txd <= 1'b1;
    else if(uart_tx_busy) begin
        case(tx_bit_cnt)
            4'd0: uart_txd <= 1'b0;
            4'd1: uart_txd <= tx_data_reg[0];
            4'd2: uart_txd <= tx_data_reg[1];
            4'd3: uart_txd <= tx_data_reg[2];
            4'd4: uart_txd <= tx_data_reg[3];
            4'd5: uart_txd <= tx_data_reg[4];
            4'd6: uart_txd <= tx_data_reg[5];
            4'd7: uart_txd <= tx_data_reg[6];
            4'd8: uart_txd <= tx_data_reg[7];
            4'd9: uart_txd <= 1'b1;
            default: uart_txd <= 1'b1;
        endcase
    end else
        uart_txd <= 1'b1;
end

endmodule
```

------

## 四、调试经验备注

- **代码没问题，80% 的问题在物理连接**
  - TX / RX 是否交叉
  - 共地是否可靠
- 波特率不准时，现象通常是：
  - 接收乱码
  - 偶发正确

------

> UART 的难点不在协议，而在 **工程时序意识**。
>  到这里，串口已经不再是“通信问题”，而只是一个工具。