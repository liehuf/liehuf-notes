---
title: FPGA 02.按键不是输入信号，而是一段时间——一次关于消抖的记录
date: 2026-02-04 15:00:00
permalink: /pages/FPGA_02/
---

在 FPGA 里面，按键并不是一个理想的 0 或 1，  
而是一段在时间轴上持续抖动的电平变化。

通常认为，机械按键在**按下**和**松开**两个瞬间，  
都会各自产生大约 10ms 左右的抖动。

---

## 一、为什么一定要消抖

如果不对按键进行消抖，那么输入信号就会在极短时间内反复变化。  
体现在波形图上，就是 **key 那一条线跳得比 clk 还勤快**。

如果不消抖，这些变化会被原样送入状态机。  
于是状态机会开始频繁、不可预测地切换状态。

此时如果状态机有嘴，它大概会说一句：

> “哈基键，你这家伙……”

---

## 二、可以不用怀疑的消抖模型图

```text
电平
 1 ────────────────┐      ┌─┐ ┌─┐ ┌──────────────
                   │      │ │ │ │ │
                   │      │ │ │ │ │ ← 松开抖动（≈10ms）
 0                 └──────┘ └─┘ └─┘                      
                        ← 按下抖动（≈10ms）
时间 ────────────────────────────────────────────────▶
                       ↑
                    按下
```

上面的 ASCII 图并不追求美观，
 但表达的是同一个事实：

**按键在由 1→0（按下）和 0→1（松开）时，
 都会经历一段持续数毫秒的抖动区间。**

因此，按键更合理的理解方式不是“某一时刻的电平”，
 而是“一段时间内是否已经稳定”。

## 三、可复用的代码

```verilog
`timescale 1ns / 1ps

// 多按键通用消抖模块
// 支持参数化配置按键数量和消抖延时，可直接复用
module btn_deb #(
    parameter BTN_WIDTH = 1,        // 按键数量（默认 1 个）
    parameter BTN_DELAY = 800_000   // 消抖延时（clk 计数个数，50MHz 时约 16ms）
)(
    input                      clk,      // 系统时钟
    input  [BTN_WIDTH-1:0]     btn_in,   // 原始按键输入（未消抖）
    output reg [BTN_WIDTH-1:0] btn_deb   // 消抖后的稳定输出
);

// 每个按键独立的计数器
reg [19:0] cnt [BTN_WIDTH-1:0];

// 抖动标志：1 表示当前处于抖动期
reg [BTN_WIDTH-1:0] jitter_flag;

// 输入打一拍，用于检测电平变化
reg [BTN_WIDTH-1:0] btn_in_d;

//-----------------------------------------------------
// 输入同步：捕获前一拍按键电平
always @(posedge clk) begin
    btn_in_d <= btn_in;
end

//-----------------------------------------------------
// 为每一个按键生成独立的消抖逻辑
genvar i;
generate
    for (i = 0; i < BTN_WIDTH; i = i + 1) begin : DEB_ONE_KEY

        // 抖动期判断：检测到电平变化则进入抖动期
        always @(posedge clk) begin
            if (btn_in_d[i] ^ btn_in[i])
                jitter_flag[i] <= 1'b1;
            else if (cnt[i] == BTN_DELAY)
                jitter_flag[i] <= 1'b0;
        end

        // 抖动计数器：抖动期计数，稳定期清零
        always @(posedge clk) begin
            if (!jitter_flag[i])
                cnt[i] <= 20'd0;
            else if (cnt[i] == BTN_DELAY)
                cnt[i] <= 20'd0;
            else
                cnt[i] <= cnt[i] + 1'b1;
        end

        // 输出逻辑：抖动期保持原值，稳定后更新
        always @(posedge clk) begin
            if (!jitter_flag[i])
                btn_deb[i] <= btn_in[i];
            else
                btn_deb[i] <= btn_deb[i];
        end

    end
endgenerate

endmodule
```

------

## 四、总结

这一节只记录按键相关内容，与 LED 实验刻意分开。

从工程角度来看，按键消抖逻辑可以粗略理解为两句话：

- **时间还没到，不管你怎么抖，我都不认**
- **时间到了，你现在稳不稳，我就认你现在的状态**

本质上，这不是对电平的判断，
 而是对**时间稳定性的判断**。
