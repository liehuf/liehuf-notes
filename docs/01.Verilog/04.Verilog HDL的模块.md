---
title: 04.Verilog HDL模块
date: 2025-07-25 15:00:00
permalink: /pages/Verilog_04/
---

# **模块（Module）—— Verilog的“积木块”**

## **1. 模块是什么？**

**核心概念**：模块是Verilog的基本设计单元，相当于电路中的一个**功能盒子**。

- **现实类比**：就像乐高积木，每个模块实现特定功能（如计数器、加法器），通过拼接构建复杂系统。

------

## **2. 模块的四大组成部分**

每个模块都包含以下结构（以D触发器为例）：

```verilog
// 1. 模块声明（定义"盒子"的名字和接口）
module dff (
  input      clk,    // 2. 端口定义：输入时钟
  input      din,    //         输入数据
  output reg q       //         输出数据（用reg存储）
);

  // 3. 逻辑功能描述：当时钟上升沿到来时，存储din的值
  always @(posedge clk) begin
    q <= din;  
  end

endmodule // 4. 模块结束
```

------

## **3. 模块的端口定义**

**端口类型**：

| 类型     | 方向             | 示例              |
| :------- | :--------------- | :---------------- |
| `input`  | 输入信号         | `input clk;`      |
| `output` | 输出信号         | `output q;`       |
| `inout`  | 双向信号（少见） | `inout data_bus;` |

**端口数据类型**：

- 默认是 `wire` 型（如 `input clk` 等价于 `input wire clk`）。

- 若输出需存储（如时序逻辑），需显式声明为 `reg`：

  ```verilog
  output reg q;  // 输出q需要在always块中赋值
  ```

------

## **4. 模块的实例化：调用“积木”**

**场景**：在顶层模块中调用子模块（如用两个D触发器构建移位寄存器）。

##### **方法1：顺序连接（按位置对应）**

```verilog
module top;
  wire clk, data_in;
  wire stage1, stage2;
  
  // 实例化第一个D触发器（端口顺序必须与模块定义一致！）
  dff dff1 (clk, data_in, stage1); 
  
  // 实例化第二个D触发器
  dff dff2 (clk, stage1, stage2);  
endmodule
```

**风险**：若模块端口顺序变更，所有实例化需同步修改！

##### **方法2：命名连接（推荐！）**

```verilog
module top;
  wire clk, data_in;
  wire stage1, stage2;
  
  // 通过.端口名(信号名)明确对应关系
  dff dff1 (
    .clk(clk), 
    .din(data_in), 
    .q(stage1)
  );
  
  dff dff2 (
    .clk(clk), 
    .din(stage1), 
    .q(stage2)
  );
endmodule
```

**优势**：

- 顺序无关，可读性强。
- 避免因模块定义修改导致错误。

------

## **5. 模块的层次化设计**

**关键思想**：自顶向下拆分功能，逐步细化。

**示例**：构建一个4位加法器

1. **顶层模块**：定义输入输出

   ```verilog
   module adder_4bit (
     input  [3:0] a, b,
     output [3:0] sum,
     output carry
   );
     // 调用子模块（全加器）
     full_adder fa0 (a[0], b[0], 1'b0, sum[0], c1);
     full_adder fa1 (a[1], b[1], c1,  sum[1], c2);
     full_adder fa2 (a[2], b[2], c2,  sum[2], c3);
     full_adder fa3 (a[3], b[3], c3,  sum[3], carry);
   endmodule
   ```

2. **子模块**：实现全加器

   ```verilog
   module full_adder (
     input  a, b, cin,
     output sum, cout
   );
     assign sum  = a ^ b ^ cin;
     assign cout = (a & b) | (cin & (a ^ b));
   endmodule
   ```

------

## **6. 模块的测试：Testbench**

**作用**：模拟输入信号，验证模块功能。

**示例**：测试D触发器

```verilog
module testbench;
  reg  clk, din;  // 测试输入（用reg驱动）
  wire q;         // 测试输出
  
  // 1. 实例化被测模块
  dff uut (.clk(clk), .din(din), .q(q));
  
  // 2. 生成时钟（周期=10ns）
  initial begin
    clk = 0;
    forever #5 clk = ~clk; // 每5ns翻转一次
  end
  
  // 3. 提供测试激励
  initial begin
    din = 0;
    #10 din = 1;  // 10ns后输入变1
    #10 din = 0;
    #20 $finish;  // 40ns后结束仿真
  end
  
  // 4. 打印结果
  initial begin
    $monitor("Time=%t, din=%b, q=%b", $time, din, q);
  end
endmodule
```

**输出结果**：

```text
Time=0, din=0, q=x  
Time=5, din=0, q=0  // 第一个时钟上升沿  
Time=15, din=1, q=1  // 第二个时钟上升沿  
Time=25, din=0, q=0  // 第三个时钟上升沿  
```

------

### **总结：模块设计要点**

1. **模块声明**：`module 模块名(端口列表);`
2. **端口方向**：`input`/`output`/`inout`，输出可声明为 `reg`。
3. **实例化**：推荐用命名连接（`.端口名(信号名)`）。
4. **测试方法**：
   - 用Testbench生成时钟和激励。
   - 通过 `$monitor` 或波形图观察输出。

**常见错误**：

- 错误1：在 `always` 块中对 `wire` 赋值 → 应改用 `reg`。
- 错误2：模块实例化时端口顺序不匹配 → 用命名连接避免。

