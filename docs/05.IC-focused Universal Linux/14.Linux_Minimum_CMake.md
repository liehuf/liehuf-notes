---
title: 14.最小CMake
date: 2026-02-28 14:00:00
permalink: /pages/Linux_14/
---

## 从零实践 CMake：给有 GCC / Makefile 基础的人

### 一、为什么要学 CMake

在真实工程（尤其是芯片 / 嵌入式 / 跨平台工程）中，手写 Makefile 会遇到：

- 规则重复
- 依赖难维护
- 多平台适配成本高

CMake 的定位很明确：

> **用更高层的描述，生成底层构建系统（Make / Ninja）**

------

### 二、解释一个最小版本的CMake

逐行解释一个`CmakeLists.txt`：

```cmake
cmake_minimum_required(VERSION 3.16)

project(cmake_demo C)

add_executable(app
    main.c
    calc.c
)

target_include_directories(app PRIVATE .)
```

- `cmake_minimum_required(VERSION 3.16)`：先跟当前的版本的CMake打个招呼，你是不是大于或等于`3.16`版本，是的话就继续，不是的话就报个错，别装懂

- `project(cmake_demo C)`：这句可厉害了，他是CMake的开关，`cmake_demo`是项目名，`C`是语言，之后，CMake会去找`gcc`并确认是C语言的编译器，之后设置一大堆**隐式变量**，再后面就是触发编译器能力检测，在后面的输出就如下（如果成功了）：

  ```cmake
  -- The C compiler identification is GNU 11.4.0
  -- Detecting C compiler ABI info
  ```

- `add_executable(app main.c calc.c)`：生成一个可执行文件，名字叫做`app`，它依赖于后面这些啥的`main.c`、`calc.c`等源文件**编译链接**而成
- `target_include_directories(app PRIVATE .)`：当前的目标叫做`app`，在生成这个目标的时候的头文件（.h）去`.(CMakeLists.txt所在目录)`去找，不要在当前的`build`目录去找，你滴找不到，`PRIVATE`是指只能自己用，也去污染别的环境

当然，也可以在`CMakeLists.txt`中写一下C标准和编译参数，在`project()`和`add_executable()`之间

```cmake
set(CMAKE_C_STANDARD 11)	# 启用C11标准
set(CMAKE_C_FLAGS "-Wall -g")	# 打开所有警告和调试信息
```

---

### 三、标准构建流程

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

要点：源码目录 ≠ 构建目录，build 目录可随时删除，增量编译由底层构建系统完成

如果构建成功了，会有如下的输出，最后只需要`./app`就可以运行`main.c`

```bash
-- The C compiler identification is GNU 11.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: .../build
```

