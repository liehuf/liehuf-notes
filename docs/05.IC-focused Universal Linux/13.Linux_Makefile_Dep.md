---
title: 13.Makefile依赖
date: 2026-02-27 11:00:00
permalink: /pages/Linux_13/
---

# Makefile依赖

## 一、基础依赖（Makefile中“最小因果单位”）

```makefile
main.o: main.c calc.h
```

这句话的**精确定义**

> **main.o 的“正确性”由 main.c 和 calc.h 共同决定**

Makefile只知道`main.o`是目标，`main.c`和`calc.h`是依赖

## 二、依赖链（Makefile的递归解析模型）

```makefile
app: main.o calc.o
main.o: main.c calc.h
calc.o: calc.c calc.h
```

Make 不是从上到下执行文件，而是：

1. 指定目标：`make app`
2. Make 发现：`app` 依赖 `main.o calc.o`
3. Make **递归展开依赖树**
4. 直到遇到“没有规则、只剩文件”的节点

顺序由依赖关系拓扑排序决定，Make保证依赖先生成，目标后生成

## 三、依赖关系进阶——使用`.d`

在大工程中依赖特别多，成百上千的那种，这时候，手写那么多`.c`和`.h`是及其不智慧的操作，并且Makefile与源码强耦合，维护困难

命令`gcc -MM main.c`可以运行 **预处理器**，解析所有 `#include`，输出“真实依赖关系”

输出格式是 **Makefile 规则**：

```makefile
main.o: main.c a.h b.h c.h
```

生成的是一个文件，在目前看来内容很少，不过这只是一个教学性质的演示

选项命令`-include $(DEPS)`这时候就可以把`.d`文件包含进来，作为Makefile的一部分，这个和 **真·手写**的效果是一样的，里面的规则会参与依赖判断

## 四、增量编译

对于一个工程，我们全部编译，称为**全量编译**，但是耗费时间长，也浪费资源，我们可以通过实行**增量编译**，即只编译修改过的文件，这一点同样通过时间戳来确定

Makefile会看：

- 依赖文件是否比目标文件新？
- 新的？那就把你拿出来重新编译！
- 旧的？那就一边站着吧

## 五、顺序依赖

```makefile
obj/%.o: src/%.c | obj
```

`|` 做了什么？

- `obj` **必须先存在**
- 但 `obj` 的时间戳 **不参与是否重编判断**

底层语义是：

```
obj 是“执行前置条件”，不是“重建依据”
```

这解决的是：

- 目录不存在 → 编译失败
- 目录时间变化 → 不触发重编

## 六、分析一个优雅的Makefile

```makefile
# 定义编译器变量 CC，这里指定使用 gcc 编译器
# 使用 := 是立即赋值，区别于 = 的延迟赋值，是 Makefile 中定义常量的常用方式
CC := gcc

# 定义编译选项变量 CFLAGS
# -Wall：开启所有常见的警告信息，帮助发现代码潜在问题
# -g：生成调试信息，可配合 gdb 等调试工具使用
CFLAGS := -Wall -g

# 定义源文件列表变量 SRC
# 包含项目中所有的 .c 源文件，这里是 main.c 和 calc.c
SRC := main.c calc.c

# 生成目标文件列表变量 OBJ
# $(SRC:.c=.o) 是 Makefile 的字符串替换语法：将 SRC 中所有 .c 后缀替换为 .o
# 最终 OBJ = main.o calc.o
OBJ := $(SRC:.c=.o)

# 生成依赖文件列表变量 DEPS
# 同样使用字符串替换，将 SRC 中 .c 替换为 .d，.d 文件用于存储头文件依赖关系
# 最终 DEPS = main.d calc.d
DEPS := $(SRC:.c=.d)

# 定义最终可执行文件目标 app，依赖于所有的 .o 目标文件
# 当 OBJ 中的文件有更新时，会执行下面的编译链接命令
app: $(OBJ)
	# 链接所有目标文件生成可执行文件 app
	# $(CC) 展开为 gcc，-o app 指定输出文件名为 app，$(OBJ) 展开为所有 .o 文件
	$(CC) -o app $(OBJ)

# 模式规则：匹配所有 .o 文件的生成规则
# %.o 是通配符，表示任意以 .o 结尾的文件，依赖于对应的 %.c 文件（如 main.o 依赖 main.c）
%.o: %.c
	# 编译单个 .c 文件生成对应的 .o 目标文件
	# $(CFLAGS) 展开为 -Wall -g，-c 表示只编译不链接
	# $< 是自动变量，表示当前规则的第一个依赖文件（即对应的 .c 文件）
	# $@ 是自动变量，表示当前规则的目标文件（即对应的 .o 文件）
	$(CC) $(CFLAGS) -c $< -o $@
	# 生成依赖文件 .d：-MM 选项会分析 .c 文件的头文件依赖，输出格式为 "目标文件: 依赖头文件"
	# $*.d 中 $* 表示去掉后缀的文件名（如 main.c 对应 main.d）
	$(CC) -MM $< > $*.d

# 包含所有 .d 依赖文件
# -include 表示如果 .d 文件不存在或有错误，Make 不会报错，只会继续执行
# 作用是让 Make 感知到头文件的变化，头文件修改后会重新编译对应的 .c 文件
-include $(DEPS)

# 定义 clean 伪目标，用于清理编译生成的文件
# 伪目标不是实际的文件，只是一个命令集合，执行 make clean 时会运行下面的命令
clean:
	# rm -f 强制删除文件，不会因为文件不存在报错
	# 删除可执行文件 app、所有 .o 目标文件、所有 .d 依赖文件
	rm -f app *.o *.d
```

