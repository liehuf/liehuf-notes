---
title: 09.ELF角度下的静态动态链接
date: 2026-02-24 21:00:00
permalink: /pages/Linux_09/
---

# 从 ELF 角度理解静态链接与动态链接的本质

## 1. 为什么要自己写一个库

写库并不是为了“复用几行代码”，而是为了**人为制造链接问题**。
只有当函数不在当前编译单元里，ELF、符号表、重定位、装载器这些东西才会真正出现。

系统库已经被高度封装，看不到链接过程；自己写 `add / mul` 这种极小库，反而能清楚观察：

- 符号什么时候被“解决”
- 代码是被“拷贝”还是“引用”
- ELF 在磁盘态和运行态的差异

所以写库，本质是在**给自己搭一个可控的链接实验场**。

------

## 2. 静态链接：代码“拷贝”进可执行文件

静态链接的核心只有一句话：

> **目标文件里的代码，被直接合并进最终 ELF。**

### ar 的本质

`ar` 并不“懂链接”，它只是把多个 `.o` 打包成一个 **符号仓库**（`.a`）：

- 每个 `.o` 仍然是完整的 ELF relocatable object
- 里面包含 `.text / .data / .symtab`

链接器在静态链接时做的事是：

- 只从 `.a` 里 **抽取用到的 `.o`**
- 把这些 `.o` 的代码段直接并入可执行文件

所以 `.a` ≈ 一堆 `.o` 的zip。

```bash
ikun@ubuntu2004:~/Desktop/link_test$ ar rcs libmath.a math_lib.o # ar 命令把目标文件.o压缩到.a文件里
ikun@ubuntu2004:~/Desktop/link_test$ ar -t libmath.a
math_lib.o
```

### nm / ldd 的证据

- `nm test_static`：把文件扒开来看看里面的函数
   能看到 `add / mul` 已经变成 **已定义符号（T）**

- ```bash
  ikun@ubuntu2004:~/Desktop/link_test$ nm test_static | grep -E " add$| mul$"
  00000000004017b0 T add
  00000000004017c8 T mul
  ```

- `ldd test_static`:查看使用哪些动态库
   看不到 `libmath.so`，因为根本不需要了

- ```bash
  ikun@ubuntu2004:~/Desktop/link_test$ ldd test_static
  	不是动态可执行文件
  ```

**函数已经变成 ELF 自己的一部分**。

------

## 3. 动态链接：符号“引用”与运行时解析

动态链接并不拷贝代码，而是留下“欠条”。

> ELF 里只记录：
>  “我需要一个叫 `add` 的符号，它在某个共享库里。”

```bash
ikun@ubuntu2004:~/Desktop/link_test$ gcc -c math_lib.c -o math_lib_pico.o -fPIC
ikun@ubuntu2004:~/Desktop/link_test$ gcc -shared -o libmath.so math_lib_pico.o
ikun@ubuntu2004:~/Desktop/link_test$ file libmath.so
libmath.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=f701bf17254bed35c1ab68eea4487c995377e054, not stripped
```

### -fPIC 的意义

动态库里的代码不能假设自己被装载到哪个地址。

`-fPIC` 的作用是：

- 所有对**全局符号 / 全局数据**的访问
- 都改成 **经由 GOT / PLT 的间接寻址**

结果是：

- `.text` 段位置无关
- 同一个 `.so` 可以被多个进程共享

###  加了 `-shared` ：

含义是：

> **不要生成可执行程序，
>  生成“可被加载的共享对象”。**

它会让链接器：

- 不要求 `main`
- 允许未解析符号
- 生成 `.so` 类型 ELF

生成动态库后查一下户口（依赖关系、把文件扒开看看里面有哪些函数）

```bash
ikun@ubuntu2004:~/Desktop/link_test$ ldd test_dynamic
	linux-vdso.so.1 (0x00007ffd9bdf4000)
	libmath.so => ./libmath.so (0x0000748d6e61a000)	# 这一个库为用户打包的库
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x0000748d6e200000)
	/lib64/ld-linux-x86-64.so.2 (0x0000748d6e626000)
ikun@ubuntu2004:~/Desktop/link_test$ nm test_dynamic | grep -E " add$| mul$"
                 U add  # U指的是未定义，这是一种设计，而并非错误
                 U mul
```

### LD_LIBRARY_PATH 的本质

```bash
kun@ubuntu2004:~/Desktop/link_test$ ./test_dynamic
./test_dynamic: error while loading shared libraries: libmath.so: cannot open shared object file: No such file or directory
ikun@ubuntu2004:~/Desktop/link_test$ export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH
ikun@ubuntu2004:~/Desktop/link_test$ ./test_dynamic
a + b = 8
a * b = 15
```

这不是“编译选项”，而是**运行时规则**。

含义是：

> 动态链接器在运行程序时，先从 `./` 这个目录找 `.so`，再找系统默认路径。

它影响的是：

- **程序启动阶段**
- 由 `/lib64/ld-linux-x86-64.so.2` 执行

和 gcc、ld 在**编译期完全无关**。

------

## 4. add / mul 在两种链接下的命运对比

| 项目      | 静态链接       | 动态链接        |
| --------- | -------------- | --------------- |
| add / mul | 代码被拷进 ELF | 只保留符号引用  |
| ELF 体积  | 更大           | 更小            |
| 运行依赖  | 无需库文件     | 依赖 `.so`      |
| 更新库    | 需重新编译     | 替换 `.so` 即可 |
| 地址      | 编译期确定     | 运行期解析      |

本质差别不是“快慢”，而是：

> **符号是在编译期解决，还是在运行期解决。**

------

## 5. 芯片 / 嵌入式视角下的取舍

在芯片与底层系统里，选择非常现实：

- **裸机 / Bootloader / ROM**
  - 静态链接是唯一选择
  - 没有动态装载器
- **Linux SoC / 用户态程序**
  - 动态链接节省内存
  - 多进程共享 `.so`

这也是为什么：

- 内核、启动代码几乎全是静态
- 用户空间库大量使用 `.so`

不是“优雅问题”，而是**系统能力边界**决定的。
