---
title: 10.看二进制
date: 2026-02-25 14:00:00
permalink: /pages/Linux_10/
---

# 读二进制

## 一、readelf-"读ELF文件的骨架"

### readelf 三个核心选项（-h、-S、-s）

 `-h`（--file-header）

显示 **ELF 文件头**（最顶层元信息）

- 看文件类型（EXEC/DYN/REL）、位数（32/64）、架构、入口地址、程序 / 节头偏移等

S`（--sections）

显示 **节头表（Section Headers）**

- 看所有节（.text/.data/.rodata/.symtab 等）的名称、类型、地址、大小、偏移

 `-s`（--symbols）

显示 **符号表（Symbol Table）**

- 看所有符号（函数、变量、外部引用）的类型、值、大小、绑定、所在节

```bash
ikun@ubuntu2004:~/Desktop/link_test$ readelf -h test_dynamic
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  OS/ABI:                            UNIX - System V
  类型:                              DYN (Position-Independent Executable file)
  系统架构:                          Advanced Micro Devices X86-64
```

有魔数、类别为ELF64、类型为 DYN（动态链接可执行文件）

```bash
ikun@ubuntu2004:~/Desktop/link_test$ readelf -S test_dynamic | grep -E "text|data|bss"
  [16] .text             PROGBITS         00000000000010a0  000010a0
  [18] .rodata           PROGBITS         0000000000002000  00002000
  [25] .data             PROGBITS         0000000000004000  00003000
  [26] .bss              NOBITS           0000000000004010  00003010
```

这是在看 **Section（段）**，不是运行时视角，而是**链接/存储视角**。

- .text ：**只读 + 可执行**，放的是机器码
- .data：**可读写**放“已初始化的全局变量”
- .bss：**可读写**放“未初始化的全局变量”磁盘上不占空间

```bash
ikun@ubuntu2004:~/Desktop/link_test$ readelf -s test_dynamic | grep -E "add|mul|printf"
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND add
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND mul
    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND add
    24: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5
    33: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND mul
```

这就是动态链接本质：不是“没有这个函数”，而是： “这个 ELF 自己不负责实现它。”

## 二、objdump：你在“看 CPU 实际要跑的指令”

命令`objdump -d test_dynamic | grep -A 20 "<main>"`

其中 `objdump -d test_dynamic`这个二进制文件做反汇编，输出所有可执行代码段（.text）的汇编指令

```bash
ikun@ubuntu2004:~/Desktop/link_test$ objdump -d test_dynamic | grep -A 20 "<main>" | grep "plt"
    11ad:	e8 be fe ff ff       	call   1070 <add@plt>
```

**main 并没有直接 call add** 它 call 的是 **PLT 里的一个跳板**

PLT 是什么，不用背定义，只记行为：第一次调用：跳进动态链接器，查库、填地址，之后调用：直接跳到真实 `add`

## 三、nm：链接方式探测器

**nm = 查看二进制文件里的「符号表」**

也就是**列出这个文件里有哪些函数、哪些全局变量、它们在哪、是什么类型。**

```bash
ikun@ubuntu2004:~/Desktop/link_test$ nm test_static | grep "add$"
00000000004017b0 T add
0000000000488020 T __nptl_stack_list_add
ikun@ubuntu2004:~/Desktop/link_test$ nm test_dynamic | grep "add$"
                 U add
```

每一列含义：

1. **地址**
2. **符号类型（大写字母）**
3. **符号名（函数名 / 变量名）**

符号类型：

- **T**：代码段里的函数（text 段）
  - 比如 `main`、`foo`、`my_func`
- **U**：未定义符号（undefined）
  - 意思是 **我要用，但我没实现，要靠动态库给我**
  - 比如 `printf`、`scanf`
- **D**：已初始化全局变量
- **B**：未初始化全局变量