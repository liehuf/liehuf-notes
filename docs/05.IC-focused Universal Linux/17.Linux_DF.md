---
title: 17.磁盘管理
date: 2026-02-28 23:00:00
permalink: /pages/Linux_17/
---

# Linux 磁盘管理（df / du / 分区与挂载）

本文记录一次在 **Ubuntu 22.04** 上进行的磁盘管理实践，目标不是“记命令”，而是建立**磁盘空间是如何被 Linux 感知、统计和使用的完整认知模型**。  
核心工具只有三个：`df`、`du`、`lsblk / mount`。

---

## 一、df：从「文件系统」视角看磁盘空间

### 1. df 在看什么？

`df`（disk free）**统计的是“已挂载文件系统”的整体空间使用情况**，而不是某个具体目录或文件。

实践命令：

```bash
df -h
```

实践输出（部分）：
```bash
文件系统         大小   已用  可用  已用%   挂载点
/dev/sda3        20G   12G  7.0G   62%  /
tmpfs           961M     0  961M    0%  /dev/shm
/dev/sda2       512M  6.1M  506M    2%  /boot/efi
```

关键列含义：

- **文件系统**：底层设备或虚拟文件系统
- **大小 / 已用 / 可用 / 已用%**：整体容量统计
- **挂载点**：该文件系统“接管”的目录位置

结论性理解：

- `df` 关心的是 **“哪个文件系统挂载到哪里，用了多少空间”**
- 日常最重要的挂载点只有一个：`/`（根文件系统）

### 2. 一个常见错误：df 不能加 `--max-depth`

实践中出现的错误：

```bash
df -h /home --max-depth=1
```

系统返回：

```bash
df: 未识别的选项 "--max-depth=1"
```

原因很简单但很关键：

- `df` **不看目录结构**
- `--max-depth` 是 `du` 的参数，不是 `df` 的

这也从侧面说明：
 **df 和 du 的职责完全不同，不能混用思维方式。**

## 二、du：从「目录 / 文件」视角找空间来源

### 1. du 在看什么？

`du`（disk usage）统计的是：
 **某个目录或文件，实际占用了多少磁盘空间**

当你遇到：

- `df -h` 显示磁盘快满了
- 但你不知道“空间被谁吃了”

那么答案一定在 `du`。

------

### 2. 典型实践：查看 `/home` 下各目录占用

```bash
du -h /home --max-depth=1
```

实践输出：

```bash
84M	/home/ikun
84M	/home
```

解释：

- `/home/ikun` 占用约 84MB
- `/home` 总体占用也是 84MB，说明当前只有一个用户目录

关键认知：

- `du` 是**定位元凶的工具**
- `--max-depth=1` 用于限制展开层级，避免信息爆炸

------

### 3. df + du 的固定排查思路

一条可以长期复用的排查路径：

```bash
df -h               # 判断哪个文件系统快满了
du -h / --max-depth=1
du -h /home --max-depth=1
du -sh 某个可疑目录
```

这是**从文件系统 → 目录 → 子目录的漏斗式定位**。

## 三、lsblk：理解“磁盘 / 分区 / 挂载”的结构关系

### 1. 为什么需要 lsblk？

Linux 下：

- 没有盘符（C: / D:）
- 只有 **设备 → 分区 → 挂载点**

`lsblk` 用树形结构把这三者一次性展示出来。

实践命令：

```bash
lsblk
```

实践输出（部分）：

```bash
sda      8:0    0    20G  0 disk 
├─sda2   8:2    0   513M  0 part /boot/efi
└─sda3   8:3    0  19.5G  0 part /
```

逐层理解：

- `sda`：一整块磁盘（20G）
- `sda2`：一个分区，挂载到 `/boot/efi`
- `sda3`：一个分区，挂载到 `/`（根文件系统）

结论性理解：

- **磁盘 ≠ 可直接使用**
- **分区必须被挂载到某个目录，空间才“生效”**

------

### 2. loop 设备是什么？

在输出中还看到大量 `loop` 设备：

```bash
loop0  /snap/core22/2292
loop2  /snap/firefox/7836
```

它们的本质是：

- snap 包使用的 **只读镜像文件**
- 被“虚拟成块设备”再挂载

这类设备通常：

- `RO = 1`（只读）
- 不参与普通磁盘空间管理
- 不要误认为是“真实磁盘”

------

## 四、mount：验证“谁被挂载到了哪里”

实践命令：

```bash
mount | less
```

`mount` 输出的是**当前系统所有已挂载的文件系统**，格式类似：

```bash
/dev/sda3 on / type ext4 (rw,relatime)
```

这句话完整表达了：

- 哪个设备：`/dev/sda3`
- 挂载到哪里：`/`
- 使用什么文件系统：`ext4`
- 挂载属性：读写、时间策略等

核心认知：

- **lsblk 看结构**
- **mount 看当前生效状态**
- 两者结合，才能真正理解磁盘是“怎么用起来的”