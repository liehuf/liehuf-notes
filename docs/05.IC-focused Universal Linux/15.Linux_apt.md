---
title: 15.包管理
date: 2026-02-28 22:00:00
permalink: /pages/Linux_15/
---

##  Linux 包管理（apt）

### 1. apt 管的是“环境一致性”

apt 的核心职责只有一句话：

> **保证系统中“软件 + 版本 + 依赖 + 安装位置”是一致且可回滚的**

------

### 2. apt 的基本工作模型

一个软件包是一组：

- 可执行文件（/usr/bin）
- 动态库（/usr/lib）
- 配置文件（/etc）
- 文档（/usr/share）

apt **知道每个文件属于哪个包**。

------

### 3. 安装 / 卸载的三个层级

安装

```bash
sudo apt install 包名
```

apt 会自动：

- 下载 .deb
- 解析依赖
- 放到系统标准路径
- 更新系统数据库

卸载

```bash
sudo apt remove 包名
```

👉 删除程序，**保留配置**（方便以后装回来）

```bash
sudo apt purge 包名
```

👉 程序 + 配置一起删（真正干净）

```bash
sudo apt autoremove
```

👉 删除“曾经被依赖、现在没人用”的包

**工程习惯：**

- 临时工具 → purge
- 长期环境 → 不乱 autoremove

------

### 4. 依赖的本质（不是“麻烦”，是保险）

apt 的依赖机制保证：

- 同一个库不会被装多份
- 多个程序共享同一份库
- 安全更新可以统一推进

可能会看到：

```
Depends: libc6 (>= 2.34)
```

意思是：

> **这个程序在运行时，假设系统里已经有这个库**

------

### 5. apt vs 手动 make install（工程分界线）

| 场景           | 推荐         |
| -------------- | ------------ |
| 系统工具       | apt          |
| 交叉编译工具链 | apt / 官方包 |
| 实验性源码     | 手动编译     |
| 工程环境       | **尽量 apt** |

一句工程原则：

> **能用 apt 管的东西，不要自己手动往 /usr 里塞**

### 6. 开机update

```bash
sudo apt update
```

**这一步做的事情只有一件：**

> **从软件源同步“可用软件列表”和“版本信息”**

它**不会**：

- 安装任何软件
- 升级任何程序
- 改动系统文件

它只是更新了本地的**包索引数据库**（在 `/var/lib/apt/lists/`）。

```bash
sudo apt upgrade
```

它的行为是：

> **在不删除、不新增依赖的前提下，升级“已经安装的软件包”**

特点：

- 不会删除包
- 不会换核心组件
- 不会升级内核到新分支
