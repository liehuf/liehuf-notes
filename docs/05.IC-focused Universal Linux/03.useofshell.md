---
title: Linux 03.Linux的Shell结构理解
date: 2026-02-21 12:00:00
permalink: /pages/Linux_03/
---

# Shell 结构理解

## 一、什么是Shell

#### 核心认知：Shell ≠ 终端

- **终端（Terminal）**：是 “输入输出的窗口”（比如你打开的命令行窗口、xterm、gnome-terminal），只负责显示和接收字符；

- Shell

  ：是运行在终端里的 “程序”，核心作用有 3 个：

  1. **命令解释器**：把你敲的`ls`、`cd`翻译成内核能懂的指令；
  2. **进程启动器**：帮你创建 / 管理进程（比如`sleep 100 &`就是 Shell 帮你启动后台进程）；
  3. **文本处理协调器**：把多个命令串起来（管道、重定向），完成复杂文本处理。

`echo $SHELL`命令可以查看当前的shell，也是默认shell

```bash
ikun@ubuntu2004:~/Desktop$ echo $SHELL
/bin/bash
```

`echo /etc/shells`命令可以查看当前所有可用的shell

```bash
ikun@ubuntu2004:~/Desktop$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
...
```

`echo $PATH`命令输出一些目录

```bash
ikun@ubuntu2004:~/Desktop$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
```

#### $PATH 核心原理：

敲`ls`时，Shell 会**按顺序遍历 $PATH 里的目录**，找到第一个名为`ls`的可执行文件（比如`/bin/ls`），然后执行它。

如果想验证：敲`which ls` → 会输出`/bin/ls`，就是 $PATH 里找到的路径；

```bash
ikun@ubuntu2004:~/Desktop$ which ls
/usr/bin/ls
```

## 二、bash基础行为

### 命令查找顺序（shell 找命令的优先级）

Shell 执行命令时，优先级从高到低：

1. 别名（alias）→ 比如`ll`其实是`ls -alF`的别名；
2. 内置命令（builtin）→ 比如`cd`、`echo`（属于 Shell 本身，无需找文件）；
3. $PATH 里的外部命令 → 比如`ls`、`top`（独立可执行文件）。

```bash
ikun@ubuntu2004:~/Desktop$ type cd
cd 是 shell 内建
ikun@ubuntu2004:~/Desktop$ type echo
echo 是 shell 内建
ikun@ubuntu2004:~/Desktop$ type ls
ls 是 "ls --color=auto" 的别名
ikun@ubuntu2004:~/Desktop$ type ll
ll 是 "ls -alF" 的别名
```

### 参数展开（shell先解析，再输出）

Shell 执行命令前，会先把变量、通配符等 “展开” 成具体内容，再执行。

```bash
# 示例：参数展开
a=10
echo $a+5  # Shell先把 $a 展开成 10，再执行echo → 输出：10+5
```

### 通配符（\* ? [])

Shell 的 “文件匹配工具”，先匹配文件，再执行命令：

| 通配符 |         含义         |                             示例                             |
| :----: | :------------------: | :----------------------------------------------------------: |
|  `*`   |  匹配任意个任意字符  |                  `ls *.txt` → 所有.txt 文件                  |
|  `?`   |  匹配 1 个任意字符   | `ls file?.txt` → file1.txt、filea.txt（但不匹配 file10.txt） |
|  `[]`  | 匹配括号内的单个字符 |     `ls file[123].txt` → file1.txt、file2.txt、file3.txt     |

```bash
ikun@ubuntu2004:~/Desktop$ touch a.txt b.txt ab.txt abc.txt file1 file12 file2
ikun@ubuntu2004:~/Desktop$ ls *.txt
abc.txt  ab.txt  a.txt  b.txt
ikun@ubuntu2004:~/Desktop$ ls file?
file1  file2
ikun@ubuntu2004:~/Desktop$ ls file[12]
file1  file2
```

### 引号差异

核心：**单引号完全屏蔽 Shell 解析，双引号只屏蔽通配符 / 别名，保留变量展开**。

| 引号类型 |             特点             |     示例      |           输出            |
| :------: | :--------------------------: | :-----------: | :-----------------------: |
|  无引号  | 全解析（变量、通配符、别名） |  `echo $a *`  | 10 file1.txt file2.txt... |
|  双引号  | 解析变量，屏蔽通配符 / 别名  | `echo "$a *"` |           10 *            |
|  单引号  |     完全不解析，原样输出     | `echo '$a *'` |           $a *            |

```bash
ikun@ubuntu2004:~/Desktop$ name=小明
ikun@ubuntu2004:~/Desktop$ echo "我是 $name"
我是 小明
ikun@ubuntu2004:~/Desktop$ echo '我是 $name'
我是 $name
```

## 三、管道符（A | B | C）

核心理解：管道连接的是「stdout（标准输出）→ stdin（标准输入）」

- 管道`|`把前一个命令的**标准输出**，直接传给后一个命令的**标准输入**；
- 管道传递的是 “数据流”，不是文件，无需临时保存到硬盘；
- Unix 哲学：“做一件事，并做到最好”，管道把多个小命令拼成复杂功能。

```bash
ikun@ubuntu2004:~/Desktop$ ps aux | grep bash # 把ps aux命令的输出过滤出含有bash的部分
ikun        2417  0.0  0.2  14532  5316 pts/0    Ss   10:49   0:00 bash
ikun        2795  0.0  0.1  12192  2544 pts/0    S+   11:03   0:00 grep --color=auto bash
```

```bash
# 3. 多级管道：组合过滤+排序+统计（找CPU占用最高的前5个进程）
ps aux | grep -v root | sort -k3 -r | head -5
# 解释：
# grep -v root → 排除root进程
# sort -k3 -r → 按第3列（%CPU）倒序排序
# head -5 → 只取前5行
ikun@ubuntu2004:~/Desktop$ ps aux | sort -k 2 -r | head -5
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          96  0.0  0.0      0     0 ?        I<   10:47   0:00 [kworker/R-scsi_]
root          95  0.0  0.0      0     0 ?        S    10:47   0:00 [scsi_eh_1]
root          94  0.0  0.0      0     0 ?        I<   10:47   0:00 [kworker/R-scsi_]
kernoops     933  0.0  0.1  13100  2224 ?        Ss   10:48   0:00 /usr/sbin/kerneloops
```

## 四、重定向（IO控制）

Linux每个进程默认打开三个文件描述符

| 描述符 | 名称               | 缩写 | 默认位置 |
| ------ | ------------------ | ---- | -------- |
| 0      | 标准输入（stdin）  | <    | 键盘     |
| 1      | 标准输出（stdout） | >/>> | 终端     |
| 2      | 标准错误（stderr） | 2>   | 终端     |

重定向就是 “改变这些数据流的去向”。

```bash
# 1. 标准输出重定向（> 覆盖，>> 追加）
ls > file_list.txt  # 把ls的输出（stdout）写入file_list.txt（覆盖原有内容）
echo "新内容" >> file_list.txt  # 追加内容到文件

# 2. 标准错误重定向（2>）：丢弃错误，或保存错误
ls /nonexistent 2> error.log  # 把ls的错误信息（找不到目录）保存到error.log
ls /nonexistent 2> /dev/null  # 丢弃错误（/dev/null是“黑洞”，写入的内容全消失）

# 3. 合并标准输出和标准错误（&> 或 1> file 2>&1）
ls /etc /nonexistent &> all_output.log  # 把正常输出和错误都写入文件
# 等价于：ls /etc /nonexistent 1> all_output.log 2>&1
```

## 五、子Shell与作用域

**当前 Shell**：正在操作的 Shell 进程（比如终端窗口）；

**子 Shell**：由当前 Shell 启动的新 Shell 进程（比如`()`、管道、脚本执行都会创建子 Shell）。

```bash
ikun@ubuntu2004:~/Desktop$ a=10
ikun@ubuntu2004:~/Desktop$ (echo 子shell: $a; a=20; echo 子shell改完: $a)
子shell: 10
子shell改完: 20
ikun@ubuntu2004:~/Desktop$ echo 父shell: $a
父shell: 10
```

子shell中的变量操作不会影响父shell，除非操作的是环境变量

### () 和 {}的区别

| 语法 |    类型    |        作用域         |                        语法要求                        |
| :--: | :--------: | :-------------------: | :----------------------------------------------------: |
| `()` |  子 Shell  | 变量只在子 Shell 生效 |          括号内命令用；分隔，括号前后可有空格          |
| `{}` | 当前 Shell | 变量在当前 Shell 生效 | 最后一个命令必须加；，括号前必须有空格（如 {echo 1;}） |

## 六、环境变量（PATH）

核心区分：环境变量 vs 普通变量

- **普通变量**：只在当前 Shell 生效（子 Shell 不可见）；
- **环境变量**：当前 Shell + 所有子 Shell 都可见（`export` 是关键）。

#### Shell 启动时加载了什么？（读懂.bashrc）

Ubuntu 的 bash 启动时，会按顺序加载这些文件（影响环境变量 / 别名）：

1. `/etc/profile`：系统级全局配置（所有用户）；
2. `~/.bash_profile` / `~/.bash_login` / `~/.profile`：用户级登录 Shell 配置；
3. `~/.bashrc`：用户级非登录 Shell 配置（比如终端窗口默认加载）。

下面通过演示修改~/.bashrc文件来展示环境变量

```bash
ikun@ubuntu2004:~/Desktop$ gedit ~/.bashrc

# 在 ~/.bashrc中添加如下内容
# 1. 添加自定义别名（myls 等价于 ls -l，简化命令）
alias myls='ls -l'
# 2. 添加永久的环境变量
export MY_PATH="/home/ikun/Documents"

ikun@ubuntu2004:~/Desktop$ source ~/.bashrc # 执行文件让其立刻生效

#再次执行：可见添加的全局变量生效！
ikun@ubuntu2004:~/Desktop$ myls
总计 12
-rw-rw-r-- 1 ikun ikun    0  2月 21 10:58 abc.txt
...
-rw-rw-r-- 1 ikun ikun   12  2月 21 11:07 test.txt


ikun@ubuntu2004:~/Desktop$ echo $MY_PATH
/home/ikun/Documents
```

