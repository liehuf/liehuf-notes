---
title: 08.C语言的位操作
date: 2025-10-18 11:00:00
permalink: /pages/C_08/
---

# C语言位运算详解：掌握底层的力量

位运算是C语言最具“底层味”的部分之一。
 它让你直接操作二进制位，从而实现**高效的运算、标志控制、寄存器管理、加密与协议解析**等功能。
 无论是搞嵌入式、芯片驱动，还是高性能算法，位操作都绕不过去。

------

## 一、什么是位运算？

C语言中的位运算是针对**整数类型（int、char、short、long）\**按\**二进制位**进行的操作。
 这些运算不会改变数据类型，只是改变二进制的比特位。

常见的位运算符如下👇：

| 运算符 | 含义     | 示例     | 作用说明                          |
| ------ | -------- | -------- | --------------------------------- |
| `&`    | 按位与   | `a & b`  | 两位都为1才为1                    |
| `|`    | 按位或   | 按位或   | 两位有一位为1就为1                |
| `^`    | 按位异或 | `a ^ b`  | 相同为0，不同为1                  |
| `~`    | 按位取反 | `~a`     | 0变1，1变0                        |
| `<<`   | 左移     | `a << n` | 所有位左移n位，右边补0            |
| `>>`   | 右移     | `a >> n` | 所有位右移n位（符号位视情况保持） |

------

## 二、按位运算的基本示例

```c
#include <stdio.h>

int main() {
    unsigned char a = 0b10101010; // 170
    unsigned char b = 0b11001100; // 204

    printf("a & b = 0x%X\n", a & b); // 按位与
    printf("a | b = 0x%X\n", a | b); // 按位或
    printf("a ^ b = 0x%X\n", a ^ b); // 按位异或
    printf("~a = 0x%X\n", ~a);       // 取反
    printf("a << 1 = 0x%X\n", a << 1);
    printf("b >> 2 = 0x%X\n", b >> 2);

    return 0;
}
```

🧩 输出示例：

```
a & b = 0xA8
a | b = 0xEE
a ^ b = 0x46
~a = 0x55
a << 1 = 0x54
b >> 2 = 0x33
```

------

## 三、位运算的常见用途

### 🔹1. 标志位控制（Flags）

在嵌入式开发中，常用**一个字节或整型变量**的各个bit表示不同的开关状态。

```c
#define FLAG_READ  0x01  // 0000 0001
#define FLAG_WRITE 0x02  // 0000 0010
#define FLAG_EXEC  0x04  // 0000 0100

unsigned char flag = 0;

// 设置标志
flag |= FLAG_READ;   // 开启READ
flag |= FLAG_WRITE;  // 开启WRITE

// 检查标志
if (flag & FLAG_READ) {
    printf("Read enabled\n");
}

// 清除标志
flag &= ~FLAG_WRITE; // 关闭WRITE
```

> 💡技巧：
>  用 `|` 设置，用 `&~` 清除，用 `&` 检查，用 `^` 切换。

------

### 🔹2. 高低字节分离与合并

位运算是拆分数据最直接的方式。

```c
unsigned short data = 0x1234;

unsigned char high = (data >> 8) & 0xFF;
unsigned char low  = data & 0xFF;

printf("高字节: 0x%X, 低字节: 0x%X\n", high, low);

// 合并
unsigned short combine = ((unsigned short)high << 8) | low;
printf("合并结果: 0x%X\n", combine);
```

------

### 🔹3. 提取或修改某一位

我们可以通过位掩码（mask）来操作单个位。

```c
unsigned char x = 0b10110010;

// 取第3位（从0开始）
int bit3 = (x >> 3) & 1;  // 结果：0

// 设置第2位为1
x |= (1 << 2);

// 清除第7位
x &= ~(1 << 7);

// 翻转第0位
x ^= 1 << 0;

printf("x = 0b");
for (int i = 7; i >= 0; i--)
    printf("%d", (x >> i) & 1);
printf("\n");
```

------

### 🔹4. 高级用法：寄存器与协议解析

在硬件寄存器映射中，位运算是基础操作：

```c
typedef union {
    struct {
        unsigned char BIT0 : 1;
        unsigned char BIT1 : 1;
        unsigned char MODE : 2;
        unsigned char ENABLE : 1;
        unsigned char RESERVED : 3;
    } bits;
    unsigned char reg;
} ControlReg;

int main() {
    ControlReg ctrl = {0};
    ctrl.bits.ENABLE = 1;
    ctrl.bits.MODE = 2;

    printf("寄存器值 = 0x%02X\n", ctrl.reg);
    return 0;
}
```

输出：

```c
寄存器值 = 0x14
```

这种写法在STM32、FPGA外围驱动等领域极其常见。
 结构体配合位运算可以同时兼顾**代码可读性与硬件精度控制**。
