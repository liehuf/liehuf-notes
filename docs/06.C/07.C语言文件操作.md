---
title: 07.C语言文件操作
date: 2025-10-18 10:00:00
permalink: /pages/C_07/
---

# C 语言文件操作详解：读写、定位、文本 vs 二进制

在 C 语言里，文件操作是把程序的数据持久化、与外部资源交换的重要方式。
 无论你做的是日志、配置、序列化、还是读写二进制协议，都离不开文件 I/O。

------

## 一、文件操作的基本概念与模式

### 1. 文件是字节序列（stream of bytes）

在 C 里，不论是“文本文件”还是“二进制文件”，在磁盘上都只是字节流。C 标准库把它抽象成 **流（stream）**，每个流都由一个 `FILE *` 指针来管理。

`stdio.h` 里定义了关于流、缓冲、EOF、各种读写函数等的标准接口。

### 2. 打开 / 关闭文件：`fopen()` / `fclose()`

```c
FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *fp);
```

- `fopen`：给定文件名和打开模式，返回一个 `FILE*` 流指针；若打开失败，返回 `NULL`。
- `fclose`：关闭文件流、刷新缓冲、释放资源。成功返回 0，失败返回 `EOF`。

| 模式   | 含义（文本模式）                   | 备注                         |
| ------ | ---------------------------------- | ---------------------------- |
| `"r"`  | 只读，文件必须存在                 | 读取模式，从文件头开始       |
| `"w"`  | 只写，若不存在则创建；若存在则清空 | 写模式会先清空原内容         |
| `"a"`  | 追加写，若不存在则创建             | 写入总是从文件尾开始         |
| `"r+"` | 读写模式，文件必须存在             | 不清空，既可读也可写         |
| `"w+"` | 读写模式，若已存在则清空           | 文件存在即被截断             |
| `"a+"` | 读/追加写                          | 可以读取，也可以一直追加写入 |

如果是二进制文件，还要在模式里加 `b`，如 `"rb"`, `"wb+"` 等。

⚠️ 在 Windows 平台上，若不加 `b`，写入或读取可能会把 `\n` 做成 `\r\n` 或反之等转换。文本 vs 二进制模式的区别在于是否进行换行符的自动转换。

------

## 二、文本 I/O：按字符 / 按行 / 格式化写读

这是最容易上手、最常用的一类文件操作。

### 1. 写入字符 / 字符串：`fputc()`, `fputs()`, `fprintf()`

- `int fputc(int c, FILE *fp);`：写一个字符到文件。成功返回写入字符，否则返回 `EOF`。
- `int fputs(const char *s, FILE *fp);`：写一个以 `\0` 结尾的字符串（不附加换行符）。成功返回非负值，失败返回 `EOF`。
- `int fprintf(FILE *fp, const char *format, ...);`：类似 `printf`，带格式化功能，写入到文件流。

### 2. 读取字符 / 行 / 格式化读：`fgetc()`, `fgets()`, `fscanf()`

- `int fgetc(FILE *fp);`：从文件中读取一个字符。返回该字符（以 `int` 形式），若遇错误或 EOF 返回 `EOF`
- `char *fgets(char *buf, int n, FILE *fp);`：从流读取最多 `n-1` 个字符，遇换行符或 EOF 停止，最后在字符串后加 `\0`。如果读到 EOF 且没有读到字符则返回 `NULL`。
- `int fscanf(FILE *fp, const char *format, ...);`：类似 `scanf`，按格式从文件中读取数据。遇空格、换行、格式不匹配等会停止。返回成功解析的项数或 `EOF`。

### 3. 检测文件结尾、错误

- `int feof(FILE *fp);`：检查是否已到文件末尾，若是返回非零。
- `int ferror(FILE *fp);`：检测流的错误状态。
- `void clearerr(FILE *fp);`：清除流的错误/EOF 标志。

------

## 三、二进制 I/O：`fread()` / `fwrite()`

当你要以“块”为单位读写内存（如数组、结构体、图像数据、网络协议包等），用文本 I/O 有时不合适，二进制 I/O 更高效、精确。

```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

- `ptr`：内存地址，读入或写出的目标
- `size`：单个元素的字节大小
- `nmemb`：元素个数
- 返回值：成功读写的元素数目（不是字节数）

例如，用 `fwrite(&obj, sizeof(obj), 1, fp)` 把结构体写入文件；用 `fread(&obj2, sizeof(obj2), 1, fp)` 读回来。

------

## 四、定位 / 偏移：`fseek()`, `ftell()`, `rewind()`

有时候你不希望按顺序读写，而是“跳转”到文件某个位置去操作。

- `int fseek(FILE *stream, long offset, int whence);`：移动文件内部指针
  - `SEEK_SET` 从文件头开始
  - `SEEK_CUR` 从当前位置
  - `SEEK_END` 从文件尾
- `long ftell(FILE *stream);`：返回当前文件指针相对于文件开头的偏移（字节数）
- `void rewind(FILE *stream);`：等价于 `fseek(stream, 0, SEEK_SET)`，把指针移到文件头。[博客园+1](https://www.cnblogs.com/bigflyny/p/17607533.html?utm_source=chatgpt.com)

例如，可以用 `fseek(fp, 0, SEEK_END)` + `ftell()` 来测文件大小。

------

## 五、典型代码示例

下面是一个综合示例，演示文本读写 + 二进制读写 + 定位操作：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    float value;
} Record;

int main() {
    FILE *fp;
    // ——————— 写文本 + 写二进制 ———————
    fp = fopen("data.txt", "w");
    if (fp == NULL) {
        perror("打开 data.txt 失败");
        return 1;
    }
    fprintf(fp, "Hello, 文件操作!\n");
    fputs("再写一行文本。\n", fp);
    fclose(fp);

    fp = fopen("data.bin", "wb");
    if (fp == NULL) {
        perror("打开 data.bin 失败");
        return 1;
    }
    Record rec1 = {100, 3.14f};
    // 把结构体写入二进制文件
    if (fwrite(&rec1, sizeof(Record), 1, fp) != 1) {
        perror("fwrite 失败");
    }
    fclose(fp);

    // ——————— 读文本文件 ———————
    fp = fopen("data.txt", "r");
    if (fp == NULL) {
        perror("打开 data.txt 失败");
        return 1;
    }
    char buf[128];
    while (fgets(buf, sizeof(buf), fp) != NULL) {
        printf("读到一行：%s", buf);
    }
    fclose(fp);

    // ——————— 读二进制 + 定位测试 ———————
    fp = fopen("data.bin", "rb");
    if (fp == NULL) {
        perror("打开 data.bin 失败");
        return 1;
    }
    // 找到文件末尾，测大小
    fseek(fp, 0, SEEK_END);
    long sz = ftell(fp);
    printf("data.bin 的大小 = %ld 字节\n", sz);

    rewind(fp);  // 指针回到头
    Record rec2;
    if (fread(&rec2, sizeof(Record), 1, fp) == 1) {
        printf("读取结构体：id = %d, value = %.2f\n",
               rec2.id, rec2.value);
    } else {
        perror("fread 失败");
    }
    fclose(fp);

    return 0;
}
```

**说明要点：**

- 我们用 `fprintf` / `fputs` 写文本，用 `fgets` 读文本；
- 用 `fwrite` / `fread` 写/读结构体（二进制）；
- 用 `fseek` + `ftell` 得到文件大小；
- 用 `rewind` 重置文件位置。

------

## 六、常见坑点 / 注意事项

| ⚠️ 问题                                     | 说明 / 经验教训                                              |
| ------------------------------------------ | ------------------------------------------------------------ |
| **检查 `fopen` 返回值**                    | 打开失败要马上处理，别拿 `NULL` 去读写。                     |
| **缓冲刷新 / 数据丢失**                    | 写操作最后要 `fclose()` 或 `fflush()`，否则缓冲里的数据可能没写到文件上。 |
| **文本 vs 二进制模式差异**                 | 在 Windows 上，不加 `b` 模式可能造成 `\n ↔ \r\n` 转换。      |
| **结构体二进制可移植性**                   | 结构体的内存布局可能因对齐、字节序（Endian）、编译器差异而不同，不宜在不同平台直接用二进制方式交换结构体。 |
| **不要混用文本和二进制读写**               | 若用文本函数去读写二进制数据可能出错。最好明确一个文件是“纯文本”或“纯二进制”。 |
| **`fseek` 在追加模式下不总能改变写入位置** | 如果文件以 append 模式打开（如 `"a"` 或 `"a+"`），写入操作仍然可能强制在文件尾。 |
| **`ftell` / `fseek` 的返回值 / 错误情况**  | `ftell` 出错返回 `-1L`，要检查；`fseek` 成功返回 0，失败返回非零。 |
| **循环读写判断 EOF**                       | 使用 `while (fgets(...) != NULL)`、或 `while (fread(...) == expected_count)`，避免用 `feof` 作为主循环条件。 |
| **文件名 / 路径**                          | 使用完整路径、注意操作系统的路径分隔符（Linux `/`，Windows `\` 或 `/`），以及目录是否存在。 |
