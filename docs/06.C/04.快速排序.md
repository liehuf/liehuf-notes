---
title: 04.快速排序
date: 2025-10-11 16:00:00
permalink: /pages/C_04/
---

快速排序 (quick sort) 是一种基于分治策略的排序算法，运行高效，应用广泛。

快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。

1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线。

快速排序的实质是将一个较长的数组的排序问题简化为两个较短数组的排序问题。

实现代码如下：
```c
#include <stdio.h>

// 1️⃣ 交换两个数
void swap(int *a, int *b) 
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 2️⃣ 哨兵划分函数
int partition(int arr[], int low, int high) 
{
    int pivot = arr[low];        // 选取第一个元素为基准
    int left = low;
    int right = high;

    while (left < right) 
    {
        // 从右往左找第一个小于 pivot 的元素
        while (left < right && arr[right] >= pivot) 
        {
            right--;
        }
        // 从左往右找第一个大于 pivot 的元素
        while (left < right && arr[left] <= pivot) 
        {
            left++;
        }
        // 交换左右两边的不符合条件的元素
        if (left < right) {
            swap(&arr[left], &arr[right]);
        }
    }

    // 最后把 pivot 放到中间正确位置
    arr[low] = arr[left];
    arr[left] = pivot;

    return left;  // 返回基准位置
}

// 3️⃣ 快速排序（递归）
void quickSort(int arr[], int low, int high) 
{
    if (low < high) 
    {
        int pivotPos = partition(arr, low, high);
        quickSort(arr, low, pivotPos - 1);   // 递归排序左子数组
        quickSort(arr, pivotPos + 1, high);  // 递归排序右子数组
    }
}

// 4️⃣ 主函数
int main() 
{
    int arr[21] = {42, 17, 8, 99, 23, 54, 76, 11, 4, 65,
                   32, 88, 2, 19, 71, 50, 13, 6, 28, 91, 35};
    int n = 21;

    printf("排序前：\n");
    for (int i = 0; i < n; i++) 
    {
        printf("%d ", arr[i]);
    }

    quickSort(arr, 0, n - 1);  // 调用快速排序

    printf("\n\n排序后：\n");
    for (int i = 0; i < n; i++) 
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
    return 0;
}

```