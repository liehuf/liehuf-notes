(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"66d4430f",3:"b0750cde",4:"27bf2368",5:"0c585c88",6:"bbde6285",7:"4f62bbe2",8:"82ef7b83",9:"21abb88b",10:"3ad0051a",11:"915ca756",12:"2bb44911",13:"b5a2e07d",14:"f6b0fb41",15:"c30ed022",16:"8cb890d3",17:"73a71826",18:"6ea86b88",19:"354c2de4",20:"bdb255c5",21:"f0bbbc47",22:"0dc6c302",23:"badb89c1",24:"72f91c5c",25:"f91562f6",26:"dd602ae9",27:"5d4fb89f",28:"ae7872dd",29:"5f421ea7",30:"6d4ac098",31:"c533ca05",32:"3e5c8a98",33:"e88de717",34:"cc5e209e",35:"16ad07d4",36:"1845134d",37:"b8fab9d1",38:"aa7f913e",39:"b12c58f8",40:"ecaf18f7",41:"eea4512b",42:"272352ed",43:"4e102a5e",44:"e12626ec",45:"07b507f3",46:"eb425dad",47:"502c72f1",48:"922a0868",49:"f3bab53d",50:"a6191add",51:"dfb062f9",52:"41d9d93c",53:"e8c7ae2c",54:"8c1c921a",55:"434111d6",56:"9a06398a",57:"692a8d05",58:"e41cc40f",59:"b0ea842e",60:"5c6a6b8d",61:"41e82863",62:"4c27b73e",63:"f8f59555",64:"98085585",65:"b33a4997",66:"9ad6c150",67:"e911c9b2",68:"3288dbd2",69:"99e254be",70:"013c3123"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;a.push([134,0]),t()}([function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,a=i.call,o=r&&i.bind.bind(a,a);n.exports=r?o:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var r=t(9),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not an object")}},function(n,e,t){"use strict";var r=t(34),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var r=t(11),i=t(4),a=t(149),o=t(5),s=t(1),l=t(90),c=t(131),u=t(91),d=t(0),p=t(10),f=t(17),h=t(92).IteratorPrototype,m=t(7),g=t(26),v=f("toStringTag"),b=TypeError,_=i.Iterator,y=g||!s(_)||_.prototype!==h||!d((function(){_({})})),x=function(){if(a(this,h),l(this)===h)throw new b("Abstract class Iterator not directly constructable")},w=function(n,e){m?c(h,n,{configurable:!0,get:function(){return e},set:function(e){if(o(this),this===h)throw new b("You can't redefine this property");p(this,n)?this[n]=e:u(this,n,e)}}):h[n]=e};p(h,v)||w(v,"Iterator"),!y&&p(h,"constructor")&&h.constructor!==Object||w("constructor",x),x.prototype=h,r({global:!0,constructor:!0,forced:y},{Iterator:x})},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){"use strict";var r=t(3),i=t(33),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){"use strict";var r=t(4),i=t(77).f,a=t(27),o=t(47),s=t(55),l=t(87),c=t(148);n.exports=function(n,e){var t,u,d,p,f,h=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[h]||s(h,{}):r[h]&&r[h].prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(f=i(t,u))&&f.value:t[u],!c(m?u:h+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),o(t,u,p,n)}}},function(n,e,t){"use strict";var r=t(1),i=t(53),a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(12),o=t(5),s=t(28),l=t(93),c=t(94),u=t(26),d=t(14),p=t(95),f=t(29),h=!u&&!p("filter",(function(){})),m=!u&&!h&&f("filter",TypeError),g=u||h||m,v=l((function(){for(var n,e,t=this.iterator,r=this.predicate,a=this.next;;){if(n=o(i(a,t)),this.done=!!n.done)return;if(e=n.value,c(t,r,[e,this.counter++],!0))return e}}));r({target:"Iterator",proto:!0,real:!0,forced:g},{filter:function(n){o(this);try{a(n)}catch(n){d(this,"throw",n)}return m?i(m,this,n):new v(s(this),{predicate:n})}})},function(n,e,t){"use strict";var r=t(6),i=t(5),a=t(39);n.exports=function(n,e,t){var o,s;i(n);try{if(!(o=a(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return i(o),t}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(102),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";var r=t(4),i=t(82),a=t(10),o=t(56),s=t(38),l=t(79),c=r.Symbol,u=i("wks"),d=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return a(u,n)||(u[n]=s&&a(c,n)?c[n]:d("Symbol."+n)),u[n]}},function(n,e,t){"use strict";var r=t(7),i=t(83),a=t(85),o=t(5),s=t(78),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(203),i=t(206);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(46),t(8),t(13),t(22),t(21);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:i,themeConfig:a}=t,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return m(n);const s=o.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?m(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function m(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function _(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return _(e)-_(n)}},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(12),o=t(5),s=t(28),l=t(93),c=t(94),u=t(14),d=t(95),p=t(29),f=t(26),h=!f&&!d("map",(function(){})),m=!f&&!h&&p("map",TypeError),g=f||h||m,v=l((function(){var n=this.iterator,e=o(i(this.next,n));if(!(this.done=!!e.done))return c(n,this.mapper,[e.value,this.counter++],!0)}));r({target:"Iterator",proto:!0,real:!0,forced:g},{map:function(n){o(this);try{a(n)}catch(n){u(this,"throw",n)}return m?i(m,this,n):new v(s(this),{mapper:n})}})},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(48),o=t(12),s=t(5),l=t(28),c=t(14),u=t(29)("forEach",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:u},{forEach:function(n){s(this);try{o(n)}catch(n){c(this,"throw",n)}if(u)return i(u,this,n);var e=l(this),t=0;a(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(3),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){"use strict";var r=t(4),i=t(1),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(7),i=t(18),a=t(35);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=r.Iterator,i=t&&t.prototype,a=i&&i[n],o=!1;if(a)try{a.call({next:function(){return{done:!0}},return:function(){o=!0}},-1)}catch(n){n instanceof e||(o=!1)}if(!o)return a}},function(n,e,t){"use strict";var r=t(146);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(32),i=t(188),a=t(189),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(16).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(50),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(73),i=t(50);n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(80),i=t(0),a=t(4).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r=t(12),i=t(51);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e,t){var r=t(193),i=t(194),a=t(195),o=t(196),s=t(197);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(104);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(19)(Object,"create");n.exports=r},function(n,e,t){var r=t(215);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(70);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(11),i=t(33),a=t(30),o=t(179),s=t(180);r({target:"Array",proto:!0,arity:1,forced:t(0)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){"use strict";var r=t(1),i=t(18),a=t(86),o=t(55);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(132),i=t(6),a=t(5),o=t(53),s=t(163),l=t(30),c=t(37),u=t(164),d=t(97),p=t(14),f=TypeError,h=function(n,e){this.stopped=n,this.result=e},m=h.prototype;n.exports=function(n,e,t){var g,v,b,_,y,x,w,k=t&&t.that,E=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_RECORD),z=!(!t||!t.IS_ITERATOR),C=!(!t||!t.INTERRUPTED),I=r(e,k),R=function(n){return g&&p(g,"normal"),new h(!0,n)},$=function(n){return E?(a(n),C?I(n[0],n[1],R):I(n[0],n[1])):C?I(n,R):I(n)};if(T)g=n.iterator;else if(z)g=n;else{if(!(v=d(n)))throw new f(o(n)+" is not iterable");if(s(v)){for(b=0,_=l(n);_>b;b++)if((y=$(n[b]))&&c(m,y))return y;return new h(!1)}g=u(n,v)}for(x=T?n.next:g.next;!(w=i(x,g)).done;){try{y=$(w.value)}catch(n){p(g,"throw",n)}if("object"==typeof y&&y&&c(m,y))return y}return new h(!1)}},function(n,e,t){"use strict";var r=t(98),i=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){"use strict";var r=t(51),i=TypeError;n.exports=function(n){if(r(n))throw new i("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(25),i=t(1),a=t(37),o=t(79),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,s(n))}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(26),i=t(4),a=t(55),o=n.exports=i["__core-js_shared__"]||a("__core-js_shared__",{});(o.versions||(o.versions=[])).push({version:"3.47.0",mode:r?"pure":"global",copyright:"© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",license:"https://github.com/zloirock/core-js/blob/v3.47.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(4),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";var r=t(3),i=0,a=Math.random(),o=r(1.1.toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){"use strict";var r,i,a,o=t(140),s=t(4),l=t(9),c=t(27),u=t(10),d=t(54),p=t(58),f=t(59),h=s.TypeError,m=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new m);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},i=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=p("state");f[v]=!0,r=function(n,e){if(u(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},i=function(n){return u(n,v)?n[v]:{}},a=function(n){return u(n,v)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(82),i=t(56),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(24);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){var r=t(187),i=t(23),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(19)(t(16),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(207),i=t(214),a=t(216),o=t(217),s=t(218);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(15),i=t(70),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(31),i=t(23);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);var r={name:"FloatingSocialIcons",data:()=>({qrVisible:{bilibili:!1,wechat:!1}}),methods:{showQR(n){this.qrVisible[n]=!0},hideQR(n){this.qrVisible[n]=!1}}},i=(t(286),t(2)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"floating-social-icons"},[e("div",{staticClass:"social-item",on:{mouseenter:function(e){return n.showQR("bilibili")},mouseleave:function(e){return n.hideQR("bilibili")}}},[e("svg",{staticClass:"social-icon bilibili",attrs:{viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg"}},[e("path",{attrs:{d:"M6.5 4.5C5.7 4.5 5 5.2 5 6v12c0 .8.7 1.5 1.5 1.5h11c.8 0 1.5-.7 1.5-1.5V6c0-.8-.7-1.5-1.5-1.5h-11z",fill:"currentColor"}}),n._v(" "),e("rect",{attrs:{x:"7",y:"7",width:"10",height:"6",rx:"1",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"9.5",cy:"9.5",r:"0.8",fill:"#00a1d6"}}),n._v(" "),e("circle",{attrs:{cx:"14.5",cy:"9.5",r:"0.8",fill:"#00a1d6"}}),n._v(" "),e("path",{attrs:{d:"M10.5 11.5c1 0 2 .5 2.5 1h-5c.5-.5 1.5-1 2.5-1z",fill:"#00a1d6"}}),n._v(" "),e("circle",{attrs:{cx:"8",cy:"3",r:"1",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"16",cy:"3",r:"1",fill:"currentColor"}}),n._v(" "),e("path",{attrs:{d:"M8 4V3M16 4V3",stroke:"currentColor","stroke-width":"1","stroke-linecap":"round"}}),n._v(" "),e("circle",{attrs:{cx:"9",cy:"16",r:"1",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"15",cy:"16",r:"1",fill:"white"}})]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.qrVisible.bilibili,expression:"qrVisible.bilibili"}],staticClass:"qr-dropdown"},[e("img",{attrs:{src:"/img/base/bilibili-qr.png",alt:"B站二维码"}}),n._v(" "),e("p",[n._v("欢迎关注小破站")])])]),n._v(" "),e("div",{staticClass:"social-item",on:{mouseenter:function(e){return n.showQR("wechat")},mouseleave:function(e){return n.hideQR("wechat")}}},[e("svg",{staticClass:"social-icon wechat",attrs:{viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg"}},[e("path",{attrs:{d:"M8.5 5C5.5 5 3 7.2 3 10c0 1.5.7 2.8 2 3.7L4.5 16l2.3-1.2c.6.2 1.2.2 1.8.2.2 0 .4 0 .6-.1-.1-.4-.2-.8-.2-1.2 0-2.8 2.5-5 5.5-5 .2 0 .4 0 .6.1C14.5 6.7 11.8 5 8.5 5z",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"6.5",cy:"9.5",r:"0.8",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"10.5",cy:"9.5",r:"0.8",fill:"white"}}),n._v(" "),e("path",{attrs:{d:"M14.5 9.5c-2.5 0-4.5 1.7-4.5 3.8s2 3.8 4.5 3.8c.5 0 1-.1 1.4-.3L17.5 18l-.4-1.2c1-.7 1.6-1.7 1.6-2.8 0-2.1-2-3.8-4.5-3.8z",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"13",cy:"12.5",r:"0.5",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"16",cy:"12.5",r:"0.5",fill:"white"}})]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.qrVisible.wechat,expression:"qrVisible.wechat"}],staticClass:"qr-dropdown"},[e("img",{attrs:{src:"/img/base/wechat-qr.png",alt:"微信公众号二维码"}}),n._v(" "),e("p",[n._v("欢迎关注公众号")])])])])}),[],!1,null,"cb9e887a",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(3),i=t(0),a=t(24),o=Object,s=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"===a(n)?s(n,""):o(n)}:o},function(n,e,t){"use strict";var r,i=t(5),a=t(151),o=t(60),s=t(59),l=t(153),c=t(84),u=t(58),d=u("IE_PROTO"),p=function(){},f=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},m=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;m="undefined"!=typeof document?document.domain&&r?h(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):h(r);for(var t=o.length;t--;)delete m.prototype[o[t]];return m()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[d]=n):t=m(),void 0===e?t:a.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function _(n){return c=n,s=setTimeout(x,e),u?b(n):o}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function x(){var n=f();if(y(n))return w(n);s=setTimeout(x,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function w(n){return s=void 0,v&&r?b(n):(r=i=void 0,o)}function k(){var n=f(),t=y(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return _(l);if(g)return s=setTimeout(x,e),b(l)}return void 0===s&&(s=setTimeout(x,e)),o}return e=m(e)||0,h(t)&&(u=!!t.leading,a=(g="maxWait"in t)?d(m(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},k.flush=function(){return void 0===s?o:w(f())},k}},function(n,e,t){"use strict";var r=t(7),i=t(6),a=t(135),o=t(35),s=t(36),l=t(78),c=t(10),u=t(83),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){"use strict";var r=t(136),i=t(52);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){"use strict";var r=t(38);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r,i,a=t(4),o=t(81),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){"use strict";var r=t(4).navigator,i=r&&r.userAgent;n.exports=i?String(i):""},function(n,e,t){"use strict";var r=t(54);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";var r=t(7),i=t(0),a=t(84);n.exports=!r&&!i((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(4),i=t(9),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){"use strict";var r=t(7),i=t(0);n.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(3),i=t(0),a=t(1),o=t(10),s=t(7),l=t(138).CONFIGURABLE,c=t(139),u=t(57),d=u.enforce,p=u.get,f=String,h=Object.defineProperty,m=r("".slice),g=r("".replace),v=r([].join),b=s&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),_=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===m(f(e),0,7)&&(e="["+g(f(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return o(r,"source")||(r.source=v(_,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var r=t(10),i=t(141),a=t(77),o=t(18);n.exports=function(n,e,t){for(var s=i(e),l=o.f,c=a.f,u=0;u<s.length;u++){var d=s[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var r=t(3),i=t(10),a=t(36),o=t(143).indexOf,s=t(59),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,u=[];for(t in r)!i(s,t)&&i(r,t)&&l(u,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(u,t)||l(u,t));return u}},function(n,e,t){"use strict";var r=t(145);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(10),i=t(1),a=t(33),o=t(58),s=t(150),l=o("IE_PROTO"),c=Object,u=c.prototype;n.exports=s?c.getPrototypeOf:function(n){var e=a(n);if(r(e,l))return e[l];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof c?u:null}},function(n,e,t){"use strict";var r=t(7),i=t(18),a=t(35);n.exports=function(n,e,t){r?i.f(n,e,a(0,t)):n[e]=t}},function(n,e,t){"use strict";var r,i,a,o=t(0),s=t(1),l=t(9),c=t(74),u=t(90),d=t(47),p=t(17),f=t(26),h=p("iterator"),m=!1;[].keys&&("next"in(a=[].keys())?(i=u(u(a)))!==Object.prototype&&(r=i):m=!0),!l(r)||o((function(){var n={};return r[h].call(n)!==n}))?r={}:f&&(r=c(r)),s(r[h])||d(r,h,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){"use strict";var r=t(6),i=t(74),a=t(27),o=t(154),s=t(17),l=t(57),c=t(39),u=t(92).IteratorPrototype,d=t(155),p=t(14),f=t(156),h=s("toStringTag"),m=l.set,g=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return o(i(u),{next:function(){var t=e(this);if(n)return t.nextHandler();if(t.done)return d(void 0,!0);try{var r=t.nextHandler();return t.returnHandlerResult?r:d(r,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),i=t.iterator;if(t.done=!0,n){var a=c(i,"return");return a?r(a,i):d(void 0,!0)}if(t.inner)try{p(t.inner.iterator,"normal")}catch(n){return p(i,"throw",n)}if(t.openIters)try{f(t.openIters,"normal")}catch(n){return p(i,"throw",n)}return i&&p(i,"normal"),d(void 0,!0)}})},v=g(!0),b=g(!1);a(b,h,"Iterator Helper"),n.exports=function(n,e,t){var r=function(r,i){i?(i.iterator=r.iterator,i.next=r.next):i=r,i.type=e?"WrapForValidIterator":"IteratorHelper",i.returnHandlerResult=!!t,i.nextHandler=n,i.counter=0,i.done=!1,m(this,i)};return r.prototype=e?v:b,r}},function(n,e,t){"use strict";var r=t(5),i=t(14);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";n.exports=function(n,e){var t="function"==typeof Iterator&&Iterator.prototype[n];if(t)try{t.call({next:null},e).next()}catch(n){return!0}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var r=t(98),i=t(39),a=t(51),o=t(96),s=t(17)("iterator");n.exports=function(n){if(!a(n))return i(n,s)||i(n,"@@iterator")||o[r(n)]}},function(n,e,t){"use strict";var r=t(165),i=t(1),a=t(24),o=t(17)("toStringTag"),s=Object,l="Arguments"===a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?a(e):"Object"===(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r=t(169),i=t(9),a=t(50),o=t(170);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),i(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e,t){"use strict";var r=t(3),i=t(10),a=SyntaxError,o=parseInt,s=String.fromCharCode,l=r("".charAt),c=r("".slice),u=r(/./.exec),d={'\\"':'"',"\\\\":"\\","\\/":"/","\\b":"\b","\\f":"\f","\\n":"\n","\\r":"\r","\\t":"\t"},p=/^[\da-f]{4}$/i,f=/^[\u0000-\u001F]$/;n.exports=function(n,e){for(var t=!0,r="";e<n.length;){var h=l(n,e);if("\\"===h){var m=c(n,e,e+2);if(i(d,m))r+=d[m],e+=2;else{if("\\u"!==m)throw new a('Unknown escape sequence: "'+m+'"');var g=c(n,e+=2,e+4);if(!u(p,g))throw new a("Bad Unicode escape at: "+e);r+=s(o(g,16)),e+=4}}else{if('"'===h){t=!1,e++;break}if(u(f,h))throw new a("Bad control character in string literal at: "+e);r+=h,e++}}if(t)throw new a("Unterminated string at: "+e);return{value:r,end:e}}},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(40),i=t(198),a=t(199),o=t(200),s=t(201),l=t(202);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(31),i=t(65);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(219),i=t(23);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(109),i=t(222),a=t(110);n.exports=function(n,e,t,o,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),f=l.get(e);if(p&&f)return p==e&&f==n;var h=-1,m=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var v=n[h],b=e[h];if(o)var _=c?o(b,v,h,e,n,l):o(v,b,h,n,e,l);if(void 0!==_){if(_)continue;m=!1;break}if(g){if(!i(e,(function(n,e){if(!a(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){m=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(66),i=t(220),a=t(221);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(232),i=t(238),a=t(115);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(16),i=t(234),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(75)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(235),i=t(236),a=t(237),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(105),i=t(68);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(19)(t(16),"Set");n.exports=r},function(n,e,t){var r=t(65);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(120),i=t(44);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(15),i=t(69),a=t(249),o=t(252);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(185),i=t(190),a=t(261),o=t(269),s=t(278),l=t(133),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(287),t(2)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(8),t(13),t(22),t(21);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(288),t(2)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(48),o=t(12),s=t(5),l=t(28),c=t(14),u=t(29)("some",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:u},{some:function(n){s(this);try{o(n)}catch(n){c(this,"throw",n)}if(u)return i(u,this,n);var e=l(this),t=0;return a(e,(function(e,r){if(n(e,t++))return r()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){"use strict";var r=t(86),i=t(18);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){"use strict";var r=t(162),i=t(12),a=t(34),o=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(294)},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(6),i=t(9),a=t(52),o=t(39),s=t(137),l=t(17),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,l=o(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||a(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";var r=t(6),i=t(1),a=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!a(s=r(t,n)))return s;if(i(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!a(s=r(t,n)))return s;throw new o("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(7),i=t(10),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var r=t(3),i=t(1),a=t(54),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){"use strict";var r=t(4),i=t(1),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){"use strict";var r=t(25),i=t(3),a=t(142),o=t(147),s=t(5),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(88),i=t(60).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(36),i=t(144),a=t(30),o=function(n){return function(e,t,o){var s=r(e),l=a(s);if(0===l)return!n&&-1;var c,u=i(o,l);if(n&&t!=t){for(;l>u;)if((c=s[u++])!=c)return!0}else for(;l>u;u++)if((n||u in s)&&s[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){"use strict";var r=t(89),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:r)(e)}},function(n,e,t){"use strict";var r=t(89),i=Math.min;n.exports=function(n){var e=r(n);return e>0?i(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(0),i=t(1),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t===u||t!==c&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var r=t(37),i=TypeError;n.exports=function(n,e){if(r(e,n))return n;throw new i("Incorrect invocation")}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var r=t(7),i=t(85),a=t(18),o=t(5),s=t(36),l=t(152);e.f=r&&!i?Object.defineProperties:function(n,e){o(n);for(var t,r=s(e),i=l(e),c=i.length,u=0;c>u;)a.f(n,t=i[u++],r[t]);return n}},function(n,e,t){"use strict";var r=t(88),i=t(60);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(25);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(47);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var r=t(14);n.exports=function(n,e,t){for(var i=n.length-1;i>=0;i--)if(void 0!==n[i])try{t=r(n[i].iterator,e,t)}catch(n){e="throw",t=n}if("throw"===e)throw t;return t}},function(n,e,t){"use strict";var r=t(11),i=t(158).left,a=t(159),o=t(80);r({target:"Array",proto:!0,forced:!t(160)&&o>79&&o<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(12),i=t(33),a=t(73),o=t(30),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,u){var d=i(e),p=a(d),f=o(d);if(r(t),0===f&&c<2)throw new s(l);var h=n?f-1:0,m=n?-1:1;if(c<2)for(;;){if(h in p){u=p[h],h+=m;break}if(h+=m,n?h<0:f<=h)throw new s(l)}for(;n?h>=0:f>h;h+=m)h in p&&(u=t(u,p[h],h,d));return u}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(161);n.exports="NODE"===r},function(n,e,t){"use strict";var r=t(4),i=t(81),a=t(24),o=function(n){return i.slice(0,n.length)===n};n.exports=o("Bun/")?"BUN":o("Cloudflare-Workers")?"CLOUDFLARE":o("Deno/")?"DENO":o("Node.js/")?"NODE":r.Bun&&"string"==typeof Bun.version?"BUN":r.Deno&&"object"==typeof Deno.version?"DENO":"process"===a(r.process)?"NODE":r.window&&r.document?"BROWSER":"REST"},function(n,e,t){"use strict";var r=t(24),i=t(3);n.exports=function(n){if("Function"===r(n))return i(n)}},function(n,e,t){"use strict";var r=t(17),i=t(96),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,e,t){"use strict";var r=t(6),i=t(12),a=t(5),o=t(53),s=t(97),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return a(r(t,n));throw new l(o(n)+" is not iterable")}},function(n,e,t){"use strict";var r={};r[t(17)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(11),i=t(48),a=t(12),o=t(5),s=t(28),l=t(14),c=t(29),u=t(61),d=t(0),p=TypeError,f=d((function(){[].keys().reduce((function(){}),void 0)})),h=!f&&c("reduce",p);r({target:"Iterator",proto:!0,real:!0,forced:f||h},{reduce:function(n){o(this);try{a(n)}catch(n){l(this,"throw",n)}var e=arguments.length<2,t=e?void 0:arguments[1];if(h)return u(h,this,e?[n]:[n,t]);var r=s(this),c=0;if(i(r,(function(r){e?(e=!1,t=r):t=n(t,r,c),c++}),{IS_RECORD:!0}),e)throw new p("Reduce of empty iterator with no initial value");return t}})},function(n,e,t){"use strict";var r=t(11),i=t(4),a=t(61),o=t(168),s=i.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(25),i=t(10),a=t(27),o=t(37),s=t(99),l=t(87),c=t(172),u=t(173),d=t(174),p=t(175),f=t(176),h=t(7),m=t(26);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),_=b[b.length-1],y=r.apply(null,b);if(y){var x=y.prototype;if(!m&&i(x,"cause")&&delete x.cause,!t)return y;var w=r("Error"),k=e((function(n,e){var t=d(g?e:n,void 0),r=g?new y(n):new y;return void 0!==t&&a(r,"message",t),f(r,k,r.stack,2),this&&o(x,this)&&u(r,this,k),arguments.length>v&&p(r,arguments[v]),r}));if(k.prototype=x,"Error"!==_?s?s(k,w):l(k,w,{name:!0}):h&&"stackTraceLimit"in y&&(c(k,y,"stackTraceLimit"),c(k,y,"prepareStackTrace")),l(k,y),!m)try{x.name!==_&&a(x,"name",_),x.constructor=k}catch(n){}return k}}},function(n,e,t){"use strict";var r=t(3),i=t(12);n.exports=function(n,e,t){try{return r(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(171),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(9);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(18).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(9),a=t(99);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){"use strict";var r=t(49);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(9),i=t(27);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(27),i=t(177),a=t(178),o=Error.captureStackTrace;n.exports=function(n,e,t,s){a&&(o?o(n,e):r(n,"stack",i(t,s)))}},function(n,e,t){"use strict";var r=t(3),i=Error,a=r("".replace),o=String(new i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){"use strict";var r=t(0),i=t(35);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(7),i=t(62),a=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!o(n,"length").writable)throw new a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var r=t(11),i=t(25),a=t(61),o=t(6),s=t(3),l=t(0),c=t(62),u=t(1),d=t(182),p=t(52),f=t(24),h=t(49),m=t(183),g=t(100),v=t(56),b=t(38),_=t(184),y=String,x=i("JSON","stringify"),w=s(/./.exec),k=s("".charAt),E=s("".charCodeAt),T=s("".replace),z=s("".slice),C=s([].push),I=s(1.1.toString),R=/[\uD800-\uDFFF]/g,$=/^[\uD800-\uDBFF]$/,S=/^[\uDC00-\uDFFF]$/,j=v(),A=j.length,L=!b||l((function(){var n=i("Symbol")("stringify detection");return"[null]"!==x([n])||"{}"!==x({a:n})||"{}"!==x(Object(n))})),O=l((function(){return'"\\udf06\\ud834"'!==x("\udf06\ud834")||'"\\udead"'!==x("\udead")})),D=L?function(n,e){var t=m(arguments),r=V(e);if(u(r)||void 0!==n&&!p(n))return t[1]=function(n,e){if(u(r)&&(e=o(r,this,y(n),e)),!p(e))return e},a(x,null,t)}:x,P=function(n,e,t){var r=k(t,e-1),i=k(t,e+1);return w($,n)&&!w(S,i)||w(S,n)&&!w($,r)?"\\u"+I(E(n,0),16):n},V=function(n){if(u(n))return n;if(c(n)){for(var e=n.length,t=[],r=0;r<e;r++){var i=n[r];"string"==typeof i?C(t,i):"number"!=typeof i&&"Number"!==f(i)&&"String"!==f(i)||C(t,h(i))}var a=t.length,o=!0;return function(n,e){if(o)return o=!1,e;if(c(this))return e;for(var r=0;r<a;r++)if(t[r]===n)return e}}};x&&r({target:"JSON",stat:!0,arity:3,forced:L||O||!_},{stringify:function(n,e,t){var r=V(e),i=[],a=D(n,(function(n,e){var t=u(r)?o(r,this,y(n),e):e;return!_&&d(t)?j+(C(i,t.rawJSON)-1):t}),t);if("string"!=typeof a)return a;if(O&&(a=T(a,R,P)),_)return a;for(var s="",l=a.length,c=0;c<l;c++){var p=k(a,c);if('"'===p){var f=g(a,++c).end-1,h=z(a,c,f);s+=z(h,0,A)===j?i[z(h,A)]:'"'+h+'"',c=f}else s+=p}return s}})},function(n,e,t){"use strict";var r=t(9),i=t(57).get;n.exports=function(n){if(!r(n))return!1;var e=i(n);return!!e&&"RawJSON"===e.type}},function(n,e,t){"use strict";var r=t(3);n.exports=r([].slice)},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){var n=JSON.rawJSON("9007199254740993");return!JSON.isRawJSON(n)||"9007199254740993"!==JSON.stringify(n)}))},function(n,e,t){var r=t(101),i=t(186);n.exports=function n(e,t,a,o,s){var l=-1,c=e.length;for(a||(a=i),s||(s=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,o,s):r(s,u):o||(s[s.length]=u)}return s}},function(n,e,t){var r=t(32),i=t(63),a=t(15),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(31),i=t(23);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(32),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(191),i=t(247),a=t(71),o=t(15),s=t(258);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(192),i=t(246),a=t(118);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(103),i=t(107);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var u=(c=t[o])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var f=new r;if(a)var h=a(d,p,u,n,e,f);if(!(void 0===h?i(p,d,3,a,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(41),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(41);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(41);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(41);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(40);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(40),i=t(64),a=t(66);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(105),i=t(204),a=t(65),o=t(106),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:s).test(o(n))}},function(n,e,t){var r,i=t(205),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(16)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(208),i=t(40),a=t(64);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(209),i=t(210),a=t(211),o=t(212),s=t(213);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(42);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(42);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(43);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(43);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(103),i=t(108),a=t(223),o=t(226),s=t(242),l=t(15),c=t(112),u=t(114),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,m){var g=l(n),v=l(e),b=g?"[object Array]":s(n),_=v?"[object Array]":s(e),y=(b="[object Arguments]"==b?d:b)==d,x=(_="[object Arguments]"==_?d:_)==d,w=b==_;if(w&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(w&&!y)return m||(m=new r),g||u(n)?i(n,e,t,f,h,m):a(n,e,b,t,f,h,m);if(!(1&t)){var k=y&&p.call(n,"__wrapped__"),E=x&&p.call(e,"__wrapped__");if(k||E){var T=k?n.value():n,z=E?e.value():e;return m||(m=new r),h(T,z,t,f,m)}}return!!w&&(m||(m=new r),o(n,e,t,f,h,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(32),i=t(224),a=t(104),o=t(108),s=t(225),l=t(67),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var m=p.get(n);if(m)return m==e;r|=2,p.set(n,e);var g=o(f(n),f(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(16).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(227),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:i.call(e,p)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var m=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],b=e[p];if(a)var _=l?a(b,v,p,e,n,s):a(v,b,p,n,e,s);if(!(void 0===_?v===b||o(v,b,t,a,s):_)){m=!1;break}g||(g="constructor"==p)}if(m&&!g){var y=n.constructor,x=e.constructor;y==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof x&&x instanceof x||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(228),i=t(229),a=t(111);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(101),i=t(15);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(230),i=t(231),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(233),i=t(63),a=t(15),o=t(112),s=t(113),l=t(114),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&i(n),d=!t&&!u&&o(n),p=!t&&!u&&!d&&l(n),f=t||u||d||p,h=f?r(n.length,String):[],m=h.length;for(var g in n)!e&&!c.call(n,g)||f&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,m))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(31),i=t(68),a=t(23),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(102),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(75)(n))},function(n,e,t){var r=t(239),i=t(240),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(241)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(243),i=t(64),a=t(244),o=t(116),s=t(245),l=t(31),c=t(106),u=c(r),d=c(i),p=c(a),f=c(o),h=c(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||a&&"[object Promise]"!=m(a.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(19)(t(16),"DataView");n.exports=r},function(n,e,t){var r=t(19)(t(16),"Promise");n.exports=r},function(n,e,t){var r=t(19)(t(16),"WeakMap");n.exports=r},function(n,e,t){var r=t(117),i=t(111);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(107),i=t(248),a=t(255),o=t(69),s=t(117),l=t(118),c=t(44);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(119);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(250),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(251);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(66);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(253);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(32),i=t(254),a=t(15),o=t(70),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(256),i=t(257);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(120),i=t(63),a=t(15),o=t(113),s=t(68),l=t(44);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&o(p,u)&&(a(n)||i(n))}},function(n,e,t){var r=t(259),i=t(260),a=t(69),o=t(44);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(119);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(71),i=t(262),a=t(264);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(263),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(265),i=t(268)(r);n.exports=i},function(n,e,t){var r=t(266),i=t(267),a=t(71),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(19),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(109),i=t(270),a=t(275),o=t(110),s=t(276),l=t(67);n.exports=function(n,e,t){var c=-1,u=i,d=n.length,p=!0,f=[],h=f;if(t)p=!1,u=a;else if(d>=200){var m=e?null:s(n);if(m)return l(m);p=!1,u=o,h=new r}else h=e?[]:f;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),f.push(g)}else u(h,v,t)||(h!==f&&h.push(v),f.push(g))}return f}},function(n,e,t){var r=t(271);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(272),i=t(273),a=t(274);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(116),i=t(277),a=t(67),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(115),i=t(23);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(282)},function(n,e,t){"use strict";var r=t(11),i=t(7),a=t(4),o=t(25),s=t(3),l=t(6),c=t(1),u=t(9),d=t(62),p=t(10),f=t(49),h=t(30),m=t(91),g=t(0),v=t(100),b=t(38),_=a.JSON,y=a.Number,x=a.SyntaxError,w=_&&_.parse,k=o("Object","keys"),E=Object.getOwnPropertyDescriptor,T=s("".charAt),z=s("".slice),C=s(/./.exec),I=s([].push),R=/^\d$/,$=/^[1-9]$/,S=/^[\d-]$/,j=/^[\t\n\r ]$/,A=function(n,e,t,r){var i,a,o,s,c,f=n[e],m=r&&f===r.value,g=m&&"string"==typeof r.source?{source:r.source}:{};if(u(f)){var v=d(f),b=m?r.nodes:v?[]:{};if(v)for(i=b.length,o=h(f),s=0;s<o;s++)L(f,s,A(f,""+s,t,s<i?b[s]:void 0));else for(a=k(f),o=h(a),s=0;s<o;s++)c=a[s],L(f,c,A(f,c,t,p(b,c)?b[c]:void 0))}return l(t,n,e,f,g)},L=function(n,e,t){if(i){var r=E(n,e);if(r&&!r.configurable)return}void 0===t?delete n[e]:m(n,e,t)},O=function(n,e,t,r){this.value=n,this.end=e,this.source=t,this.nodes=r},D=function(n,e){this.source=n,this.index=e};D.prototype={fork:function(n){return new D(this.source,n)},parse:function(){var n=this.source,e=this.skip(j,this.index),t=this.fork(e),r=T(n,e);if(C(S,r))return t.number();switch(r){case"{":return t.object();case"[":return t.array();case'"':return t.string();case"t":return t.keyword(!0);case"f":return t.keyword(!1);case"n":return t.keyword(null)}throw new x('Unexpected character: "'+r+'" at: '+e)},node:function(n,e,t,r,i){return new O(e,r,n?null:z(this.source,t,r),i)},object:function(){for(var n=this.source,e=this.index+1,t=!1,r={},i={};e<n.length;){if(e=this.until(['"',"}"],e),"}"===T(n,e)&&!t){e++;break}var a=this.fork(e).string(),o=a.value;e=a.end,e=this.until([":"],e)+1,e=this.skip(j,e),a=this.fork(e).parse(),m(i,o,a),m(r,o,a.value),e=this.until([",","}"],a.end);var s=T(n,e);if(","===s)t=!0,e++;else if("}"===s){e++;break}}return this.node(1,r,this.index,e,i)},array:function(){for(var n=this.source,e=this.index+1,t=!1,r=[],i=[];e<n.length;){if(e=this.skip(j,e),"]"===T(n,e)&&!t){e++;break}var a=this.fork(e).parse();if(I(i,a),I(r,a.value),e=this.until([",","]"],a.end),","===T(n,e))t=!0,e++;else if("]"===T(n,e)){e++;break}}return this.node(1,r,this.index,e,i)},string:function(){var n=this.index,e=v(this.source,this.index+1);return this.node(0,e.value,n,e.end)},number:function(){var n=this.source,e=this.index,t=e;if("-"===T(n,t)&&t++,"0"===T(n,t))t++;else{if(!C($,T(n,t)))throw new x("Failed to parse number at: "+t);t=this.skip(R,t+1)}if(("."===T(n,t)&&(t=this.skip(R,t+1)),"e"===T(n,t)||"E"===T(n,t))&&(t++,"+"!==T(n,t)&&"-"!==T(n,t)||t++,t===(t=this.skip(R,t))))throw new x("Failed to parse number's exponent value at: "+t);return this.node(0,y(z(n,e,t)),e,t)},keyword:function(n){var e=""+n,t=this.index,r=t+e.length;if(z(this.source,t,r)!==e)throw new x("Failed to parse value at: "+t);return this.node(0,n,t,r)},skip:function(n,e){for(var t=this.source;e<t.length&&C(n,T(t,e));e++);return e},until:function(n,e){e=this.skip(j,e);for(var t=T(this.source,e),r=0;r<n.length;r++)if(n[r]===t)return e;throw new x('Unexpected character: "'+t+'" at: '+e)}};var P=g((function(){var n;return w("9007199254740993",(function(e,t,r){n=r.source})),"9007199254740993"!==n})),V=b&&!g((function(){return 1/w("-0 \t")!=-1/0}));r({target:"JSON",stat:!0,forced:P},{parse:function(n,e){return V&&!c(e)?w(n):function(n,e){n=f(n);var t=new D(n,0,""),r=t.parse(),i=r.value,a=t.skip(j,r.end);if(a<n.length)throw new x('Unexpected extra character: "'+T(n,a)+'" after the parsed data at: '+a);return c(e)?A({"":i},"",e,r):i}(n,e)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(121)},function(n,e,t){"use strict";t(122)},function(n,e,t){"use strict";t(123)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(124)},function(n,e,t){"use strict";t(125)},function(n,e,t){"use strict";t(126)},function(n,e,t){"use strict";t.r(e);t(8),t(13),t(21);var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function f(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,v,2):String(n)}function v(n,e){return e&&e.__v_isRef?e.value:e}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function _(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}_("slot,component",!0);var y=_("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,z=E((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),C=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,R=E((function(n){return n.replace(I,"-$1").toLowerCase()}));var $=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function S(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function j(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function L(n,e,t){}var O=function(n,e,t){return!1},D=function(n){return n};function P(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return P(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return P(n[t],e[t])}))}catch(n){return!1}}function V(n,e){for(var t=0;t<n.length;t++)if(P(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],M={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:L,parsePlatformTagName:D,mustUseProp:O,async:!0,_lifecycleHooks:N},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function Y(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(H.source,".$_\\d]"));var W="__proto__"in{},X="undefined"!=typeof window,Z=X&&window.navigator.userAgent.toLowerCase(),Q=Z&&/msie|trident/.test(Z),K=Z&&Z.indexOf("msie 9.0")>0,J=Z&&Z.indexOf("edge/")>0;Z&&Z.indexOf("android");var nn=Z&&/iphone|ipad|ipod|ios/.test(Z);Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z);var en,tn=Z&&Z.match(/firefox\/(\d+)/),rn={}.watch,an=!1;if(X)try{var on={};Object.defineProperty(on,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===en&&(en=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);un="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function fn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function gn(n){return new hn(void 0,void 0,void 0,String(n))}function vn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var bn=0,_n=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,_n.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function kn(){xn.pop(),yn.target=xn[xn.length-1]}var En=Array.prototype,Tn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];Y(Tn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var zn=Object.getOwnPropertyNames(Tn),Cn={},In=!0;function Rn(n){In=n}var $n={notify:L,depend:L,addSub:L,removeSub:L},Sn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?$n:new yn,this.vmCount=0,Y(n,"__ob__",this),i(n)){if(!t)if(W)n.__proto__=Tn;else for(var r=0,a=zn.length;r<a;r++){Y(n,s=zn[r],Tn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;An(n,s=o[r],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)jn(n[e],!1,this.mock)},n}();function jn(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof Sn?n.__ob__:!In||!t&&sn()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||qn(n)||n instanceof hn?void 0:new Sn(n,e,t)}function An(n,e,t,r,a,o,s){void 0===s&&(s=!1);var l=new yn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var u=c&&c.get,d=c&&c.set;u&&!d||t!==Cn&&2!==arguments.length||(t=n[e]);var p=a?t&&t.__ob__:jn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=u?u.call(n):t;return yn.target&&(l.depend(),p&&(p.dep.depend(),i(e)&&Dn(e))),qn(e)&&!a?e.value:e},set:function(e){var r=u?u.call(n):t;if(q(r,e)){if(d)d.call(n,e);else{if(u)return;if(!a&&qn(r)&&!qn(e))return void(r.value=e);t=e}p=a?e&&e.__ob__:jn(e,!1,o),l.notify()}}}),l}}function Ln(n,e,t){if(!Bn(n)){var r=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&jn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(An(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function On(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Bn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Dn(e)}function Pn(n){return Vn(n,!0),Y(n,"__v_isShallow",!0),n}function Vn(n,e){if(!Bn(n)){jn(n,e,sn());0}}function Bn(n){return!(!n||!n.__v_isReadonly)}function qn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(qn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];qn(r)&&!qn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Nn;var Mn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Nn,!n&&Nn&&(this.index=(Nn.scopes||(Nn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Nn;try{return Nn=this,n()}finally{Nn=e}}else 0},n.prototype.on=function(){Nn=this},n.prototype.off=function(){Nn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Un=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Yn(n,e){function t(){var n=t.fns;if(!i(n))return Ie(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Ie(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,r,i,o){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Un(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=Yn(c,o)),s(d.once)&&(c=n[l]=i(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((d=Un(l)).name,e[l],d.capture)}function Wn(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}a(i)?r=Yn([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=Yn([i,l]),r.merged=!0,n[e]=r}function Xn(n,e,t,r,i){if(o(e)){if(k(e,t))return n[t]=e[t],i||delete e[t],!0;if(k(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Zn(n){return l(n)?[gn(n)]:i(n)?function n(e,t){var r,c,u,d,p=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(u=p.length-1,d=p[u],i(c)?c.length>0&&(Qn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Qn(d)&&(p[u]=gn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Qn(d)?p[u]=gn(d.text+c):""!==c&&p.push(gn(c)):Qn(c)&&Qn(d)?p[u]=gn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&a(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Qn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Kn(n,e){var t,r,a,s,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Jn(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=j(j({},r),t)),i=a(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function ne(n){return St(this.$options,"filters",n,!0)||D}function ee(n,e){return i(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,i){var a=M.keyCodes[e]||t;return i&&r&&!M.keyCodes[e]?ee(i,r):a?ee(a,n):r?R(r)!==e:void 0===n}function re(n,e,t,r,a){if(t)if(u(t)){i(t)&&(t=A(t));var o=void 0,s=function(i){if("class"===i||"style"===i||y(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||M.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=z(i),c=R(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)s(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?j({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];i(o)?ce(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=ae,n._n=b,n._s=g,n._l=Kn,n._t=Jn,n._q=P,n._i=V,n._m=ie,n._f=ne,n._k=te,n._b=re,n._v=gn,n._e=mn,n._u=ce,n._g=le,n._d=ue,n._p=de}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,i){var a,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==r&&l===i.$key&&!o&&!i.$hasNormal)return i;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ve(n,t,c,e[c]))}else a={};for(var u in t)u in a||(a[u]=be(t,u));return e&&Object.isExtensible(e)&&(e._normalized=a),Y(a,"$stable",s),Y(a,"$key",l),Y(a,"$hasNormal",o),a}function ve(n,e,t,r){var a=function(){var e=pn;fn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:Zn(t))&&t[0];return fn(e),t&&(!a||1===t.length&&a.isComment&&!me(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function be(n,e){return function(){return n[e]}}function _e(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};Y(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:$(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function ye(n,e,t,r,i){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,xe(n,o,r,i));for(var o in n)o in e||(a=!0,delete n[o]);return a}function xe(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function Ee(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Te(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||me(t)))return t}}function ze(n,e,t,r,d,p){return(i(t)||l(t))&&(d=r,r=t,t=void 0),s(p)&&(d=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return mn();o(t)&&o(t.is)&&(e=t.is);if(!e)return mn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Zn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,p;if("string"==typeof e){var f=void 0;p=n.$vnode&&n.$vnode.ns||M.getTagNamespace(e),d=M.isReservedTag(e)?new hn(M.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(f=St(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):xt(f,t,n,r,e)}else d=xt(e,t,n,r);return i(d)?d:o(d)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,p),o(t)&&function(n){u(n.style)&&Me(n.style);u(n.class)&&Me(n.class)}(t),d):mn()}(n,e,t,r,d)}function Ce(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Re(n,r,"errorCaptured hook")}}Re(n,e,t)}finally{kn()}}function Ie(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&m(a)&&!a._handled&&(a.catch((function(n){return Ce(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Ce(n,r,i)}return a}function Re(n,e,t){if(M.errorHandler)try{return M.errorHandler.call(null,n,e,t)}catch(e){e!==n&&$e(e,null,"config.errorHandler")}$e(n,e,t)}function $e(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Se,je=!1,Ae=[],Le=!1;function Oe(){Le=!1;var n=Ae.slice(0);Ae.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var De=Promise.resolve();Se=function(){De.then(Oe),nn&&setTimeout(L)},je=!0}else if(Q||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Se="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Oe)}:function(){setTimeout(Oe,0)};else{var Pe=1,Ve=new MutationObserver(Oe),Be=document.createTextNode(String(Pe));Ve.observe(Be,{characterData:!0}),Se=function(){Pe=(Pe+1)%2,Be.data=String(Pe)},je=!0}function qe(n,e){var t;if(Ae.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),Le||(Le=!0,Se()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=Ct(r[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Ne=new un;function Me(n){return function n(e,t){var r,a,o=i(e);if(!o&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(qn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Ne),Ne.clear(),n}var He,Ue=0,Ye=function(){function n(n,e,t,r,i){var a,o;a=this,void 0===(o=Nn&&!Nn._vm?Nn:n?n._scope:void 0)&&(o=Nn),o&&o.active&&o.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ue,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Me(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ft(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){He.$on(n,e)}function We(n,e){He.$off(n,e)}function Xe(n,e){var t=He;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Ze(n,e,t){He=n,Gn(e,t||{},Ge,We,Xe,n),He=void 0}var Qe=null;function Ke(n){var e=Qe;return Qe=n,function(){Qe=e}}function Je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),wn();var i=pn,a=Nn;r&&fn(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var l=0,c=o.length;l<c;l++)Ie(o[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&(fn(i),a&&a.on()),kn()}var tt=[],rt=[],it={},at=!1,ot=!1,st=0;var lt=0,ct=Date.now;if(X&&!Q){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ct(),ot=!0,tt.sort(dt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,it={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<_n.length;n++){var e=_n[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}_n.length=0}(),ln&&M.devtools&&ln.emit("flush")}function ft(n){var e=n.id;if(null==it[e]&&(n!==yn.target||!n.noRecurse)){if(it[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,qe(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var o=n[a].from;if(o in e._provided)t[a]=e._provided[o];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function mt(n,e,t,a,o){var l,c=this,u=o.options;k(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=s(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=ht(u.inject,a),this.slots=function(){return c.$slots||ge(a,n.scopedSlots,c.$slots=fe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var o=ze(l,n,e,t,r,p);return o&&!i(o)&&(o.fnScopeId=u._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return ze(l,n,e,t,r,p)}}function gt(n,e,t,r,i){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function vt(n,e){for(var t in e)n[z(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}pe(mt.prototype);var _t={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;_t.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Qe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var o=i.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var d=i.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,d,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ze(n,t,p),e&&n.$options.props){Rn(!1);for(var f=n._props,h=n.$options._propKeys||[],m=0;m<h.length;m++){var g=h[m],v=n.$options.props;f[g]=jt(g,v,e,n)}Rn(!0),n.$options.propsData=e}c&&(n.$slots=fe(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Je(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(_t);function xt(n,e,t,l,c){if(!a(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=ke;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=B((function(t){n.resolved=Ee(t,e),i?r.length=0:d(!0)})),f=B((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,f);return u(h)&&(m(h)?a(n.resolved)&&h.then(p,f):m(h.component)&&(h.component.then(p,f),o(h.error)&&(n.errorComp=Ee(h.error,e)),o(h.loading)&&(n.loadingComp=Ee(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&f(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,r,i){var a=mn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(p,e,t,l,c);e=e||{},Yt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;o(s)?(i(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var u=R(c);Xn(i,l,c,u,!0)||Xn(i,s,c,u,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},u=l.props;if(o(u))for(var d in u)c[d]=jt(d,u,e||r);else o(t.attrs)&&vt(c,t.attrs),o(t.props)&&vt(c,t.props);var p=new mt(t,c,s,a,n),f=l.render.call(null,p._c,p);if(f instanceof hn)return gt(f,t,p.parent,l,p);if(i(f)){for(var h=Zn(f)||[],m=new Array(h.length),g=0;g<h.length;g++)m[g]=gt(h[g],t,p.parent,l,p);return m}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],i=e[r],a=_t[r];i===a||i&&i._merged||(e[r]=i?wt(a,i):a)}}(e);var v=bt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:c,children:l},p)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=L,Et=M.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(i=n[r],a=e[r],t&&k(n,r)?i!==a&&p(i)&&p(a)&&Tt(i,a):Ln(n,r,a));return n}function zt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?Tt(r,i):i}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,r){var i=Object.create(n||null);return e?j(i,e):i}Et.data=function(n,e,t){return t?zt(n,e,t):e&&"function"!=typeof e?n:zt(n,e)},N.forEach((function(n){Et[n]=Ct})),F.forEach((function(n){Et[n+"s"]=It})),Et.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in j(a,n),e){var s=a[o],l=e[o];s&&!i(s)&&(s=[s]),a[o]=s?s.concat(l):i(l)?l:[l]}return a},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return j(i,n),e&&j(i,e),i},Et.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var Rt=function(n,e){return void 0===e?n:e};function $t(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[z(a)]={type:null});else if(p(t))for(var s in t)a=t[s],o[z(s)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var s=t[o];r[o]=p(s)?j({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=$t(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=$t(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)k(n,o)||l(o);function l(r){var i=Et[r]||Rt;s[r]=i(n[r],e[r],t,r)}return s}function St(n,e,t,r){if("string"==typeof t){var i=n[e];if(k(i,t))return i[t];var a=z(t);if(k(i,a))return i[a];var o=C(a);return k(i,o)?i[o]:i[t]||i[a]||i[o]}}function jt(n,e,t,r){var i=e[n],a=!k(t,n),o=t[n],s=Dt(Boolean,i.type);if(s>-1)if(a&&!k(i,"default"))o=!1;else if(""===o||o===R(n)){var l=Dt(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Lt(e.type)?r.call(n):r}(r,i,n);var u=In;Rn(!0),jn(o),Rn(u)}return o}var At=/^\s*function (\w+)/;function Lt(n){var e=n&&n.toString().match(At);return e?e[1]:""}function Ot(n,e){return Lt(n)===Lt(e)}function Dt(n,e){if(!i(e))return Ot(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Ot(e[t],n))return t;return-1}var Pt={enumerable:!0,configurable:!0,get:L,set:L};function Vt(n,e,t){Pt.get=function(){return this[e][t]},Pt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Pt)}function Bt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Pn({}),i=n.$options._propKeys=[];n.$parent&&Rn(!1);var a=function(a){i.push(a);var o=jt(a,e,t,n);An(r,a,o,void 0,!0),a in n||Vt(n,"_props",a)};for(var o in e)a(o);Rn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=_e(n);fn(n),wn();var i=Ie(t,null,[n._props||Pn({}),r],n,"setup");if(kn(),fn(),c(i))e.render=i;else if(u(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var o in i)"__sfc"!==o&&Fn(a,i,o)}else for(var o in i)U(o)||Fn(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:$(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&k(r,a)||U(a)||Vt(n,"_data",a)}var o=jn(e);o&&o.vmCount++}(n);else{var t=jn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var i in e){var a=e[i],o=c(a)?a:a.get;0,r||(t[i]=new Ye(n,o||L,L,qt)),i in n||Ft(n,i,a)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)Ht(n,t,r[a]);else Ht(n,t,r)}}(n,e.watch)}var qt={lazy:!0};function Ft(n,e,t){var r=!sn();c(t)?(Pt.get=r?Nt(e):Mt(t),Pt.set=L):(Pt.get=t.get?r&&!1!==t.cache?Nt(e):Mt(t.get):L,Pt.set=t.set||L),Object.defineProperty(n,e,Pt)}function Nt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Mt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ut=0;function Yt(n){var e=n.options;if(n.super){var t=Yt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&j(n.extendOptions,r),(e=n.options=$t(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=bt(n)||bt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=$t(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Vt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=j({},o.options),i[r]=o,o}}function Xt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Zt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Qt(n,e){var t=n.cache,r=n.keys,i=n._vnode,a=n.$vnode;for(var o in t){var s=t[o];if(s){var l=s.name;l&&!e(l)&&Kt(t,o,r,i)}}a.componentOptions.children=void 0}function Kt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}Gt.prototype._init=function(n){var e=this;e._uid=Ut++,e._isVue=!0,e.__v_skip=!0,e._scope=new Mn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=$t(Yt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=fe(e._renderChildren,i),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return ze(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return ze(n,e,t,r,i,!0)};var a=t&&t.data;An(n,"$attrs",a&&a.attrs||r,null,!0),An(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(Rn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),Rn(!0))}(e),Bt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Hn(n),i=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var o=i[a];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Ln,n.prototype.$delete=On,n.prototype.$watch=function(n,e,t){if(p(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var r=new Ye(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');wn(),Ie(e,this,[r.value],this,i),kn()}return function(){r.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?S(t):t;for(var r=S(arguments,1),i='event handler for "'.concat(n,'"'),a=0,o=t.length;a<o;a++)Ie(t[a],e,r,e,i)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Ke(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return qe(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=ge(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&we(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var a,o=pn,s=ke;try{fn(n),ke=n,a=t.call(n._renderProxy,n.$createElement)}catch(e){Ce(e,n,"render"),a=n._vnode}finally{ke=s,fn(o)}return i(a)&&1===a.length&&(a=a[0]),a instanceof hn||(a=mn()),a.parent=r,a}}(Gt);var Jt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jt,exclude:Jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Xt(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Kt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Kt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Qt(n,(function(n){return Zt(e,n)}))})),this.$watch("exclude",(function(e){Qt(n,(function(n){return!Zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var r=Xt(t),i=this.include,a=this.exclude;if(i&&(!r||!Zt(i,r))||a&&r&&Zt(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return M}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:j,mergeOptions:$t,defineReactive:An},n.set=Ln,n.delete=On,n.nextTick=qe,n.observable=function(n){return jn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=S(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=$t(this.options,n),this}}(n),Wt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:sn}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:mt}),Gt.version="2.7.16";var er=_("style,class"),tr=_("input,textarea,option,select,progress"),rr=_("contenteditable,draggable,spellcheck"),ir=_("events,caret,typing,plaintext-only"),ar=_("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return sr(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function ur(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return pr(n,fr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:pr(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function pr(n,e){return n?e?n+" "+e:n:e||""}function fr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=fr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},mr=_("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=_("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return mr(n)||gr(n)};var br=Object.create(null);var _r=_("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xr={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))Ie(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=qn(t),f=r.$refs;if(d||p)if(u){var h=d?f[t]:t.value;e?i(h)&&x(h,a):i(h)?h.includes(a)||h.push(a):d?(f[t]=[a],kr(r,t,f[t])):t.value=[a]}else if(d){if(e&&f[t]!==a)return;f[t]=l,kr(r,t,s)}else if(p){if(e&&t.value!==a)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(qn(r[e])?r[e].value=t:r[e]=t)}var Er=new hn("",{},[]),Tr=["create","activate","update","remove","destroy"];function zr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||_r(r)&&_r(i)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Cr(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var Ir={create:Rr,update:Rr,destroy:function(n){Rr(n,Er)}};function Rr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===Er,o=e===Er,s=Sr(n.data.directives,n.context),l=Sr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Ar(i,"update",e,n),i.def&&i.def.componentUpdated&&u.push(i)):(Ar(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Ar(c[t],"inserted",e,n)};a?Wn(e,"insert",d):d()}u.length&&Wn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Ar(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Ar(s[t],"unbind",n,n,o)}(n,e)}var $r=Object.create(null);function Sr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=$r),i[jr(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||St(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||St(e.$options,"directives",r.name)}return i}function jr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ar(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Ce(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Lr=[xr,Ir];function Or(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(o(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=j({},u)),u)i=u[r],c[r]!==i&&Dr(l,r,i,e.data.pre);for(r in(Q||J)&&u.value!==c.value&&Dr(l,"value",u.value),c)a(u[r])&&(sr(r)?l.removeAttributeNS(or,lr(r)):rr(r)||l.removeAttribute(r))}}function Dr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Pr(n,e,t):ar(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&ir(e)?e:"true"}(e,t)):sr(e)?cr(t)?n.removeAttributeNS(or,lr(e)):n.setAttributeNS(or,e,t):Pr(n,e,t)}function Pr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(Q&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Vr={create:Or,update:Or};function Br(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=ur(e),l=t._transitionClasses;o(l)&&(s=pr(s,fr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var qr,Fr={create:Br,update:Br};function Nr(n,e,t){var r=qr;return function i(){var a=e.apply(null,arguments);null!==a&&Ur(n,i,t,r)}}var Mr=je&&!(tn&&Number(tn[1])<=53);function Hr(n,e,t,r){if(Mr){var i=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}qr.addEventListener(n,e,an?{capture:t,passive:r}:t)}function Ur(n,e,t,r){(r||qr).removeEventListener(n,e._wrapper||e,t)}function Yr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};qr=e.elm||n.elm,function(n){if(o(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,r,Hr,Ur,Nr,e.context),qr=void 0}}var Gr,Wr={create:Yr,update:Yr,destroy:function(n){return Yr(n,Er)}};function Xr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=j({},c)),l)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var u=a(r)?"":String(r);Zr(i,u)&&(i.value=u)}else if("innerHTML"===t&&gr(i.tagName)&&a(i.innerHTML)){(Gr=Gr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Gr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Zr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return b(t)!==b(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Qr={create:Xr,update:Xr},Kr=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Jr(n){var e=ni(n.style);return n.staticStyle?j(n.staticStyle,e):e}function ni(n){return Array.isArray(n)?A(n):"string"==typeof n?Kr(n):n}var ei,ti=/^--/,ri=/\s*!important$/,ii=function(n,e,t){if(ti.test(e))n.style.setProperty(e,t);else if(ri.test(t))n.style.setProperty(R(e),t.replace(ri,""),"important");else{var r=oi(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ai=["Webkit","Moz","ms"],oi=E((function(n){if(ei=ei||document.createElement("div").style,"filter"!==(n=z(n))&&n in ei)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ai.length;t++){var r=ai[t]+e;if(r in ei)return r}}));function si(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=ni(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?j({},p):p;var f=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Jr(i.data))&&j(r,t);(t=Jr(n.data))&&j(r,t);for(var a=n;a=a.parent;)a.data&&(t=Jr(a.data))&&j(r,t);return r}(e,!0);for(s in d)a(f[s])&&ii(l,s,"");for(s in f)i=f[s],ii(l,s,null==i?"":i)}}var li={create:si,update:si},ci=/\s+/;function ui(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pi(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,fi(n.name||"v")),j(e,n),e}return"string"==typeof n?fi(n):void 0}}var fi=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hi=X&&!K,mi="transition",gi="transitionend",vi="animation",bi="animationend";hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vi="WebkitAnimation",bi="webkitAnimationEnd"));var _i=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yi(n){_i((function(){_i(n)}))}function xi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ui(n,e))}function wi(n,e){n._transitionClasses&&x(n._transitionClasses,e),di(n,e)}function ki(n,e,t){var r=Ti(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?gi:bi,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),a+1),n.addEventListener(s,u)}var Ei=/\b(transform|all)(,|$)/;function Ti(n,e){var t,r=window.getComputedStyle(n),i=(r[mi+"Delay"]||"").split(", "),a=(r[mi+"Duration"]||"").split(", "),o=zi(i,a),s=(r[vi+"Delay"]||"").split(", "),l=(r[vi+"Duration"]||"").split(", "),c=zi(s,l),u=0,d=0;return"transition"===e?o>0&&(t="transition",u=o,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&Ei.test(r[mi+"Property"])}}function zi(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ci(e)+Ci(n[t])})))}function Ci(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ii(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=pi(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,p=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,v=r.enter,_=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,w=r.appear,k=r.afterAppear,E=r.appearCancelled,T=r.duration,z=Qe,C=Qe.$vnode;C&&C.parent;)z=C.context,C=C.parent;var I=!z._isMounted||!n.isRootInsert;if(!I||w||""===w){var R=I&&f?f:l,$=I&&m?m:p,S=I&&h?h:d,j=I&&x||g,A=I&&c(w)?w:v,L=I&&k||_,O=I&&E||y,D=b(u(T)?T.enter:T);0;var P=!1!==i&&!K,V=Si(A),q=t._enterCb=B((function(){P&&(wi(t,S),wi(t,$)),q.cancelled?(P&&wi(t,R),O&&O(t)):L&&L(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),A&&A(t,q)})),j&&j(t),P&&(xi(t,R),xi(t,$),yi((function(){wi(t,R),q.cancelled||(xi(t,S),V||($i(D)?setTimeout(q,D):ki(t,s,q)))}))),n.data.show&&(e&&e(),A&&A(t,q)),P||V||q()}}}function Ri(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=pi(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,v=r.duration,_=!1!==i&&!K,y=Si(f),x=b(u(v)?v.leave:v);0;var w=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),_&&(wi(t,c),wi(t,d)),w.cancelled?(_&&wi(t,l),m&&m(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(k):k()}function k(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),_&&(xi(t,l),xi(t,d),yi((function(){wi(t,l),w.cancelled||(xi(t,c),y||($i(x)?setTimeout(w,x):ki(t,s,w)))}))),f&&f(t,w),_||y||w())}}function $i(n){return"number"==typeof n&&!isNaN(n)}function Si(n){if(a(n))return!1;var e=n.fns;return o(e)?Si(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ji(n,e){!0!==e.data.show&&Ii(e)}var Ai=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<Tr.length;++e)for(r[Tr[e]]=[],t=0;t<c.length;++t)o(c[t][Tr[e]])&&r[Tr[e]].push(c[t][Tr[e]]);function d(n){var e=u.parentNode(n);o(e)&&u.removeChild(e,n)}function p(n,e,t,i,a,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=vn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var l=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return f(n,e),h(t,n.elm,i),s(l)&&function(n,e,t,i){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(a=s.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Er,s);e.push(s);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),m(n,p,e),o(d)&&v(n,e),h(t,n.elm,i)):s(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,i)):(n.elm=u.createTextNode(n.text),h(t,n.elm,i))}}function f(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),b(n)):(wr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function m(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var i=0;i<r.create.length;++i)r.create[i](Er,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Er,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;o(e=Qe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)p(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),x(r)):d(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function E(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&zr(n,a))return i}}function T(n,e,t,i,l,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=vn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;o(h)&&o(f=h.hook)&&o(f=f.prepatch)&&f(n,e);var m=n.children,v=e.children;if(o(h)&&g(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);o(f=h.hook)&&o(f=f.update)&&f(n,e)}a(e.text)?o(m)&&o(v)?m!==v&&function(n,e,t,r,i){var s,l,c,d=0,f=0,h=e.length-1,m=e[0],g=e[h],v=t.length-1,b=t[0],_=t[v],x=!i;for(0;d<=h&&f<=v;)a(m)?m=e[++d]:a(g)?g=e[--h]:zr(m,b)?(T(m,b,r,t,f),m=e[++d],b=t[++f]):zr(g,_)?(T(g,_,r,t,v),g=e[--h],_=t[--v]):zr(m,_)?(T(m,_,r,t,v),x&&u.insertBefore(n,m.elm,u.nextSibling(g.elm)),m=e[++d],_=t[--v]):zr(g,b)?(T(g,b,r,t,f),x&&u.insertBefore(n,g.elm,m.elm),g=e[--h],b=t[++f]):(a(s)&&(s=Cr(e,d,h)),a(l=o(b.key)?s[b.key]:E(b,e,d,h))?p(b,r,n,m.elm,!1,t,f):zr(c=e[l],b)?(T(c,b,r,t,f),e[l]=void 0,x&&u.insertBefore(n,c.elm,m.elm)):p(b,r,n,m.elm,!1,t,f),b=t[++f]);d>h?y(n,a(t[v+1])?null:t[v+1].elm,t,f,v,r):f>v&&w(e,d,h)}(d,m,v,t,c):o(v)?(o(n.text)&&u.setTextContent(d,""),y(d,null,v,0,v.length-1,t)):o(m)?w(m,0,m.length-1):o(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),o(h)&&o(f=h.hook)&&o(f=f.postpatch)&&f(n,e)}}}function z(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=_("attrs,class,staticClass,staticStyle,key");function I(n,e,t,r){var i,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return f(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!I(d,c[p],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else m(e,c,t);if(o(l)){var h=!1;for(var g in l)if(!C(g)){h=!0,v(e,t);break}!h&&l.class&&Me(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,c=!1,d=[];if(a(n))c=!0,p(e,d);else{var f=o(n.nodeType);if(!f&&zr(n,e))T(n,e,d,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&I(n,e,d))return z(e,d,!0),n;l=n,n=new hn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,m=u.parentNode(h);if(p(e,d,h._leaveCb?null:m,u.nextSibling(h)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var _=0;_<r.destroy.length;++_)r.destroy[_](v);if(v.elm=e.elm,b){for(var y=0;y<r.create.length;++y)r.create[y](Er,v);var k=v.data.hook.insert;if(k.merged)for(var E=k.fns.slice(1),C=0;C<E.length;C++)E[C]()}else wr(v);v=v.parent}o(m)?w([n],0,0):o(n.tag)&&x(n)}}return z(e,d,c),e.elm}o(n)&&x(n)}}({nodeOps:yr,modules:[Vr,Fr,Wr,Qr,li,X?{create:ji,activate:ji,remove:function(n,e){!0!==n.data.show?Ri(n,e):e()}}:{}].concat(Lr)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fi(n,"input")}));var Li={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Wn(t,"postpatch",(function(){Li.componentUpdated(n,e,t)})):Oi(n,e,t.context),n._vOptions=[].map.call(n.options,Vi)):("textarea"===t.tag||_r(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Bi),n.addEventListener("compositionend",qi),n.addEventListener("change",qi),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Oi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Vi);if(i.some((function(n,e){return!P(n,r[e])})))(n.multiple?e.value.some((function(n){return Pi(n,i)})):e.value!==e.oldValue&&Pi(e.value,i))&&Fi(n,"change")}}};function Oi(n,e,t){Di(n,e,t),(Q||J)&&setTimeout((function(){Di(n,e,t)}),0)}function Di(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=V(r,Vi(o))>-1,o.selected!==a&&(o.selected=a);else if(P(Vi(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Pi(n,e){return e.every((function(e){return!P(e,n)}))}function Vi(n){return"_value"in n?n._value:n.value}function Bi(n){n.target.composing=!0}function qi(n){n.target.composing&&(n.target.composing=!1,Fi(n.target,"input"))}function Fi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ni(n){return!n.componentInstance||n.data&&n.data.transition?n:Ni(n.componentInstance._vnode)}var Mi={model:Li,show:{bind:function(n,e,t){var r=e.value,i=(t=Ni(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Ii(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ni(t)).data&&t.data.transition?(t.data.show=!0,r?Ii(t,(function(){n.style.display=n.__vOriginalDisplay})):Ri(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Hi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ui(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ui(Te(e.children)):n}function Yi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[z(r)]=i[r];return e}function Gi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wi=function(n){return n.tag||me(n)},Xi=function(n){return"show"===n.name},Zi={name:"transition",props:Hi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Ui(i);if(!a)return i;if(this._leaving)return Gi(n,i);var o="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=Yi(this),c=this._vnode,u=Ui(c);if(a.data.directives&&a.data.directives.some(Xi)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!me(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=j({},s);if("out-in"===r)return this._leaving=!0,Wn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gi(n,i);if("in-out"===r){if(me(a))return c;var p,f=function(){p()};Wn(s,"afterEnter",f),Wn(s,"enterCancelled",f),Wn(d,"delayLeave",(function(n){p=n}))}}return i}}},Qi=j({tag:String,moveClass:String},Hi);function Ki(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function na(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete Qi.mode;var ea={Transition:Zi,TransitionGroup:{props:Qi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Yi(this),s=0;s<i.length;s++){if((u=i[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))a.push(u),t[u.key]=u,(u.data||(u.data={})).transition=o;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ki),n.forEach(Ji),n.forEach(na),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xi(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(gi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(gi,n),t._moveCb=null,wi(t,e))})}})))},methods:{hasMove:function(n,e){if(!hi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),ui(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ti(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ta(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=vr,Gt.config.isReservedAttr=er,Gt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!X)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=br[n])return br[n];var e=document.createElement(n);return n.indexOf("-")>-1?br[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:br[n]=/HTMLUnknownElement/.test(e.toString())},j(Gt.options.directives,Mi),j(Gt.options.components,ea),Gt.prototype.__patch__=X?Ai:L,Gt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=mn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ye(n,r,L,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){M.devtools&&ln&&ln.emit("init",Gt)}),0);var ra=/[!'()*]/g,ia=function(n){return"%"+n.charCodeAt(0).toString(16)},aa=/%2C/g,oa=function(n){return encodeURIComponent(n).replace(ra,ia).replace(aa,",")};function sa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var la=function(n){return null==n||"object"==typeof n?n:String(n)};function ca(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=sa(t.shift()),i=t.length>0?sa(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function ua(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oa(e)):r.push(oa(e)+"="+oa(n)))})),r.join("&")}return oa(e)+"="+oa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function pa(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=fa(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ga(e,i),matched:n?ma(n):[]};return t&&(o.redirectedFrom=ga(t,i)),Object.freeze(o)}function fa(n){if(Array.isArray(n))return n.map(fa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=fa(n[t]);return e}return n}var ha=pa(null,{path:"/"});function ma(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ga(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||ua)(r)+i}function va(n,e,t){return e===ha?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&ba(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ba(n.query,e.query)&&ba(n.params,e.params))))}function ba(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?ba(a,o):String(a)===String(o)}))}function _a(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,s=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),u=0,d=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&u++,p.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(a.routerViewDepth=u,d){var f=c[s],h=f&&f.component;return h?(f.configProps&&xa(h,a,f.route,f.configProps),o(h,a,r)):o()}var m=l.matched[u],g=m&&m.components[s];if(!m||!g)return c[s]=null,o();c[s]={component:g},a.registerRouteInstance=function(n,e){var t=m.instances[s];(e&&t!==n||!e&&t===n)&&(m.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){m.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),_a(l)};var v=m.props&&m.props[s];return v&&(ta(c[s],{route:l,configProps:v}),xa(g,a,l,v)),o(g,a,r)}};function xa(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ta({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function wa(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ka(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ea=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ta=Ba,za=Sa,Ca=function(n,e){return Aa(Sa(n,e),e)},Ia=Aa,Ra=Va,$a=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Sa(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=$a.exec(n));){var l=t[0],c=t[1],u=t.index;if(o+=n.slice(a,u),a=u+l.length,c)o+=c[1];else{var d=n[a],p=t[2],f=t[3],h=t[4],m=t[5],g=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=p&&null!=d&&d!==p,_="+"===g||"*"===g,y="?"===g||"*"===g,x=t[2]||s,w=h||m;r.push({name:f||i++,prefix:p||"",delimiter:x,optional:y,repeat:_,partial:b,asterisk:!!v,pattern:w?Oa(w):v?".*":"[^"+La(x)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function ja(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Aa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Pa(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?ja:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Ea(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=o(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function La(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Oa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Da(n,e){return n.keys=e,n}function Pa(n){return n&&n.sensitive?"":"i"}function Va(n,e,t){Ea(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=La(s);else{var l=La(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=La(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=i?"$":r&&d?"":"(?="+u+"|$)",Da(new RegExp("^"+a,Pa(t)),e)}function Ba(n,e,t){return Ea(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Da(n,e)}(n,e):Ea(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(Ba(n[i],e,t).source);return Da(new RegExp("(?:"+r.join("|")+")",Pa(t)),e)}(n,e,t):function(n,e,t){return Va(Sa(n,t),e,t)}(n,e,t)}Ta.parse=za,Ta.compile=Ca,Ta.tokensToFunction=Ia,Ta.tokensToRegExp=Ra;var qa=Object.create(null);function Fa(n,e,t){e=e||{};try{var r=qa[n]||(qa[n]=Ta.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Na(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ta({},n)).params;return a&&"object"==typeof a&&(i.params=ta({},a)),i}if(!i.path&&i.params&&e){(i=ta({},i))._normalized=!0;var o=ta(ta({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=Fa(s,o,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",u=l.path?wa(l.path,c,t||i.append):c,d=function(n,e,t){void 0===e&&(e={});var r,i=t||ca;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(la):la(o)}return r}(l.query,i.query,r&&r.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var Ma,Ha=function(){},Ua={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,f=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,m=o.redirectedFrom?pa(null,Na(o.redirectedFrom),null,t):o;l[h]=va(r,m,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Ya(n)&&(e.replace?t.replace(a,Ha):t.push(a,Ha))},b={click:Ya};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var _={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[f],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)_.on=b,_.attrs={href:s,"aria-current":g};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=ta({},x.data);for(var k in w.on=w.on||{},w.on){var E=w.on[k];k in b&&(w.on[k]=Array.isArray(E)?E:[E])}for(var T in b)T in w.on?w.on[T].push(b[T]):w.on[T]=v;var z=x.data.attrs=ta({},x.data.attrs);z.href=s,z["aria-current"]=g}else _.on=b}return n(this.tag,_,this.$slots.default)}};function Ya(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ga="undefined"!=typeof window;function Wa(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ka(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var d={path:u,regex:Xa(u,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ka(o+"/"+i.path):void 0;n(e,t,r,i,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<p.length;++f){0;var h={path:p[f],children:i.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,o,s,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:o,nameMap:s}}function Xa(n,e){return Ta(n,[],e)}function Za(n,e){var t=Wa(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=Na(n,t,!1,e),c=s.name;if(c){var u=a[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Fa(u.path,s.params),l(u,s,o)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Qa(m.regex,s.path,s.params))return l(m,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(pa(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,u=s.path,d=t.query,p=t.hash,f=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,f=s.hasOwnProperty("params")?s.params:f,c){a[c];return o({_normalized:!0,name:c,query:d,hash:p,params:f},void 0,t)}if(u){var h=function(n,e){return wa(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:Fa(h,f),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Fa(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):pa(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Wa([e||n],r,i,a,t),t&&t.alias.length&&Wa(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Wa(n,r,i,a)}}}function Qa(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?sa(r[i]):r[i])}return!0}var Ka=Ga&&window.performance&&window.performance.now?window.performance:Date;function Ja(){return Ka.now().toFixed(3)}var no=Ja();function eo(){return no}function to(n){return no=n}var ro=Object.create(null);function io(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ta({},window.history.state);return t.key=eo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",so),function(){window.removeEventListener("popstate",so)}}function ao(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=eo();if(n)return ro[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){fo(n,a)})).catch((function(n){0})):fo(o,a))}))}}function oo(){var n=eo();n&&(ro[n]={x:window.pageXOffset,y:window.pageYOffset})}function so(n){oo(),n.state&&n.state.key&&to(n.state.key)}function lo(n){return uo(n.x)||uo(n.y)}function co(n){return{x:uo(n.x)?n.x:window.pageXOffset,y:uo(n.y)?n.y:window.pageYOffset}}function uo(n){return"number"==typeof n}var po=/^#\d/;function fo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:uo((t=a).x)?t.x:0,y:uo(t.y)?t.y:0})}else lo(n)&&(e=co(n))}else r&&lo(n)&&(e=co(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ho,mo=Ga&&((-1===(ho=window.navigator.userAgent).indexOf("Android 2.")&&-1===ho.indexOf("Android 4.0")||-1===ho.indexOf("Mobile Safari")||-1!==ho.indexOf("Chrome")||-1!==ho.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){oo();var t=window.history;try{if(e){var r=ta({},t.state);r.key=eo(),t.replaceState(r,"",n)}else t.pushState({key:to(Ja())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vo(n){go(n,!0)}var bo={redirected:2,aborted:4,cancelled:8,duplicated:16};function _o(n,e){return xo(n,e,bo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,bo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var wo=["params","query","hash"];function ko(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Eo(n,e){return ko(n)&&n._isRouter&&(null==e||n.type===e)}function To(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function zo(n){return function(e,t,r){var i=!1,a=0,o=null;Co(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=$o((function(e){var i;((i=e).__esModule||Ro&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ma.extend(e),t.components[s]=e,--a<=0&&r()})),u=$o((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=ko(n)?n:new Error(e),r(o))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),i||r()}}function Co(n,e){return Io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Io(n){return Array.prototype.concat.apply([],n)}var Ro="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function $o(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var So=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ga){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ha,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function jo(n,e,t,r){var i=Co(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=Ma.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return Io(r?i.reverse():i)}function Ao(n,e){if(e)return function(){return n.apply(e,arguments)}}So.prototype.listen=function(n){this.cb=n},So.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},So.prototype.onError=function(n){this.errorCbs.push(n)},So.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(Eo(n,bo.redirected)&&a===ha||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},So.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!Eo(n)&&ko(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(va(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&ao(this.router,i,n,!1),s(((o=xo(a=i,n,bo.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,f=u.activated,h=[].concat(function(n){return jo(n,"beforeRouteLeave",Ao,!0)}(p),this.router.beforeHooks,function(n){return jo(n,"beforeRouteUpdate",Ao)}(d),f.map((function(n){return n.beforeEnter})),zo(f)),m=function(e,t){if(r.pending!==n)return s(yo(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return xo(n,e,bo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):ko(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(_o(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};To(h,m,(function(){To(function(n){return jo(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(yo(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){_a(n)}))}))}))},So.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},So.prototype.setupListeners=function(){},So.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ha,this.pending=null};var Lo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Oo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=mo&&t;r&&this.listeners.push(io());var i=function(){var t=n.current,i=Oo(n.base);n.current===ha&&i===n._startLocation||n.transitionTo(i,(function(n){r&&ao(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){go(ka(r.base+n.fullPath)),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){vo(ka(r.base+n.fullPath)),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Oo(this.base)!==this.current.fullPath){var e=ka(this.base+this.current.fullPath);n?go(e):vo(e)}},e.prototype.getCurrentLocation=function(){return Oo(this.base)},e}(So);function Oo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ka(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Do=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Oo(n);if(!/^\/#/.test(e))return window.location.replace(ka(n+"/#"+e)),!0}(this.base)||Po()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=mo&&e;t&&this.listeners.push(io());var r=function(){var e=n.current;Po()&&n.transitionTo(Vo(),(function(r){t&&ao(n.router,r,e,!0),mo||Fo(r.fullPath)}))},i=mo?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){qo(n.fullPath),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Vo()!==e&&(n?qo(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Vo()},e}(So);function Po(){var n=Vo();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Vo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Bo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function qo(n){mo?go(Bo(n)):window.location.hash=n}function Fo(n){mo?vo(Bo(n)):window.location.replace(Bo(n))}var No=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Eo(n,bo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(So),Mo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Za(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!mo&&!1!==n.fallback,this.fallback&&(e="hash"),Ga||(e="abstract"),this.mode=e,e){case"history":this.history=new Lo(this,n.base);break;case"hash":this.history=new Do(this,n.base,this.fallback);break;case"abstract":this.history=new No(this,n.base);break;default:0}},Ho={currentRoute:{configurable:!0}};Mo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ho.currentRoute.get=function(){return this.history&&this.history.current},Mo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Lo||t instanceof Do){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;mo&&i&&"fullPath"in n&&ao(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Mo.prototype.beforeEach=function(n){return Yo(this.beforeHooks,n)},Mo.prototype.beforeResolve=function(n){return Yo(this.resolveHooks,n)},Mo.prototype.afterEach=function(n){return Yo(this.afterHooks,n)},Mo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Mo.prototype.onError=function(n){this.history.onError(n)},Mo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Mo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Mo.prototype.go=function(n){this.history.go(n)},Mo.prototype.back=function(){this.go(-1)},Mo.prototype.forward=function(){this.go(1)},Mo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Mo.prototype.resolve=function(n,e,t){var r=Na(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ka(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},Mo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Mo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Mo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Mo.prototype,Ho);var Uo=Mo;function Yo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Mo.install=function n(e){if(!n.installed||Ma!==e){n.installed=!0,Ma=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ya),e.component("RouterLink",Ua);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Mo.version="3.6.5",Mo.isNavigationFailure=Eo,Mo.NavigationFailureType=bo,Mo.START_LOCATION=ha,Ga&&window.Vue&&window.Vue.use(Mo);t(157),t(22),t(166);t(167),t(46);var Go={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,376)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,375))},Wo={"v-72a9ee7c":()=>t.e(6).then(t.bind(null,377)),"v-c2184f54":()=>t.e(7).then(t.bind(null,378)),"v-4a1eacb6":()=>t.e(8).then(t.bind(null,379)),"v-3e99d850":()=>t.e(10).then(t.bind(null,380)),"v-3b89e5c1":()=>t.e(11).then(t.bind(null,381)),"v-56bac38c":()=>t.e(9).then(t.bind(null,382)),"v-4cd14734":()=>t.e(12).then(t.bind(null,383)),"v-2e6c17e3":()=>t.e(13).then(t.bind(null,384)),"v-1d3661da":()=>t.e(14).then(t.bind(null,385)),"v-3ebe77ee":()=>t.e(15).then(t.bind(null,386)),"v-7fd48428":()=>t.e(16).then(t.bind(null,387)),"v-bfeb2552":()=>t.e(17).then(t.bind(null,388)),"v-12f412e4":()=>t.e(18).then(t.bind(null,389)),"v-42f8cede":()=>t.e(19).then(t.bind(null,390)),"v-a3179a3e":()=>t.e(20).then(t.bind(null,391)),"v-3042a0fd":()=>t.e(21).then(t.bind(null,392)),"v-03ff47ee":()=>t.e(22).then(t.bind(null,393)),"v-6df42ea1":()=>t.e(24).then(t.bind(null,394)),"v-709769d8":()=>t.e(23).then(t.bind(null,395)),"v-a6e17e70":()=>t.e(25).then(t.bind(null,396)),"v-14e5d69d":()=>t.e(27).then(t.bind(null,397)),"v-3a3d840e":()=>t.e(26).then(t.bind(null,398)),"v-992cc3d6":()=>t.e(28).then(t.bind(null,399)),"v-72530f3f":()=>t.e(29).then(t.bind(null,400)),"v-0f7eb5cf":()=>t.e(30).then(t.bind(null,401)),"v-7c9e4be6":()=>t.e(32).then(t.bind(null,402)),"v-6b5141e8":()=>t.e(34).then(t.bind(null,403)),"v-b5fe0ffa":()=>t.e(35).then(t.bind(null,404)),"v-8fe40c64":()=>t.e(33).then(t.bind(null,405)),"v-6642d632":()=>t.e(31).then(t.bind(null,406)),"v-aac979ae":()=>t.e(36).then(t.bind(null,407)),"v-17d104cc":()=>t.e(37).then(t.bind(null,408)),"v-1a6776ec":()=>t.e(38).then(t.bind(null,409)),"v-8041b53e":()=>t.e(39).then(t.bind(null,410)),"v-a0af79c8":()=>t.e(41).then(t.bind(null,411)),"v-2a8deef1":()=>t.e(40).then(t.bind(null,412)),"v-29a271f4":()=>t.e(42).then(t.bind(null,413)),"v-1c87ad4a":()=>t.e(43).then(t.bind(null,414)),"v-7a1f2933":()=>t.e(44).then(t.bind(null,415)),"v-3d878538":()=>t.e(45).then(t.bind(null,416)),"v-11435202":()=>t.e(46).then(t.bind(null,417)),"v-8713be10":()=>t.e(48).then(t.bind(null,418)),"v-f0192e14":()=>t.e(49).then(t.bind(null,419)),"v-85746228":()=>t.e(50).then(t.bind(null,420)),"v-6082182f":()=>t.e(47).then(t.bind(null,421)),"v-1d58d132":()=>t.e(51).then(t.bind(null,422)),"v-a1c9e1c2":()=>t.e(52).then(t.bind(null,423)),"v-45e07bf4":()=>t.e(53).then(t.bind(null,424)),"v-385042bf":()=>t.e(54).then(t.bind(null,425)),"v-cc2c3696":()=>t.e(55).then(t.bind(null,426)),"v-31773509":()=>t.e(56).then(t.bind(null,427)),"v-36a51484":()=>t.e(57).then(t.bind(null,428)),"v-461cfdea":()=>t.e(59).then(t.bind(null,429)),"v-b34af184":()=>t.e(60).then(t.bind(null,430)),"v-4edd7f5c":()=>t.e(61).then(t.bind(null,431)),"v-c5ed5e9c":()=>t.e(58).then(t.bind(null,432)),"v-99ec5b4c":()=>t.e(62).then(t.bind(null,433)),"v-67e1f5a6":()=>t.e(64).then(t.bind(null,434)),"v-4035c28f":()=>t.e(63).then(t.bind(null,435)),"v-75a0de9c":()=>t.e(65).then(t.bind(null,436)),"v-01b5feb6":()=>t.e(66).then(t.bind(null,437)),"v-58b44ebe":()=>t.e(67).then(t.bind(null,438)),"v-c9bd4b28":()=>t.e(68).then(t.bind(null,439)),"v-acf2df8a":()=>t.e(69).then(t.bind(null,440))};function Xo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Zo=/-(\w)/g,Qo=Xo(n=>n.replace(Zo,(n,e)=>e?e.toUpperCase():"")),Ko=/\B([A-Z])/g,Jo=Xo(n=>n.replace(Ko,"-$1").toLowerCase()),ns=Xo(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Qo(e))):n(ns(e))||n(Jo(e))}const ts=Object.assign({},Go,Wo),rs=n=>ts[n],is=n=>Wo[n],as=n=>Go[n],os=n=>Gt.component(n);function ss(n){return es(is,n)}function ls(n){return es(as,n)}function cs(n){return es(rs,n)}function us(n){return es(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!us(n)&&cs(n)){const e=await cs(n)();Gt.component(n,e.default)}}))}function ps(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}t(181);var fs=t(127),hs=t.n(fs),ms={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${n[t]}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=bs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,_s)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){bs(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function bs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function _s(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(130);var ys=t(76),xs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ys)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ws=t(45),ks=t.n(ws),Es={mounted(){ks.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||ks.a.start(),t()}),this.$router.afterEach(()=>{ks.a.done(),this.isSidebarOpen=!1})}};t(279),t(280);class Ts{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var zs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ts).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},Cs=(t(281),"auto"),Is="zoom-in",Rs="zoom-out",$s="grab",Ss="move";function js(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function As(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ls(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Os(n,e,t){!function(n){var e=Ds,t=Ps;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Ds="transition",Ps="transform",Vs="transform",Bs="transitionend";var qs=function(){},Fs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:qs,onClose:qs,onGrab:qs,onMove:qs,onRelease:qs,onBeforeOpen:qs,onBeforeClose:qs,onBeforeGrab:qs,onBeforeRelease:qs,onImageLoading:qs,onImageLoaded:qs},Ns={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Hs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ms(n)&&!Hs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ms(n)&&!Hs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ms(n){return 0===n.button}function Hs(n){return n.metaKey||n.ctrlKey}var Us={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Os(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),js(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Os(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ys="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Gs=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Ws=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Xs={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ls(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?$s:Rs,transition:Vs+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Os(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Os(this.el,{transform:"none"})},grab:function(n,e,t){var r=Zs(),i=r.x-n,a=r.y-e;Os(this.el,{cursor:Ss,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Zs(),i=r.x-n,a=r.y-e;Os(this.el,{transition:Vs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Os(this.el,this.styleClose)},restoreOpenStyle:function(){Os(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Zs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ys(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=Zs(),c={x:l.x-o,y:l.y-s},u=c.x/o,d=c.y/s,p=a+Math.min(u,d);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,m=parseFloat(i)*f/(100*this.rect.width),g=parseFloat(i)*h/(100*this.rect.height);if(p>m||p>g)return{x:m,y:g}}return{x:p,y:p}}};function Zs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Qs(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){js(n,r,e[r],t)}))}var Ks=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Xs),this.overlay=Object.create(Us),this.handler=Object.create(Ns),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ws({},Fs,e),this.overlay.init(this),this.handler.init(this)}return Gs(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Is,js(n,"click",this.handler.click),this.options.preloadImage&&As(Ls(n)));return this}},{key:"config",value:function(n){return n?(Ws(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),As(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),js(document,"scroll",this.handler.scroll),js(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&js(window,"resize",this.handler.resizeWindow);var a=function n(){js(r,Bs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Qs(document,e.handler,!0),t(r)};return js(r,Bs,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Cs,this.overlay.fadeOut(),this.target.zoomOut(),js(document,"scroll",this.handler.scroll,!1),js(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&js(window,"resize",this.handler.resizeWindow,!1);var r=function r(){js(t,Bs,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Qs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return js(t,Bs,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){js(i,Bs,n,!1),r(i)};return js(i,Bs,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ss,this.target.move(n,e,t);var i=this.target.el,a=function n(){js(i,Bs,n,!1),r(i)};return js(i,Bs,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Cs,this.target.restoreOpenStyle();var r=function r(){js(t,Bs,r,!1),n.lock=!1,n.released=!0,e(t)};return js(t,Bs,r),this}}}]),n}();const Js=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nl=Number("500");class el{constructor(){this.instance=new Ks(Js)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=nl){setTimeout(()=>this.update(n),e)}}var tl={watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new el,this.$vuepress.zooming.updateDelay()}},rl=(t(283),t(284),t(285),[ms,xs,Es,zs,tl,{}]),il={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ps("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},al=t(2),ol=Object(al.a)(il,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(ol,"mixins",rl);const sl=[{name:"v-72a9ee7c",path:"/pages/Notes/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-72a9ee7c").then(t)}},{path:"/pages/Notes/index.html",redirect:"/pages/Notes/"},{path:"/00.目录页/Notes.html",redirect:"/pages/Notes/"},{name:"v-c2184f54",path:"/pages/Projects/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c2184f54").then(t)}},{path:"/pages/Projects/index.html",redirect:"/pages/Projects/"},{path:"/00.目录页/Projects.html",redirect:"/pages/Projects/"},{name:"v-4a1eacb6",path:"/pages/Teasting/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4a1eacb6").then(t)}},{path:"/pages/Teasting/index.html",redirect:"/pages/Teasting/"},{path:"/00.目录页/Teasting.html",redirect:"/pages/Teasting/"},{name:"v-3e99d850",path:"/pages/Verilog_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3e99d850").then(t)}},{path:"/pages/Verilog_02/index.html",redirect:"/pages/Verilog_02/"},{path:"/01.Verilog/02.Verilog HDL基本数据类型.html",redirect:"/pages/Verilog_02/"},{name:"v-3b89e5c1",path:"/pages/Verilog_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3b89e5c1").then(t)}},{path:"/pages/Verilog_03/index.html",redirect:"/pages/Verilog_03/"},{path:"/01.Verilog/03.Verilog运算符和表达式.html",redirect:"/pages/Verilog_03/"},{name:"v-56bac38c",path:"/pages/Verilog_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-56bac38c").then(t)}},{path:"/pages/Verilog_01/index.html",redirect:"/pages/Verilog_01/"},{path:"/01.Verilog/01.Verilog HDL基本要素.html",redirect:"/pages/Verilog_01/"},{name:"v-4cd14734",path:"/pages/Verilog_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4cd14734").then(t)}},{path:"/pages/Verilog_04/index.html",redirect:"/pages/Verilog_04/"},{path:"/01.Verilog/04.Verilog HDL的模块.html",redirect:"/pages/Verilog_04/"},{name:"v-2e6c17e3",path:"/pages/Verilog_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-2e6c17e3").then(t)}},{path:"/pages/Verilog_05/index.html",redirect:"/pages/Verilog_05/"},{path:"/01.Verilog/05.VerilogHDL程序设计和描述方式.html",redirect:"/pages/Verilog_05/"},{name:"v-1d3661da",path:"/pages/Verilog_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-1d3661da").then(t)}},{path:"/pages/Verilog_06/index.html",redirect:"/pages/Verilog_06/"},{path:"/01.Verilog/06.Verilog HDL程序设计思想概览.html",redirect:"/pages/Verilog_06/"},{name:"v-3ebe77ee",path:"/pages/Verilog_07/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3ebe77ee").then(t)}},{path:"/pages/Verilog_07/index.html",redirect:"/pages/Verilog_07/"},{path:"/01.Verilog/07.Verilog HDL组合电路设计的方法.html",redirect:"/pages/Verilog_07/"},{name:"v-7fd48428",path:"/pages/Verilog_08/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-7fd48428").then(t)}},{path:"/pages/Verilog_08/index.html",redirect:"/pages/Verilog_08/"},{path:"/01.Verilog/08.verilog HDL组合电路之数字加法器.html",redirect:"/pages/Verilog_08/"},{name:"v-bfeb2552",path:"/pages/Verilog_09/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-bfeb2552").then(t)}},{path:"/pages/Verilog_09/index.html",redirect:"/pages/Verilog_09/"},{path:"/01.Verilog/09.Verilog HDL组合电路之数据比较器.html",redirect:"/pages/Verilog_09/"},{name:"v-12f412e4",path:"/pages/Verilog_10/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-12f412e4").then(t)}},{path:"/pages/Verilog_10/index.html",redirect:"/pages/Verilog_10/"},{path:"/01.Verilog/10.Verilog HDL组合电路之数据选择器.html",redirect:"/pages/Verilog_10/"},{name:"v-42f8cede",path:"/pages/Verilog_11/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-42f8cede").then(t)}},{path:"/pages/Verilog_11/index.html",redirect:"/pages/Verilog_11/"},{path:"/01.Verilog/11.verilog HDL组合电路之数字编码器.html",redirect:"/pages/Verilog_11/"},{name:"v-a3179a3e",path:"/pages/Verilog_12/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a3179a3e").then(t)}},{path:"/pages/Verilog_12/index.html",redirect:"/pages/Verilog_12/"},{path:"/01.Verilog/12.verilog HDL组合电路之数字译码器.html",redirect:"/pages/Verilog_12/"},{name:"v-3042a0fd",path:"/pages/Verilog_13/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3042a0fd").then(t)}},{path:"/pages/Verilog_13/index.html",redirect:"/pages/Verilog_13/"},{path:"/01.Verilog/13.verilog HDL组合电路之奇偶校验器.html",redirect:"/pages/Verilog_13/"},{name:"v-03ff47ee",path:"/pages/Verilog_14/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-03ff47ee").then(t)}},{path:"/pages/Verilog_14/index.html",redirect:"/pages/Verilog_14/"},{path:"/01.Verilog/14.Verilog HDL时序电路设计基础.html",redirect:"/pages/Verilog_14/"},{name:"v-6df42ea1",path:"/pages/Verilog_16/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6df42ea1").then(t)}},{path:"/pages/Verilog_16/index.html",redirect:"/pages/Verilog_16/"},{path:"/01.Verilog/16.Verilog HDL时序逻辑电路之计数器.html",redirect:"/pages/Verilog_16/"},{name:"v-709769d8",path:"/pages/Verilog_15/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-709769d8").then(t)}},{path:"/pages/Verilog_15/index.html",redirect:"/pages/Verilog_15/"},{path:"/01.Verilog/15.Verilog HDL时序电路之基本触发器.html",redirect:"/pages/Verilog_15/"},{name:"v-a6e17e70",path:"/pages/Verilog_17/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a6e17e70").then(t)}},{path:"/pages/Verilog_17/index.html",redirect:"/pages/Verilog_17/"},{path:"/01.Verilog/17.Verilog HDL时序逻辑电路之移位寄存器.html",redirect:"/pages/Verilog_17/"},{name:"v-14e5d69d",path:"/pages/Verilog_19/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-14e5d69d").then(t)}},{path:"/pages/Verilog_19/index.html",redirect:"/pages/Verilog_19/"},{path:"/01.Verilog/19.Verilog HDL有限状态机（FSM）设计基础.html",redirect:"/pages/Verilog_19/"},{name:"v-3a3d840e",path:"/pages/Verilog_18/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3a3d840e").then(t)}},{path:"/pages/Verilog_18/index.html",redirect:"/pages/Verilog_18/"},{path:"/01.Verilog/18.Verilog HDL时序逻辑电路之信号发生器.html",redirect:"/pages/Verilog_18/"},{name:"v-992cc3d6",path:"/pages/DP_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-992cc3d6").then(t)}},{path:"/pages/DP_01/index.html",redirect:"/pages/DP_01/"},{path:"/02.Dp/01.线性回归.html",redirect:"/pages/DP_01/"},{name:"v-72530f3f",path:"/pages/DP_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-72530f3f").then(t)}},{path:"/pages/DP_02/index.html",redirect:"/pages/DP_02/"},{path:"/02.Dp/02.SoftMax回归.html",redirect:"/pages/DP_02/"},{name:"v-0f7eb5cf",path:"/pages/DP_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-0f7eb5cf").then(t)}},{path:"/pages/DP_03/index.html",redirect:"/pages/DP_03/"},{path:"/02.Dp/03.多层感知机.html",redirect:"/pages/DP_03/"},{name:"v-7c9e4be6",path:"/pages/DP_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-7c9e4be6").then(t)}},{path:"/pages/DP_05/index.html",redirect:"/pages/DP_05/"},{path:"/02.Dp/05.LeNet.html",redirect:"/pages/DP_05/"},{name:"v-6b5141e8",path:"/pages/Rust_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6b5141e8").then(t)}},{path:"/pages/Rust_01/index.html",redirect:"/pages/Rust_01/"},{path:"/03.Rust/01.Rust的变量与可变性.html",redirect:"/pages/Rust_01/"},{name:"v-b5fe0ffa",path:"/pages/Rust_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-b5fe0ffa").then(t)}},{path:"/pages/Rust_02/index.html",redirect:"/pages/Rust_02/"},{path:"/03.Rust/02.Rust的数据类型.html",redirect:"/pages/Rust_02/"},{name:"v-8fe40c64",path:"/pages/Rust_00/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-8fe40c64").then(t)}},{path:"/pages/Rust_00/index.html",redirect:"/pages/Rust_00/"},{path:"/03.Rust/00.Rust的基本素养.html",redirect:"/pages/Rust_00/"},{name:"v-6642d632",path:"/pages/DP_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6642d632").then(t)}},{path:"/pages/DP_04/index.html",redirect:"/pages/DP_04/"},{path:"/02.Dp/04.卷积神经网络.html",redirect:"/pages/DP_04/"},{name:"v-aac979ae",path:"/pages/Rust_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-aac979ae").then(t)}},{path:"/pages/Rust_03/index.html",redirect:"/pages/Rust_03/"},{path:"/03.Rust/03.Rust的函数和注释.html",redirect:"/pages/Rust_03/"},{name:"v-17d104cc",path:"/pages/Rust_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-17d104cc").then(t)}},{path:"/pages/Rust_04/index.html",redirect:"/pages/Rust_04/"},{path:"/03.Rust/04.Rust的控制流.html",redirect:"/pages/Rust_04/"},{name:"v-1a6776ec",path:"/pages/Rust_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-1a6776ec").then(t)}},{path:"/pages/Rust_05/index.html",redirect:"/pages/Rust_05/"},{path:"/03.Rust/05.Rust的所有权概念.html",redirect:"/pages/Rust_05/"},{name:"v-8041b53e",path:"/pages/Rust_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-8041b53e").then(t)}},{path:"/pages/Rust_06/index.html",redirect:"/pages/Rust_06/"},{path:"/03.Rust/06.Rust的引用和借用.html",redirect:"/pages/Rust_06/"},{name:"v-a0af79c8",path:"/pages/Rust_08/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a0af79c8").then(t)}},{path:"/pages/Rust_08/index.html",redirect:"/pages/Rust_08/"},{path:"/03.Rust/08.Rust的结构体类型.html",redirect:"/pages/Rust_08/"},{name:"v-2a8deef1",path:"/pages/Rust_07/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-2a8deef1").then(t)}},{path:"/pages/Rust_07/index.html",redirect:"/pages/Rust_07/"},{path:"/03.Rust/07.Rust的Slice类型.html",redirect:"/pages/Rust_07/"},{name:"v-29a271f4",path:"/pages/Rust_09/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-29a271f4").then(t)}},{path:"/pages/Rust_09/index.html",redirect:"/pages/Rust_09/"},{path:"/03.Rust/09.Rust的结构体的打印与调试.html",redirect:"/pages/Rust_09/"},{name:"v-1c87ad4a",path:"/pages/Rust_10/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-1c87ad4a").then(t)}},{path:"/pages/Rust_10/index.html",redirect:"/pages/Rust_10/"},{path:"/03.Rust/10.Rust的方法.html",redirect:"/pages/Rust_10/"},{name:"v-7a1f2933",path:"/pages/Rust_11/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-7a1f2933").then(t)}},{path:"/pages/Rust_11/index.html",redirect:"/pages/Rust_11/"},{path:"/03.Rust/11.Rust的枚举.html",redirect:"/pages/Rust_11/"},{name:"v-3d878538",path:"/pages/Rust_12/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3d878538").then(t)}},{path:"/pages/Rust_12/index.html",redirect:"/pages/Rust_12/"},{path:"/03.Rust/12.Rust的match控制流结构.html",redirect:"/pages/Rust_12/"},{name:"v-11435202",path:"/pages/Rust_13/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-11435202").then(t)}},{path:"/pages/Rust_13/index.html",redirect:"/pages/Rust_13/"},{path:"/03.Rust/13.Rust的语法糖-iflet.html",redirect:"/pages/Rust_13/"},{name:"v-8713be10",path:"/pages/Rust_15/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-8713be10").then(t)}},{path:"/pages/Rust_15/index.html",redirect:"/pages/Rust_15/"},{path:"/03.Rust/15.Rust的Vector.html",redirect:"/pages/Rust_15/"},{name:"v-f0192e14",path:"/pages/Rust_16/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-f0192e14").then(t)}},{path:"/pages/Rust_16/index.html",redirect:"/pages/Rust_16/"},{path:"/03.Rust/16.Rust的String类型基本原理.html",redirect:"/pages/Rust_16/"},{name:"v-85746228",path:"/pages/Rust_17/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-85746228").then(t)}},{path:"/pages/Rust_17/index.html",redirect:"/pages/Rust_17/"},{path:"/03.Rust/17.Rust的HashMap.html",redirect:"/pages/Rust_17/"},{name:"v-6082182f",path:"/pages/Rust_14/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6082182f").then(t)}},{path:"/pages/Rust_14/index.html",redirect:"/pages/Rust_14/"},{path:"/03.Rust/14.Rust的模块系统.html",redirect:"/pages/Rust_14/"},{name:"v-1d58d132",path:"/pages/Linux_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-1d58d132").then(t)}},{path:"/pages/Linux_01/index.html",redirect:"/pages/Linux_01/"},{path:"/04.Linux/01.Linux 的常用命令.html",redirect:"/pages/Linux_01/"},{name:"v-a1c9e1c2",path:"/pages/Linux_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a1c9e1c2").then(t)}},{path:"/pages/Linux_02/index.html",redirect:"/pages/Linux_02/"},{path:"/04.Linux/02.nano 编辑器.html",redirect:"/pages/Linux_02/"},{name:"v-45e07bf4",path:"/pages/Linux_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-45e07bf4").then(t)}},{path:"/pages/Linux_03/index.html",redirect:"/pages/Linux_03/"},{path:"/04.Linux/03.shell 脚本.html",redirect:"/pages/Linux_03/"},{name:"v-385042bf",path:"/pages/Python_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-385042bf").then(t)}},{path:"/pages/Python_01/index.html",redirect:"/pages/Python_01/"},{path:"/05.python/01.numpy 模块.html",redirect:"/pages/Python_01/"},{name:"v-cc2c3696",path:"/pages/Python_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-cc2c3696").then(t)}},{path:"/pages/Python_02/index.html",redirect:"/pages/Python_02/"},{path:"/05.python/02.pandas 模块.html",redirect:"/pages/Python_02/"},{name:"v-31773509",path:"/pages/Python_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-31773509").then(t)}},{path:"/pages/Python_03/index.html",redirect:"/pages/Python_03/"},{path:"/05.python/03.matplotlib 模块.html",redirect:"/pages/Python_03/"},{name:"v-36a51484",path:"/pages/C_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-36a51484").then(t)}},{path:"/pages/C_01/index.html",redirect:"/pages/C_01/"},{path:"/06.C/01.C语言的编译过程.html",redirect:"/pages/C_01/"},{name:"v-461cfdea",path:"/pages/C_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-461cfdea").then(t)}},{path:"/pages/C_03/index.html",redirect:"/pages/C_03/"},{path:"/06.C/03.C语言的字符串.html",redirect:"/pages/C_03/"},{name:"v-b34af184",path:"/pages/C_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-b34af184").then(t)}},{path:"/pages/C_04/index.html",redirect:"/pages/C_04/"},{path:"/06.C/04.C语言的结构体和共用体.html",redirect:"/pages/C_04/"},{name:"v-4edd7f5c",path:"/pages/C_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4edd7f5c").then(t)}},{path:"/pages/C_05/index.html",redirect:"/pages/C_05/"},{path:"/06.C/05.C语言的可变参数.html",redirect:"/pages/C_05/"},{name:"v-c5ed5e9c",path:"/pages/C_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c5ed5e9c").then(t)}},{path:"/pages/C_02/index.html",redirect:"/pages/C_02/"},{path:"/06.C/02.C语言的输入输出.html",redirect:"/pages/C_02/"},{name:"v-99ec5b4c",path:"/pages/C_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-99ec5b4c").then(t)}},{path:"/pages/C_06/index.html",redirect:"/pages/C_06/"},{path:"/06.C/06.C语言动态内存管理.html",redirect:"/pages/C_06/"},{name:"v-67e1f5a6",path:"/pages/C_08/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-67e1f5a6").then(t)}},{path:"/pages/C_08/index.html",redirect:"/pages/C_08/"},{path:"/06.C/08.C语言的位操作.html",redirect:"/pages/C_08/"},{name:"v-4035c28f",path:"/pages/C_07/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4035c28f").then(t)}},{path:"/pages/C_07/index.html",redirect:"/pages/C_07/"},{path:"/06.C/07.C语言文件操作.html",redirect:"/pages/C_07/"},{name:"v-75a0de9c",path:"/pages/Verilog_20/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-75a0de9c").then(t)}},{path:"/pages/Verilog_20/index.html",redirect:"/pages/Verilog_20/"},{path:"/07.Chip_Verification/1.testBench的编写规范.html",redirect:"/pages/Verilog_20/"},{name:"v-01b5feb6",path:"/archives/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-01b5feb6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-58b44ebe",path:"/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-58b44ebe").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-c9bd4b28",path:"/message-board/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c9bd4b28").then(t)}},{path:"/message-board/index.html",redirect:"/message-board/"},{path:"/message_board/留言板.html",redirect:"/message-board/"},{name:"v-acf2df8a",path:"/pages/Teasting_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-acf2df8a").then(t)}},{path:"/pages/Teasting_01/index.html",redirect:"/pages/Teasting_01/"},{path:"/teasting/01.可恶的wifi频段.html",redirect:"/pages/Teasting_01/"},{path:"*",component:ol}],ll={title:"原码纪事",description:"vdoing博客主题模板",base:"/",headTags:[["link",{rel:"icon",href:"https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220720_132133.ico"}],["meta",{name:"keywords",content:"猎户f,golang,vue,go-web,go-admin,go-ldap-admin"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["script",{language:"javascript",type:"text/javascript",src:"/js/pgmanor-self.js"}],["script",{async:!0,src:"https://www.googletagmanager.com/gtag/js?id=G-LPRG9SPLFF"}],["script",{},"\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n      gtag('config', 'G-LPRG9SPLFF');\n    "]],pages:[{title:"博客笔记",frontmatter:{title:"博客笔记",date:"2025-07-08T11:41:49.000Z",permalink:"/pages/Notes/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Notes.html",relativePath:"00.目录页/Notes.md",key:"v-72a9ee7c",path:"/pages/Notes/",headers:[{level:2,title:"Advanced C",slug:"advanced-c",normalizedTitle:"advanced c",charIndex:11},{level:2,title:"Advanced Python",slug:"advanced-python",normalizedTitle:"advanced python",charIndex:190},{level:2,title:"Linux for circuitors",slug:"linux-for-circuitors",normalizedTitle:"linux for circuitors",charIndex:304},{level:2,title:"Verilog HDL",slug:"verilog-hdl",normalizedTitle:"verilog hdl",charIndex:420},{level:2,title:"deeplearning simple notes",slug:"deeplearning-simple-notes",normalizedTitle:"deeplearning simple notes",charIndex:1015},{level:2,title:"Rust",slug:"rust",normalizedTitle:"rust",charIndex:1152}],headersStr:"Advanced C Advanced Python Linux for circuitors Verilog HDL deeplearning simple notes Rust",content:"# 博客笔记\n\n\n# Advanced C\n\n * 01.C语言的编译过程\n * 02.C语言的输入输出\n * 03.C语言的字符串\n * 04.C语言的结构体和共用体\n * 05.C语言的可变参数\n * 06.C语言动态内存管理\n * 07.C语言文件操作\n * 08.C语言的位操作\n\n----------------------------------------\n\n\n# Advanced Python\n\n * 01.numpy 模块\n * 02.pandas 模块\n * 03.matplotlib 模块\n\n----------------------------------------\n\n\n# Linux for circuitors\n\n * 01.Linux 的常用命令\n * 02.nano 编辑器\n * 03.shell 脚本\n\n----------------------------------------\n\n\n# Verilog HDL\n\n * 01.Verilog HDL语言基本要素\n * 02.Verilog HDL基本数据类型\n * 03.Verilog HDL运算符和表达式\n * 04.Verilog HDL模块\n * 05.Verilog HDL程序设计和描述方式\n * 06.Verilog HDL程序设计思想概览\n * 07.Verilog HDL组合电路设计的方法\n * 08.Verilog HDL组合电路之数字加法器\n * 09.Verilog HDL组合电路之数值比较器\n * 10.Verilog HDL组合电路之数据选择器\n * 11.Verilog HDL组合电路之数字编码器\n * 12.Verilog HDL组合电路之数字译码器\n * 13.Verilog HDL组合电路之奇偶校验器\n * 14.Verilog HDL时序电路设计基础\n * 15.Verilog HDL时序电路之基本触发器\n * 16.Verilog HDL时序逻辑电路之计数器\n * 17.Verilog HDL时序逻辑电路之移位寄存器\n * 18.Verilog HDL时序逻辑电路之信号发生器\n * 19.Verilog HDL有限状态机（FSM）设计基础\n * 20.testBench的编写规范\n\n----------------------------------------\n\n\n# deeplearning simple notes\n\n * 01.线性回归\n * 02.SoftMax回归\n * 03.多层感知机\n * 04.卷积神经网络\n * 05.LeNet\n\n----------------------------------------\n\n\n# Rust\n\n * 00.Rust的基本素养\n * 01.Rust的变量与可变性\n * 02.Rust的数据类型\n * 03.Rust的函数和注释\n * 04.Rust的控制流\n * 05.Rust的所有权概念\n * 06.Rust的引用和借用\n * 07.Rust的Slice类型\n * 08.Rust的结构体类型\n * 09.Rust的结构体的打印与调试\n * 10.Rust的方法\n * 11.Rust的枚举\n * 12.Rust的match控制流结构\n * 13.Rust的语法糖-iflet\n * 14.Rust的模块系统\n * 15.Rust的Vector\n * 16.Rust的String类型基本原理\n * 17.Rust的HashMap\n\n----------------------------------------\n\n留言板",normalizedContent:"# 博客笔记\n\n\n# advanced c\n\n * 01.c语言的编译过程\n * 02.c语言的输入输出\n * 03.c语言的字符串\n * 04.c语言的结构体和共用体\n * 05.c语言的可变参数\n * 06.c语言动态内存管理\n * 07.c语言文件操作\n * 08.c语言的位操作\n\n----------------------------------------\n\n\n# advanced python\n\n * 01.numpy 模块\n * 02.pandas 模块\n * 03.matplotlib 模块\n\n----------------------------------------\n\n\n# linux for circuitors\n\n * 01.linux 的常用命令\n * 02.nano 编辑器\n * 03.shell 脚本\n\n----------------------------------------\n\n\n# verilog hdl\n\n * 01.verilog hdl语言基本要素\n * 02.verilog hdl基本数据类型\n * 03.verilog hdl运算符和表达式\n * 04.verilog hdl模块\n * 05.verilog hdl程序设计和描述方式\n * 06.verilog hdl程序设计思想概览\n * 07.verilog hdl组合电路设计的方法\n * 08.verilog hdl组合电路之数字加法器\n * 09.verilog hdl组合电路之数值比较器\n * 10.verilog hdl组合电路之数据选择器\n * 11.verilog hdl组合电路之数字编码器\n * 12.verilog hdl组合电路之数字译码器\n * 13.verilog hdl组合电路之奇偶校验器\n * 14.verilog hdl时序电路设计基础\n * 15.verilog hdl时序电路之基本触发器\n * 16.verilog hdl时序逻辑电路之计数器\n * 17.verilog hdl时序逻辑电路之移位寄存器\n * 18.verilog hdl时序逻辑电路之信号发生器\n * 19.verilog hdl有限状态机（fsm）设计基础\n * 20.testbench的编写规范\n\n----------------------------------------\n\n\n# deeplearning simple notes\n\n * 01.线性回归\n * 02.softmax回归\n * 03.多层感知机\n * 04.卷积神经网络\n * 05.lenet\n\n----------------------------------------\n\n\n# rust\n\n * 00.rust的基本素养\n * 01.rust的变量与可变性\n * 02.rust的数据类型\n * 03.rust的函数和注释\n * 04.rust的控制流\n * 05.rust的所有权概念\n * 06.rust的引用和借用\n * 07.rust的slice类型\n * 08.rust的结构体类型\n * 09.rust的结构体的打印与调试\n * 10.rust的方法\n * 11.rust的枚举\n * 12.rust的match控制流结构\n * 13.rust的语法糖-iflet\n * 14.rust的模块系统\n * 15.rust的vector\n * 16.rust的string类型基本原理\n * 17.rust的hashmap\n\n----------------------------------------\n\n留言板",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"项目",frontmatter:{title:"项目",date:"2025-07-08T11:41:49.000Z",permalink:"/pages/Projects/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Projects.html",relativePath:"00.目录页/Projects.md",key:"v-c2184f54",path:"/pages/Projects/",headersStr:null,content:"# 项目\n\n留言板",normalizedContent:"# 项目\n\n留言板",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"吐槽",frontmatter:{title:"吐槽",date:"2025-08-17T21:35:00.000Z",permalink:"/pages/Teasting/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Teasting.html",relativePath:"00.目录页/Teasting.md",key:"v-4a1eacb6",path:"/pages/Teasting/",headersStr:null,content:"# 吐槽\n\n * 01.可恶的wifi频段\n\n留言板",normalizedContent:"# 吐槽\n\n * 01.可恶的wifi频段\n\n留言板",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.Verilog HDL基本数据类型",frontmatter:{title:"02.Verilog HDL基本数据类型",date:"2025-07-18T16:00:49.000Z",permalink:"/pages/Verilog_02/"},regularPath:"/01.Verilog/02.Verilog%20HDL%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"01.Verilog/02.Verilog HDL基本数据类型.md",key:"v-3e99d850",path:"/pages/Verilog_02/",headers:[{level:2,title:"1. 物理数据类型：硬件电路的“材料”",slug:"_1-物理数据类型-硬件电路的-材料",normalizedTitle:"1. 物理数据类型：硬件电路的“材料”",charIndex:24},{level:3,title:"1.1 连线型（Net Type）—— 相当于“电线”",slug:"_1-1-连线型-net-type-相当于-电线",normalizedTitle:"1.1 连线型（net type）—— 相当于“电线”",charIndex:135},{level:3,title:"1.2 寄存器型（Register Type）—— 相当于“存储单元”",slug:"_1-2-寄存器型-register-type-相当于-存储单元",normalizedTitle:"1.2 寄存器型（register type）—— 相当于“存储单元”",charIndex:825},{level:2,title:"2. 存储器型（Memory）—— 相当于“RAM/ROM”",slug:"_2-存储器型-memory-相当于-ram-rom",normalizedTitle:"2. 存储器型（memory）—— 相当于“ram/rom”",charIndex:1536},{level:2,title:"3. 抽象数据类型：辅助设计的“工具”",slug:"_3-抽象数据类型-辅助设计的-工具",normalizedTitle:"3. 抽象数据类型：辅助设计的“工具”",charIndex:2069},{level:3,title:"3.1 整型（`integer`）",slug:"_3-1-整型-integer",normalizedTitle:"3.1 整型（<code>integer</code>）",charIndex:null},{level:3,title:"3.2 时间型（`time`）",slug:"_3-2-时间型-time",normalizedTitle:"3.2 时间型（<code>time</code>）",charIndex:null},{level:3,title:"3.3 实型（`real`）",slug:"_3-3-实型-real",normalizedTitle:"3.3 实型（<code>real</code>）",charIndex:null},{level:3,title:"3.4 参数型（`parameter`）—— 相当于“常量”",slug:"_3-4-参数型-parameter-相当于-常量",normalizedTitle:"3.4 参数型（<code>parameter</code>）—— 相当于“常量”",charIndex:null},{level:3,title:"总结：数据类型的选择指南",slug:"总结-数据类型的选择指南",normalizedTitle:"总结：数据类型的选择指南",charIndex:3110}],headersStr:"1. 物理数据类型：硬件电路的“材料” 1.1 连线型（Net Type）—— 相当于“电线” 1.2 寄存器型（Register Type）—— 相当于“存储单元” 2. 存储器型（Memory）—— 相当于“RAM/ROM” 3. 抽象数据类型：辅助设计的“工具” 3.1 整型（`integer`） 3.2 时间型（`time`） 3.3 实型（`real`） 3.4 参数型（`parameter`）—— 相当于“常量” 总结：数据类型的选择指南",content:"# Verilog HDL基本数据类型\n\n\n# 1. 物理数据类型：硬件电路的“材料”\n\n核心思想：Verilog的数据类型是对实际硬件电路的抽象，比如电线、寄存器、存储器等。\n\n----------------------------------------\n\n\n# 1.1 连线型（Net Type）—— 相当于“电线”\n\n * 作用：表示电路中的物理连接，不能存储数据，只能传递信号。\n\n * 常见类型：\n   \n   类型            功能说明            现实类比\n   wire          普通导线（默认类型）      铜线\n   tri           三态导线（可高阻态）      带开关的线\n   wor/trior     多驱动时，实现“线或”逻辑   多个开关并联\n   wand/triand   多驱动时，实现“线与”逻辑   多个开关串联\n   supply1       电源线（恒定高电平）      VCC（+5V）\n   supply0       地线（恒定低电平）       GND（0V）\n\n * 声明格式：\n   \n   wire [位宽] 变量名;       // 普通连线\n   tri [7:0] bus;          // 8位三态总线\n   supply1 vdd;            // 电源线\n   \n   \n   1\n   2\n   3\n   \n\n * 关键特性：\n   \n   * 默认初值为 z（高阻态）。\n   \n   * 需要用 assign 或模块输出驱动：\n     \n     wire a;\n     assign a = 1'b1;  // 给电线a赋值高电平\n     \n     \n     1\n     2\n     \n\n----------------------------------------\n\n\n# 1.2 寄存器型（Register Type）—— 相当于“存储单元”\n\n * 作用：表示可以存储数据的硬件元件（如触发器、锁存器）。\n\n * 关键字：reg\n\n * 声明格式：\n   \n   reg [位宽] 变量名;  \n   \n   \n   1\n   \n\n * 示例：\n   \n   reg q;          // 1位寄存器（存储1bit数据）\n   reg [7:0] data; // 8位寄存器（存储一个字节）\n   \n   \n   1\n   2\n   \n\n * 关键特性：\n   \n   * 默认初值为 x（未知状态）。\n   \n   * 必须在 always 或 initial 块中赋值：\n     \n     always @(posedge clk) begin\n       q <= din;  // 在时钟上升沿存储din的值\n     end\n     \n     \n     1\n     2\n     3\n     \n   \n   * 注意：\n     \n     * reg 不一定是实际的寄存器！综合工具可能将其优化为组合逻辑。\n     \n     * 若需要明确符号，可用 reg signed：\n       \n       reg signed [3:0] num; // 4位有符号数（范围-8到7）\n       num = -2;             // 存储为1110（补码）\n       \n       \n       1\n       2\n       \n\n----------------------------------------\n\n\n# 2. 存储器型（Memory）—— 相当于“RAM/ROM”\n\n * 作用：描述硬件中的存储阵列（如内存、寄存器堆）。\n\n * 本质：一组 reg 的集合。\n\n * 声明格式：\n   \n   reg [数据位宽] 存储器名 [地址数量];  \n   \n   \n   1\n   \n\n * 示例：\n   \n   reg [7:0] ram [0:255]; // 256个8位存储单元（地址0~255）\n   reg [31:0] rom [0:1023]; // 1KB的32位ROM\n   \n   \n   1\n   2\n   \n\n * 操作方式：\n   \n   * 按地址读写：\n     \n     ram[0] = 8'hFF;  // 给地址0写入255\n     data_out = rom[5]; // 读取地址5的数据\n     \n     \n     1\n     2\n     \n   \n   * 重要限制：\n     \n     * 不能一次性读写整个存储器！必须逐个地址操作。\n     * 综合时可能被映射为FPGA的Block RAM或寄存器堆。\n\n----------------------------------------\n\n\n# 3. 抽象数据类型：辅助设计的“工具”\n\n\n# 3.1 整型（integer）\n\n * 作用：用于仿真时的数学运算（不直接对应硬件）。\n\n * 特点：\n   \n   * 32位有符号整数（范围 -2^31 到 2^31-1）。\n   * 常用于循环计数器、临时计算。\n\n * 示例：\n   \n   integer i;\n   for (i=0; i<10; i=i+1) begin // 循环10次\n     // 执行操作\n   end\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 3.2 时间型（time）\n\n * 作用：记录仿真时间（如测试延迟）。\n\n * 特点：\n   \n   * 64位无符号整数，单位由 ``timescale定义（如1ns`）。\n   * 常与 $time 系统函数配合使用。\n\n * 示例\n   \n   time start_time;\n   initial begin\n     start_time = $time; // 记录当前仿真时间\n     #10;               // 延迟10个时间单位\n     $display(\"耗时：%t\", $time - start_time);\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 3.3 实型（real）\n\n * 作用：仿真时的浮点数计算（如模拟电路参数）。\n\n * 示例：\n   \n   real voltage;\n   voltage = 3.3; // 表示3.3V电压\n   \n   \n   1\n   2\n   \n\n\n# 3.4 参数型（parameter）—— 相当于“常量”\n\n * 作用：定义模块中的固定值（如位宽、延迟时间）。\n\n * 特点：\n   \n   * 仿真前确定，运行时不可修改。\n   * 提高代码可读性和可维护性。\n\n * 示例：\n   \n   parameter WIDTH = 8;       // 定义位宽为8\n   parameter DELAY = 10;      // 定义延迟10ns\n   reg [WIDTH-1:0] data;      // 实际声明为reg [7:0] data\n   \n   \n   1\n   2\n   3\n   \n\n----------------------------------------\n\n\n# 总结：数据类型的选择指南\n\n类型      关键字            适用场景        硬件对应物\n连线型     wire           模块间信号连接     导线\n寄存器型    reg            时序逻辑存储      触发器/锁存器\n存储器型    reg [] []      RAM/ROM建模   存储阵列\n整型/实型   integer/real   仿真计算        无直接对应\n参数型     parameter      常量定义（如位宽）   硬件配置参数\n\n黄金法则：\n\n 1. 连线用 wire，存储用 reg。\n 2. 存储器本质是 reg 数组，按地址访问。\n 3. integer/real 仅用于仿真，不生成实际电路。\n\n常见错误：\n\n * 错误1：对 wire 用过程赋值（=）。\n   \n   wire a;\n   always @(*) a = b; // 错！wire必须用assign驱动\n   \n   \n   1\n   2\n   \n\n * 错误2：试图整体操作存储器。\n   \n   reg [7:0] mem [0:255];\n   mem = 0; // 错！必须逐个地址初始化\n   \n   \n   1\n   2\n   ",normalizedContent:"# verilog hdl基本数据类型\n\n\n# 1. 物理数据类型：硬件电路的“材料”\n\n核心思想：verilog的数据类型是对实际硬件电路的抽象，比如电线、寄存器、存储器等。\n\n----------------------------------------\n\n\n# 1.1 连线型（net type）—— 相当于“电线”\n\n * 作用：表示电路中的物理连接，不能存储数据，只能传递信号。\n\n * 常见类型：\n   \n   类型            功能说明            现实类比\n   wire          普通导线（默认类型）      铜线\n   tri           三态导线（可高阻态）      带开关的线\n   wor/trior     多驱动时，实现“线或”逻辑   多个开关并联\n   wand/triand   多驱动时，实现“线与”逻辑   多个开关串联\n   supply1       电源线（恒定高电平）      vcc（+5v）\n   supply0       地线（恒定低电平）       gnd（0v）\n\n * 声明格式：\n   \n   wire [位宽] 变量名;       // 普通连线\n   tri [7:0] bus;          // 8位三态总线\n   supply1 vdd;            // 电源线\n   \n   \n   1\n   2\n   3\n   \n\n * 关键特性：\n   \n   * 默认初值为 z（高阻态）。\n   \n   * 需要用 assign 或模块输出驱动：\n     \n     wire a;\n     assign a = 1'b1;  // 给电线a赋值高电平\n     \n     \n     1\n     2\n     \n\n----------------------------------------\n\n\n# 1.2 寄存器型（register type）—— 相当于“存储单元”\n\n * 作用：表示可以存储数据的硬件元件（如触发器、锁存器）。\n\n * 关键字：reg\n\n * 声明格式：\n   \n   reg [位宽] 变量名;  \n   \n   \n   1\n   \n\n * 示例：\n   \n   reg q;          // 1位寄存器（存储1bit数据）\n   reg [7:0] data; // 8位寄存器（存储一个字节）\n   \n   \n   1\n   2\n   \n\n * 关键特性：\n   \n   * 默认初值为 x（未知状态）。\n   \n   * 必须在 always 或 initial 块中赋值：\n     \n     always @(posedge clk) begin\n       q <= din;  // 在时钟上升沿存储din的值\n     end\n     \n     \n     1\n     2\n     3\n     \n   \n   * 注意：\n     \n     * reg 不一定是实际的寄存器！综合工具可能将其优化为组合逻辑。\n     \n     * 若需要明确符号，可用 reg signed：\n       \n       reg signed [3:0] num; // 4位有符号数（范围-8到7）\n       num = -2;             // 存储为1110（补码）\n       \n       \n       1\n       2\n       \n\n----------------------------------------\n\n\n# 2. 存储器型（memory）—— 相当于“ram/rom”\n\n * 作用：描述硬件中的存储阵列（如内存、寄存器堆）。\n\n * 本质：一组 reg 的集合。\n\n * 声明格式：\n   \n   reg [数据位宽] 存储器名 [地址数量];  \n   \n   \n   1\n   \n\n * 示例：\n   \n   reg [7:0] ram [0:255]; // 256个8位存储单元（地址0~255）\n   reg [31:0] rom [0:1023]; // 1kb的32位rom\n   \n   \n   1\n   2\n   \n\n * 操作方式：\n   \n   * 按地址读写：\n     \n     ram[0] = 8'hff;  // 给地址0写入255\n     data_out = rom[5]; // 读取地址5的数据\n     \n     \n     1\n     2\n     \n   \n   * 重要限制：\n     \n     * 不能一次性读写整个存储器！必须逐个地址操作。\n     * 综合时可能被映射为fpga的block ram或寄存器堆。\n\n----------------------------------------\n\n\n# 3. 抽象数据类型：辅助设计的“工具”\n\n\n# 3.1 整型（integer）\n\n * 作用：用于仿真时的数学运算（不直接对应硬件）。\n\n * 特点：\n   \n   * 32位有符号整数（范围 -2^31 到 2^31-1）。\n   * 常用于循环计数器、临时计算。\n\n * 示例：\n   \n   integer i;\n   for (i=0; i<10; i=i+1) begin // 循环10次\n     // 执行操作\n   end\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 3.2 时间型（time）\n\n * 作用：记录仿真时间（如测试延迟）。\n\n * 特点：\n   \n   * 64位无符号整数，单位由 ``timescale定义（如1ns`）。\n   * 常与 $time 系统函数配合使用。\n\n * 示例\n   \n   time start_time;\n   initial begin\n     start_time = $time; // 记录当前仿真时间\n     #10;               // 延迟10个时间单位\n     $display(\"耗时：%t\", $time - start_time);\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 3.3 实型（real）\n\n * 作用：仿真时的浮点数计算（如模拟电路参数）。\n\n * 示例：\n   \n   real voltage;\n   voltage = 3.3; // 表示3.3v电压\n   \n   \n   1\n   2\n   \n\n\n# 3.4 参数型（parameter）—— 相当于“常量”\n\n * 作用：定义模块中的固定值（如位宽、延迟时间）。\n\n * 特点：\n   \n   * 仿真前确定，运行时不可修改。\n   * 提高代码可读性和可维护性。\n\n * 示例：\n   \n   parameter width = 8;       // 定义位宽为8\n   parameter delay = 10;      // 定义延迟10ns\n   reg [width-1:0] data;      // 实际声明为reg [7:0] data\n   \n   \n   1\n   2\n   3\n   \n\n----------------------------------------\n\n\n# 总结：数据类型的选择指南\n\n类型      关键字            适用场景        硬件对应物\n连线型     wire           模块间信号连接     导线\n寄存器型    reg            时序逻辑存储      触发器/锁存器\n存储器型    reg [] []      ram/rom建模   存储阵列\n整型/实型   integer/real   仿真计算        无直接对应\n参数型     parameter      常量定义（如位宽）   硬件配置参数\n\n黄金法则：\n\n 1. 连线用 wire，存储用 reg。\n 2. 存储器本质是 reg 数组，按地址访问。\n 3. integer/real 仅用于仿真，不生成实际电路。\n\n常见错误：\n\n * 错误1：对 wire 用过程赋值（=）。\n   \n   wire a;\n   always @(*) a = b; // 错！wire必须用assign驱动\n   \n   \n   1\n   2\n   \n\n * 错误2：试图整体操作存储器。\n   \n   reg [7:0] mem [0:255];\n   mem = 0; // 错！必须逐个地址初始化\n   \n   \n   1\n   2\n   ",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.Verilog HDL运算符和表达式",frontmatter:{title:"03.Verilog HDL运算符和表达式",date:"2025-07-19T08:00:49.000Z",permalink:"/pages/Verilog_03/"},regularPath:"/01.Verilog/03.Verilog%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"01.Verilog/03.Verilog运算符和表达式.md",key:"v-3b89e5c1",path:"/pages/Verilog_03/",headers:[{level:2,title:"1、算术运算符：加减乘除",slug:"_1、算术运算符-加减乘除",normalizedTitle:"1、算术运算符：加减乘除",charIndex:14},{level:2,title:"2. 关系运算符：比较大小",slug:"_2-关系运算符-比较大小",normalizedTitle:"2. 关系运算符：比较大小",charIndex:565},{level:2,title:"3. 相等运算符：判等",slug:"_3-相等运算符-判等",normalizedTitle:"3. 相等运算符：判等",charIndex:947},{level:2,title:"4. 逻辑运算符：真/假判断",slug:"_4-逻辑运算符-真-假判断",normalizedTitle:"4. 逻辑运算符：真/假判断",charIndex:1440},{level:2,title:"5. 按位运算符：逐bit操作",slug:"_5-按位运算符-逐bit操作",normalizedTitle:"5. 按位运算符：逐bit操作",charIndex:1919},{level:2,title:"6. 移位运算符：左移/右移",slug:"_6-移位运算符-左移-右移",normalizedTitle:"6. 移位运算符：左移/右移",charIndex:2466},{level:2,title:"7. 条件运算符：简化的if-else",slug:"_7-条件运算符-简化的if-else",normalizedTitle:"7. 条件运算符：简化的if-else",charIndex:2889},{level:2,title:"8. 连接与复制运算符：合并信号",slug:"_8-连接与复制运算符-合并信号",normalizedTitle:"8. 连接与复制运算符：合并信号",charIndex:3309},{level:3,title:"总结：运算符优先级表",slug:"总结-运算符优先级表",normalizedTitle:"总结：运算符优先级表",charIndex:3774}],headersStr:"1、算术运算符：加减乘除 2. 关系运算符：比较大小 3. 相等运算符：判等 4. 逻辑运算符：真/假判断 5. 按位运算符：逐bit操作 6. 移位运算符：左移/右移 7. 条件运算符：简化的if-else 8. 连接与复制运算符：合并信号 总结：运算符优先级表",content:'# 运算符和表达式\n\n\n# 1、算术运算符：加减乘除\n\n符号：+、-、*、/、%（取模） 作用：数学运算，注意位宽规则！\n\nmodule arithmetic;\n  reg [3:0] a = 4\'b1100; // 12\n  reg [2:0] b = 3\'b011;  // 3\n  \n  initial begin\n    $display("a + b = %b", a + b); // 12+3=15 → 4\'b1111\n    $display("a - b = %b", a - b); // 12-3=9 → 4\'b1001\n    $display("a * b = %b", a * b); // 12*3=36 → 但a只有4位，截断后=4\'b0100（36%16=4）\n    $display("a / b = %b", a / b); // 12/3=4 → 4\'b0100\n    $display("a %% b = %b", a % b); // 12%3=0 → 4\'b0000\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 结果位宽 = 操作数的最大位宽（如4位+3位=4位结果）。\n * 除法/取模会舍去小数（如 7/3=2）\n\n\n# 2. 关系运算符：比较大小\n\n符号：>、<、>=、<= 输出：1（真）、0（假）、x（未知）\n\nmodule compare;\n  reg [3:0] x = 4\'b1010; // 10\n  reg [3:0] y = 4\'b0011; // 3\n  \n  initial begin\n    $display("x > y? %b", x > y);  // 10>3 → 1\n    $display("x < y? %b", x < y);  // 10<3 → 0\n    $display("x >=10? %b", x >= 4\'d10); // 10>=10 → 1\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：若操作数含 x，结果可能是 x（如 4\'b101x > 4\'b0000 → x）。\n\n\n# 3. 相等运算符：判等\n\n符号：\n\n * ==（等于）、!=（不等）→ 可能返回 x\n * ===（全等）、!==（非全等）→ 严格比较（包括 x 和 z）\n\nmodule equality;\n  reg [3:0] p = 4\'b101x;\n  reg [3:0] q = 4\'b1010;\n  \n  initial begin\n    $display("p == q? %b", p == q);  // 101x == 1010 → x（不确定）\n    $display("p === q? %b", p === q); // 101x === 1010 → 0（严格不等）\n    $display("p != q? %b", p != q);  // 101x != 1010 → x\n    $display("p !== q? %b", p !== q); // 101x !== 1010 → 1（确实不等）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n何时用 ===？ 测试中精确匹配高阻态 z 或未知态 x。\n\n\n# 4. 逻辑运算符：真/假判断\n\n符号：&&（与）、||（或）、!（非） 规则：非0即真（0=假，1/x/z=真）\n\nmodule logical;\n  reg a = 1\'b1;\n  reg b = 1\'b0;\n  reg c = 1\'bx;\n  \n  initial begin\n    $display("a && b = %b", a && b); // 1 && 0 → 0\n    $display("a || b = %b", a || b); // 1 || 0 → 1\n    $display("!a = %b", !a);         // !1 → 0\n    $display("a && c = %b", a && c); // 1 && x → x（不确定）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n易错点：逻辑运算符会先化简操作数为1位（如 4\'b1011 当作 1\'b1）。\n\n----------------------------------------\n\n\n# 5. 按位运算符：逐bit操作\n\n符号：&（与）、|（或）、^（异或）、~（非）\n\nmodule bitwise;\n  reg [3:0] m = 4\'b1100;\n  reg [3:0] n = 4\'b1010;\n  \n  initial begin\n    $display("m & n = %b", m & n); // 1100 & 1010 → 1000\n    $display("m | n = %b", m | n); // 1100 | 1010 → 1110\n    $display("m ^ n = %b", m ^ n); // 1100 ^ 1010 → 0110（相同为0，不同为1）\n    $display("~m = %b", ~m);       // ~1100 → 0011\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对比逻辑运算符：\n\n * & 是逐位与，&& 是整体逻辑与。\n * 示例：4\'b1100 && 4\'b1010 → 1（非0即真），但 4\'b1100 & 4\'b1010 → 4\'b1000。\n\n----------------------------------------\n\n\n# 6. 移位运算符：左移/右移\n\n符号：<<（左移）、>>（右移） 规则：空位补 0，不循环移位！\n\nmodule shift;\n  reg [3:0] num = 4\'b1101; // 13\n  \n  initial begin\n    $display("num << 1 = %b", num << 1); // 1101→1010（高位1丢弃，低位补0）\n    $display("num >> 2 = %b", num >> 2); // 1101→0011（低位01丢弃，高位补0）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n应用场景：\n\n * 左移1位 ≈ 乘以2（4\'b0011<<1 → 4\'b0110，即3→6）。\n * 右移2位 ≈ 除以4（4\'b1100>>2 → 4\'b0011，即12→3）。\n\n----------------------------------------\n\n\n# 7. 条件运算符：简化的if-else\n\n符号：条件 ? 表达式1 : 表达式2\n\nmodule conditional;\n  reg sel = 1\'b1;\n  reg [3:0] in1 = 4\'b1010;\n  reg [3:0] in2 = 4\'b0101;\n  wire [3:0] out;\n  \n  assign out = sel ? in1 : in2; // sel为1选in1，否则选in2\n  \n  initial begin\n    $display("out = %b", out); // sel=1 → out=1010\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n等效代码：\n\nif (sel) out = in1;\nelse out = in2;\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 8. 连接与复制运算符：合并信号\n\n符号：\n\n * 连接 {a, b}：将多个信号拼接。\n * 复制 {n{a}}：重复信号n次。\n\nmodule concat;\n  reg [1:0] a = 2\'b10;\n  reg [2:0] b = 3\'b110;\n  \n  initial begin\n    $display("{a, b} = %b", {a, b}); // 10 + 110 → 5\'b10110\n    $display("{3{a}} = %b", {3{a}}); // 10重复3次 → 6\'b101010\n    $display("{2{a}, 1\'b0, b} = %b", {2{a}, 1\'b0, b}); // 1010 + 0 + 110 → 7\'b1010110\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型用途：\n\n * 扩展位宽：{4{1\'b1}} 生成 4\'b1111。\n * 组合总线：{addr, data} 合并地址和数据。\n\n\n# 总结：运算符优先级表\n\n优先级   运算符             描述              \n最高    ! ~             逻辑非、按位非         \n      * / %           乘、除、取模          \n      + -             加、减             \n      << >>           移位              \n      < <= > >=       关系比较            \n      == != === !==   相等判断            \n      &               按位与             \n      ^ ^~            按位异或、同或         \n      |               按位或             \n      &&              逻辑与             \n      最低              | |       逻辑或   \n\n黄金法则：\n\n 1. 不确定优先级时，加括号！如 (a & b) || c。\n 2. 按位操作 vs 逻辑操作：看是否需要逐bit处理。\n 3. 移位运算的空位永远补 0。',normalizedContent:'# 运算符和表达式\n\n\n# 1、算术运算符：加减乘除\n\n符号：+、-、*、/、%（取模） 作用：数学运算，注意位宽规则！\n\nmodule arithmetic;\n  reg [3:0] a = 4\'b1100; // 12\n  reg [2:0] b = 3\'b011;  // 3\n  \n  initial begin\n    $display("a + b = %b", a + b); // 12+3=15 → 4\'b1111\n    $display("a - b = %b", a - b); // 12-3=9 → 4\'b1001\n    $display("a * b = %b", a * b); // 12*3=36 → 但a只有4位，截断后=4\'b0100（36%16=4）\n    $display("a / b = %b", a / b); // 12/3=4 → 4\'b0100\n    $display("a %% b = %b", a % b); // 12%3=0 → 4\'b0000\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 结果位宽 = 操作数的最大位宽（如4位+3位=4位结果）。\n * 除法/取模会舍去小数（如 7/3=2）\n\n\n# 2. 关系运算符：比较大小\n\n符号：>、<、>=、<= 输出：1（真）、0（假）、x（未知）\n\nmodule compare;\n  reg [3:0] x = 4\'b1010; // 10\n  reg [3:0] y = 4\'b0011; // 3\n  \n  initial begin\n    $display("x > y? %b", x > y);  // 10>3 → 1\n    $display("x < y? %b", x < y);  // 10<3 → 0\n    $display("x >=10? %b", x >= 4\'d10); // 10>=10 → 1\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意：若操作数含 x，结果可能是 x（如 4\'b101x > 4\'b0000 → x）。\n\n\n# 3. 相等运算符：判等\n\n符号：\n\n * ==（等于）、!=（不等）→ 可能返回 x\n * ===（全等）、!==（非全等）→ 严格比较（包括 x 和 z）\n\nmodule equality;\n  reg [3:0] p = 4\'b101x;\n  reg [3:0] q = 4\'b1010;\n  \n  initial begin\n    $display("p == q? %b", p == q);  // 101x == 1010 → x（不确定）\n    $display("p === q? %b", p === q); // 101x === 1010 → 0（严格不等）\n    $display("p != q? %b", p != q);  // 101x != 1010 → x\n    $display("p !== q? %b", p !== q); // 101x !== 1010 → 1（确实不等）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n何时用 ===？ 测试中精确匹配高阻态 z 或未知态 x。\n\n\n# 4. 逻辑运算符：真/假判断\n\n符号：&&（与）、||（或）、!（非） 规则：非0即真（0=假，1/x/z=真）\n\nmodule logical;\n  reg a = 1\'b1;\n  reg b = 1\'b0;\n  reg c = 1\'bx;\n  \n  initial begin\n    $display("a && b = %b", a && b); // 1 && 0 → 0\n    $display("a || b = %b", a || b); // 1 || 0 → 1\n    $display("!a = %b", !a);         // !1 → 0\n    $display("a && c = %b", a && c); // 1 && x → x（不确定）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n易错点：逻辑运算符会先化简操作数为1位（如 4\'b1011 当作 1\'b1）。\n\n----------------------------------------\n\n\n# 5. 按位运算符：逐bit操作\n\n符号：&（与）、|（或）、^（异或）、~（非）\n\nmodule bitwise;\n  reg [3:0] m = 4\'b1100;\n  reg [3:0] n = 4\'b1010;\n  \n  initial begin\n    $display("m & n = %b", m & n); // 1100 & 1010 → 1000\n    $display("m | n = %b", m | n); // 1100 | 1010 → 1110\n    $display("m ^ n = %b", m ^ n); // 1100 ^ 1010 → 0110（相同为0，不同为1）\n    $display("~m = %b", ~m);       // ~1100 → 0011\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对比逻辑运算符：\n\n * & 是逐位与，&& 是整体逻辑与。\n * 示例：4\'b1100 && 4\'b1010 → 1（非0即真），但 4\'b1100 & 4\'b1010 → 4\'b1000。\n\n----------------------------------------\n\n\n# 6. 移位运算符：左移/右移\n\n符号：<<（左移）、>>（右移） 规则：空位补 0，不循环移位！\n\nmodule shift;\n  reg [3:0] num = 4\'b1101; // 13\n  \n  initial begin\n    $display("num << 1 = %b", num << 1); // 1101→1010（高位1丢弃，低位补0）\n    $display("num >> 2 = %b", num >> 2); // 1101→0011（低位01丢弃，高位补0）\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n应用场景：\n\n * 左移1位 ≈ 乘以2（4\'b0011<<1 → 4\'b0110，即3→6）。\n * 右移2位 ≈ 除以4（4\'b1100>>2 → 4\'b0011，即12→3）。\n\n----------------------------------------\n\n\n# 7. 条件运算符：简化的if-else\n\n符号：条件 ? 表达式1 : 表达式2\n\nmodule conditional;\n  reg sel = 1\'b1;\n  reg [3:0] in1 = 4\'b1010;\n  reg [3:0] in2 = 4\'b0101;\n  wire [3:0] out;\n  \n  assign out = sel ? in1 : in2; // sel为1选in1，否则选in2\n  \n  initial begin\n    $display("out = %b", out); // sel=1 → out=1010\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n等效代码：\n\nif (sel) out = in1;\nelse out = in2;\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 8. 连接与复制运算符：合并信号\n\n符号：\n\n * 连接 {a, b}：将多个信号拼接。\n * 复制 {n{a}}：重复信号n次。\n\nmodule concat;\n  reg [1:0] a = 2\'b10;\n  reg [2:0] b = 3\'b110;\n  \n  initial begin\n    $display("{a, b} = %b", {a, b}); // 10 + 110 → 5\'b10110\n    $display("{3{a}} = %b", {3{a}}); // 10重复3次 → 6\'b101010\n    $display("{2{a}, 1\'b0, b} = %b", {2{a}, 1\'b0, b}); // 1010 + 0 + 110 → 7\'b1010110\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型用途：\n\n * 扩展位宽：{4{1\'b1}} 生成 4\'b1111。\n * 组合总线：{addr, data} 合并地址和数据。\n\n\n# 总结：运算符优先级表\n\n优先级   运算符             描述              \n最高    ! ~             逻辑非、按位非         \n      * / %           乘、除、取模          \n      + -             加、减             \n      << >>           移位              \n      < <= > >=       关系比较            \n      == != === !==   相等判断            \n      &               按位与             \n      ^ ^~            按位异或、同或         \n      |               按位或             \n      &&              逻辑与             \n      最低              | |       逻辑或   \n\n黄金法则：\n\n 1. 不确定优先级时，加括号！如 (a & b) || c。\n 2. 按位操作 vs 逻辑操作：看是否需要逐bit处理。\n 3. 移位运算的空位永远补 0。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.Verilog HDL语言基本要素",frontmatter:{title:"01.Verilog HDL语言基本要素",date:"2025-07-12T17:00:49.000Z",permalink:"/pages/Verilog_01/"},regularPath:"/01.Verilog/01.Verilog%20HDL%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0.html",relativePath:"01.Verilog/01.Verilog HDL基本要素.md",key:"v-56bac38c",path:"/pages/Verilog_01/",headers:[{level:2,title:"1、空白符",slug:"_1、空白符",normalizedTitle:"1、空白符",charIndex:24},{level:2,title:"2、注释",slug:"_2、注释",normalizedTitle:"2、注释",charIndex:279},{level:2,title:"3、标识符（给变量/模块起名字）",slug:"_3、标识符-给变量-模块起名字",normalizedTitle:"3、标识符（给变量/模块起名字）",charIndex:716},{level:2,title:"4、关键字",slug:"_4、关键字",normalizedTitle:"4、关键字",charIndex:1418},{level:2,title:"5、数字（如何表示0、1、不定、高阻态？）",slug:"_5、数字-如何表示0、1、不定、高阻态",normalizedTitle:"5、数字（如何表示0、1、不定、高阻态？）",charIndex:1763}],headersStr:"1、空白符 2、注释 3、标识符（给变量/模块起名字） 4、关键字 5、数字（如何表示0、1、不定、高阻态？）",content:"# Verilog HDL语言基本要素\n\n\n# 1、空白符\n\n * 包括空格符（\\b）、制表符（\\t）、换行符和换页符，编译时被忽略。\n\n * 示例：\n   \n   initial begin a = 3'b100; b = 3'b010; end\n   \n   \n   1\n   \n\n * 在加入空白符之后，代码变得更加可读：\n   \n   initial \n   begin \n       a = 3'b100; \n       b = 3'b010; \n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2、注释\n\n * 作用：用来写说明文字，不会被编译，是给可爱的同学们看的笔记，防止一觉睡醒看不懂了（汇编程序员的痛）。\n\n * 两种写法：\n   \n   * 单行注释：用 //，直到行尾都算注释。\n     \n     assign a = b & c;  // 这是单行注释：计算a等于b和c的按位与\n     \n     \n     1\n     \n   \n   * 多行注释：用 /* */，中间可以跨多行。\n     \n     /* 这是多行注释：\n        可以写很长的说明，\n        比如这个模块的功能是XXX */**重要规则**：\n     \n     \n     1\n     2\n     3\n     \n   \n   * 重要规则\n     \n     * 多行注释不能嵌套！比如 /* 注释1 /* 注释2 */ 注释1 */ 会报错。\n     \n     * 但多行注释里可以包含单行注释：/* // 这是合法的 */。\n\n\n# 3、标识符（给变量/模块起名字）\n\n作为一个类C语言，verilog十分有素养，所以它的标识符命名方式以及注意点和C语言的变量几乎没有区别\n\n * 组成：字母、数字、$、_，区分大小写，首字符必须为字母或下划线。\n\n * 示例：count、_CC_G5（合法）；30count、out*（非法）。\n\n * 转义标识符：以 \\ 开头，以空白结尾，可包含任意可打印字符（如 \\a+b=c）。\n\n * 合法示例：\n   \n   counter    // 纯字母\n   _data_in   // 下划线开头\n   $signal    // 美元符号开头（较少用）\n   \n   \n   1\n   2\n   3\n   \n\n * 非法示例：\n   \n   3state     // 数字开头\n   out#put    // 包含非法字符#\n   a+b        // 包含运算符+\n   \n   \n   1\n   2\n   3\n   \n\n * 特殊技巧：转义标识符\n   \n   * 如果非要起一个奇怪的名字（比如包含空格、符号），可以用 \\ 开头，空格结尾。\n   \n   * 示例：\n     \n     \\7400      // 实际名字是 \"7400\"（通常用于和传统电路编号兼容）\n     \\a+b=c     // 实际名字是 \"a+b=c\"\n     \\***       // 实际名字是 \"***\"\n     \n     \n     1\n     2\n     3\n     \n   \n   * 但不建议滥用，尽量用常规命名（如 and_gate 而不是 \\a&b）。\n\n\n# 4、关键字\n\n就是说verilog里面已经用于设计的“标识符”不能让它换工作，这就是关键字，这点和C语言没有任何区别。总之有点：咱们是兄弟，你的就是我的，我的还是我的，那种味儿……\n\n * 特点：\n   \n   * 全部是小写，比如 always 是关键字，但 ALWAYS 不是。\n   * 不能用来起名字！比如定义一个变量叫 module 会报错。\n\n * 常见关键字列表（不止这点，因为我用的框架不行）：\n   \n   关键字      作用\n   module   定义模块开头\n   input    声明输入端口\n   output   声明输出端口\n   reg      声明寄存器变量\n   wire     声明连线\n   always   描述时序/组合逻辑\n\n\n# 5、数字（如何表示0、1、不定、高阻态？）\n\n四种基本逻辑状态：\n\n状态    含义\n0     低电平、逻辑0或假\n1     高电平、逻辑1或真\nx/X   不确定或未知状态\nz/Z   高阻态\n\n * 整数表示法：<位宽>'<基数><数值>\n   \n   * 位宽：二进制位的总数（如 4'b1011 表示4位二进制数）。\n   \n   * 基数：\n     \n     基数符号   进制     合法字符\n     b/B    二进制    0,1,x,X,z,Z,?, _（下划线可忽略）\n     o/O    八进制    0-7,x,X,z,Z,?, _\n     d/D    十进制    0-9, _\n     h/H    十六进制   0-9, a-f, A-F, x,X,z,Z,?, _\n   \n   * 示例：\n     \n     8'b1010_1101    // 8位二进制，下划线提高可读性\n     16'hFF00        // 16位十六进制，等于65535\n     4'd10           // 4位十进制，实际存储为1010\n     3'b1x0          // 3位二进制，第二位未知\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 易错点：\n     \n     * 位宽不能是表达式：(2+2)'b11 ❌\n     * 负号必须在最左边：-4'd3 ✅，4'd-3 ❌\n\n * 实数（浮点数）表示法：\n   * 两种写法：\n     1. 直接写小数：3.14、0.5（注意：.5 是错的，必须写 0.5）。\n     2. 科学计数法：2.5e3（=2500）、1E-6（=0.000001）。",normalizedContent:"# verilog hdl语言基本要素\n\n\n# 1、空白符\n\n * 包括空格符（\\b）、制表符（\\t）、换行符和换页符，编译时被忽略。\n\n * 示例：\n   \n   initial begin a = 3'b100; b = 3'b010; end\n   \n   \n   1\n   \n\n * 在加入空白符之后，代码变得更加可读：\n   \n   initial \n   begin \n       a = 3'b100; \n       b = 3'b010; \n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2、注释\n\n * 作用：用来写说明文字，不会被编译，是给可爱的同学们看的笔记，防止一觉睡醒看不懂了（汇编程序员的痛）。\n\n * 两种写法：\n   \n   * 单行注释：用 //，直到行尾都算注释。\n     \n     assign a = b & c;  // 这是单行注释：计算a等于b和c的按位与\n     \n     \n     1\n     \n   \n   * 多行注释：用 /* */，中间可以跨多行。\n     \n     /* 这是多行注释：\n        可以写很长的说明，\n        比如这个模块的功能是xxx */**重要规则**：\n     \n     \n     1\n     2\n     3\n     \n   \n   * 重要规则\n     \n     * 多行注释不能嵌套！比如 /* 注释1 /* 注释2 */ 注释1 */ 会报错。\n     \n     * 但多行注释里可以包含单行注释：/* // 这是合法的 */。\n\n\n# 3、标识符（给变量/模块起名字）\n\n作为一个类c语言，verilog十分有素养，所以它的标识符命名方式以及注意点和c语言的变量几乎没有区别\n\n * 组成：字母、数字、$、_，区分大小写，首字符必须为字母或下划线。\n\n * 示例：count、_cc_g5（合法）；30count、out*（非法）。\n\n * 转义标识符：以 \\ 开头，以空白结尾，可包含任意可打印字符（如 \\a+b=c）。\n\n * 合法示例：\n   \n   counter    // 纯字母\n   _data_in   // 下划线开头\n   $signal    // 美元符号开头（较少用）\n   \n   \n   1\n   2\n   3\n   \n\n * 非法示例：\n   \n   3state     // 数字开头\n   out#put    // 包含非法字符#\n   a+b        // 包含运算符+\n   \n   \n   1\n   2\n   3\n   \n\n * 特殊技巧：转义标识符\n   \n   * 如果非要起一个奇怪的名字（比如包含空格、符号），可以用 \\ 开头，空格结尾。\n   \n   * 示例：\n     \n     \\7400      // 实际名字是 \"7400\"（通常用于和传统电路编号兼容）\n     \\a+b=c     // 实际名字是 \"a+b=c\"\n     \\***       // 实际名字是 \"***\"\n     \n     \n     1\n     2\n     3\n     \n   \n   * 但不建议滥用，尽量用常规命名（如 and_gate 而不是 \\a&b）。\n\n\n# 4、关键字\n\n就是说verilog里面已经用于设计的“标识符”不能让它换工作，这就是关键字，这点和c语言没有任何区别。总之有点：咱们是兄弟，你的就是我的，我的还是我的，那种味儿……\n\n * 特点：\n   \n   * 全部是小写，比如 always 是关键字，但 always 不是。\n   * 不能用来起名字！比如定义一个变量叫 module 会报错。\n\n * 常见关键字列表（不止这点，因为我用的框架不行）：\n   \n   关键字      作用\n   module   定义模块开头\n   input    声明输入端口\n   output   声明输出端口\n   reg      声明寄存器变量\n   wire     声明连线\n   always   描述时序/组合逻辑\n\n\n# 5、数字（如何表示0、1、不定、高阻态？）\n\n四种基本逻辑状态：\n\n状态    含义\n0     低电平、逻辑0或假\n1     高电平、逻辑1或真\nx/x   不确定或未知状态\nz/z   高阻态\n\n * 整数表示法：<位宽>'<基数><数值>\n   \n   * 位宽：二进制位的总数（如 4'b1011 表示4位二进制数）。\n   \n   * 基数：\n     \n     基数符号   进制     合法字符\n     b/b    二进制    0,1,x,x,z,z,?, _（下划线可忽略）\n     o/o    八进制    0-7,x,x,z,z,?, _\n     d/d    十进制    0-9, _\n     h/h    十六进制   0-9, a-f, a-f, x,x,z,z,?, _\n   \n   * 示例：\n     \n     8'b1010_1101    // 8位二进制，下划线提高可读性\n     16'hff00        // 16位十六进制，等于65535\n     4'd10           // 4位十进制，实际存储为1010\n     3'b1x0          // 3位二进制，第二位未知\n     \n     \n     1\n     2\n     3\n     4\n     \n   \n   * 易错点：\n     \n     * 位宽不能是表达式：(2+2)'b11 ❌\n     * 负号必须在最左边：-4'd3 ✅，4'd-3 ❌\n\n * 实数（浮点数）表示法：\n   * 两种写法：\n     1. 直接写小数：3.14、0.5（注意：.5 是错的，必须写 0.5）。\n     2. 科学计数法：2.5e3（=2500）、1e-6（=0.000001）。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"04.Verilog HDL模块",frontmatter:{title:"04.Verilog HDL模块",date:"2025-07-25T15:00:00.000Z",permalink:"/pages/Verilog_04/"},regularPath:"/01.Verilog/04.Verilog%20HDL%E7%9A%84%E6%A8%A1%E5%9D%97.html",relativePath:"01.Verilog/04.Verilog HDL的模块.md",key:"v-4cd14734",path:"/pages/Verilog_04/",headers:[{level:2,title:"1. 模块是什么？",slug:"_1-模块是什么",normalizedTitle:"1. 模块是什么？",charIndex:33},{level:2,title:"2. 模块的四大组成部分",slug:"_2-模块的四大组成部分",normalizedTitle:"2. 模块的四大组成部分",charIndex:177},{level:2,title:"3. 模块的端口定义",slug:"_3-模块的端口定义",normalizedTitle:"3. 模块的端口定义",charIndex:561},{level:2,title:"4. 模块的实例化：调用“积木”",slug:"_4-模块的实例化-调用-积木",normalizedTitle:"4. 模块的实例化：调用“积木”",charIndex:892},{level:2,title:"5. 模块的层次化设计",slug:"_5-模块的层次化设计",normalizedTitle:"5. 模块的层次化设计",charIndex:1584},{level:2,title:"6. 模块的测试：Testbench",slug:"_6-模块的测试-testbench",normalizedTitle:"6. 模块的测试：testbench",charIndex:2376},{level:3,title:"总结：模块设计要点",slug:"总结-模块设计要点",normalizedTitle:"总结：模块设计要点",charIndex:3159}],headersStr:"1. 模块是什么？ 2. 模块的四大组成部分 3. 模块的端口定义 4. 模块的实例化：调用“积木” 5. 模块的层次化设计 6. 模块的测试：Testbench 总结：模块设计要点",content:'# 模块（Module）—— Verilog的“积木块”\n\n\n# 1. 模块是什么？\n\n核心概念：模块是Verilog的基本设计单元，相当于电路中的一个功能盒子。\n\n * 现实类比：就像乐高积木，每个模块实现特定功能（如计数器、加法器），通过拼接构建复杂系统。\n\n----------------------------------------\n\n\n# 2. 模块的四大组成部分\n\n每个模块都包含以下结构（以D触发器为例）：\n\n// 1. 模块声明（定义"盒子"的名字和接口）\nmodule dff (\n  input      clk,    // 2. 端口定义：输入时钟\n  input      din,    //         输入数据\n  output reg q       //         输出数据（用reg存储）\n);\n\n  // 3. 逻辑功能描述：当时钟上升沿到来时，存储din的值\n  always @(posedge clk) begin\n    q <= din;  \n  end\n\nendmodule // 4. 模块结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 3. 模块的端口定义\n\n端口类型：\n\n类型       方向         示例\ninput    输入信号       input clk;\noutput   输出信号       output q;\ninout    双向信号（少见）   inout data_bus;\n\n端口数据类型：\n\n * 默认是 wire 型（如 input clk 等价于 input wire clk）。\n\n * 若输出需存储（如时序逻辑），需显式声明为 reg：\n   \n   output reg q;  // 输出q需要在always块中赋值\n   \n   \n   1\n   \n\n----------------------------------------\n\n\n# 4. 模块的实例化：调用“积木”\n\n场景：在顶层模块中调用子模块（如用两个D触发器构建移位寄存器）。\n\n# 方法1：顺序连接（按位置对应）\n\nmodule top;\n  wire clk, data_in;\n  wire stage1, stage2;\n  \n  // 实例化第一个D触发器（端口顺序必须与模块定义一致！）\n  dff dff1 (clk, data_in, stage1); \n  \n  // 实例化第二个D触发器\n  dff dff2 (clk, stage1, stage2);  \nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n风险：若模块端口顺序变更，所有实例化需同步修改！\n\n# 方法2：命名连接（推荐！）\n\nmodule top;\n  wire clk, data_in;\n  wire stage1, stage2;\n  \n  // 通过.端口名(信号名)明确对应关系\n  dff dff1 (\n    .clk(clk), \n    .din(data_in), \n    .q(stage1)\n  );\n  \n  dff dff2 (\n    .clk(clk), \n    .din(stage1), \n    .q(stage2)\n  );\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n优势：\n\n * 顺序无关，可读性强。\n * 避免因模块定义修改导致错误。\n\n----------------------------------------\n\n\n# 5. 模块的层次化设计\n\n关键思想：自顶向下拆分功能，逐步细化。\n\n示例：构建一个4位加法器\n\n 1. 顶层模块：定义输入输出\n    \n    module adder_4bit (\n      input  [3:0] a, b,\n      output [3:0] sum,\n      output carry\n    );\n      // 调用子模块（全加器）\n      full_adder fa0 (a[0], b[0], 1\'b0, sum[0], c1);\n      full_adder fa1 (a[1], b[1], c1,  sum[1], c2);\n      full_adder fa2 (a[2], b[2], c2,  sum[2], c3);\n      full_adder fa3 (a[3], b[3], c3,  sum[3], carry);\n    endmodule\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 2. 子模块：实现全加器\n    \n    module full_adder (\n      input  a, b, cin,\n      output sum, cout\n    );\n      assign sum  = a ^ b ^ cin;\n      assign cout = (a & b) | (cin & (a ^ b));\n    endmodule\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n----------------------------------------\n\n\n# 6. 模块的测试：Testbench\n\n作用：模拟输入信号，验证模块功能。\n\n示例：测试D触发器\n\nmodule testbench;\n  reg  clk, din;  // 测试输入（用reg驱动）\n  wire q;         // 测试输出\n  \n  // 1. 实例化被测模块\n  dff uut (.clk(clk), .din(din), .q(q));\n  \n  // 2. 生成时钟（周期=10ns）\n  initial begin\n    clk = 0;\n    forever #5 clk = ~clk; // 每5ns翻转一次\n  end\n  \n  // 3. 提供测试激励\n  initial begin\n    din = 0;\n    #10 din = 1;  // 10ns后输入变1\n    #10 din = 0;\n    #20 $finish;  // 40ns后结束仿真\n  end\n  \n  // 4. 打印结果\n  initial begin\n    $monitor("Time=%t, din=%b, q=%b", $time, din, q);\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n输出结果：\n\nTime=0, din=0, q=x  \nTime=5, din=0, q=0  // 第一个时钟上升沿  \nTime=15, din=1, q=1  // 第二个时钟上升沿  \nTime=25, din=0, q=0  // 第三个时钟上升沿  \n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 总结：模块设计要点\n\n 1. 模块声明：module 模块名(端口列表);\n 2. 端口方向：input/output/inout，输出可声明为 reg。\n 3. 实例化：推荐用命名连接（.端口名(信号名)）。\n 4. 测试方法：\n    * 用Testbench生成时钟和激励。\n    * 通过 $monitor 或波形图观察输出。\n\n常见错误：\n\n * 错误1：在 always 块中对 wire 赋值 → 应改用 reg。\n * 错误2：模块实例化时端口顺序不匹配 → 用命名连接避免。',normalizedContent:'# 模块（module）—— verilog的“积木块”\n\n\n# 1. 模块是什么？\n\n核心概念：模块是verilog的基本设计单元，相当于电路中的一个功能盒子。\n\n * 现实类比：就像乐高积木，每个模块实现特定功能（如计数器、加法器），通过拼接构建复杂系统。\n\n----------------------------------------\n\n\n# 2. 模块的四大组成部分\n\n每个模块都包含以下结构（以d触发器为例）：\n\n// 1. 模块声明（定义"盒子"的名字和接口）\nmodule dff (\n  input      clk,    // 2. 端口定义：输入时钟\n  input      din,    //         输入数据\n  output reg q       //         输出数据（用reg存储）\n);\n\n  // 3. 逻辑功能描述：当时钟上升沿到来时，存储din的值\n  always @(posedge clk) begin\n    q <= din;  \n  end\n\nendmodule // 4. 模块结束\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 3. 模块的端口定义\n\n端口类型：\n\n类型       方向         示例\ninput    输入信号       input clk;\noutput   输出信号       output q;\ninout    双向信号（少见）   inout data_bus;\n\n端口数据类型：\n\n * 默认是 wire 型（如 input clk 等价于 input wire clk）。\n\n * 若输出需存储（如时序逻辑），需显式声明为 reg：\n   \n   output reg q;  // 输出q需要在always块中赋值\n   \n   \n   1\n   \n\n----------------------------------------\n\n\n# 4. 模块的实例化：调用“积木”\n\n场景：在顶层模块中调用子模块（如用两个d触发器构建移位寄存器）。\n\n# 方法1：顺序连接（按位置对应）\n\nmodule top;\n  wire clk, data_in;\n  wire stage1, stage2;\n  \n  // 实例化第一个d触发器（端口顺序必须与模块定义一致！）\n  dff dff1 (clk, data_in, stage1); \n  \n  // 实例化第二个d触发器\n  dff dff2 (clk, stage1, stage2);  \nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n风险：若模块端口顺序变更，所有实例化需同步修改！\n\n# 方法2：命名连接（推荐！）\n\nmodule top;\n  wire clk, data_in;\n  wire stage1, stage2;\n  \n  // 通过.端口名(信号名)明确对应关系\n  dff dff1 (\n    .clk(clk), \n    .din(data_in), \n    .q(stage1)\n  );\n  \n  dff dff2 (\n    .clk(clk), \n    .din(stage1), \n    .q(stage2)\n  );\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n优势：\n\n * 顺序无关，可读性强。\n * 避免因模块定义修改导致错误。\n\n----------------------------------------\n\n\n# 5. 模块的层次化设计\n\n关键思想：自顶向下拆分功能，逐步细化。\n\n示例：构建一个4位加法器\n\n 1. 顶层模块：定义输入输出\n    \n    module adder_4bit (\n      input  [3:0] a, b,\n      output [3:0] sum,\n      output carry\n    );\n      // 调用子模块（全加器）\n      full_adder fa0 (a[0], b[0], 1\'b0, sum[0], c1);\n      full_adder fa1 (a[1], b[1], c1,  sum[1], c2);\n      full_adder fa2 (a[2], b[2], c2,  sum[2], c3);\n      full_adder fa3 (a[3], b[3], c3,  sum[3], carry);\n    endmodule\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 2. 子模块：实现全加器\n    \n    module full_adder (\n      input  a, b, cin,\n      output sum, cout\n    );\n      assign sum  = a ^ b ^ cin;\n      assign cout = (a & b) | (cin & (a ^ b));\n    endmodule\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n----------------------------------------\n\n\n# 6. 模块的测试：testbench\n\n作用：模拟输入信号，验证模块功能。\n\n示例：测试d触发器\n\nmodule testbench;\n  reg  clk, din;  // 测试输入（用reg驱动）\n  wire q;         // 测试输出\n  \n  // 1. 实例化被测模块\n  dff uut (.clk(clk), .din(din), .q(q));\n  \n  // 2. 生成时钟（周期=10ns）\n  initial begin\n    clk = 0;\n    forever #5 clk = ~clk; // 每5ns翻转一次\n  end\n  \n  // 3. 提供测试激励\n  initial begin\n    din = 0;\n    #10 din = 1;  // 10ns后输入变1\n    #10 din = 0;\n    #20 $finish;  // 40ns后结束仿真\n  end\n  \n  // 4. 打印结果\n  initial begin\n    $monitor("time=%t, din=%b, q=%b", $time, din, q);\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n输出结果：\n\ntime=0, din=0, q=x  \ntime=5, din=0, q=0  // 第一个时钟上升沿  \ntime=15, din=1, q=1  // 第二个时钟上升沿  \ntime=25, din=0, q=0  // 第三个时钟上升沿  \n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 总结：模块设计要点\n\n 1. 模块声明：module 模块名(端口列表);\n 2. 端口方向：input/output/inout，输出可声明为 reg。\n 3. 实例化：推荐用命名连接（.端口名(信号名)）。\n 4. 测试方法：\n    * 用testbench生成时钟和激励。\n    * 通过 $monitor 或波形图观察输出。\n\n常见错误：\n\n * 错误1：在 always 块中对 wire 赋值 → 应改用 reg。\n * 错误2：模块实例化时端口顺序不匹配 → 用命名连接避免。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"05.Verilog HDL程序设计和描述方式",frontmatter:{title:"05.Verilog HDL程序设计和描述方式",date:"2025-08-02T16:00:49.000Z",permalink:"/pages/Verilog_05/"},regularPath:"/01.Verilog/05.VerilogHDL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%8F%8F%E8%BF%B0%E6%96%B9%E5%BC%8F.html",relativePath:"01.Verilog/05.VerilogHDL程序设计和描述方式.md",key:"v-2e6c17e3",path:"/pages/Verilog_05/",headers:[{level:2,title:"一、数据流建模",slug:"一、数据流建模",normalizedTitle:"一、数据流建模",charIndex:22},{level:2,title:"二、行为级建模",slug:"二、行为级建模",normalizedTitle:"二、行为级建模",charIndex:2005},{level:2,title:"三、 结构化建模是啥？",slug:"三、-结构化建模是啥",normalizedTitle:"三、 结构化建模是啥？",charIndex:4310},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6336}],headersStr:"一、数据流建模 二、行为级建模 三、 结构化建模是啥？ 总结",content:'# Verilog HDL程序设计\n\n\n# 一、数据流建模\n\n# 1. 数据流建模是啥？\n\n核心思想：用“电线连接”的方式描述电路，直接表示信号如何从输入流动到输出。 类比：就像画电路图，用导线把各个元件连起来，比如 A和B接个与门，输出Y。\n\n# 2. 核心工具：连续赋值语句（assign）\n\n作用：告诉Verilog“这根线（wire）的值等于某个表达式的结果”。\n\n# 2.1 显式连续赋值\n\n * 语法：\n   \n   wire Y;          // 先声明线网\n   assign Y = A & B; // 再用assign赋值\n   \n   \n   1\n   2\n   \n\n * 带延迟的例子：\n   \n   assign #3 Y = A & B; // 计算A&B后，延迟3个单位时间再赋值给Y\n   \n   \n   1\n   \n\n# 2.2 隐式连续赋值\n\n * 语法（声明时直接赋值）：\n   \n   wire Y = A & B;      // 声明时直接赋值\n   wire #(2,3,4) Z = X; // 带延迟（上升2，下降3，关断4）\n   \n   \n   1\n   2\n   \n\n * 带驱动强度的例子：\n   \n   wire (strong1, weak0) Y = A | B; // 输出1时强驱动，0时弱驱动\n   \n   \n   1\n   \n\n----------------------------------------\n\n# 3. 连续赋值的特点\n\n 1. 目标必须是wire：\n    \n    * 不能给reg类型赋值！\n    \n    * 示例：\n      \n      wire Y;    // 正确\n      reg Y;     // 错误！assign不能用于reg\n      assign Y = A;\n      \n      \n      1\n      2\n      3\n      \n\n 2. 实时更新：\n    \n    * 只要右边的信号（如A或B）变化，立刻重新计算并赋值。\n    \n    * 示例：\n      \n      assign Y = A + B; // A或B一变，Y立刻更新\n      \n      \n      1\n      \n\n 3. 并行执行：\n    \n    * 所有assign语句同时工作，和代码顺序无关。\n    \n    * 示例：\n      \n      assign Y = A & B;\n      assign Z = C | D; // 这两行并行执行\n      \n      \n      1\n      2\n      \n\n 4. 延迟是“惯性延时”：\n    \n    * 短于延迟的脉冲会被过滤掉。\n    \n    * 示例：\n      \n      assign #5 Y = A; // 如果A的脉冲宽度<5，Y不会变化\n      \n      \n      1\n      \n\n----------------------------------------\n\n# 4. 实际代码示例\n\n# 4.1 显式赋值（带延迟）\n\nmodule example1(input [3:0] A, B, output [3:0] Y);\n  wire [3:0] Y;\n  assign #(3,2,4) Y = A & B; // 上升延迟3，下降2，关断4\nendmodule\n\n\n1\n2\n3\n4\n\n\n# 4.2 隐式赋值（带驱动强度）\n\nmodule example2(input [3:0] M, N, output [3:0] W);\n  wire (strong0, weak1) [3:0] W = (M ^ N) & (M | N);\nendmodule\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 5. 常见问题\n\n 1. 什么时候用连续赋值？\n    \n    * 描述组合逻辑（如与门、加法器、多路选择器）。\n    * 不适合时序逻辑（如触发器要用always块）。\n\n 2. 忘记写assign会怎样？\n    \n    * 直接写 wire Y = A; 是隐式赋值，合法。\n    \n    * 但分开写时漏掉assign会报错：\n      \n      wire Y;\n      Y = A; // 错误！缺少assign\n      \n      \n      1\n      2\n      \n\n 3. 能用在always块里吗？\n    \n    * 不能！ assign是并行语句，always是过程块，两者不兼容。\n\n\n# 二、行为级建模\n\n# 1. 行为级建模是啥？\n\n核心思想：用"软件思维"描述硬件行为，重点关注电路做什么（功能），而不是具体怎么连线。 类比：就像写剧本告诉演员怎么演，而不是设计舞台的每个螺丝钉。\n\n# 2. 核心工具：过程块（always/initial）\n\n# 2.1 initial块 - 一次性剧本\n\n * 特点：只执行一次，主要用于仿真初始化。\n\n * 示例：\n   \n   initial begin\n     clk = 0;      // 初始时钟为0\n     reset = 1;    // 复位信号置1\n     #50 reset = 0;// 50单位时间后取消复位\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# 2.2 always块 - 循环剧本\n\n * 特点：不断重复执行，是硬件行为的核心描述方式。\n\n * 敏感列表：决定何时触发：\n   \n   // 组合逻辑：输入变化就执行\n   always @(a or b or sel) \n   \n   // 时序逻辑：时钟边沿触发\n   always @(posedge clk)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# 3. 过程赋值：硬件界的"变量赋值"\n\n# 3.1 阻塞赋值（=） - 顺序执行\n\n * 特点：像普通编程语言，一步完成计算和赋值。\n\n * 适用场景：组合逻辑设计。\n\n * 示例：\n   \n   always @(a or b) begin\n     temp = a & b;  // 立即计算并赋值\n     y = temp | c;  // 使用更新后的temp\n   end\n   \n   \n   1\n   2\n   3\n   4\n   \n\n# 3.2 非阻塞赋值（<=） - 并行执行\n\n * 特点：先计算右边，等时间步结束才统一赋值。\n\n * 适用场景：时序逻辑设计（触发器）。\n\n * 示例：\n   \n   always @(posedge clk) begin\n     q1 <= d;   // 这三个赋值\n     q2 <= q1;  // 是同时进行的\n     q3 <= q2;  // 构成移位寄存器\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n----------------------------------------\n\n# 4. 流程控制：硬件版的"if-else"\n\n# 4.1 if-else语句\n\n * 特点：带优先级的选择结构。\n\n * 示例：\n   \n   always @(sel or a or b) begin\n     if (sel == 1\'b1)\n       y = a;    // sel为1选a\n     else \n       y = b;    // 否则选b\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n# 4.2 case语句\n\n * 特点：多路分支，无优先级。\n\n * 特殊形式：\n   \n   * casez：忽略z(高阻)和?（无关位）\n   * casex：忽略x(未知)、z和?\n\n * 示例（BCD译码器）：\n   \n   case(num)\n     4\'d0: seg = 7\'b1111110;  // 显示数字0\n     4\'d1: seg = 7\'b0110000;  // 显示数字1\n     default: seg = 7\'bx;     // 其他情况输出未知\n   endcase\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n----------------------------------------\n\n# 5. 循环语句：硬件也能"循环"？\n\n# 5.1 for循环 - 可综合的循环\n\n * 特点：编译时会展开为硬件结构。\n\n * 示例（位反转）：\n   \n   for(i=0; i<8; i=i+1)\n     rev[7-i] = data[i];  // 生成8个并行的连线\n   \n   \n   1\n   2\n   \n\n# 5.2 其他循环（仿真用）\n\n * forever：无限循环（如生成时钟）\n   \n   initial forever #10 clk = ~clk;  // 每10ns翻转\n   \n   \n   1\n   \n\n * repeat：固定次数循环\n   \n   repeat(5) @(posedge clk);  // 等待5个时钟周期\n   \n   \n   1\n   \n\n----------------------------------------\n\n# 6. 关键注意事项\n\n 1. reg不一定生成寄存器：\n    \n    * 在always块中用=赋值可能生成组合逻辑\n    * 只有时钟触发的<=才会生成触发器\n\n 2. 敏感列表要完整：\n    \n    // 组合逻辑必须列出所有输入！\n    always @(a or b or sel) // 漏掉sel会导致bug\n    \n    \n    1\n    2\n    \n\n 3. 避免锁存器：\n    \n    * if缺少else分支\n    * case缺少default\n    * 解决办法：确保所有路径都有赋值\n\n\n# 三、 结构化建模是啥？\n\n核心思想：像搭积木一样用现成的模块/门电路来构建系统，直接对应硬件层次结构，说白了就是面向对象设计。\n\n类比：\n\n * 模块级：用现成的CPU、内存等大组件拼电脑\n * 门级：用与门、或门等小零件搭电路\n * 开关级：用晶体管构建最基础的逻辑门\n\n# 2. 模块级建模：调用现成模块\n\n# 2.1 基本调用方式\n\n// 定义子模块（积木）\nmodule AND_gate(input a, b, output y);\n  assign y = a & b;\nendmodule\n\n// 顶层模块（拼积木）\nmodule TOP(input x1, x2, output z);\n  wire w;\n  // 实例化子模块（两种方式）\n  AND_gate U1(x1, x2, w);  // 方式1：按顺序连接\n  AND_gate U2(.a(w), .b(x1), .y(z)); // 方式2：按名称连接（推荐！）\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.2 参数化模块\n\nmodule #(parameter WIDTH=4) \n  Adder(input [WIDTH-1:0] a,b, output [WIDTH:0] sum);\n  assign sum = a + b;\nendmodule\n\n// 调用时修改参数\nAdder #(8) U3(a_8bit, b_8bit, sum_8bit); // 8位加法器\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 门级建模：调用基本逻辑门\n\n# 3.1 Verilog内置门类型\n\n门类型     关键字      示例\n与门      and      and U1(out, a, b);\n或门      or       or U2(out, a, b, c);\n非门      not      not U3(out, in);\n三态缓冲器   bufif1   bufif1 U4(out, in, ctrl);\n\n# 3.2 实际案例：2-4译码器\n\nmodule decoder(\n  input [1:0] sel,\n  input en,\n  output [3:0] y\n);\n  wire not_sel0, not_sel1;\n  \n  // 基本门调用\n  not U1(not_sel0, sel[0]);\n  not U2(not_sel1, sel[1]);\n  \n  nand U3(y[0], en, not_sel1, not_sel0);\n  nand U4(y[1], en, not_sel1, sel[0]);\n  nand U5(y[2], en, sel[1], not_sel0);\n  nand U6(y[3], en, sel[1], sel[0]);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n# 4. 开关级建模：晶体管级描述\n\n# 4.1 MOS开关类型\n\n类型     关键字    功能\nNMOS   nmos   控制=1时导通\nPMOS   pmos   控制=0时导通\nCMOS   cmos   双控制（nctrl和pctrl互补）\n双向开关   tran   两端直接连通\n\n# 4.2 CMOS与非门实现\n\nmodule NAND(\n  input a, b,\n  output y\n);\n  supply1 VDD;  // 电源\n  supply0 GND;  // 地\n  \n  pmos P1(y, VDD, a);\n  pmos P2(y, VDD, b);\n  nmos N1(y, mid, a);\n  nmos N2(mid, GND, b);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5. 关键注意事项\n\n 1. 端口连接陷阱：\n    \n    // 危险！容易接反\n    Sub_module U1(a, b);  \n    // 安全推荐\n    Sub_module U1(.port_a(a), .port_b(b));\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 参数传递优先级：\n    \n    * #(参数)直接传递 > defparam语句\n\n 3. 开关级设计限制：\n    \n    * 通常只用于ASIC设计\n    * FPGA综合经常忽略开关级细节\n\n----------------------------------------\n\n\n# 总结\n\n * 核心价值：\n   * 模块化设计：提高代码复用性\n   * 贴近物理实现：适合性能优化\n   * 混合使用：高层用行为级，底层用结构化\n * 典型应用：\n   * 数字IP核集成（如调用现成的存储器、PLL）\n   * 标准单元库开发\n   * 晶体管级电路设计',normalizedContent:'# verilog hdl程序设计\n\n\n# 一、数据流建模\n\n# 1. 数据流建模是啥？\n\n核心思想：用“电线连接”的方式描述电路，直接表示信号如何从输入流动到输出。 类比：就像画电路图，用导线把各个元件连起来，比如 a和b接个与门，输出y。\n\n# 2. 核心工具：连续赋值语句（assign）\n\n作用：告诉verilog“这根线（wire）的值等于某个表达式的结果”。\n\n# 2.1 显式连续赋值\n\n * 语法：\n   \n   wire y;          // 先声明线网\n   assign y = a & b; // 再用assign赋值\n   \n   \n   1\n   2\n   \n\n * 带延迟的例子：\n   \n   assign #3 y = a & b; // 计算a&b后，延迟3个单位时间再赋值给y\n   \n   \n   1\n   \n\n# 2.2 隐式连续赋值\n\n * 语法（声明时直接赋值）：\n   \n   wire y = a & b;      // 声明时直接赋值\n   wire #(2,3,4) z = x; // 带延迟（上升2，下降3，关断4）\n   \n   \n   1\n   2\n   \n\n * 带驱动强度的例子：\n   \n   wire (strong1, weak0) y = a | b; // 输出1时强驱动，0时弱驱动\n   \n   \n   1\n   \n\n----------------------------------------\n\n# 3. 连续赋值的特点\n\n 1. 目标必须是wire：\n    \n    * 不能给reg类型赋值！\n    \n    * 示例：\n      \n      wire y;    // 正确\n      reg y;     // 错误！assign不能用于reg\n      assign y = a;\n      \n      \n      1\n      2\n      3\n      \n\n 2. 实时更新：\n    \n    * 只要右边的信号（如a或b）变化，立刻重新计算并赋值。\n    \n    * 示例：\n      \n      assign y = a + b; // a或b一变，y立刻更新\n      \n      \n      1\n      \n\n 3. 并行执行：\n    \n    * 所有assign语句同时工作，和代码顺序无关。\n    \n    * 示例：\n      \n      assign y = a & b;\n      assign z = c | d; // 这两行并行执行\n      \n      \n      1\n      2\n      \n\n 4. 延迟是“惯性延时”：\n    \n    * 短于延迟的脉冲会被过滤掉。\n    \n    * 示例：\n      \n      assign #5 y = a; // 如果a的脉冲宽度<5，y不会变化\n      \n      \n      1\n      \n\n----------------------------------------\n\n# 4. 实际代码示例\n\n# 4.1 显式赋值（带延迟）\n\nmodule example1(input [3:0] a, b, output [3:0] y);\n  wire [3:0] y;\n  assign #(3,2,4) y = a & b; // 上升延迟3，下降2，关断4\nendmodule\n\n\n1\n2\n3\n4\n\n\n# 4.2 隐式赋值（带驱动强度）\n\nmodule example2(input [3:0] m, n, output [3:0] w);\n  wire (strong0, weak1) [3:0] w = (m ^ n) & (m | n);\nendmodule\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# 5. 常见问题\n\n 1. 什么时候用连续赋值？\n    \n    * 描述组合逻辑（如与门、加法器、多路选择器）。\n    * 不适合时序逻辑（如触发器要用always块）。\n\n 2. 忘记写assign会怎样？\n    \n    * 直接写 wire y = a; 是隐式赋值，合法。\n    \n    * 但分开写时漏掉assign会报错：\n      \n      wire y;\n      y = a; // 错误！缺少assign\n      \n      \n      1\n      2\n      \n\n 3. 能用在always块里吗？\n    \n    * 不能！ assign是并行语句，always是过程块，两者不兼容。\n\n\n# 二、行为级建模\n\n# 1. 行为级建模是啥？\n\n核心思想：用"软件思维"描述硬件行为，重点关注电路做什么（功能），而不是具体怎么连线。 类比：就像写剧本告诉演员怎么演，而不是设计舞台的每个螺丝钉。\n\n# 2. 核心工具：过程块（always/initial）\n\n# 2.1 initial块 - 一次性剧本\n\n * 特点：只执行一次，主要用于仿真初始化。\n\n * 示例：\n   \n   initial begin\n     clk = 0;      // 初始时钟为0\n     reset = 1;    // 复位信号置1\n     #50 reset = 0;// 50单位时间后取消复位\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# 2.2 always块 - 循环剧本\n\n * 特点：不断重复执行，是硬件行为的核心描述方式。\n\n * 敏感列表：决定何时触发：\n   \n   // 组合逻辑：输入变化就执行\n   always @(a or b or sel) \n   \n   // 时序逻辑：时钟边沿触发\n   always @(posedge clk)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n# 3. 过程赋值：硬件界的"变量赋值"\n\n# 3.1 阻塞赋值（=） - 顺序执行\n\n * 特点：像普通编程语言，一步完成计算和赋值。\n\n * 适用场景：组合逻辑设计。\n\n * 示例：\n   \n   always @(a or b) begin\n     temp = a & b;  // 立即计算并赋值\n     y = temp | c;  // 使用更新后的temp\n   end\n   \n   \n   1\n   2\n   3\n   4\n   \n\n# 3.2 非阻塞赋值（<=） - 并行执行\n\n * 特点：先计算右边，等时间步结束才统一赋值。\n\n * 适用场景：时序逻辑设计（触发器）。\n\n * 示例：\n   \n   always @(posedge clk) begin\n     q1 <= d;   // 这三个赋值\n     q2 <= q1;  // 是同时进行的\n     q3 <= q2;  // 构成移位寄存器\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n----------------------------------------\n\n# 4. 流程控制：硬件版的"if-else"\n\n# 4.1 if-else语句\n\n * 特点：带优先级的选择结构。\n\n * 示例：\n   \n   always @(sel or a or b) begin\n     if (sel == 1\'b1)\n       y = a;    // sel为1选a\n     else \n       y = b;    // 否则选b\n   end\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n# 4.2 case语句\n\n * 特点：多路分支，无优先级。\n\n * 特殊形式：\n   \n   * casez：忽略z(高阻)和?（无关位）\n   * casex：忽略x(未知)、z和?\n\n * 示例（bcd译码器）：\n   \n   case(num)\n     4\'d0: seg = 7\'b1111110;  // 显示数字0\n     4\'d1: seg = 7\'b0110000;  // 显示数字1\n     default: seg = 7\'bx;     // 其他情况输出未知\n   endcase\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n----------------------------------------\n\n# 5. 循环语句：硬件也能"循环"？\n\n# 5.1 for循环 - 可综合的循环\n\n * 特点：编译时会展开为硬件结构。\n\n * 示例（位反转）：\n   \n   for(i=0; i<8; i=i+1)\n     rev[7-i] = data[i];  // 生成8个并行的连线\n   \n   \n   1\n   2\n   \n\n# 5.2 其他循环（仿真用）\n\n * forever：无限循环（如生成时钟）\n   \n   initial forever #10 clk = ~clk;  // 每10ns翻转\n   \n   \n   1\n   \n\n * repeat：固定次数循环\n   \n   repeat(5) @(posedge clk);  // 等待5个时钟周期\n   \n   \n   1\n   \n\n----------------------------------------\n\n# 6. 关键注意事项\n\n 1. reg不一定生成寄存器：\n    \n    * 在always块中用=赋值可能生成组合逻辑\n    * 只有时钟触发的<=才会生成触发器\n\n 2. 敏感列表要完整：\n    \n    // 组合逻辑必须列出所有输入！\n    always @(a or b or sel) // 漏掉sel会导致bug\n    \n    \n    1\n    2\n    \n\n 3. 避免锁存器：\n    \n    * if缺少else分支\n    * case缺少default\n    * 解决办法：确保所有路径都有赋值\n\n\n# 三、 结构化建模是啥？\n\n核心思想：像搭积木一样用现成的模块/门电路来构建系统，直接对应硬件层次结构，说白了就是面向对象设计。\n\n类比：\n\n * 模块级：用现成的cpu、内存等大组件拼电脑\n * 门级：用与门、或门等小零件搭电路\n * 开关级：用晶体管构建最基础的逻辑门\n\n# 2. 模块级建模：调用现成模块\n\n# 2.1 基本调用方式\n\n// 定义子模块（积木）\nmodule and_gate(input a, b, output y);\n  assign y = a & b;\nendmodule\n\n// 顶层模块（拼积木）\nmodule top(input x1, x2, output z);\n  wire w;\n  // 实例化子模块（两种方式）\n  and_gate u1(x1, x2, w);  // 方式1：按顺序连接\n  and_gate u2(.a(w), .b(x1), .y(z)); // 方式2：按名称连接（推荐！）\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.2 参数化模块\n\nmodule #(parameter width=4) \n  adder(input [width-1:0] a,b, output [width:0] sum);\n  assign sum = a + b;\nendmodule\n\n// 调用时修改参数\nadder #(8) u3(a_8bit, b_8bit, sum_8bit); // 8位加法器\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 3. 门级建模：调用基本逻辑门\n\n# 3.1 verilog内置门类型\n\n门类型     关键字      示例\n与门      and      and u1(out, a, b);\n或门      or       or u2(out, a, b, c);\n非门      not      not u3(out, in);\n三态缓冲器   bufif1   bufif1 u4(out, in, ctrl);\n\n# 3.2 实际案例：2-4译码器\n\nmodule decoder(\n  input [1:0] sel,\n  input en,\n  output [3:0] y\n);\n  wire not_sel0, not_sel1;\n  \n  // 基本门调用\n  not u1(not_sel0, sel[0]);\n  not u2(not_sel1, sel[1]);\n  \n  nand u3(y[0], en, not_sel1, not_sel0);\n  nand u4(y[1], en, not_sel1, sel[0]);\n  nand u5(y[2], en, sel[1], not_sel0);\n  nand u6(y[3], en, sel[1], sel[0]);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n# 4. 开关级建模：晶体管级描述\n\n# 4.1 mos开关类型\n\n类型     关键字    功能\nnmos   nmos   控制=1时导通\npmos   pmos   控制=0时导通\ncmos   cmos   双控制（nctrl和pctrl互补）\n双向开关   tran   两端直接连通\n\n# 4.2 cmos与非门实现\n\nmodule nand(\n  input a, b,\n  output y\n);\n  supply1 vdd;  // 电源\n  supply0 gnd;  // 地\n  \n  pmos p1(y, vdd, a);\n  pmos p2(y, vdd, b);\n  nmos n1(y, mid, a);\n  nmos n2(mid, gnd, b);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5. 关键注意事项\n\n 1. 端口连接陷阱：\n    \n    // 危险！容易接反\n    sub_module u1(a, b);  \n    // 安全推荐\n    sub_module u1(.port_a(a), .port_b(b));\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 参数传递优先级：\n    \n    * #(参数)直接传递 > defparam语句\n\n 3. 开关级设计限制：\n    \n    * 通常只用于asic设计\n    * fpga综合经常忽略开关级细节\n\n----------------------------------------\n\n\n# 总结\n\n * 核心价值：\n   * 模块化设计：提高代码复用性\n   * 贴近物理实现：适合性能优化\n   * 混合使用：高层用行为级，底层用结构化\n * 典型应用：\n   * 数字ip核集成（如调用现成的存储器、pll）\n   * 标准单元库开发\n   * 晶体管级电路设计',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"06.Verilog HDL程序设计思想概览",frontmatter:{title:"06.Verilog HDL程序设计思想概览",date:"2025-08-05T12:30:00.000Z",permalink:"/pages/Verilog_06/"},regularPath:"/01.Verilog/06.Verilog%20HDL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%A6%82%E8%A7%88.html",relativePath:"01.Verilog/06.Verilog HDL程序设计思想概览.md",key:"v-1d3661da",path:"/pages/Verilog_06/",headers:[{level:2,title:"1. 可综合设计的基本原则",slug:"_1-可综合设计的基本原则",normalizedTitle:"1. 可综合设计的基本原则",charIndex:286},{level:2,title:"2. 示例对比：模256计数器",slug:"_2-示例对比-模256计数器",normalizedTitle:"2. 示例对比：模256计数器",charIndex:505},{level:3,title:"(a) 可综合的实现方式",slug:"a-可综合的实现方式",normalizedTitle:"(a) 可综合的实现方式",charIndex:525},{level:3,title:"(b) 常见的错误描述",slug:"b-常见的错误描述",normalizedTitle:"(b) 常见的错误描述",charIndex:954},{level:2,title:"3. 设计多样性：多路选择器（MUX）的实现",slug:"_3-设计多样性-多路选择器-mux-的实现",normalizedTitle:"3. 设计多样性：多路选择器（mux）的实现",charIndex:1531},{level:3,title:"(1) 真值表形式（行为描述）",slug:"_1-真值表形式-行为描述",normalizedTitle:"(1) 真值表形式（行为描述）",charIndex:1599},{level:3,title:"(2) 逻辑表达式形式（数据流描述）",slug:"_2-逻辑表达式形式-数据流描述",normalizedTitle:"(2) 逻辑表达式形式（数据流描述）",charIndex:1966},{level:3,title:"(3) 结构性描述（门级建模）",slug:"_3-结构性描述-门级建模",normalizedTitle:"(3) 结构性描述（门级建模）",charIndex:2321},{level:2,title:"4. 关键总结",slug:"_4-关键总结",normalizedTitle:"4. 关键总结",charIndex:2788},{level:2,title:"5. 延伸思考",slug:"_5-延伸思考",normalizedTitle:"5. 延伸思考",charIndex:3087}],headersStr:"1. 可综合设计的基本原则 2. 示例对比：模256计数器 (a) 可综合的实现方式 (b) 常见的错误描述 3. 设计多样性：多路选择器（MUX）的实现 (1) 真值表形式（行为描述） (2) 逻辑表达式形式（数据流描述） (3) 结构性描述（门级建模） 4. 关键总结 5. 延伸思考",content:"# Verilog HDL 设计思想与可综合特性：从计数器到多路选择器\n\n在数字电路设计中，Verilog HDL 是一种强大的硬件描述语言，能够以多种方式描述电路功能。然而，并非所有代码都能被综合工具正确转换为实际硬件电路。本文将围绕 Verilog 的设计思想和可综合特性，通过典型示例（如计数器、多路选择器）对比 可综合代码 和 常见错误，帮助读者掌握高效、可靠的 Verilog 设计方法。\n\n下面出现的代码在初学阶段没必要完全掌握，读者只需了解一下基本的代码架构即可。\n\n----------------------------------------\n\n\n# 1. 可综合设计的基本原则\n\n可综合的 Verilog 代码需满足：\n\n * 明确硬件映射：代码应直接对应实际的逻辑门、触发器或组合电路。\n * 避免不可综合语法：如 for 循环的滥用、initial 块（部分场景不支持）、复杂的动态操作。\n * 时序控制清晰：同步设计推荐使用 always @(posedge clk)，避免混合边沿触发。\n\n----------------------------------------\n\n\n# 2. 示例对比：模256计数器\n\n\n# (a) 可综合的实现方式\n\nmodule counter (count, clk, reset);\n  output [7:0] count;\n  input clk, reset;\n  reg [7:0] count;\n\n  always @(posedge clk) begin\n    if (!reset) \n      count <= 0;          // 同步复位\n    else if (count == 8'b11111111) \n      count <= 0;          // 计数到255归零\n    else \n      count <= count + 1;  // 正常计数\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n特点：\n\n * 仅使用时钟上升沿触发，明确时序逻辑。\n * 复位和计数逻辑清晰，综合工具可识别为标准的计数器结构。\n\n\n# (b) 常见的错误描述\n\nmodule counter (count, clk, reset);\n  output [7:0] count;\n  input clk, reset;\n  reg [7:0] count;\n  integer i;\n\n  always @(posedge clk, reset) begin  // 混合边沿触发（错误！）\n    if (!reset) \n      count <= 0;\n    else \n      for (i = 0; i <= 255; i = i + 1)  // for循环不可综合为硬件\n        count <= count + 1;             // 非阻塞赋值在循环中无效\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n问题分析：\n\n 1. 敏感列表错误：always @(posedge clk, reset) 混合了时钟和复位信号边沿，可能导致综合结果不符合预期。\n 2. 不可综合的 for 循环：综合工具无法将其展开为并行硬件逻辑。\n 3. 非阻塞赋值在循环中无效：实际硬件无法实现循环内的逐步更新。\n\n----------------------------------------\n\n\n# 3. 设计多样性：多路选择器（MUX）的实现\n\nVerilog 支持多种风格描述同一功能，以下是三种常见的 MUX 实现方式：\n\n\n# (1) 真值表形式（行为描述）\n\nmodule MUX (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  reg out;\n\n  always @(data or sel) begin\n    case (sel)\n      2'b00: out <= data[0];\n      2'b01: out <= data[1];\n      2'b10: out <= data[2];\n      2'b11: out <= data[3];\n    endcase\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优点：直观，类似软件编程，适合复杂条件逻辑。\n\n\n# (2) 逻辑表达式形式（数据流描述）\n\nmodule MUX (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  \n  assign out = (~sel[1] & ~sel[0] & data[0]) |\n               (~sel[1] &  sel[0] & data[1]) |\n               ( sel[1] & ~sel[0] & data[2]) |\n               ( sel[1] &  sel[0] & data[3]);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n优点：直接映射到与或门结构，适合优化组合逻辑。\n\n\n# (3) 结构性描述（门级建模）\n\nmodule MUX (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  wire w1, w2, w3, w4;\n\n  not U1 (w1, sel[1]);\n  not U2 (w2, sel[0]);\n  and U3 (w3, w1, w2, data[0]);\n  and U4 (w4, w1, sel[0], data[1]);\n  and U5 (w5, sel[1], w2, data[2]);\n  and U6 (w6, sel[1], sel[0], data[3]);\n  or  U7 (out, w3, w4, w5, w6);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优点：显式定义门级连接，适合对底层硬件有严格要求的场景。\n\n----------------------------------------\n\n\n# 4. 关键总结\n\n 1. 可综合代码：\n    * 使用明确的时序控制（如 always @(posedge clk)）。\n    * 避免不可综合语法（如 for 循环、混合边沿触发）。\n 2. 设计风格选择：\n    * 行为描述（case/if-else）：适合复杂状态机或算法。\n    * 数据流描述（assign）：适合组合逻辑优化。\n    * 结构性描述：适合门级精确控制。\n 3. 验证工具：\n    * 使用 Synplify 等综合工具检查代码是否可综合，并观察生成的 RTL 图。\n\n----------------------------------------\n\n\n# 5. 延伸思考\n\n * 如果设计一个 可变模计数器（如模 N），如何保证可综合性？ 提示：使用参数化设计（parameter）和比较器逻辑，而非动态循环。\n\n通过对比正确与错误的代码示例，我们可以更深刻地理解 Verilog 的可综合设计思想。在实际项目中，选择合适的设计风格并严格遵循硬件映射规则，是保证电路可靠性和效率的关键！",normalizedContent:"# verilog hdl 设计思想与可综合特性：从计数器到多路选择器\n\n在数字电路设计中，verilog hdl 是一种强大的硬件描述语言，能够以多种方式描述电路功能。然而，并非所有代码都能被综合工具正确转换为实际硬件电路。本文将围绕 verilog 的设计思想和可综合特性，通过典型示例（如计数器、多路选择器）对比 可综合代码 和 常见错误，帮助读者掌握高效、可靠的 verilog 设计方法。\n\n下面出现的代码在初学阶段没必要完全掌握，读者只需了解一下基本的代码架构即可。\n\n----------------------------------------\n\n\n# 1. 可综合设计的基本原则\n\n可综合的 verilog 代码需满足：\n\n * 明确硬件映射：代码应直接对应实际的逻辑门、触发器或组合电路。\n * 避免不可综合语法：如 for 循环的滥用、initial 块（部分场景不支持）、复杂的动态操作。\n * 时序控制清晰：同步设计推荐使用 always @(posedge clk)，避免混合边沿触发。\n\n----------------------------------------\n\n\n# 2. 示例对比：模256计数器\n\n\n# (a) 可综合的实现方式\n\nmodule counter (count, clk, reset);\n  output [7:0] count;\n  input clk, reset;\n  reg [7:0] count;\n\n  always @(posedge clk) begin\n    if (!reset) \n      count <= 0;          // 同步复位\n    else if (count == 8'b11111111) \n      count <= 0;          // 计数到255归零\n    else \n      count <= count + 1;  // 正常计数\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n特点：\n\n * 仅使用时钟上升沿触发，明确时序逻辑。\n * 复位和计数逻辑清晰，综合工具可识别为标准的计数器结构。\n\n\n# (b) 常见的错误描述\n\nmodule counter (count, clk, reset);\n  output [7:0] count;\n  input clk, reset;\n  reg [7:0] count;\n  integer i;\n\n  always @(posedge clk, reset) begin  // 混合边沿触发（错误！）\n    if (!reset) \n      count <= 0;\n    else \n      for (i = 0; i <= 255; i = i + 1)  // for循环不可综合为硬件\n        count <= count + 1;             // 非阻塞赋值在循环中无效\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n问题分析：\n\n 1. 敏感列表错误：always @(posedge clk, reset) 混合了时钟和复位信号边沿，可能导致综合结果不符合预期。\n 2. 不可综合的 for 循环：综合工具无法将其展开为并行硬件逻辑。\n 3. 非阻塞赋值在循环中无效：实际硬件无法实现循环内的逐步更新。\n\n----------------------------------------\n\n\n# 3. 设计多样性：多路选择器（mux）的实现\n\nverilog 支持多种风格描述同一功能，以下是三种常见的 mux 实现方式：\n\n\n# (1) 真值表形式（行为描述）\n\nmodule mux (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  reg out;\n\n  always @(data or sel) begin\n    case (sel)\n      2'b00: out <= data[0];\n      2'b01: out <= data[1];\n      2'b10: out <= data[2];\n      2'b11: out <= data[3];\n    endcase\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优点：直观，类似软件编程，适合复杂条件逻辑。\n\n\n# (2) 逻辑表达式形式（数据流描述）\n\nmodule mux (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  \n  assign out = (~sel[1] & ~sel[0] & data[0]) |\n               (~sel[1] &  sel[0] & data[1]) |\n               ( sel[1] & ~sel[0] & data[2]) |\n               ( sel[1] &  sel[0] & data[3]);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n优点：直接映射到与或门结构，适合优化组合逻辑。\n\n\n# (3) 结构性描述（门级建模）\n\nmodule mux (out, data, sel);\n  output out;\n  input [3:0] data;\n  input [1:0] sel;\n  wire w1, w2, w3, w4;\n\n  not u1 (w1, sel[1]);\n  not u2 (w2, sel[0]);\n  and u3 (w3, w1, w2, data[0]);\n  and u4 (w4, w1, sel[0], data[1]);\n  and u5 (w5, sel[1], w2, data[2]);\n  and u6 (w6, sel[1], sel[0], data[3]);\n  or  u7 (out, w3, w4, w5, w6);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优点：显式定义门级连接，适合对底层硬件有严格要求的场景。\n\n----------------------------------------\n\n\n# 4. 关键总结\n\n 1. 可综合代码：\n    * 使用明确的时序控制（如 always @(posedge clk)）。\n    * 避免不可综合语法（如 for 循环、混合边沿触发）。\n 2. 设计风格选择：\n    * 行为描述（case/if-else）：适合复杂状态机或算法。\n    * 数据流描述（assign）：适合组合逻辑优化。\n    * 结构性描述：适合门级精确控制。\n 3. 验证工具：\n    * 使用 synplify 等综合工具检查代码是否可综合，并观察生成的 rtl 图。\n\n----------------------------------------\n\n\n# 5. 延伸思考\n\n * 如果设计一个 可变模计数器（如模 n），如何保证可综合性？ 提示：使用参数化设计（parameter）和比较器逻辑，而非动态循环。\n\n通过对比正确与错误的代码示例，我们可以更深刻地理解 verilog 的可综合设计思想。在实际项目中，选择合适的设计风格并严格遵循硬件映射规则，是保证电路可靠性和效率的关键！",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"07.Verilog HDL组合电路设计的方法",frontmatter:{title:"07.Verilog HDL组合电路设计的方法",date:"2025-08-05T12:38:00.000Z",permalink:"/pages/Verilog_07/"},regularPath:"/01.Verilog/07.Verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"01.Verilog/07.Verilog HDL组合电路设计的方法.md",key:"v-3ebe77ee",path:"/pages/Verilog_07/",headers:[{level:2,title:"1. 真值表描述法",slug:"_1-真值表描述法",normalizedTitle:"1. 真值表描述法",charIndex:190},{level:3,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:62},{level:3,title:"示例：3裁判表决电路",slug:"示例-3裁判表决电路",normalizedTitle:"示例：3裁判表决电路",charIndex:254},{level:2,title:"2. 逻辑代数描述法",slug:"_2-逻辑代数描述法",normalizedTitle:"2. 逻辑代数描述法",charIndex:727},{level:3,title:"特点",slug:"特点-2",normalizedTitle:"特点",charIndex:62},{level:3,title:"示例：同一表决电路",slug:"示例-同一表决电路",normalizedTitle:"示例：同一表决电路",charIndex:791},{level:2,title:"3. 结构描述法",slug:"_3-结构描述法",normalizedTitle:"3. 结构描述法",charIndex:1030},{level:3,title:"特点",slug:"特点-3",normalizedTitle:"特点",charIndex:62},{level:3,title:"示例：表决电路门级实现",slug:"示例-表决电路门级实现",normalizedTitle:"示例：表决电路门级实现",charIndex:1088},{level:2,title:"4. 抽象描述法",slug:"_4-抽象描述法",normalizedTitle:"4. 抽象描述法",charIndex:1382},{level:3,title:"特点",slug:"特点-4",normalizedTitle:"特点",charIndex:62},{level:3,title:"示例：表决电路行为级描述",slug:"示例-表决电路行为级描述",normalizedTitle:"示例：表决电路行为级描述",charIndex:1442}],headersStr:"1. 真值表描述法 特点 示例：3裁判表决电路 2. 逻辑代数描述法 特点 示例：同一表决电路 3. 结构描述法 特点 示例：表决电路门级实现 4. 抽象描述法 特点 示例：表决电路行为级描述",content:"# Verilog组合电路设计：四种实现方法详解\n\n数字电路设计中，组合逻辑电路是最基础也是最重要的组成部分之一。组合电路的特点是输出仅取决于当前输入，与电路历史状态无关。本文将详细介绍Verilog HDL中实现组合电路的四种经典方法，并通过实际代码示例展示它们的应用场景和优劣对比。\n\n----------------------------------------\n\n\n# 1. 真值表描述法\n\n\n# 特点\n\n * 最直观的设计方法\n * 直接映射功能需求到代码\n * 适合输入变量较少的情况\n\n\n# 示例：3裁判表决电路\n\nmodule voter_case(OUT, A, B, C);\n  output OUT;\n  input A, B, C;\n  reg OUT;\n  \n  always @(A or B or C) begin\n    case({A,B,C})\n      3'b000: OUT = 0;\n      3'b001: OUT = 0;\n      3'b010: OUT = 0; \n      3'b100: OUT = 0;\n      3'b011: OUT = 1;\n      3'b101: OUT = 1;\n      3'b110: OUT = 1;\n      3'b111: OUT = 1;\n    endcase\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n优点：逻辑清晰，易于理解 缺点：输入变量多时代码冗长\n\n----------------------------------------\n\n\n# 2. 逻辑代数描述法\n\n\n# 特点\n\n * 基于布尔代数表达式\n * 需要人工进行逻辑化简\n * 生成的电路通常更优化\n\n\n# 示例：同一表决电路\n\nmodule voter_assign(OUT, A, B, C);\n  output OUT;\n  input A, B, C;\n  \n  assign OUT = (A&B) | (B&C) | (A&C);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n\n\n优化原理：通过卡诺图化简得到最简表达式 优点：电路结构精简，延迟小 缺点：需要手动推导逻辑表达式\n\n----------------------------------------\n\n\n# 3. 结构描述法\n\n\n# 特点\n\n * 直接实例化逻辑门\n * 完全控制电路结构\n * 类似原理图设计方式\n\n\n# 示例：表决电路门级实现\n\nmodule voter_struct(OUT, A, B, C);\n  output OUT;\n  input A, B, C;\n  wire w1, w2, w3;\n  \n  and U1(w1, A, B);\n  and U2(w2, B, C);\n  and U3(w3, A, C);\n  or U4(OUT, w1, w2, w3);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n优点：精确控制门级连接 缺点：代码量大，维护成本高\n\n----------------------------------------\n\n\n# 4. 抽象描述法\n\n\n# 特点\n\n * 从功能角度描述电路\n * 不关注具体实现细节\n * 利用运算符简化设计\n\n\n# 示例：表决电路行为级描述\n\nmodule voter_abstract(OUT, A, B, C);\n  output OUT;\n  input A, B, C;\n  reg OUT;\n  \n  always @(*) begin\n    OUT = (A + B + C) >= 2;  // 统计\"1\"的个数\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n优点：代码简洁，设计效率高 缺点：综合结果可能不如预期优化",normalizedContent:"# verilog组合电路设计：四种实现方法详解\n\n数字电路设计中，组合逻辑电路是最基础也是最重要的组成部分之一。组合电路的特点是输出仅取决于当前输入，与电路历史状态无关。本文将详细介绍verilog hdl中实现组合电路的四种经典方法，并通过实际代码示例展示它们的应用场景和优劣对比。\n\n----------------------------------------\n\n\n# 1. 真值表描述法\n\n\n# 特点\n\n * 最直观的设计方法\n * 直接映射功能需求到代码\n * 适合输入变量较少的情况\n\n\n# 示例：3裁判表决电路\n\nmodule voter_case(out, a, b, c);\n  output out;\n  input a, b, c;\n  reg out;\n  \n  always @(a or b or c) begin\n    case({a,b,c})\n      3'b000: out = 0;\n      3'b001: out = 0;\n      3'b010: out = 0; \n      3'b100: out = 0;\n      3'b011: out = 1;\n      3'b101: out = 1;\n      3'b110: out = 1;\n      3'b111: out = 1;\n    endcase\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n优点：逻辑清晰，易于理解 缺点：输入变量多时代码冗长\n\n----------------------------------------\n\n\n# 2. 逻辑代数描述法\n\n\n# 特点\n\n * 基于布尔代数表达式\n * 需要人工进行逻辑化简\n * 生成的电路通常更优化\n\n\n# 示例：同一表决电路\n\nmodule voter_assign(out, a, b, c);\n  output out;\n  input a, b, c;\n  \n  assign out = (a&b) | (b&c) | (a&c);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n\n\n优化原理：通过卡诺图化简得到最简表达式 优点：电路结构精简，延迟小 缺点：需要手动推导逻辑表达式\n\n----------------------------------------\n\n\n# 3. 结构描述法\n\n\n# 特点\n\n * 直接实例化逻辑门\n * 完全控制电路结构\n * 类似原理图设计方式\n\n\n# 示例：表决电路门级实现\n\nmodule voter_struct(out, a, b, c);\n  output out;\n  input a, b, c;\n  wire w1, w2, w3;\n  \n  and u1(w1, a, b);\n  and u2(w2, b, c);\n  and u3(w3, a, c);\n  or u4(out, w1, w2, w3);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n优点：精确控制门级连接 缺点：代码量大，维护成本高\n\n----------------------------------------\n\n\n# 4. 抽象描述法\n\n\n# 特点\n\n * 从功能角度描述电路\n * 不关注具体实现细节\n * 利用运算符简化设计\n\n\n# 示例：表决电路行为级描述\n\nmodule voter_abstract(out, a, b, c);\n  output out;\n  input a, b, c;\n  reg out;\n  \n  always @(*) begin\n    out = (a + b + c) >= 2;  // 统计\"1\"的个数\n  end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n优点：代码简洁，设计效率高 缺点：综合结果可能不如预期优化",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"08.verilog HDL组合电路之数字加法器",frontmatter:{title:"08.verilog HDL组合电路之数字加法器",date:"2025-08-06T10:51:00.000Z",permalink:"/pages/Verilog_08/"},regularPath:"/01.Verilog/08.verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%95%B0%E5%AD%97%E5%8A%A0%E6%B3%95%E5%99%A8.html",relativePath:"01.Verilog/08.verilog HDL组合电路之数字加法器.md",key:"v-7fd48428",path:"/pages/Verilog_08/",headers:[{level:2,title:"1. 半加器（Half Adder）",slug:"_1-半加器-half-adder",normalizedTitle:"1. 半加器（half adder）",charIndex:20},{level:3,title:"真值表",slug:"真值表",normalizedTitle:"真值表",charIndex:76},{level:3,title:"逻辑表达式",slug:"逻辑表达式",normalizedTitle:"逻辑表达式",charIndex:169},{level:3,title:"Verilog代码",slug:"verilog代码",normalizedTitle:"verilog代码",charIndex:219},{level:2,title:"2. 全加器（Full Adder）",slug:"_2-全加器-full-adder",normalizedTitle:"2. 全加器（full adder）",charIndex:427},{level:3,title:"真值表",slug:"真值表-2",normalizedTitle:"真值表",charIndex:76},{level:3,title:"逻辑表达式",slug:"逻辑表达式-2",normalizedTitle:"逻辑表达式",charIndex:169},{level:3,title:"Verilog代码",slug:"verilog代码-2",normalizedTitle:"verilog代码",charIndex:219}],headersStr:"1. 半加器（Half Adder） 真值表 逻辑表达式 Verilog代码 2. 全加器（Full Adder） 真值表 逻辑表达式 Verilog代码",content:"# 数字加法器：半加器与全加器\n\n\n# 1. 半加器（Half Adder）\n\n功能：计算两个1位二进制数的和（sum）和进位（carry）。\n\n\n# 真值表\n\nA   B   SUM   CARRY\n0   0   0     0\n0   1   1     0\n1   0   1     0\n1   1   0     1\n\n\n# 逻辑表达式\n\n * sum = A ⊕ B（异或）\n * carry = A & B（与）\n\n\n# Verilog代码\n\nmodule half_adder (\n    input A, B,\n    output sum, carry\n);\n    assign sum = A ^ B;   // 异或\n    assign carry = A & B; // 与\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 2. 全加器（Full Adder）\n\n功能：计算两个1位二进制数的和（sum）和进位（carry），并考虑来自低位的进位（c_in）。\n\n\n# 真值表\n\nA   B   C_IN   SUM   C_OUT\n0   0   0      0     0\n0   0   1      1     0\n0   1   0      1     0\n0   1   1      0     1\n1   0   0      1     0\n1   0   1      0     1\n1   1   0      0     1\n1   1   1      1     1\n\n\n# 逻辑表达式\n\n * sum = A ⊕ B ⊕ c_in\n * c_out = (A & B) | ((A ⊕ B) & c_in)\n\n\n# Verilog代码\n\nmodule full_adder (\n    input A, B, c_in,\n    output sum, c_out\n);\n    assign sum = A ^ B ^ c_in;\n    assign c_out = (A & B) | ((A ^ B) & c_in);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 数字加法器：半加器与全加器\n\n\n# 1. 半加器（half adder）\n\n功能：计算两个1位二进制数的和（sum）和进位（carry）。\n\n\n# 真值表\n\na   b   sum   carry\n0   0   0     0\n0   1   1     0\n1   0   1     0\n1   1   0     1\n\n\n# 逻辑表达式\n\n * sum = a ⊕ b（异或）\n * carry = a & b（与）\n\n\n# verilog代码\n\nmodule half_adder (\n    input a, b,\n    output sum, carry\n);\n    assign sum = a ^ b;   // 异或\n    assign carry = a & b; // 与\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 2. 全加器（full adder）\n\n功能：计算两个1位二进制数的和（sum）和进位（carry），并考虑来自低位的进位（c_in）。\n\n\n# 真值表\n\na   b   c_in   sum   c_out\n0   0   0      0     0\n0   0   1      1     0\n0   1   0      1     0\n0   1   1      0     1\n1   0   0      1     0\n1   0   1      0     1\n1   1   0      0     1\n1   1   1      1     1\n\n\n# 逻辑表达式\n\n * sum = a ⊕ b ⊕ c_in\n * c_out = (a & b) | ((a ⊕ b) & c_in)\n\n\n# verilog代码\n\nmodule full_adder (\n    input a, b, c_in,\n    output sum, c_out\n);\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | ((a ^ b) & c_in);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"09.Verilog HDL组合电路之数据比较器",frontmatter:{title:"09.Verilog HDL组合电路之数据比较器",date:"2025-08-06T11:01:00.000Z",permalink:"/pages/Verilog_09/"},regularPath:"/01.Verilog/09.Verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83%E5%99%A8.html",relativePath:"01.Verilog/09.Verilog HDL组合电路之数据比较器.md",key:"v-bfeb2552",path:"/pages/Verilog_09/",headers:[{level:2,title:"1. 概念",slug:"_1-概念",normalizedTitle:"1. 概念",charIndex:14},{level:2,title:"2. 真值表",slug:"_2-真值表",normalizedTitle:"2. 真值表",charIndex:109},{level:2,title:"3. Verilog代码",slug:"_3-verilog代码",normalizedTitle:"3. verilog代码",charIndex:278},{level:2,title:"4. 说明",slug:"_4-说明",normalizedTitle:"4. 说明",charIndex:497}],headersStr:"1. 概念 2. 真值表 3. Verilog代码 4. 说明",content:"# 4位数据比较器\n\n\n# 1. 概念\n\n数据比较器用于比较两个二进制数的大小关系，输出比较结果（A>B、A<B、A=B）。4位比较器逐位比较两个4位二进制数，从最高位（MSB）开始，若高位相等则比较下一位。\n\n\n# 2. 真值表\n\nA[3:0]   B[3:0]   A_GT_B   A_LT_B   A_EQ_B\nA > B    任意       1        0        0\nA < B    任意       0        1        0\nA = B    任意       0        0        1\n\n\n# 3. Verilog代码\n\nmodule comparator_4bit (\n    input [3:0] A, B,\n    output A_gt_B, A_lt_B, A_eq_B\n);\n    assign A_gt_B = (A > B);\n    assign A_lt_B = (A < B);\n    assign A_eq_B = (A == B);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4. 说明\n\n * A_gt_B=1：A > B\n * A_lt_B=1：A < B\n * A_eq_B=1：A = B",normalizedContent:"# 4位数据比较器\n\n\n# 1. 概念\n\n数据比较器用于比较两个二进制数的大小关系，输出比较结果（a>b、a<b、a=b）。4位比较器逐位比较两个4位二进制数，从最高位（msb）开始，若高位相等则比较下一位。\n\n\n# 2. 真值表\n\na[3:0]   b[3:0]   a_gt_b   a_lt_b   a_eq_b\na > b    任意       1        0        0\na < b    任意       0        1        0\na = b    任意       0        0        1\n\n\n# 3. verilog代码\n\nmodule comparator_4bit (\n    input [3:0] a, b,\n    output a_gt_b, a_lt_b, a_eq_b\n);\n    assign a_gt_b = (a > b);\n    assign a_lt_b = (a < b);\n    assign a_eq_b = (a == b);\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4. 说明\n\n * a_gt_b=1：a > b\n * a_lt_b=1：a < b\n * a_eq_b=1：a = b",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"10.Verilog HDL组合电路之数据选择器",frontmatter:{title:"10.Verilog HDL组合电路之数据选择器",date:"2025-08-07T13:10:00.000Z",permalink:"/pages/Verilog_10/"},regularPath:"/01.Verilog/10.Verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8.html",relativePath:"01.Verilog/10.Verilog HDL组合电路之数据选择器.md",key:"v-12f412e4",path:"/pages/Verilog_10/",headers:[{level:2,title:"1. 原理简介",slug:"_1-原理简介",normalizedTitle:"1. 原理简介",charIndex:74},{level:2,title:"2. 示例一：2选1选择器（使用条件运算符 `?:`）",slug:"_2-示例一-2选1选择器-使用条件运算符",normalizedTitle:"2. 示例一：2选1选择器（使用条件运算符 <code>?:</code>）",charIndex:null},{level:3,title:"结构说明",slug:"结构说明",normalizedTitle:"结构说明",charIndex:379},{level:3,title:"完整的Verilog代码",slug:"完整的verilog代码",normalizedTitle:"完整的verilog代码",charIndex:494},{level:3,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:381},{level:2,title:"3. 示例二：4选1选择器（使用 case 语句）",slug:"_3-示例二-4选1选择器-使用-case-语句",normalizedTitle:"3. 示例二：4选1选择器（使用 case 语句）",charIndex:759},{level:3,title:"结构说明",slug:"结构说明-2",normalizedTitle:"结构说明",charIndex:379},{level:3,title:"Verilog代码",slug:"verilog代码",normalizedTitle:"verilog代码",charIndex:497},{level:3,title:"说明",slug:"说明-2",normalizedTitle:"说明",charIndex:381}],headersStr:"1. 原理简介 2. 示例一：2选1选择器（使用条件运算符 `?:`） 结构说明 完整的Verilog代码 说明 3. 示例二：4选1选择器（使用 case 语句） 结构说明 Verilog代码 说明",content:"----------------------------------------\n\n\n# 数据选择器：多路选择器（Multiplexer）\n\n\n# 1. 原理简介\n\n功能：从多个输入信号中，根据选择信号的值，输出其中一个。\n在数字电路中，数据选择器常用于数据通路控制，像个“电子开关”。\n\n最常见的多路选择器有：\n\n * 2选1：两个输入、一个选择位\n * 4选1：四个输入、两个选择位\n\n它的工作原理就是：\n\n> 选择线控制“哪个输入”可以通过，输出到Y端口。\n\n形式表达式一般如下：\n\nY = I[sel]\n\n当然 Verilog 不支持数组直接这么写组合逻辑，我们会用 ?:、case 等手段实现。\n\n----------------------------------------\n\n\n# 2. 示例一：2选1选择器（使用条件运算符 ?:）\n\n\n# 结构说明\n\n * 输入信号：A, B\n * 选择信号：sel（1位）\n * 输出信号：Y\n\n当 sel=0，输出为 A；\n当 sel=1，输出为 B。\n\n就像：\n\nY = (sel == 0) ? A : B;\n\n\n1\n\n\n\n# 完整的Verilog代码\n\nmodule mux2to1 (\n    input wire A,\n    input wire B,\n    input wire sel,\n    output wire Y\n);\n    assign Y = sel ? B : A; // sel=1输出B，sel=0输出A\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 说明\n\n * ?: 是三目运算符，也叫条件运算符，是写组合逻辑非常常见的一种方式。\n * 它简洁、直观，适合 2选1 或多个嵌套判断的场景。\n\n\n# 3. 示例二：4选1选择器（使用 case 语句）\n\n\n# 结构说明\n\n * 输入信号：I0, I1, I2, I3（可以打包成一个 4 位向量）\n * 选择信号：sel[1:0]（2位）\n * 输出信号：Y\n\n选择信号 sel 决定输出哪一路：\n\nSEL   Y输出\n00    I0\n01    I1\n10    I2\n11    I3\n\n\n# Verilog代码\n\nmodule mux4to1 (\n    input wire [3:0] I,       // 四个输入 I[3:0]\n    input wire [1:0] sel,     // 2位选择信号\n    output reg Y              // 用 reg，因为在 always 块中赋值\n);\n    always @(*) begin\n        case (sel)\n            2'b00: Y = I[0];\n            2'b01: Y = I[1];\n            2'b10: Y = I[2];\n            2'b11: Y = I[3];\n            default: Y = 1'b0; // 默认值防止综合警告\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 说明\n\n * case 语句适用于选择分支比较多的场景。\n * 记得给 Y 写默认值，避免综合时 latch 错误。\n * 这种写法比条件运算符更直观清晰，适合复杂选择器。",normalizedContent:"----------------------------------------\n\n\n# 数据选择器：多路选择器（multiplexer）\n\n\n# 1. 原理简介\n\n功能：从多个输入信号中，根据选择信号的值，输出其中一个。\n在数字电路中，数据选择器常用于数据通路控制，像个“电子开关”。\n\n最常见的多路选择器有：\n\n * 2选1：两个输入、一个选择位\n * 4选1：四个输入、两个选择位\n\n它的工作原理就是：\n\n> 选择线控制“哪个输入”可以通过，输出到y端口。\n\n形式表达式一般如下：\n\ny = i[sel]\n\n当然 verilog 不支持数组直接这么写组合逻辑，我们会用 ?:、case 等手段实现。\n\n----------------------------------------\n\n\n# 2. 示例一：2选1选择器（使用条件运算符 ?:）\n\n\n# 结构说明\n\n * 输入信号：a, b\n * 选择信号：sel（1位）\n * 输出信号：y\n\n当 sel=0，输出为 a；\n当 sel=1，输出为 b。\n\n就像：\n\ny = (sel == 0) ? a : b;\n\n\n1\n\n\n\n# 完整的verilog代码\n\nmodule mux2to1 (\n    input wire a,\n    input wire b,\n    input wire sel,\n    output wire y\n);\n    assign y = sel ? b : a; // sel=1输出b，sel=0输出a\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 说明\n\n * ?: 是三目运算符，也叫条件运算符，是写组合逻辑非常常见的一种方式。\n * 它简洁、直观，适合 2选1 或多个嵌套判断的场景。\n\n\n# 3. 示例二：4选1选择器（使用 case 语句）\n\n\n# 结构说明\n\n * 输入信号：i0, i1, i2, i3（可以打包成一个 4 位向量）\n * 选择信号：sel[1:0]（2位）\n * 输出信号：y\n\n选择信号 sel 决定输出哪一路：\n\nsel   y输出\n00    i0\n01    i1\n10    i2\n11    i3\n\n\n# verilog代码\n\nmodule mux4to1 (\n    input wire [3:0] i,       // 四个输入 i[3:0]\n    input wire [1:0] sel,     // 2位选择信号\n    output reg y              // 用 reg，因为在 always 块中赋值\n);\n    always @(*) begin\n        case (sel)\n            2'b00: y = i[0];\n            2'b01: y = i[1];\n            2'b10: y = i[2];\n            2'b11: y = i[3];\n            default: y = 1'b0; // 默认值防止综合警告\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 说明\n\n * case 语句适用于选择分支比较多的场景。\n * 记得给 y 写默认值，避免综合时 latch 错误。\n * 这种写法比条件运算符更直观清晰，适合复杂选择器。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"11.verilog HDL组合电路之数字编码器",frontmatter:{title:"11.verilog HDL组合电路之数字编码器",date:"2025-08-07T16:20:00.000Z",permalink:"/pages/Verilog_11/"},regularPath:"/01.Verilog/11.verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81%E5%99%A8.html",relativePath:"01.Verilog/11.verilog HDL组合电路之数字编码器.md",key:"v-42f8cede",path:"/pages/Verilog_11/",headers:[{level:2,title:"1. 功能说明",slug:"_1-功能说明",normalizedTitle:"1. 功能说明",charIndex:25},{level:2,title:"2. 编码器的分类与实现",slug:"_2-编码器的分类与实现",normalizedTitle:"2. 编码器的分类与实现",charIndex:197},{level:3,title:"2.1 普通编码器（Basic Encoder）",slug:"_2-1-普通编码器-basic-encoder",normalizedTitle:"2.1 普通编码器（basic encoder）",charIndex:230},{level:3,title:"2.2 优先编码器（Priority Encoder）",slug:"_2-2-优先编码器-priority-encoder",normalizedTitle:"2.2 优先编码器（priority encoder）",charIndex:1115},{level:3,title:"2.3 二进制转BCD编码器（Binary to BCD Encoder）",slug:"_2-3-二进制转bcd编码器-binary-to-bcd-encoder",normalizedTitle:"2.3 二进制转bcd编码器（binary to bcd encoder）",charIndex:1991}],headersStr:"1. 功能说明 2. 编码器的分类与实现 2.1 普通编码器（Basic Encoder） 2.2 优先编码器（Priority Encoder） 2.3 二进制转BCD编码器（Binary to BCD Encoder）",content:"# 数字编码器：Encoder模块的实现\n\n\n# 1. 功能说明\n\n编码器的作用是：\n\n> 将多个输入线路中“有效”的一个信号，转换为对应的二进制编码输出。\n\n从硬件直觉讲，你可以把它看成“反向的多路选择器”——选择器是从输入中挑一个送出去，编码器是从多个输入中判断“哪个激活”，然后生成一个编码值。\n\n----------------------------------------\n\n\n# 2. 编码器的分类与实现\n\n编码器不止一种，常见有三类：\n\n\n# 2.1 普通编码器（Basic Encoder）\n\n * 要求：同一时刻只能有一个输入是有效的（即为1）\n * 功能：直接将有效输入的位置转换为二进制输出\n\n# ✅ 示例：8线-3线普通编码器\n\n输入编号（IN）   二进制输出（Y）\nIN[0]=1    000\nIN[1]=1    001\nIN[2]=1    010\nIN[3]=1    011\nIN[4]=1    100\nIN[5]=1    101\nIN[6]=1    110\nIN[7]=1    111\n\n# 🔧 Verilog代码\n\nmodule encoder8to3 (\n    input wire [7:0] IN,\n    output reg [2:0] Y\n);\n    always @(*) begin\n        case (IN)\n            8'b0000_0001: Y = 3'b000;\n            8'b0000_0010: Y = 3'b001;\n            8'b0000_0100: Y = 3'b010;\n            8'b0000_1000: Y = 3'b011;\n            8'b0001_0000: Y = 3'b100;\n            8'b0010_0000: Y = 3'b101;\n            8'b0100_0000: Y = 3'b110;\n            8'b1000_0000: Y = 3'b111;\n            default:      Y = 3'b000; // 默认输出，防止综合报警\n        endcase\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 💡 注意\n\n * 多个输入为1会导致编码冲突，因此只能有一个输入为高电平。\n * 不满足时默认输出可能错误，实际应用中要加输入检查。\n\n\n# 2.2 优先编码器（Priority Encoder）\n\n * 特点：多个输入同时有效时，按编号优先级高的先输出。\n * 常用于：中断管理、抢占式调度。\n\n# ✅ 示例：8线-3线优先编码器（高位优先）\n\nIN[7:0]     Y输出\n0000_0001   000\n0000_0011   001\n1000_0001   111\n0001_1111   100\n...         ...\n\n# 🔧 Verilog代码\n\nmodule priority_encoder8to3 (\n    input wire [7:0] IN,\n    output reg [2:0] Y\n);\n    always @(*) begin\n        casex (IN)\n            8'b1xxxxxxx: Y = 3'b111;\n            8'b01xxxxxx: Y = 3'b110;\n            8'b001xxxxx: Y = 3'b101;\n            8'b0001xxxx: Y = 3'b100;\n            8'b00001xxx: Y = 3'b011;\n            8'b000001xx: Y = 3'b010;\n            8'b0000001x: Y = 3'b001;\n            8'b00000001: Y = 3'b000;\n            default:     Y = 3'b000;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 💡 casex说明：\n\n * casex 允许使用 x 表示“无关位”，在优先编码中很方便。\n * 越靠前的匹配项优先级越高，符合“优先”语义。\n\n----------------------------------------\n\n\n# 2.3 二进制转BCD编码器（Binary to BCD Encoder）\n\n * 作用：将普通二进制数转换为BCD码（8421码或余3码等）\n * 常用于：数码管显示、七段码驱动\n\n# ✅ 示例：4位二进制转8421BCD\n\n * 输入范围：00001001（09）\n * 输出即为对应的4位BCD码，其实和原输入一样（只是明确为BCD）\n\n# 🔧 Verilog代码（例：显示0~9）\n\nmodule binary_to_bcd (\n    input wire [3:0] bin,\n    output reg [3:0] bcd\n);\n    always @(*) begin\n        if (bin < 10)\n            bcd = bin; // 直接映射\n        else\n            bcd = 4'b0000; // 超过9则清零（可自定义处理）\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 💡 扩展应用\n\n * 结合 数码管译码器，可用在计数器、时间显示、输入设备反馈等场景。",normalizedContent:"# 数字编码器：encoder模块的实现\n\n\n# 1. 功能说明\n\n编码器的作用是：\n\n> 将多个输入线路中“有效”的一个信号，转换为对应的二进制编码输出。\n\n从硬件直觉讲，你可以把它看成“反向的多路选择器”——选择器是从输入中挑一个送出去，编码器是从多个输入中判断“哪个激活”，然后生成一个编码值。\n\n----------------------------------------\n\n\n# 2. 编码器的分类与实现\n\n编码器不止一种，常见有三类：\n\n\n# 2.1 普通编码器（basic encoder）\n\n * 要求：同一时刻只能有一个输入是有效的（即为1）\n * 功能：直接将有效输入的位置转换为二进制输出\n\n# ✅ 示例：8线-3线普通编码器\n\n输入编号（in）   二进制输出（y）\nin[0]=1    000\nin[1]=1    001\nin[2]=1    010\nin[3]=1    011\nin[4]=1    100\nin[5]=1    101\nin[6]=1    110\nin[7]=1    111\n\n# 🔧 verilog代码\n\nmodule encoder8to3 (\n    input wire [7:0] in,\n    output reg [2:0] y\n);\n    always @(*) begin\n        case (in)\n            8'b0000_0001: y = 3'b000;\n            8'b0000_0010: y = 3'b001;\n            8'b0000_0100: y = 3'b010;\n            8'b0000_1000: y = 3'b011;\n            8'b0001_0000: y = 3'b100;\n            8'b0010_0000: y = 3'b101;\n            8'b0100_0000: y = 3'b110;\n            8'b1000_0000: y = 3'b111;\n            default:      y = 3'b000; // 默认输出，防止综合报警\n        endcase\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 💡 注意\n\n * 多个输入为1会导致编码冲突，因此只能有一个输入为高电平。\n * 不满足时默认输出可能错误，实际应用中要加输入检查。\n\n\n# 2.2 优先编码器（priority encoder）\n\n * 特点：多个输入同时有效时，按编号优先级高的先输出。\n * 常用于：中断管理、抢占式调度。\n\n# ✅ 示例：8线-3线优先编码器（高位优先）\n\nin[7:0]     y输出\n0000_0001   000\n0000_0011   001\n1000_0001   111\n0001_1111   100\n...         ...\n\n# 🔧 verilog代码\n\nmodule priority_encoder8to3 (\n    input wire [7:0] in,\n    output reg [2:0] y\n);\n    always @(*) begin\n        casex (in)\n            8'b1xxxxxxx: y = 3'b111;\n            8'b01xxxxxx: y = 3'b110;\n            8'b001xxxxx: y = 3'b101;\n            8'b0001xxxx: y = 3'b100;\n            8'b00001xxx: y = 3'b011;\n            8'b000001xx: y = 3'b010;\n            8'b0000001x: y = 3'b001;\n            8'b00000001: y = 3'b000;\n            default:     y = 3'b000;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 💡 casex说明：\n\n * casex 允许使用 x 表示“无关位”，在优先编码中很方便。\n * 越靠前的匹配项优先级越高，符合“优先”语义。\n\n----------------------------------------\n\n\n# 2.3 二进制转bcd编码器（binary to bcd encoder）\n\n * 作用：将普通二进制数转换为bcd码（8421码或余3码等）\n * 常用于：数码管显示、七段码驱动\n\n# ✅ 示例：4位二进制转8421bcd\n\n * 输入范围：00001001（09）\n * 输出即为对应的4位bcd码，其实和原输入一样（只是明确为bcd）\n\n# 🔧 verilog代码（例：显示0~9）\n\nmodule binary_to_bcd (\n    input wire [3:0] bin,\n    output reg [3:0] bcd\n);\n    always @(*) begin\n        if (bin < 10)\n            bcd = bin; // 直接映射\n        else\n            bcd = 4'b0000; // 超过9则清零（可自定义处理）\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 💡 扩展应用\n\n * 结合 数码管译码器，可用在计数器、时间显示、输入设备反馈等场景。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"12.verilog HDL组合电路之数字译码器",frontmatter:{title:"12.verilog HDL组合电路之数字译码器",date:"2025-08-07T17:10:00.000Z",permalink:"/pages/Verilog_12/"},regularPath:"/01.Verilog/12.verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E6%95%B0%E5%AD%97%E8%AF%91%E7%A0%81%E5%99%A8.html",relativePath:"01.Verilog/12.verilog HDL组合电路之数字译码器.md",key:"v-a3179a3e",path:"/pages/Verilog_12/",headers:[{level:2,title:"1. 功能说明",slug:"_1-功能说明",normalizedTitle:"1. 功能说明",charIndex:25},{level:2,title:"2. 示例：2线-4线译码器（2-to-4 Decoder）",slug:"_2-示例-2线-4线译码器-2-to-4-decoder",normalizedTitle:"2. 示例：2线-4线译码器（2-to-4 decoder）",charIndex:184},{level:3,title:"2.1 真值表（带使能）",slug:"_2-1-真值表-带使能",normalizedTitle:"2.1 真值表（带使能）",charIndex:316},{level:2,title:"3. 原理分析",slug:"_3-原理分析",normalizedTitle:"3. 原理分析",charIndex:668},{level:3,title:"输出函数表达式：",slug:"输出函数表达式",normalizedTitle:"输出函数表达式：",charIndex:704},{level:2,title:"4. Verilog实现方式",slug:"_4-verilog实现方式",normalizedTitle:"4. verilog实现方式",charIndex:925},{level:3,title:"4.1 方式一：使用逻辑表达式实现",slug:"_4-1-方式一-使用逻辑表达式实现",normalizedTitle:"4.1 方式一：使用逻辑表达式实现",charIndex:944},{level:3,title:"说明：",slug:"说明",normalizedTitle:"说明：",charIndex:1283},{level:3,title:"4.2 方式二：使用case语句抽象描述",slug:"_4-2-方式二-使用case语句抽象描述",normalizedTitle:"4.2 方式二：使用case语句抽象描述",charIndex:1394},{level:3,title:"说明：",slug:"说明-2",normalizedTitle:"说明：",charIndex:1283}],headersStr:"1. 功能说明 2. 示例：2线-4线译码器（2-to-4 Decoder） 2.1 真值表（带使能） 3. 原理分析 输出函数表达式： 4. Verilog实现方式 4.1 方式一：使用逻辑表达式实现 说明： 4.2 方式二：使用case语句抽象描述 说明：",content:"# 数字译码器：Decoder模块的实现\n\n\n# 1. 功能说明\n\n数字译码器的作用是：\n\n> 将二进制代码“翻译”为唯一一个输出信号为有效的形式。\n\n说白了，就是告诉你：“当前是哪一位激活？”\n如果编码器是“你说话我翻译成代码”，那译码器就是“你给我代码我告诉你选了谁”。\n\n----------------------------------------\n\n\n# 2. 示例：2线-4线译码器（2-to-4 Decoder）\n\n * 输入：2位选择信号 A[1:0]\n * 输出：4路输出 Y[3:0]\n * 使能信号：E（有效低）\n\n> 当 E = 0 时，根据 A 的值，仅有一位 Y[i] 输出为低电平（即有效）\n\n\n# 2.1 真值表（带使能）\n\nE   A[1]   A[0]   Y[3]   Y[2]   Y[1]   Y[0]\n1   x      x      1      1      1      1\n0   0      0      1      1      1      0\n0   0      1      1      1      0      1\n0   1      0      1      0      1      1\n0   1      1      0      1      1      1\n\n输出低电平表示有效（有点反直觉，但这是最常见用法，一个真正的man要拿得起放得下）\n\n----------------------------------------\n\n\n# 3. 原理分析\n\n译码器的输出函数用最小项的“非”形式来表示：\n\n\n# 输出函数表达式：\n\n> 对于第 i 路输出，\n> Yi = ~E & mi，其中 mi 是第 i 项的最小项（对应 A 的取值）\n\n举例：\n\n * Y0 = ~E & ~A[1] & ~A[0]\n * Y1 = ~E & ~A[1] & A[0]\n * Y2 = ~E & A[1] & ~A[0]\n * Y3 = ~E & A[1] & A[0]\n\n----------------------------------------\n\n\n# 4. Verilog实现方式\n\n\n# 4.1 方式一：使用逻辑表达式实现\n\nmodule decoder2to4_expr (\n    input wire [1:0] A,\n    input wire E,             // 有效低\n    output wire [3:0] Y\n);\n    assign Y[0] = ~(~E & ~A[1] & ~A[0]);\n    assign Y[1] = ~(~E & ~A[1] &  A[0]);\n    assign Y[2] = ~(~E &  A[1] & ~A[0]);\n    assign Y[3] = ~(~E &  A[1] &  A[0]);\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 说明：\n\n * 用的是 组合逻辑“显式写法”，所有逻辑条件完全展开。\n * 输出高电平默认，只有选中那一路输出为低电平（有效）。\n\n----------------------------------------\n\n\n# 4.2 方式二：使用case语句抽象描述\n\nmodule decoder2to4_case (\n    input wire [1:0] A,\n    input wire E,\n    output reg [3:0] Y\n);\n    always @(*) begin\n        if (E == 1'b1) begin\n            Y = 4'b1111;  // 禁止译码，全1表示全无效\n        end else begin\n            case (A)\n                2'b00: Y = 4'b1110;\n                2'b01: Y = 4'b1101;\n                2'b10: Y = 4'b1011;\n                2'b11: Y = 4'b0111;\n                default: Y = 4'b1111;\n            endcase\n        end\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 说明：\n\n * 结构更清晰，适合综合时易读易维护。\n * 默认 Y=4'b1111 是个好习惯，避免 latch。",normalizedContent:"# 数字译码器：decoder模块的实现\n\n\n# 1. 功能说明\n\n数字译码器的作用是：\n\n> 将二进制代码“翻译”为唯一一个输出信号为有效的形式。\n\n说白了，就是告诉你：“当前是哪一位激活？”\n如果编码器是“你说话我翻译成代码”，那译码器就是“你给我代码我告诉你选了谁”。\n\n----------------------------------------\n\n\n# 2. 示例：2线-4线译码器（2-to-4 decoder）\n\n * 输入：2位选择信号 a[1:0]\n * 输出：4路输出 y[3:0]\n * 使能信号：e（有效低）\n\n> 当 e = 0 时，根据 a 的值，仅有一位 y[i] 输出为低电平（即有效）\n\n\n# 2.1 真值表（带使能）\n\ne   a[1]   a[0]   y[3]   y[2]   y[1]   y[0]\n1   x      x      1      1      1      1\n0   0      0      1      1      1      0\n0   0      1      1      1      0      1\n0   1      0      1      0      1      1\n0   1      1      0      1      1      1\n\n输出低电平表示有效（有点反直觉，但这是最常见用法，一个真正的man要拿得起放得下）\n\n----------------------------------------\n\n\n# 3. 原理分析\n\n译码器的输出函数用最小项的“非”形式来表示：\n\n\n# 输出函数表达式：\n\n> 对于第 i 路输出，\n> yi = ~e & mi，其中 mi 是第 i 项的最小项（对应 a 的取值）\n\n举例：\n\n * y0 = ~e & ~a[1] & ~a[0]\n * y1 = ~e & ~a[1] & a[0]\n * y2 = ~e & a[1] & ~a[0]\n * y3 = ~e & a[1] & a[0]\n\n----------------------------------------\n\n\n# 4. verilog实现方式\n\n\n# 4.1 方式一：使用逻辑表达式实现\n\nmodule decoder2to4_expr (\n    input wire [1:0] a,\n    input wire e,             // 有效低\n    output wire [3:0] y\n);\n    assign y[0] = ~(~e & ~a[1] & ~a[0]);\n    assign y[1] = ~(~e & ~a[1] &  a[0]);\n    assign y[2] = ~(~e &  a[1] & ~a[0]);\n    assign y[3] = ~(~e &  a[1] &  a[0]);\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 说明：\n\n * 用的是 组合逻辑“显式写法”，所有逻辑条件完全展开。\n * 输出高电平默认，只有选中那一路输出为低电平（有效）。\n\n----------------------------------------\n\n\n# 4.2 方式二：使用case语句抽象描述\n\nmodule decoder2to4_case (\n    input wire [1:0] a,\n    input wire e,\n    output reg [3:0] y\n);\n    always @(*) begin\n        if (e == 1'b1) begin\n            y = 4'b1111;  // 禁止译码，全1表示全无效\n        end else begin\n            case (a)\n                2'b00: y = 4'b1110;\n                2'b01: y = 4'b1101;\n                2'b10: y = 4'b1011;\n                2'b11: y = 4'b0111;\n                default: y = 4'b1111;\n            endcase\n        end\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 说明：\n\n * 结构更清晰，适合综合时易读易维护。\n * 默认 y=4'b1111 是个好习惯，避免 latch。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"13.verilog HDL组合电路之奇偶校验器",frontmatter:{title:"13.verilog HDL组合电路之奇偶校验器",date:"2025-08-07T17:45:00.000Z",permalink:"/pages/Verilog_13/"},regularPath:"/01.Verilog/13.verilog%20HDL%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E4%B9%8B%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%99%A8.html",relativePath:"01.Verilog/13.verilog HDL组合电路之奇偶校验器.md",key:"v-3042a0fd",path:"/pages/Verilog_13/",headers:[{level:2,title:"1. 功能说明",slug:"_1-功能说明",normalizedTitle:"1. 功能说明",charIndex:32},{level:2,title:"2. 校验类型",slug:"_2-校验类型",normalizedTitle:"2. 校验类型",charIndex:196},{level:3,title:"2.1 奇校验（Odd Parity）",slug:"_2-1-奇校验-odd-parity",normalizedTitle:"2.1 奇校验（odd parity）",charIndex:208},{level:3,title:"2.2 偶校验（Even Parity）",slug:"_2-2-偶校验-even-parity",normalizedTitle:"2.2 偶校验（even parity）",charIndex:335},{level:2,title:"3. 原理分析：全体异或判断",slug:"_3-原理分析-全体异或判断",normalizedTitle:"3. 原理分析：全体异或判断",charIndex:468},{level:2,title:"4. Verilog实现方式",slug:"_4-verilog实现方式",normalizedTitle:"4. verilog实现方式",charIndex:641},{level:3,title:"4.1 结构性描述：逐级异或（适合教学/多位扩展）",slug:"_4-1-结构性描述-逐级异或-适合教学-多位扩展",normalizedTitle:"4.1 结构性描述：逐级异或（适合教学/多位扩展）",charIndex:660},{level:3,title:"说明：",slug:"说明",normalizedTitle:"说明：",charIndex:1026},{level:3,title:"4.2 抽象描述：直接异或所有位",slug:"_4-2-抽象描述-直接异或所有位",normalizedTitle:"4.2 抽象描述：直接异或所有位",charIndex:1126},{level:3,title:"说明：",slug:"说明-2",normalizedTitle:"说明：",charIndex:1026}],headersStr:"1. 功能说明 2. 校验类型 2.1 奇校验（Odd Parity） 2.2 偶校验（Even Parity） 3. 原理分析：全体异或判断 4. Verilog实现方式 4.1 结构性描述：逐级异或（适合教学/多位扩展） 说明： 4.2 抽象描述：直接异或所有位 说明：",content:"# 奇偶校验器：Parity Checker模块的实现\n\n\n# 1. 功能说明\n\n奇偶校验器用于检测一个二进制数据中 1 的个数是奇数还是偶数。\n是数字通信中的老熟人，常用于**错误检测（Error Detection）**中。\n\n> 不纠错，只报错：这玩意不会修数据，但能告诉你“传的可能不对”。\n\n----------------------------------------\n\n\n# 2. 校验类型\n\n\n# 2.1 奇校验（Odd Parity）\n\n> 在原始数据后面加一个奇校验位，使得整体1的个数为奇数。\n\n例：1011（三个1）→ 校验位为 0，保证总共有3个1\n   1000（一个1）→ 校验位为 0\n   1100（两个1）→ 校验位为 1\n\n\n# 2.2 偶校验（Even Parity）\n\n> 校验位保证总1的个数为偶数。\n\n例：1011（三个1）→ 校验位为 1（凑成四个1）\n  1100（两个1）→ 校验位为 0\n\n----------------------------------------\n\n\n# 3. 原理分析：全体异或判断\n\n关键结论：\n\n * 所有位异或的结果 = 奇偶校验结果\n * 因为异或就是：“不同为1，相同为0”，正好能记录1的奇偶性。\n\n所以：\n\n * P = D[3] ^ D[2] ^ D[1] ^ D[0] 就能输出奇偶信息。\n\n----------------------------------------\n\n\n# 4. Verilog实现方式\n\n\n# 4.1 结构性描述：逐级异或（适合教学/多位扩展）\n\nmodule parity_checker_struct (\n    input wire [3:0] D,    // 原始4位数据\n    output wire parity_odd,\n    output wire parity_even\n);\n    wire xor1, xor2;\n\n    assign xor1 = D[3] ^ D[2];\n    assign xor2 = xor1 ^ D[1];\n    assign parity_odd  = xor2 ^ D[0];\n    assign parity_even = ~parity_odd;\nendmodule\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 说明：\n\n * 逐级展开异或，逻辑路径清晰，适合结构化学习\n * 输出两个信号，一个奇校验位，一个偶校验位\n\n----------------------------------------\n\n\n# 4.2 抽象描述：直接异或所有位\n\nmodule parity_checker_abstract (\n    input wire [7:0] D,      // 8位数据\n    output wire parity_odd,\n    output wire parity_even\n);\n    assign parity_odd  = ^D;     // 按位异或归约（^D 表示从 D[7] 到 D[0] 全异或）\n    assign parity_even = ~^D;\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 说明：\n\n * ^D 是 Verilog 的“归约异或”操作符，非常简洁\n * 支持任意位宽，适合实际项目使用",normalizedContent:"# 奇偶校验器：parity checker模块的实现\n\n\n# 1. 功能说明\n\n奇偶校验器用于检测一个二进制数据中 1 的个数是奇数还是偶数。\n是数字通信中的老熟人，常用于**错误检测（error detection）**中。\n\n> 不纠错，只报错：这玩意不会修数据，但能告诉你“传的可能不对”。\n\n----------------------------------------\n\n\n# 2. 校验类型\n\n\n# 2.1 奇校验（odd parity）\n\n> 在原始数据后面加一个奇校验位，使得整体1的个数为奇数。\n\n例：1011（三个1）→ 校验位为 0，保证总共有3个1\n   1000（一个1）→ 校验位为 0\n   1100（两个1）→ 校验位为 1\n\n\n# 2.2 偶校验（even parity）\n\n> 校验位保证总1的个数为偶数。\n\n例：1011（三个1）→ 校验位为 1（凑成四个1）\n  1100（两个1）→ 校验位为 0\n\n----------------------------------------\n\n\n# 3. 原理分析：全体异或判断\n\n关键结论：\n\n * 所有位异或的结果 = 奇偶校验结果\n * 因为异或就是：“不同为1，相同为0”，正好能记录1的奇偶性。\n\n所以：\n\n * p = d[3] ^ d[2] ^ d[1] ^ d[0] 就能输出奇偶信息。\n\n----------------------------------------\n\n\n# 4. verilog实现方式\n\n\n# 4.1 结构性描述：逐级异或（适合教学/多位扩展）\n\nmodule parity_checker_struct (\n    input wire [3:0] d,    // 原始4位数据\n    output wire parity_odd,\n    output wire parity_even\n);\n    wire xor1, xor2;\n\n    assign xor1 = d[3] ^ d[2];\n    assign xor2 = xor1 ^ d[1];\n    assign parity_odd  = xor2 ^ d[0];\n    assign parity_even = ~parity_odd;\nendmodule\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 说明：\n\n * 逐级展开异或，逻辑路径清晰，适合结构化学习\n * 输出两个信号，一个奇校验位，一个偶校验位\n\n----------------------------------------\n\n\n# 4.2 抽象描述：直接异或所有位\n\nmodule parity_checker_abstract (\n    input wire [7:0] d,      // 8位数据\n    output wire parity_odd,\n    output wire parity_even\n);\n    assign parity_odd  = ^d;     // 按位异或归约（^d 表示从 d[7] 到 d[0] 全异或）\n    assign parity_even = ~^d;\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 说明：\n\n * ^d 是 verilog 的“归约异或”操作符，非常简洁\n * 支持任意位宽，适合实际项目使用",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"14.Verilog HDL时序电路设计基础",frontmatter:{title:"14.Verilog HDL时序电路设计基础",date:"2025-08-13T14:00:00.000Z",permalink:"/pages/Verilog_14/"},regularPath:"/01.Verilog/14.Verilog%20HDL%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html",relativePath:"01.Verilog/14.Verilog HDL时序电路设计基础.md",key:"v-03ff47ee",path:"/pages/Verilog_14/",headers:[{level:2,title:"1. 核心特点",slug:"_1-核心特点",normalizedTitle:"1. 核心特点",charIndex:24},{level:2,title:"2. 核心组成",slug:"_2-核心组成",normalizedTitle:"2. 核心组成",charIndex:193},{level:2,title:"3. 同步时序的核心：时钟控制",slug:"_3-同步时序的核心-时钟控制",normalizedTitle:"3. 同步时序的核心：时钟控制",charIndex:423},{level:2,title:"4. Verilog 实现示例",slug:"_4-verilog-实现示例",normalizedTitle:"4. verilog 实现示例",charIndex:657},{level:2,title:"5. 小结",slug:"_5-小结",normalizedTitle:"5. 小结",charIndex:1073}],headersStr:"1. 核心特点 2. 核心组成 3. 同步时序的核心：时钟控制 4. Verilog 实现示例 5. 小结",content:"# 时序电路设计基础：从“有记忆”开始\n\n\n# 1. 核心特点\n\n时序电路和组合逻辑最大的区别，就在于它有记忆。\n它的输出不仅取决于当前输入，还取决于电路的历史状态。\n\n> 组合逻辑是“你说啥我立刻答啥”，时序电路是“我记得你之前说过啥，所以我这次回答不一样”。\n\n换句话说，时序电路有状态。\n\n----------------------------------------\n\n\n# 2. 核心组成\n\n时序电路 = 组合逻辑电路 + 存储电路（触发器）\n\n * 组合逻辑电路：负责“算”，根据输入信号和当前状态生成下一状态和输出。\n * 存储电路（触发器）：负责“记”，保存状态直到下一个时钟触发。\n\n在 Verilog 中，我们通常用 always @(posedge clk) 或 always @(negedge clk) 来描述触发器的行为。\n\n----------------------------------------\n\n\n# 3. 同步时序的核心：时钟控制\n\n在同步时序电路中，状态的变化严格由时钟边沿控制。\n\n * 上升沿触发：posedge clk\n * 下降沿触发：negedge clk\n\n时钟信号就像一个节拍器：\n\n> 节拍一到，所有触发器一起“换状态”；节拍之间，状态保持不变。\n\n这种设计的好处：\n\n 1. 所有状态变化有统一节拍，电路稳定。\n 2. 容易分析和调试（画时序图很方便）。\n\n----------------------------------------\n\n\n# 4. Verilog 实现示例\n\n下面用一个简单的D触发器例子展示同步时序电路的写法：\n\nmodule d_ff (\n    input  wire clk,    // 时钟信号\n    input  wire rst_n,  // 异步复位，低有效\n    input  wire d,      // 数据输入\n    output reg  q       // 数据输出（存储状态）\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;     // 复位状态\n        else\n            q <= d;        // 在时钟上升沿，存储输入数据\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 5. 小结\n\n * 时序电路的关键是状态，状态由触发器保存。\n * 同步时序电路用时钟边沿统一控制状态变化。\n * 组合逻辑 + 存储器件的结合，让电路能“记住过去”，实现计数器、寄存器、状态机等功能。\n\n> 组合逻辑是“计算器”，时序电路是“计算器 + 笔记本”——算得出，还记得住。",normalizedContent:"# 时序电路设计基础：从“有记忆”开始\n\n\n# 1. 核心特点\n\n时序电路和组合逻辑最大的区别，就在于它有记忆。\n它的输出不仅取决于当前输入，还取决于电路的历史状态。\n\n> 组合逻辑是“你说啥我立刻答啥”，时序电路是“我记得你之前说过啥，所以我这次回答不一样”。\n\n换句话说，时序电路有状态。\n\n----------------------------------------\n\n\n# 2. 核心组成\n\n时序电路 = 组合逻辑电路 + 存储电路（触发器）\n\n * 组合逻辑电路：负责“算”，根据输入信号和当前状态生成下一状态和输出。\n * 存储电路（触发器）：负责“记”，保存状态直到下一个时钟触发。\n\n在 verilog 中，我们通常用 always @(posedge clk) 或 always @(negedge clk) 来描述触发器的行为。\n\n----------------------------------------\n\n\n# 3. 同步时序的核心：时钟控制\n\n在同步时序电路中，状态的变化严格由时钟边沿控制。\n\n * 上升沿触发：posedge clk\n * 下降沿触发：negedge clk\n\n时钟信号就像一个节拍器：\n\n> 节拍一到，所有触发器一起“换状态”；节拍之间，状态保持不变。\n\n这种设计的好处：\n\n 1. 所有状态变化有统一节拍，电路稳定。\n 2. 容易分析和调试（画时序图很方便）。\n\n----------------------------------------\n\n\n# 4. verilog 实现示例\n\n下面用一个简单的d触发器例子展示同步时序电路的写法：\n\nmodule d_ff (\n    input  wire clk,    // 时钟信号\n    input  wire rst_n,  // 异步复位，低有效\n    input  wire d,      // 数据输入\n    output reg  q       // 数据输出（存储状态）\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;     // 复位状态\n        else\n            q <= d;        // 在时钟上升沿，存储输入数据\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 5. 小结\n\n * 时序电路的关键是状态，状态由触发器保存。\n * 同步时序电路用时钟边沿统一控制状态变化。\n * 组合逻辑 + 存储器件的结合，让电路能“记住过去”，实现计数器、寄存器、状态机等功能。\n\n> 组合逻辑是“计算器”，时序电路是“计算器 + 笔记本”——算得出，还记得住。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"16.Verilog HDL计数器设计",frontmatter:{title:"16.Verilog HDL计数器设计",date:"2025-08-13T14:40:00.000Z",permalink:"/pages/Verilog_16/"},regularPath:"/01.Verilog/16.Verilog%20HDL%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E4%B9%8B%E8%AE%A1%E6%95%B0%E5%99%A8.html",relativePath:"01.Verilog/16.Verilog HDL时序逻辑电路之计数器.md",key:"v-6df42ea1",path:"/pages/Verilog_16/",headers:[{level:2,title:"1. 二进制计数器",slug:"_1-二进制计数器",normalizedTitle:"1. 二进制计数器",charIndex:23},{level:2,title:"2. 任意模值计数器（模 M）",slug:"_2-任意模值计数器-模-m",normalizedTitle:"2. 任意模值计数器（模 m）",charIndex:297},{level:3,title:"2.1 核心设计思路",slug:"_2-1-核心设计思路",normalizedTitle:"2.1 核心设计思路",charIndex:317},{level:3,title:"2.2 Verilog 示例",slug:"_2-2-verilog-示例",normalizedTitle:"2.2 verilog 示例",charIndex:480},{level:2,title:"3. 小结",slug:"_3-小结",normalizedTitle:"3. 小结",charIndex:969}],headersStr:"1. 二进制计数器 2. 任意模值计数器（模 M） 2.1 核心设计思路 2.2 Verilog 示例 3. 小结",content:"# 计数器设计：数字世界的“节拍器”\n\n\n# 1. 二进制计数器\n\n最简单的计数器就是二进制计数器。\n1位二进制计数器可以用一个触发器实现——每次时钟来就翻转一次。\n\nmodule counter_1bit (\n    input  wire clk,\n    output reg  Q\n);\n    always @(posedge clk) begin\n        Q <= ~Q;  // 每个时钟上升沿翻转\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n1位计数器：0 → 1 → 0 → 1 … 周期是输入时钟的两倍，也就是分频器的雏形。\n\n\n# 2. 任意模值计数器（模 M）\n\n\n# 2.1 核心设计思路\n\n 1. 确定触发器数量：找到最小的 N，使得 2^N > M。 例如 M=10，2^3=8 不够，2^4=16 满足，所以 N=4。\n 2. 计数逻辑：每个时钟+1。\n 3. 反馈清零：计到 M-1 时清零。\n\n----------------------------------------\n\n\n# 2.2 Verilog 示例\n\nmodule counter_modM #(\n    parameter M = 10  // 模值\n)(\n    input  wire clk,\n    input  wire rst_n,   // 低有效复位\n    output reg  [$clog2(M)-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == M-1)\n            count <= 0;         // 计满清零\n        else\n            count <= count + 1; // 正常计数\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 3. 小结\n\n * 二进制计数器：简单，直接用触发器翻转输出，常作分频器。\n * 模 M 计数器：设计前先算出需要的触发器数量，然后用反馈清零法限制计数范围。\n * 在工程中，计数器是时序控制的基础，比如分频、延时、状态机定时等都会用到。\n\n> 如果说时钟是数字电路的“心跳”，那计数器就是“心跳的节拍器”。",normalizedContent:"# 计数器设计：数字世界的“节拍器”\n\n\n# 1. 二进制计数器\n\n最简单的计数器就是二进制计数器。\n1位二进制计数器可以用一个触发器实现——每次时钟来就翻转一次。\n\nmodule counter_1bit (\n    input  wire clk,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= ~q;  // 每个时钟上升沿翻转\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n1位计数器：0 → 1 → 0 → 1 … 周期是输入时钟的两倍，也就是分频器的雏形。\n\n\n# 2. 任意模值计数器（模 m）\n\n\n# 2.1 核心设计思路\n\n 1. 确定触发器数量：找到最小的 n，使得 2^n > m。 例如 m=10，2^3=8 不够，2^4=16 满足，所以 n=4。\n 2. 计数逻辑：每个时钟+1。\n 3. 反馈清零：计到 m-1 时清零。\n\n----------------------------------------\n\n\n# 2.2 verilog 示例\n\nmodule counter_modm #(\n    parameter m = 10  // 模值\n)(\n    input  wire clk,\n    input  wire rst_n,   // 低有效复位\n    output reg  [$clog2(m)-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == m-1)\n            count <= 0;         // 计满清零\n        else\n            count <= count + 1; // 正常计数\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 3. 小结\n\n * 二进制计数器：简单，直接用触发器翻转输出，常作分频器。\n * 模 m 计数器：设计前先算出需要的触发器数量，然后用反馈清零法限制计数范围。\n * 在工程中，计数器是时序控制的基础，比如分频、延时、状态机定时等都会用到。\n\n> 如果说时钟是数字电路的“心跳”，那计数器就是“心跳的节拍器”。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"15.Verilog HDL触发器设计",frontmatter:{title:"15.Verilog HDL触发器设计",date:"2025-08-13T14:20:00.000Z",permalink:"/pages/Verilog_15/"},regularPath:"/01.Verilog/15.Verilog%20HDL%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%A7%A6%E5%8F%91%E5%99%A8.html",relativePath:"01.Verilog/15.Verilog HDL时序电路之基本触发器.md",key:"v-709769d8",path:"/pages/Verilog_15/",headers:[{level:2,title:"1. 基本 D 触发器",slug:"_1-基本-d-触发器",normalizedTitle:"1. 基本 d 触发器",charIndex:23},{level:3,title:"Verilog 示例：基本 D 触发器",slug:"verilog-示例-基本-d-触发器",normalizedTitle:"verilog 示例：基本 d 触发器",charIndex:128},{level:3,title:"2.1 同步复位",slug:"_2-1-同步复位",normalizedTitle:"2.1 同步复位",charIndex:352},{level:3,title:"2.2 异步复位",slug:"_2-2-异步复位",normalizedTitle:"2.2 异步复位",charIndex:779},{level:2,title:"3. T 触发器",slug:"_3-t-触发器",normalizedTitle:"3. t 触发器",charIndex:1228},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:1753}],headersStr:"1. 基本 D 触发器 Verilog 示例：基本 D 触发器 2.1 同步复位 2.2 异步复位 3. T 触发器 4. 小结",content:"# 触发器设计：数字电路的“记事本”\n\n\n# 1. 基本 D 触发器\n\nD触发器（Data 或 Delay Flip-Flop）是最常见的触发器。\n它会在时钟边沿（上升沿或下降沿）把输入 data_in 的值存入输出 q，并保持到下一个时钟触发。\n\n\n# Verilog 示例：基本 D 触发器\n\nmodule d_ff_basic (\n    input  wire clk,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= data_in;  // 在时钟上升沿锁存输入\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.1 同步复位\n\n * 复位信号在时钟边沿生效。\n * 好处：复位动作和数据更新有相同时序，容易分析。\n * 坏处：复位需要等待时钟边沿，速度可能不够快。\n\nmodule d_ff_sync_rst (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        if (!rst_n)\n            q <= 1'b0;    // 同步复位\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 2.2 异步复位\n\n * 复位信号在任何时间都能立即生效（不用等时钟）。\n * 好处：可以快速清零。\n * 坏处：如果复位释放时机不当，可能导致亚稳态问题。\n\nmodule d_ff_async_rst (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;    // 异步复位立即生效\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 3. T 触发器\n\nT触发器（Toggle Flip-Flop）常用于分频器、计数器等电路。 它的行为是：\n\n * T = 1 → 状态翻转\n * T = 0 → 保持状态\n\nmodule t_ff (\n    input  wire clk,\n    input  wire rst_n,     // 低有效复位\n    input  wire T,\n    output reg  data_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 1'b0;\n        else if (T)\n            data_out <= ~data_out;  // 翻转\n        else\n            data_out <= data_out;   // 保持\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 小结\n\n * D触发器是最基础的状态存储单元。\n * 同步复位安全、易分析；异步复位快速，但要注意释放时机。\n * T触发器是计数器和分频器的好帮手。\n\n> 组合逻辑会“算”，触发器会“记”，两者结合才是完整的数字电路。",normalizedContent:"# 触发器设计：数字电路的“记事本”\n\n\n# 1. 基本 d 触发器\n\nd触发器（data 或 delay flip-flop）是最常见的触发器。\n它会在时钟边沿（上升沿或下降沿）把输入 data_in 的值存入输出 q，并保持到下一个时钟触发。\n\n\n# verilog 示例：基本 d 触发器\n\nmodule d_ff_basic (\n    input  wire clk,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= data_in;  // 在时钟上升沿锁存输入\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.1 同步复位\n\n * 复位信号在时钟边沿生效。\n * 好处：复位动作和数据更新有相同时序，容易分析。\n * 坏处：复位需要等待时钟边沿，速度可能不够快。\n\nmodule d_ff_sync_rst (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        if (!rst_n)\n            q <= 1'b0;    // 同步复位\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 2.2 异步复位\n\n * 复位信号在任何时间都能立即生效（不用等时钟）。\n * 好处：可以快速清零。\n * 坏处：如果复位释放时机不当，可能导致亚稳态问题。\n\nmodule d_ff_async_rst (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;    // 异步复位立即生效\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n----------------------------------------\n\n\n# 3. t 触发器\n\nt触发器（toggle flip-flop）常用于分频器、计数器等电路。 它的行为是：\n\n * t = 1 → 状态翻转\n * t = 0 → 保持状态\n\nmodule t_ff (\n    input  wire clk,\n    input  wire rst_n,     // 低有效复位\n    input  wire t,\n    output reg  data_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 1'b0;\n        else if (t)\n            data_out <= ~data_out;  // 翻转\n        else\n            data_out <= data_out;   // 保持\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 小结\n\n * d触发器是最基础的状态存储单元。\n * 同步复位安全、易分析；异步复位快速，但要注意释放时机。\n * t触发器是计数器和分频器的好帮手。\n\n> 组合逻辑会“算”，触发器会“记”，两者结合才是完整的数字电路。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"17.Verilog HDL移位寄存器",frontmatter:{title:"17.Verilog HDL移位寄存器",date:"2025-08-13T15:00:00.000Z",permalink:"/pages/Verilog_17/"},regularPath:"/01.Verilog/17.Verilog%20HDL%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E4%B9%8B%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8.html",relativePath:"01.Verilog/17.Verilog HDL时序逻辑电路之移位寄存器.md",key:"v-a6e17e70",path:"/pages/Verilog_17/",headers:[{level:2,title:"1. 什么是移位寄存器？",slug:"_1-什么是移位寄存器",normalizedTitle:"1. 什么是移位寄存器？",charIndex:20},{level:2,title:"2. 环形移位寄存器",slug:"_2-环形移位寄存器",normalizedTitle:"2. 环形移位寄存器",charIndex:168},{level:3,title:"工作原理：",slug:"工作原理",normalizedTitle:"工作原理：",charIndex:227},{level:3,title:"Verilog 示例：4位循环右移",slug:"verilog-示例-4位循环右移",normalizedTitle:"verilog 示例：4位循环右移",charIndex:325},{level:2,title:"3. 应用场景",slug:"_3-应用场景",normalizedTitle:"3. 应用场景",charIndex:728},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:921}],headersStr:"1. 什么是移位寄存器？ 2. 环形移位寄存器 工作原理： Verilog 示例：4位循环右移 3. 应用场景 4. 小结",content:"# 移位寄存器：数据“搬运工”\n\n\n# 1. 什么是移位寄存器？\n\n移位寄存器是一种能在时钟触发下，将数据按位向左或向右移动的寄存器。\n它常用来在数字电路中搬运、延迟或循环数据。\n\n> 如果触发器是“记忆单元”，移位寄存器就是一列“搬运带”。\n\n----------------------------------------\n\n\n# 2. 环形移位寄存器\n\n环形移位寄存器是一种特殊移位寄存器——\n移出的一端数据会反馈到另一端，形成一个闭环。\n\n\n# 工作原理：\n\n * 右移：最低位丢掉，高位填入原最高位。\n * 左移：最高位丢掉，最低位填入原最低位。\n\n----------------------------------------\n\n\n# Verilog 示例：4位循环右移\n\nmodule shift_reg_ring (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire [3:0] D_init, // 初始值\n    output reg  [3:0] D\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            D <= D_init;                // 复位加载初始值\n        else\n            D <= {D[2:0], D[3]};        // 循环右移\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3. 应用场景\n\n环形移位寄存器在工程中很常见，典型用途有：\n\n 1. 串/并转换 串行输入、并行输出，或反之（常见于串口通信）。\n 2. 序列检测 用移位寄存器保存最近 N 位输入，与目标模式比较。\n 3. 伪随机码生成 配合异或反馈实现 LFSR（线性反馈移位寄存器），用于加密、测试等。\n\n----------------------------------------\n\n\n# 4. 小结\n\n * 移位寄存器就是一组能在时钟下按位搬运数据的触发器。\n * 环形移位寄存器通过反馈实现“首尾相接”的循环移动。\n * 搭配逻辑运算可实现更复杂的功能，如序列识别和伪随机数生成。\n\n> 它是数据的搬运带，也是时序电路的节拍舞者。",normalizedContent:"# 移位寄存器：数据“搬运工”\n\n\n# 1. 什么是移位寄存器？\n\n移位寄存器是一种能在时钟触发下，将数据按位向左或向右移动的寄存器。\n它常用来在数字电路中搬运、延迟或循环数据。\n\n> 如果触发器是“记忆单元”，移位寄存器就是一列“搬运带”。\n\n----------------------------------------\n\n\n# 2. 环形移位寄存器\n\n环形移位寄存器是一种特殊移位寄存器——\n移出的一端数据会反馈到另一端，形成一个闭环。\n\n\n# 工作原理：\n\n * 右移：最低位丢掉，高位填入原最高位。\n * 左移：最高位丢掉，最低位填入原最低位。\n\n----------------------------------------\n\n\n# verilog 示例：4位循环右移\n\nmodule shift_reg_ring (\n    input  wire clk,\n    input  wire rst_n,    // 低有效复位\n    input  wire [3:0] d_init, // 初始值\n    output reg  [3:0] d\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            d <= d_init;                // 复位加载初始值\n        else\n            d <= {d[2:0], d[3]};        // 循环右移\n    end\nendmodule\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3. 应用场景\n\n环形移位寄存器在工程中很常见，典型用途有：\n\n 1. 串/并转换 串行输入、并行输出，或反之（常见于串口通信）。\n 2. 序列检测 用移位寄存器保存最近 n 位输入，与目标模式比较。\n 3. 伪随机码生成 配合异或反馈实现 lfsr（线性反馈移位寄存器），用于加密、测试等。\n\n----------------------------------------\n\n\n# 4. 小结\n\n * 移位寄存器就是一组能在时钟下按位搬运数据的触发器。\n * 环形移位寄存器通过反馈实现“首尾相接”的循环移动。\n * 搭配逻辑运算可实现更复杂的功能，如序列识别和伪随机数生成。\n\n> 它是数据的搬运带，也是时序电路的节拍舞者。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"19.Verilog HDL有限状态机（FSM）设计基础",frontmatter:{title:"19.Verilog HDL有限状态机（FSM）设计基础",date:"2025-08-13T15:40:00.000Z",permalink:"/pages/Verilog_19/"},regularPath:"/01.Verilog/19.Verilog%20HDL%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88FSM%EF%BC%89%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html",relativePath:"01.Verilog/19.Verilog HDL有限状态机（FSM）设计基础.md",key:"v-14e5d69d",path:"/pages/Verilog_19/",headers:[{level:2,title:"1. FSM 类型对比",slug:"_1-fsm-类型对比",normalizedTitle:"1. fsm 类型对比",charIndex:27},{level:2,title:"2. 状态编码方式",slug:"_2-状态编码方式",normalizedTitle:"2. 状态编码方式",charIndex:229},{level:2,title:"3. 三段式设计模板",slug:"_3-三段式设计模板",normalizedTitle:"3. 三段式设计模板",charIndex:470},{level:3,title:"Verilog 典型模板示例（Moore机）",slug:"verilog-典型模板示例-moore机",normalizedTitle:"verilog 典型模板示例（moore机）",charIndex:637},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:1641}],headersStr:"1. FSM 类型对比 2. 状态编码方式 3. 三段式设计模板 Verilog 典型模板示例（Moore机） 4. 小结",content:"# 有限状态机（FSM）：数字电路的“大脑”\n\n\n# 1. FSM 类型对比\n\n类型       输出依赖          特点\nMoore机   仅当前状态         输出稳定，无延迟毛刺\nMealy机   当前状态 + 当前输入   响应快，但可能带毛刺（输出跳变）\n\n> Moore机输出只看状态，Mealy机输出对输入敏感，速度快但要注意毛刺问题。\n\n----------------------------------------\n\n\n# 2. 状态编码方式\n\n选择合适的状态编码对面积、速度、设计复杂度影响大：\n\n编码方式   触发器数量     优势\n二进制    log2(N)   占用面积小，资源节约\n独热码    N         速度快，组合逻辑简单\n格雷码    log2(N)   状态切换无毛刺\n\n> 独热码用触发器多，但状态跳变只改变一位，适合高速设计。\n> 格雷码的状态切换避免多位同时跳变，减少毛刺。\n\n----------------------------------------\n\n\n# 3. 三段式设计模板\n\n设计FSM通常分成三步：\n\n 1. 状态寄存器：用时钟更新当前状态。\n 2. 下一状态逻辑：组合逻辑，根据当前状态和输入计算下一状态。\n 3. 输出逻辑：根据当前状态（Moore）或状态+输入（Mealy）产生输出。\n\n----------------------------------------\n\n\n# Verilog 典型模板示例（Moore机）\n\nmodule fsm_example (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    // 状态定义（可用枚举）\n    typedef enum logic [1:0] {\n        S0 = 2'b00,\n        S1 = 2'b01,\n        S2 = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // 1. 状态寄存器更新\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // 2. 下一状态逻辑\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // 3. 输出逻辑（Moore机，输出只和状态相关）\n    always @(*) begin\n        out = 1'b0;\n        if (current_state == S2)\n            out = 1'b1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 小结\n\n * FSM 是数字电路的核心“大脑”，负责状态管理和控制流程。\n * Moore机输出稳定、设计简单；Mealy机响应快，但要注意毛刺。\n * 状态编码选择直接影响设计效率和性能。\n * 三段式设计模板是业界常用的高效设计模式。\n\n> 设计FSM就像搭积木：状态寄存器是基础，下一状态是桥梁，输出逻辑是点睛。",normalizedContent:"# 有限状态机（fsm）：数字电路的“大脑”\n\n\n# 1. fsm 类型对比\n\n类型       输出依赖          特点\nmoore机   仅当前状态         输出稳定，无延迟毛刺\nmealy机   当前状态 + 当前输入   响应快，但可能带毛刺（输出跳变）\n\n> moore机输出只看状态，mealy机输出对输入敏感，速度快但要注意毛刺问题。\n\n----------------------------------------\n\n\n# 2. 状态编码方式\n\n选择合适的状态编码对面积、速度、设计复杂度影响大：\n\n编码方式   触发器数量     优势\n二进制    log2(n)   占用面积小，资源节约\n独热码    n         速度快，组合逻辑简单\n格雷码    log2(n)   状态切换无毛刺\n\n> 独热码用触发器多，但状态跳变只改变一位，适合高速设计。\n> 格雷码的状态切换避免多位同时跳变，减少毛刺。\n\n----------------------------------------\n\n\n# 3. 三段式设计模板\n\n设计fsm通常分成三步：\n\n 1. 状态寄存器：用时钟更新当前状态。\n 2. 下一状态逻辑：组合逻辑，根据当前状态和输入计算下一状态。\n 3. 输出逻辑：根据当前状态（moore）或状态+输入（mealy）产生输出。\n\n----------------------------------------\n\n\n# verilog 典型模板示例（moore机）\n\nmodule fsm_example (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    // 状态定义（可用枚举）\n    typedef enum logic [1:0] {\n        s0 = 2'b00,\n        s1 = 2'b01,\n        s2 = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // 1. 状态寄存器更新\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            current_state <= s0;\n        else\n            current_state <= next_state;\n    end\n\n    // 2. 下一状态逻辑\n    always @(*) begin\n        case (current_state)\n            s0: next_state = in ? s1 : s0;\n            s1: next_state = in ? s2 : s0;\n            s2: next_state = s0;\n            default: next_state = s0;\n        endcase\n    end\n\n    // 3. 输出逻辑（moore机，输出只和状态相关）\n    always @(*) begin\n        out = 1'b0;\n        if (current_state == s2)\n            out = 1'b1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 小结\n\n * fsm 是数字电路的核心“大脑”，负责状态管理和控制流程。\n * moore机输出稳定、设计简单；mealy机响应快，但要注意毛刺。\n * 状态编码选择直接影响设计效率和性能。\n * 三段式设计模板是业界常用的高效设计模式。\n\n> 设计fsm就像搭积木：状态寄存器是基础，下一状态是桥梁，输出逻辑是点睛。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"18.Verilog HDL序列信号发生器",frontmatter:{title:"18.Verilog HDL序列信号发生器",date:"2025-08-13T15:20:00.000Z",permalink:"/pages/Verilog_18/"},regularPath:"/01.Verilog/18.Verilog%20HDL%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8.html",relativePath:"01.Verilog/18.Verilog HDL时序逻辑电路之信号发生器.md",key:"v-3a3d840e",path:"/pages/Verilog_18/",headers:[{level:2,title:"1. 基本概念",slug:"_1-基本概念",normalizedTitle:"1. 基本概念",charIndex:27},{level:2,title:"2. 移位寄存器型",slug:"_2-移位寄存器型",normalizedTitle:"2. 移位寄存器型",charIndex:183},{level:3,title:"Verilog 示例",slug:"verilog-示例",normalizedTitle:"verilog 示例",charIndex:274},{level:2,title:"3. 反馈组合型",slug:"_3-反馈组合型",normalizedTitle:"3. 反馈组合型",charIndex:823},{level:3,title:"Verilog 框架",slug:"verilog-框架",normalizedTitle:"verilog 框架",charIndex:1079},{level:2,title:"4. 计数器型",slug:"_4-计数器型",normalizedTitle:"4. 计数器型",charIndex:1556},{level:3,title:"Verilog 示例",slug:"verilog-示例-2",normalizedTitle:"verilog 示例",charIndex:274},{level:2,title:"5. 小结",slug:"_5-小结",normalizedTitle:"5. 小结",charIndex:2508}],headersStr:"1. 基本概念 2. 移位寄存器型 Verilog 示例 3. 反馈组合型 Verilog 框架 4. 计数器型 Verilog 示例 5. 小结",content:"# 序列信号发生器：数字电路的“节奏编曲器”\n\n\n# 1. 基本概念\n\n序列信号发生器是能按照预设规律产生一串二进制信号的时序电路。\n它常用于通信码型生成、测试波形输出、序列控制等场景。\n\n常见实现方式有三种：\n\n 1. 移位寄存器型\n 2. 反馈组合型\n 3. 计数器型\n\n----------------------------------------\n\n\n# 2. 移位寄存器型\n\n * 原理：把整个序列直接存储在寄存器中，通过移位依次输出。\n * 优点：速度快，实现简单。\n * 缺点：需要较多触发器（存储量大），不适合超长序列。\n\n\n# Verilog 示例\n\nmodule seq_gen_shift #(\n    parameter N = 8          // 序列位数\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [N-1:0] seq_init, // 序列初始值\n    output wire seq_out\n);\n    reg [N-1:0] shift_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_reg <= seq_init;                 // 加载序列\n        else\n            shift_reg <= {shift_reg[N-2:0], shift_reg[N-1]}; // 循环移位\n    end\n\n    assign seq_out = shift_reg[N-1];  // 输出最高位\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 反馈组合型\n\n * 原理：用移位寄存器+组合逻辑反馈实现序列生成。\n\n * 优点：存储量小，可产生长序列（典型如 LFSR）。\n\n * 设计步骤：\n   \n   1. 根据序列长度 M 确定寄存器位数 N。\n   \n   2. 列出状态序表。\n   \n   3. 根据序列规律推导反馈函数。 例如：\n      \n      F = Q3 + Q0·Q1 + Q2·Q3\n      \n      \n      1\n      \n      \n      表示反馈信号由这几个触发器状态组合而成。\n\n\n# Verilog 框架\n\nmodule seq_gen_feedback (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [3:0] Q\n);\n    wire F; // 反馈信号\n\n    assign F = Q[3] | (Q[0] & Q[1]) | (Q[2] & Q[3]); // 示例反馈函数\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q <= 4'b0001;             // 初始状态\n        else\n            Q <= {Q[2:0], F};         // 移位 + 反馈\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 4. 计数器型\n\n * 原理：用计数器按顺序切换状态，然后通过组合逻辑生成所需输出。\n * 优点：实现灵活，可生成任意规律信号。\n * 缺点：对于非常长序列，组合逻辑可能复杂。\n\n\n# Verilog 示例\n\nmodule seq_gen_counter #(\n    parameter M = 8 // 序列长度\n)(\n    input  wire clk,\n    input  wire rst_n,\n    output reg  seq_out\n);\n    reg [$clog2(M)-1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == M-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n\n    // 根据计数值输出序列（示例：预定义8位序列 10110011）\n    always @(*) begin\n        case (cnt)\n            0: seq_out = 1'b1;\n            1: seq_out = 1'b0;\n            2: seq_out = 1'b1;\n            3: seq_out = 1'b1;\n            4: seq_out = 1'b0;\n            5: seq_out = 1'b0;\n            6: seq_out = 1'b1;\n            7: seq_out = 1'b1;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n----------------------------------------\n\n\n# 5. 小结\n\n * 移位寄存器型：直接存储，速度快，占用面积大。\n * 反馈组合型：存储少，可产生长序列，典型应用是 LFSR。\n * 计数器型：灵活，但输出逻辑可能复杂。\n\n> 不同实现方式，就像不同的编曲手法——目标曲子一样，但乐器选择和演奏方式不同。",normalizedContent:"# 序列信号发生器：数字电路的“节奏编曲器”\n\n\n# 1. 基本概念\n\n序列信号发生器是能按照预设规律产生一串二进制信号的时序电路。\n它常用于通信码型生成、测试波形输出、序列控制等场景。\n\n常见实现方式有三种：\n\n 1. 移位寄存器型\n 2. 反馈组合型\n 3. 计数器型\n\n----------------------------------------\n\n\n# 2. 移位寄存器型\n\n * 原理：把整个序列直接存储在寄存器中，通过移位依次输出。\n * 优点：速度快，实现简单。\n * 缺点：需要较多触发器（存储量大），不适合超长序列。\n\n\n# verilog 示例\n\nmodule seq_gen_shift #(\n    parameter n = 8          // 序列位数\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [n-1:0] seq_init, // 序列初始值\n    output wire seq_out\n);\n    reg [n-1:0] shift_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_reg <= seq_init;                 // 加载序列\n        else\n            shift_reg <= {shift_reg[n-2:0], shift_reg[n-1]}; // 循环移位\n    end\n\n    assign seq_out = shift_reg[n-1];  // 输出最高位\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3. 反馈组合型\n\n * 原理：用移位寄存器+组合逻辑反馈实现序列生成。\n\n * 优点：存储量小，可产生长序列（典型如 lfsr）。\n\n * 设计步骤：\n   \n   1. 根据序列长度 m 确定寄存器位数 n。\n   \n   2. 列出状态序表。\n   \n   3. 根据序列规律推导反馈函数。 例如：\n      \n      f = q3 + q0·q1 + q2·q3\n      \n      \n      1\n      \n      \n      表示反馈信号由这几个触发器状态组合而成。\n\n\n# verilog 框架\n\nmodule seq_gen_feedback (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [3:0] q\n);\n    wire f; // 反馈信号\n\n    assign f = q[3] | (q[0] & q[1]) | (q[2] & q[3]); // 示例反馈函数\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 4'b0001;             // 初始状态\n        else\n            q <= {q[2:0], f};         // 移位 + 反馈\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 4. 计数器型\n\n * 原理：用计数器按顺序切换状态，然后通过组合逻辑生成所需输出。\n * 优点：实现灵活，可生成任意规律信号。\n * 缺点：对于非常长序列，组合逻辑可能复杂。\n\n\n# verilog 示例\n\nmodule seq_gen_counter #(\n    parameter m = 8 // 序列长度\n)(\n    input  wire clk,\n    input  wire rst_n,\n    output reg  seq_out\n);\n    reg [$clog2(m)-1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == m-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n\n    // 根据计数值输出序列（示例：预定义8位序列 10110011）\n    always @(*) begin\n        case (cnt)\n            0: seq_out = 1'b1;\n            1: seq_out = 1'b0;\n            2: seq_out = 1'b1;\n            3: seq_out = 1'b1;\n            4: seq_out = 1'b0;\n            5: seq_out = 1'b0;\n            6: seq_out = 1'b1;\n            7: seq_out = 1'b1;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n----------------------------------------\n\n\n# 5. 小结\n\n * 移位寄存器型：直接存储，速度快，占用面积大。\n * 反馈组合型：存储少，可产生长序列，典型应用是 lfsr。\n * 计数器型：灵活，但输出逻辑可能复杂。\n\n> 不同实现方式，就像不同的编曲手法——目标曲子一样，但乐器选择和演奏方式不同。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.线性回归",frontmatter:{title:"01.线性回归",date:"2025-09-17T17:00:49.000Z",permalink:"/pages/DP_01/"},regularPath:"/02.Dp/01.%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html",relativePath:"02.Dp/01.线性回归.md",key:"v-992cc3d6",path:"/pages/DP_01/",headers:[{level:2,title:"线性回归的基本原理",slug:"线性回归的基本原理",normalizedTitle:"线性回归的基本原理",charIndex:87},{level:2,title:"线性模型",slug:"线性模型",normalizedTitle:"线性模型",charIndex:658},{level:2,title:"损失函数",slug:"损失函数",normalizedTitle:"损失函数",charIndex:1525},{level:2,title:"随机梯度下降",slug:"随机梯度下降",normalizedTitle:"随机梯度下降",charIndex:2468}],headersStr:"线性回归的基本原理 线性模型 损失函数 随机梯度下降",content:"# 线性回归\n\n回归（regression）是能为一个或多个自变量与因变量之间关系建模的一类方法。 在自然科学和社会科学领域，回归经常用来表示输入和输出之间的关系。\n\n\n# 线性回归的基本原理\n\n线性回归是最早的一类回归模型，其基于几个简单的假设：\n\n * 假设自变量和因变量之间的关系是线性的， 即 y\\mathbf{y}y 可以表示为 x\\mathbf{x}x 中元素的加权和，这里通常允许包含观测值的一些噪声\n * 任何噪声都比较正常，如遵循正态分布\n\n----------------------------------------\n\n下面阐述一些基本概念： 我们为了开发一个模型，首先要做的就是收集一个真实的数据集。 在机器学习的术语中，\n\n * 该数据集被称为训练数据集(training data set)\n * 每行数据为样本（sample）\n * 试图预测的目标称为标签（label）\n * 预测所需要的自变量称为特征（feature）\n\n通常，我们使用 nnn 来表示数据集中的样本数。对索引为 iii 的样本，其输入表示为\n\nx(i)=[x1(i),x2(i)]⊤ \\mathbf{x}^{(i)} = \\left[ x_1^{(i)}, x_2^{(i)} \\right]^{\\top} x(i)=[x1(i) ,x2(i) ]⊤\n\n对应的标签是 y(i)\\mathbf{y}^{(i)}y(i).\n\n----------------------------------------\n\n\n# 线性模型\n\n如下面的公式：\n\nprice=warea⋅area+wage⋅age+b \\text{price} = w_{\\text{area}} \\cdot \\text{area} + w_{\\text{age}} \\cdot \\text{age} + b price=warea ⋅area+wage ⋅age+b\n\n其中的 wareaw_{\\text{area}}warea 和 wagew_{\\text{age}}wage 称为权重（weight），权重决定了每个特征对我们预测值的影响，b\\mathbf{b}b 称为偏置（bias），偏执是指当所有特征都去值为0时，预测值应该为多少。\n\n在机器学习领域，使用的通常是高维数据集，建模时采用线性代数表示法，下面的三个公式展示了预测结果(y^\\hat{y}y^ ) 与特征的关系，维度依次上升，不过多阐述：\n\ny^=w1x1+⋯+wdxd+b \\hat{y} = w_1x_1 + \\dots + w_dx_d + b y^ =w1 x1 +⋯+wd xd +b\n\nx1,x2,…,xdx_1, x_2, \\dots, x_dx1 ,x2 ,…,xd (单个数据样本的ddd个特征)\n\ny^=w⊤x+b \\hat{y} = \\mathbf{w}^\\top \\mathbf{x} + b y^ =w⊤x+b\n\nx\\mathbf{x}x (单个数据样本的特征向量，包含ddd个特征， x∈Rd\\mathbf{x} \\in \\mathbb{R}^dx∈Rd)\n\ny^=Xw+b \\hat{\\mathbf{y}} = \\mathbf{X}\\mathbf{w} + b y^ =Xw+b\n\nX\\mathbf{X}X（整个数据集的特征矩阵，X∈Rn×d\\mathbf{X} \\in \\mathbb{R}^{n \\times d}X∈Rn×d，其中nnn是样本数，每一行对应一个样本的ddd个特征）\n\n----------------------------------------\n\n\n# 损失函数\n\n在拟合（fit）数据之前，需要确定一个拟合程度的度量，而损失函数(loss function)正好能够量化目标的实际值与预测值之间的差距，通常选择非负数，数值越小表示损失越小，完美时的损失为0.\n\n常用的损失函数是平方误差函数，当样本的预测值为 y^(i)\\hat{y}^{(i)}y^ (i),其相应真实标签为 y(i)y^{(i)}y(i)时，平方误差可以定义为一下公式：\n\nl(i)(w,b)=12(y^(i)−y(i))2 l^{(i)}(\\mathbf{w}, b) = \\frac{1}{2} \\left( \\hat{y}^{(i)} - y^{(i)} \\right)^2 l(i)(w,b)=21 (y^ (i)−y(i))2\n\n由于二次项的固有特性，较大的差异将会导致更大的损失，因此，为了度量模型在整个数据集上的质量，我们需要在训练集 nnn 个样本上的损失值（等价于求和）\n\nL(w,b)=1n∑i=1nl(i)(w,b)=1n∑i=1n12(w⊤x(i)+b−y(i))2 L(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} l^{(i)}(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} \\frac{1}{2} \\left( \\mathbf{w}^\\top \\mathbf{x}^{(i)} + b - y^{(i)} \\right)^2 L(w,b)=n1 i=1∑n l(i)(w,b)=n1 i=1∑n 21 (w⊤x(i)+b−y(i))2\n\n训练模型时，我们最希望的是找一组参数 (w∗,b∗)(\\mathbf{w}^*, b^*)(w∗,b∗)，这组参数能够最小化在所有训练样本上的总损失：\n\nw∗,b∗=argmin⁡w,b L(w,b) \\mathbf{w}^*, b^* = \\underset{\\mathbf{w}, b}{\\operatorname{argmin}} \\ L(\\mathbf{w}, b) w∗,b∗=w,bargmin  L(w,b)\n\n----------------------------------------\n\n\n# 随机梯度下降\n\n梯度下降(gradient descent) 的方法几乎可以优化所有深度学习模型，其通过不断在损失函数递减的方向上更新参数来降低误差。\n\n梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做小批量随机梯度下降（minibatch stochastic gradient descent）。\n\n在每次迭代中，我们首先随机抽样一个小批量B\\mathcal{B}B， 它是由固定数量的训练样本组成的。然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数 η\\etaη，并从当前参数的值中减掉。\n\n下面的数学公式可以表示这一更新过程（∂\\partial∂表示偏导数）：\n\n(w,b)←(w,b)−η∣B∣∑i∈B∂(w,b)l(i)(w,b) (\\mathbf{w}, b) \\leftarrow (\\mathbf{w}, b) - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}} \\partial_{(\\mathbf{w}, b)} l^{(i)}(\\mathbf{w}, b) (w,b)←(w,b)−∣B∣η i∈B∑ ∂(w,b) l(i)(w,b)",normalizedContent:"# 线性回归\n\n回归（regression）是能为一个或多个自变量与因变量之间关系建模的一类方法。 在自然科学和社会科学领域，回归经常用来表示输入和输出之间的关系。\n\n\n# 线性回归的基本原理\n\n线性回归是最早的一类回归模型，其基于几个简单的假设：\n\n * 假设自变量和因变量之间的关系是线性的， 即 y\\mathbf{y}y 可以表示为 x\\mathbf{x}x 中元素的加权和，这里通常允许包含观测值的一些噪声\n * 任何噪声都比较正常，如遵循正态分布\n\n----------------------------------------\n\n下面阐述一些基本概念： 我们为了开发一个模型，首先要做的就是收集一个真实的数据集。 在机器学习的术语中，\n\n * 该数据集被称为训练数据集(training data set)\n * 每行数据为样本（sample）\n * 试图预测的目标称为标签（label）\n * 预测所需要的自变量称为特征（feature）\n\n通常，我们使用 nnn 来表示数据集中的样本数。对索引为 iii 的样本，其输入表示为\n\nx(i)=[x1(i),x2(i)]⊤ \\mathbf{x}^{(i)} = \\left[ x_1^{(i)}, x_2^{(i)} \\right]^{\\top} x(i)=[x1(i) ,x2(i) ]⊤\n\n对应的标签是 y(i)\\mathbf{y}^{(i)}y(i).\n\n----------------------------------------\n\n\n# 线性模型\n\n如下面的公式：\n\nprice=warea⋅area+wage⋅age+b \\text{price} = w_{\\text{area}} \\cdot \\text{area} + w_{\\text{age}} \\cdot \\text{age} + b price=warea ⋅area+wage ⋅age+b\n\n其中的 wareaw_{\\text{area}}warea 和 wagew_{\\text{age}}wage 称为权重（weight），权重决定了每个特征对我们预测值的影响，b\\mathbf{b}b 称为偏置（bias），偏执是指当所有特征都去值为0时，预测值应该为多少。\n\n在机器学习领域，使用的通常是高维数据集，建模时采用线性代数表示法，下面的三个公式展示了预测结果(y^\\hat{y}y^ ) 与特征的关系，维度依次上升，不过多阐述：\n\ny^=w1x1+⋯+wdxd+b \\hat{y} = w_1x_1 + \\dots + w_dx_d + b y^ =w1 x1 +⋯+wd xd +b\n\nx1,x2,…,xdx_1, x_2, \\dots, x_dx1 ,x2 ,…,xd (单个数据样本的ddd个特征)\n\ny^=w⊤x+b \\hat{y} = \\mathbf{w}^\\top \\mathbf{x} + b y^ =w⊤x+b\n\nx\\mathbf{x}x (单个数据样本的特征向量，包含ddd个特征， x∈rd\\mathbf{x} \\in \\mathbb{r}^dx∈rd)\n\ny^=xw+b \\hat{\\mathbf{y}} = \\mathbf{x}\\mathbf{w} + b y^ =xw+b\n\nx\\mathbf{x}x（整个数据集的特征矩阵，x∈rn×d\\mathbf{x} \\in \\mathbb{r}^{n \\times d}x∈rn×d，其中nnn是样本数，每一行对应一个样本的ddd个特征）\n\n----------------------------------------\n\n\n# 损失函数\n\n在拟合（fit）数据之前，需要确定一个拟合程度的度量，而损失函数(loss function)正好能够量化目标的实际值与预测值之间的差距，通常选择非负数，数值越小表示损失越小，完美时的损失为0.\n\n常用的损失函数是平方误差函数，当样本的预测值为 y^(i)\\hat{y}^{(i)}y^ (i),其相应真实标签为 y(i)y^{(i)}y(i)时，平方误差可以定义为一下公式：\n\nl(i)(w,b)=12(y^(i)−y(i))2 l^{(i)}(\\mathbf{w}, b) = \\frac{1}{2} \\left( \\hat{y}^{(i)} - y^{(i)} \\right)^2 l(i)(w,b)=21 (y^ (i)−y(i))2\n\n由于二次项的固有特性，较大的差异将会导致更大的损失，因此，为了度量模型在整个数据集上的质量，我们需要在训练集 nnn 个样本上的损失值（等价于求和）\n\nl(w,b)=1n∑i=1nl(i)(w,b)=1n∑i=1n12(w⊤x(i)+b−y(i))2 l(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} l^{(i)}(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} \\frac{1}{2} \\left( \\mathbf{w}^\\top \\mathbf{x}^{(i)} + b - y^{(i)} \\right)^2 l(w,b)=n1 i=1∑n l(i)(w,b)=n1 i=1∑n 21 (w⊤x(i)+b−y(i))2\n\n训练模型时，我们最希望的是找一组参数 (w∗,b∗)(\\mathbf{w}^*, b^*)(w∗,b∗)，这组参数能够最小化在所有训练样本上的总损失：\n\nw∗,b∗=argmin⁡w,b l(w,b) \\mathbf{w}^*, b^* = \\underset{\\mathbf{w}, b}{\\operatorname{argmin}} \\ l(\\mathbf{w}, b) w∗,b∗=w,bargmin  l(w,b)\n\n----------------------------------------\n\n\n# 随机梯度下降\n\n梯度下降(gradient descent) 的方法几乎可以优化所有深度学习模型，其通过不断在损失函数递减的方向上更新参数来降低误差。\n\n梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做小批量随机梯度下降（minibatch stochastic gradient descent）。\n\n在每次迭代中，我们首先随机抽样一个小批量b\\mathcal{b}b， 它是由固定数量的训练样本组成的。然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数 η\\etaη，并从当前参数的值中减掉。\n\n下面的数学公式可以表示这一更新过程（∂\\partial∂表示偏导数）：\n\n(w,b)←(w,b)−η∣b∣∑i∈b∂(w,b)l(i)(w,b) (\\mathbf{w}, b) \\leftarrow (\\mathbf{w}, b) - \\frac{\\eta}{|\\mathcal{b}|} \\sum_{i \\in \\mathcal{b}} \\partial_{(\\mathbf{w}, b)} l^{(i)}(\\mathbf{w}, b) (w,b)←(w,b)−∣b∣η i∈b∑ ∂(w,b) l(i)(w,b)",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.SoftMax回归",frontmatter:{title:"02.SoftMax回归",date:"2025-09-17T17:00:49.000Z",permalink:"/pages/DP_02/"},regularPath:"/02.Dp/02.SoftMax%E5%9B%9E%E5%BD%92.html",relativePath:"02.Dp/02.SoftMax回归.md",key:"v-72530f3f",path:"/pages/DP_02/",headers:[{level:2,title:"分类问题",slug:"分类问题",normalizedTitle:"分类问题",charIndex:17},{level:2,title:"网络架构",slug:"网络架构",normalizedTitle:"网络架构",charIndex:375},{level:2,title:"softmax运算",slug:"softmax运算",normalizedTitle:"softmax运算",charIndex:491},{level:2,title:"小批量样本的矢量化",slug:"小批量样本的矢量化",normalizedTitle:"小批量样本的矢量化",charIndex:867},{level:2,title:"交叉熵损失函数",slug:"交叉熵损失函数",normalizedTitle:"交叉熵损失函数",charIndex:1338},{level:2,title:"softmax的导数",slug:"softmax的导数",normalizedTitle:"softmax的导数",charIndex:1753}],headersStr:"分类问题 网络架构 softmax运算 小批量样本的矢量化 交叉熵损失函数 softmax的导数",content:"# SoftMax 回归\n\n\n# 分类问题\n\n独热编码（one-hot encodeing):一个向量，其分量和类别一样多。类别对应的分量为1，其他分量为0.\n\n举一个最简单的例子，我们分类各种瓜，标签 yyy 将会是一个三维向量，其中(⃗1,0,0)\\vec (1,0,0)( 1,0,0)对应“冬瓜”，(0,1,0)(0,1,0)(0,1,0)对应“西瓜”，(0,0,1)(0,0,1)(0,0,1)对应“傻瓜”，\n\ny∈{(1,0,0),(0,1,0),(0,0,1)(Eq. 2.1) y \\in \\{(1,0,0),(0,1,0),(0,0,1)\\tag {Eq. 2.1} y∈{(1,0,0),(0,1,0),(0,0,1)(Eq. 2.1)\n\n----------------------------------------\n\n\n# 网络架构\n\nsoftmax回归是一个单层神经网络，同时也是全连接层，如下图，计算输出o1o_1o1 、o2o_2o2 和o3o3o3取决于所有输入x1x_1x1 、x2x_2x2 、x3x_3x3 、x4x_4x4 .\n\n\n\n\n# softmax运算\n\nsoftmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质，如下式：\n\ny^=softmax(o)其中y^j=exp⁡(oj)∑kexp⁡(ok)(Eq. 2.2) \\hat{\\mathbf{y}} = \\text{softmax}(\\mathbf{o}) \\quad \\text{其中} \\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)} \\tag{Eq. 2.2} y^ =softmax(o)其中y^ j =∑k exp(ok )exp(oj ) (Eq. 2.2)\n\n上式中对于所有的jjj总会有0≤y^j≤10 \\leq \\hat{y}_j \\leq 10≤y^ j ≤1，因此，y^\\hat{y}y^ 是一个正确的概率分布。\n\n\n# 小批量样本的矢量化\n\n可以假设我们读取了一个批量的样本 X\\mathbf{X}X,其中特征维度（输入数量）为ddd, 批量大小为nnn, 输出中有qqq个类别。则小批量样本的特征为X∈Rn×d\\mathbf{X} \\in \\mathbb{R}^{n \\times d}X∈Rn×d，权重为W∈Rd×q\\mathbf{W} \\in \\mathbb{R}^{d \\times q}W∈Rd×q,偏置为b∈R1×q\\mathbf{b} \\in \\mathbb{R}^{1 \\times q}b∈R1×q,softmax的矢量计算表达式为：\n\nO=XW+b,Y^=softmax(O).(Eq. 2,3) \\begin{aligned} \\mathbf{O} &= \\mathbf{XW} + \\mathbf{b}, \\\\ \\hat{\\mathbf{Y}} &= \\text{softmax}(\\mathbf{O}). \\end{aligned} \\tag{Eq. 2,3} OY^ =XW+b,=softmax(O). (Eq. 2,3)\n\n\n# 交叉熵损失函数\n\nsoftmax给出了一个向量y^\\hat {y}y^ , 通俗地说，它就是一个条件概率，表示给定任意输入xxx的每个类的条件概率，举个例子：\n\ny^3=P(y=傻瓜∣x)(Eq. 2.4) \\hat {y}_3 = P(y = \\text{傻瓜} \\mid \\mathbf{x}) \\tag{Eq. 2.4} y^ 3 =P(y=傻瓜∣x)(Eq. 2.4)\n\n根据最大似然估计法（中间省略很多内容），就可以得到下面的损失函数，对于标签yyy和模型预测y^\\hat {y}y^ ,其表达式为：\n\nl(y,y^)=−∑j=1qyjlog⁡y^j(Eq. 2.5) l(\\mathbf{y}, \\hat{\\mathbf{y}}) = -\\sum_{j=1}^{q} y_j \\log \\hat{y}_j \\tag {Eq. 2.5} l(y,y^ )=−j=1∑q yj logy^ j (Eq. 2.5)\n\n\n# softmax的导数\n\n将 Eq. 2.2 代入 Eq. 2.5 ，同时根据softmax和独热编码的定义，我们得到：\n\nl(y,y^)=−∑j=1qyjlog⁡exp⁡(oj)∑k=1qexp⁡(ok)=∑j=1qyjlog⁡∑k=1qexp⁡(ok)−∑j=1qyjoj=log⁡∑k=1qexp⁡(ok)−∑j=1qyjoj(Eq. 2.6) \\begin{aligned} l(\\mathbf{y}, \\hat{\\mathbf{y}}) &= -\\sum_{j=1}^{q} y_j \\log \\frac{\\exp(o_j)}{\\sum_{k=1}^{q} \\exp(o_k)} \\\\ &= \\sum_{j=1}^{q} y_j \\log \\sum_{k=1}^{q} \\exp(o_k) - \\sum_{j=1}^{q} y_j o_j \\\\ &= \\log \\sum_{k=1}^{q} \\exp(o_k) - \\sum_{j=1}^{q} y_j o_j \\end{aligned} \\tag {Eq. 2.6} l(y,y^ ) =−j=1∑q yj log∑k=1q exp(ok )exp(oj ) =j=1∑q yj logk=1∑q exp(ok )−j=1∑q yj oj =logk=1∑q exp(ok )−j=1∑q yj oj (Eq. 2.6)\n\n接下来是softmax的导数，相较于任何未规范化的预测ojo_joj 的导数：\n\n∂ojl(y,y^)=exp⁡(oj)∑k=1qexp⁡(ok)−yj=softmax(o)j−yj(Eq. 2.7) \\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^{q} \\exp(o_k)} - y_j = \\text{softmax}(\\mathbf{o})_j - y_j \\tag {Eq. 2.7} ∂oj l(y,y^ )=∑k=1q exp(ok )exp(oj ) −yj =softmax(o)j −yj (Eq. 2.7)",normalizedContent:"# softmax 回归\n\n\n# 分类问题\n\n独热编码（one-hot encodeing):一个向量，其分量和类别一样多。类别对应的分量为1，其他分量为0.\n\n举一个最简单的例子，我们分类各种瓜，标签 yyy 将会是一个三维向量，其中(⃗1,0,0)\\vec (1,0,0)( 1,0,0)对应“冬瓜”，(0,1,0)(0,1,0)(0,1,0)对应“西瓜”，(0,0,1)(0,0,1)(0,0,1)对应“傻瓜”，\n\ny∈{(1,0,0),(0,1,0),(0,0,1)(eq. 2.1) y \\in \\{(1,0,0),(0,1,0),(0,0,1)\\tag {eq. 2.1} y∈{(1,0,0),(0,1,0),(0,0,1)(eq. 2.1)\n\n----------------------------------------\n\n\n# 网络架构\n\nsoftmax回归是一个单层神经网络，同时也是全连接层，如下图，计算输出o1o_1o1 、o2o_2o2 和o3o3o3取决于所有输入x1x_1x1 、x2x_2x2 、x3x_3x3 、x4x_4x4 .\n\n\n\n\n# softmax运算\n\nsoftmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质，如下式：\n\ny^=softmax(o)其中y^j=exp⁡(oj)∑kexp⁡(ok)(eq. 2.2) \\hat{\\mathbf{y}} = \\text{softmax}(\\mathbf{o}) \\quad \\text{其中} \\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)} \\tag{eq. 2.2} y^ =softmax(o)其中y^ j =∑k exp(ok )exp(oj ) (eq. 2.2)\n\n上式中对于所有的jjj总会有0≤y^j≤10 \\leq \\hat{y}_j \\leq 10≤y^ j ≤1，因此，y^\\hat{y}y^ 是一个正确的概率分布。\n\n\n# 小批量样本的矢量化\n\n可以假设我们读取了一个批量的样本 x\\mathbf{x}x,其中特征维度（输入数量）为ddd, 批量大小为nnn, 输出中有qqq个类别。则小批量样本的特征为x∈rn×d\\mathbf{x} \\in \\mathbb{r}^{n \\times d}x∈rn×d，权重为w∈rd×q\\mathbf{w} \\in \\mathbb{r}^{d \\times q}w∈rd×q,偏置为b∈r1×q\\mathbf{b} \\in \\mathbb{r}^{1 \\times q}b∈r1×q,softmax的矢量计算表达式为：\n\no=xw+b,y^=softmax(o).(eq. 2,3) \\begin{aligned} \\mathbf{o} &= \\mathbf{xw} + \\mathbf{b}, \\\\ \\hat{\\mathbf{y}} &= \\text{softmax}(\\mathbf{o}). \\end{aligned} \\tag{eq. 2,3} oy^ =xw+b,=softmax(o). (eq. 2,3)\n\n\n# 交叉熵损失函数\n\nsoftmax给出了一个向量y^\\hat {y}y^ , 通俗地说，它就是一个条件概率，表示给定任意输入xxx的每个类的条件概率，举个例子：\n\ny^3=p(y=傻瓜∣x)(eq. 2.4) \\hat {y}_3 = p(y = \\text{傻瓜} \\mid \\mathbf{x}) \\tag{eq. 2.4} y^ 3 =p(y=傻瓜∣x)(eq. 2.4)\n\n根据最大似然估计法（中间省略很多内容），就可以得到下面的损失函数，对于标签yyy和模型预测y^\\hat {y}y^ ,其表达式为：\n\nl(y,y^)=−∑j=1qyjlog⁡y^j(eq. 2.5) l(\\mathbf{y}, \\hat{\\mathbf{y}}) = -\\sum_{j=1}^{q} y_j \\log \\hat{y}_j \\tag {eq. 2.5} l(y,y^ )=−j=1∑q yj logy^ j (eq. 2.5)\n\n\n# softmax的导数\n\n将 eq. 2.2 代入 eq. 2.5 ，同时根据softmax和独热编码的定义，我们得到：\n\nl(y,y^)=−∑j=1qyjlog⁡exp⁡(oj)∑k=1qexp⁡(ok)=∑j=1qyjlog⁡∑k=1qexp⁡(ok)−∑j=1qyjoj=log⁡∑k=1qexp⁡(ok)−∑j=1qyjoj(eq. 2.6) \\begin{aligned} l(\\mathbf{y}, \\hat{\\mathbf{y}}) &= -\\sum_{j=1}^{q} y_j \\log \\frac{\\exp(o_j)}{\\sum_{k=1}^{q} \\exp(o_k)} \\\\ &= \\sum_{j=1}^{q} y_j \\log \\sum_{k=1}^{q} \\exp(o_k) - \\sum_{j=1}^{q} y_j o_j \\\\ &= \\log \\sum_{k=1}^{q} \\exp(o_k) - \\sum_{j=1}^{q} y_j o_j \\end{aligned} \\tag {eq. 2.6} l(y,y^ ) =−j=1∑q yj log∑k=1q exp(ok )exp(oj ) =j=1∑q yj logk=1∑q exp(ok )−j=1∑q yj oj =logk=1∑q exp(ok )−j=1∑q yj oj (eq. 2.6)\n\n接下来是softmax的导数，相较于任何未规范化的预测ojo_joj 的导数：\n\n∂ojl(y,y^)=exp⁡(oj)∑k=1qexp⁡(ok)−yj=softmax(o)j−yj(eq. 2.7) \\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^{q} \\exp(o_k)} - y_j = \\text{softmax}(\\mathbf{o})_j - y_j \\tag {eq. 2.7} ∂oj l(y,y^ )=∑k=1q exp(ok )exp(oj ) −yj =softmax(o)j −yj (eq. 2.7)",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.多层感知机",frontmatter:{title:"03.多层感知机",date:"2025-09-17T17:00:49.000Z",permalink:"/pages/DP_03/"},regularPath:"/02.Dp/03.%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA.html",relativePath:"02.Dp/03.多层感知机.md",key:"v-0f7eb5cf",path:"/pages/DP_03/",headers:[{level:2,title:"隐藏层",slug:"隐藏层",normalizedTitle:"隐藏层",charIndex:12},{level:2,title:"激活函数",slug:"激活函数",normalizedTitle:"激活函数",charIndex:195},{level:3,title:"ReLU函数",slug:"relu函数",normalizedTitle:"relu函数",charIndex:291},{level:3,title:"sigmoid函数",slug:"sigmoid函数",normalizedTitle:"sigmoid函数",charIndex:508},{level:3,title:"tanh函数",slug:"tanh函数",normalizedTitle:"tanh函数",charIndex:1195},{level:2,title:"模型选择、欠拟合与过拟合",slug:"模型选择、欠拟合与过拟合",normalizedTitle:"模型选择、欠拟合与过拟合",charIndex:1640},{level:2,title:"权重衰减（Weight Decay / L2 正则化）",slug:"权重衰减-weight-decay-l2-正则化",normalizedTitle:"权重衰减（weight decay / l2 正则化）",charIndex:2078},{level:2,title:"暂退法（Dropout）",slug:"暂退法-dropout",normalizedTitle:"暂退法（dropout）",charIndex:2587},{level:2,title:"4.7 前向传播、反向传播与计算图",slug:"_4-7-前向传播、反向传播与计算图",normalizedTitle:"4.7 前向传播、反向传播与计算图",charIndex:3068},{level:3,title:"前向传播（Forward Propagation）",slug:"前向传播-forward-propagation",normalizedTitle:"前向传播（forward propagation）",charIndex:3090},{level:3,title:"反向传播（Backpropagation）",slug:"反向传播-backpropagation",normalizedTitle:"反向传播（backpropagation）",charIndex:3415},{level:3,title:"计算图（Computational Graph）",slug:"计算图-computational-graph",normalizedTitle:"计算图（computational graph）",charIndex:3674},{level:2,title:"4.8 数值稳定性与模型初始化",slug:"_4-8-数值稳定性与模型初始化",normalizedTitle:"4.8 数值稳定性与模型初始化",charIndex:3876},{level:3,title:"梯度消失",slug:"梯度消失",normalizedTitle:"梯度消失",charIndex:3908},{level:3,title:"梯度爆炸",slug:"梯度爆炸",normalizedTitle:"梯度爆炸",charIndex:3915},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:4062},{level:2,title:"环境与分布偏移",slug:"环境与分布偏移",normalizedTitle:"环境与分布偏移",charIndex:4609},{level:3,title:"什么是分布偏移",slug:"什么是分布偏移",normalizedTitle:"什么是分布偏移",charIndex:4621},{level:3,title:"类型",slug:"类型",normalizedTitle:"类型",charIndex:4693},{level:3,title:"应对方法",slug:"应对方法",normalizedTitle:"应对方法",charIndex:1880}],headersStr:"隐藏层 激活函数 ReLU函数 sigmoid函数 tanh函数 模型选择、欠拟合与过拟合 权重衰减（Weight Decay / L2 正则化） 暂退法（Dropout） 4.7 前向传播、反向传播与计算图 前向传播（Forward Propagation） 反向传播（Backpropagation） 计算图（Computational Graph） 4.8 数值稳定性与模型初始化 梯度消失 梯度爆炸 解决方法 环境与分布偏移 什么是分布偏移 类型 应对方法",content:"# 多层感知机\n\n\n# 隐藏层\n\n线性模型可能会出错，因此，我们需要在模型中加入隐藏层来增强模型与数据集的拟合。\n\n最简单的方法是将许多的全连接层堆叠在一起，每一层都输出到上面的层，直到生成最后的输出，可以把前 L−1L -1L−1 层看作表示，把最后一层看作线性预测器，这种架构通常称为多层感知机（multiayer perceptron),通常缩写为 MLP，如下图所示：\n\n\n\n\n# 激活函数\n\n激活函数（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。\n\n\n# ReLU函数\n\n修正线性单元（Rectified linear unit，ReLU）\n\nReLU(x)=max⁡(x,0)(Eq. 3.1) ReLU(x) = \\max(x, 0) \\tag{Eq. 3.1} ReLU(x)=max(x,0)(Eq. 3.1)\n\nReLU函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素，图像图下 当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1\n\n\n\n\n# sigmoid函数\n\n对于一个定义域在 R\\mathbb{R}R 中的输入， sigmoid函数将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为挤压函数（squashing function）： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值：\n\nsigmoid(x)=11+exp⁡(−x)(Eq. 3.2) \\text{sigmoid}(x) = \\frac{1}{1 + \\exp(-x)} \\tag{Eq. 3.2} sigmoid(x)=1+exp(−x)1 (Eq. 3.2)\n\nsigmoid函数在二分类问题上仍被广泛使用，但是在隐藏层中已经较少使用\n\n其图像图下： sigmoid函数的导数为下面的公式：\n\nddxsigmoid(x)=exp⁡(−x)(1+exp⁡(−x))2=sigmoid(x)(1−sigmoid(x))(Eq. 3.3) \\frac{d}{dx}\\text{sigmoid}(x) = \\frac{\\exp(-x)}{\\left(1 + \\exp(-x)\\right)^2} = \\text{sigmoid}(x)\\left(1 - \\text{sigmoid}(x)\\right) \\tag{Eq. 3.3} dxd sigmoid(x)=(1+exp(−x))2exp(−x) =sigmoid(x)(1−sigmoid(x))(Eq. 3.3)\n\n当输入为 000 时，sigmoid函数的导数达到最大值0.25，但在任意方向越远离 000 时，导数越接近 000\n\n\n\n\n# tanh函数\n\ntanh为双曲正切函数，也能将输入压缩转换到区间 (−1,1)(-1,1)(−1,1) 上，其公式如下：\n\ntanh⁡(x)=1−exp⁡(−2x)1+exp⁡(−2x)(Eq. 3.4) \\tanh(x) = \\frac{1 - \\exp(-2x)}{1 + \\exp(-2x)} \\tag{Eq. 3.4} tanh(x)=1+exp(−2x)1−exp(−2x) (Eq. 3.4)\n\n当输入在 000 附近时，tanh函数接近线性变换，其图像如下：\n\ntanh的导数为：\n\nddxtanh⁡(x)=1−tanh⁡2(x)(Eq. 3.5) \\frac{d}{dx}\\tanh(x) = 1 - \\tanh^2(x) \\tag{Eq. 3.5} dxd tanh(x)=1−tanh2(x)(Eq. 3.5)\n\n当输入接近 000 时，tanh函数的导数皆尽最大值 111，输入在任意方向上原理 000 点,导数越接近 000\n\ntanh的导数图像如下：\n\n\n\n\n# 模型选择、欠拟合与过拟合\n\n在训练神经网络时，我们关心的不仅仅是训练集上的表现，而是模型在新数据上的泛化能力。\n\n * 训练误差（training error）：模型在训练集上的误差。\n * 泛化误差（generalization error）：模型在测试集或新数据上的误差。\n\n如果模型太简单，它连训练集都学不好，这叫 欠拟合（underfitting）。\n如果模型太复杂，它可能把训练数据中的噪音也记住了，导致测试集效果变差，这叫 过拟合（overfitting）。\n\n常见的应对方法：\n\n * 欠拟合：增加模型复杂度（更多层、更多隐藏单元）、训练更久、增加特征。\n * 过拟合：加入正则化（如权重衰减、Dropout）、增加数据量或数据增强、提前停止（early stopping）。\n\n在模型选择过程中，通常会用 验证集 或 交叉验证 来估计泛化误差，帮助选择更合适的模型。\n\n----------------------------------------\n\n\n# 权重衰减（Weight Decay / L2 正则化）\n\n思想：在损失函数中对模型参数的大小进行惩罚，防止权重过大，从而缓解过拟合。\n\n修改后的损失函数形式为：\n\nL′=L+λ2∥w∥22 L' = L + \\frac{\\lambda}{2} \\| \\mathbf{w} \\|_2^2 L′=L+2λ ∥w∥22\n\n其中：\n\n * LLL 是原始损失函数（如均方误差）。\n * λ\\lambdaλ 是正则化强度（超参数）。\n * ∣∣w∥22=∑iwi2|| \\mathbf{w} \\|_2^2 = \\sum_i w_i^2∣∣w∥22 =∑i wi2 表示权重平方和。\n\n直观理解：\n\n * 如果参数过大，就会增加损失，促使优化器把参数控制在较小范围内。\n * 权重衰减可以让模型更平滑，不容易记住训练数据的噪声。\n\n除了 L2 正则化，还有 L1 正则化：\n\nL′=L+λ∥w∥1 L' = L + \\lambda \\| \\mathbf{w} \\|_1 L′=L+λ∥w∥1\n\n它会使得权重稀疏（很多参数直接变成 0）。\n\n----------------------------------------\n\n\n# 暂退法（Dropout）\n\n思想：在训练过程中，随机“屏蔽”一部分神经元，让网络在不同的子网络上训练，从而减少过拟合。\n\n具体做法：\n\n * 在训练时，以概率 (p) 将某些神经元的输出置零。\n * 在测试时，使用完整网络，但将输出按比例缩放，以保证期望一致。\n\n数学形式（训练阶段）：\n\nhi′={0,以概率 phi1−p,以概率 (1−p) h_i' = \\begin{cases} 0, & \\text{以概率 } p \\\\ \\frac{h_i}{1-p}, & \\text{以概率 } (1-p) \\end{cases} hi′ ={0,1−phi , 以概率 p以概率 (1−p)\n\n其中 hi\\mathbf{h_i}hi 是神经元原始输出，hi′\\mathbf{h}_{i}^{'}hi′ 是 Dropout 后的输出。\n\n直观理解：\n\n * Dropout 相当于“给模型加噪音”，迫使它不依赖某个特定神经元。\n * 最终效果是减少过拟合，提高泛化能力。\n\n----------------------------------------\n\n\n# 4.7 前向传播、反向传播与计算图\n\n\n# 前向传播（Forward Propagation）\n\n数据从输入层开始，依次通过隐藏层，最后输出预测结果。\n例如单隐层网络：\n\nh=σ(W1x+b1) \\mathbf{h} = \\sigma(\\mathbf{W}_1 \\mathbf{x} + \\mathbf{b}_1) h=σ(W1 x+b1 )\no=W2h+b2 \\mathbf{o} = \\mathbf{W}_2 \\mathbf{h} + \\mathbf{b}_2 o=W2 h+b2\n\n其中：\n\n * x\\mathbf{x}x 是输入，h\\mathbf{h}h 是隐藏层输出，o\\mathbf{o}o $是最终输出。\n * σ(⋅)\\sigma(\\cdot)σ(⋅) 表示激活函数。\n\n\n# 反向传播（Backpropagation）\n\n为了更新参数，我们需要计算损失函数对每一层参数的梯度。\n梯度通过链式法则逐层传回：\n\n∂L∂W1=∂L∂h⋅∂h∂W1 \\frac{\\partial L}{\\partial \\mathbf{W}_1} = \\frac{\\partial L}{\\partial \\mathbf{h}} \\cdot \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{W}_1} ∂W1 ∂L =∂h∂L ⋅∂W1 ∂h\n\n这个过程就是反向传播。\n\n\n# 计算图（Computational Graph）\n\n神经网络的计算可以表示为一个有向图：\n\n * 节点：运算（如加、乘、激活）。\n * 边：张量（数据流）。\n\n前向传播：数据在图中“前进”。\n反向传播：梯度在图中“反传”。\n\n深度学习框架（PyTorch、TensorFlow）就是基于计算图自动完成反向传播。\n\n----------------------------------------\n\n\n# 4.8 数值稳定性与模型初始化\n\n在训练深层网络时，经常会遇到 梯度消失 或 梯度爆炸 问题。\n\n\n# 梯度消失\n\n * 当使用 Sigmoid/Tanh 等激活函数时，深层传播会让梯度趋近于 0。\n * 结果：前面几层参数几乎不更新。\n\n\n# 梯度爆炸\n\n * 如果权重过大或层数过深，梯度在传播过程中会指数级增大。\n * 结果：参数震荡、loss 无法收敛。\n\n\n# 解决方法\n\n 1. 合适的激活函数\n    \n    * ReLU 能缓解梯度消失问题。\n\n 2. 参数初始化方法\n    \n    * Xavier/Glorot 初始化（适合 Sigmoid/Tanh）:\n      \n      w∼U(−6nin+nout,6nin+nout) w \\sim U\\left(-\\sqrt{\\frac{6}{n_\\text{in} + n_\\text{out}}}, \\sqrt{\\frac{6}{n_\\text{in} + n_\\text{out}}}\\right) w∼U(−nin +nout 6 ,nin +nout 6 )\n      \n      保证前后层输出方差一致。\n    \n    * He 初始化（适合 ReLU）：\n      \n      w∼N(0,2nin) w \\sim \\mathcal{N}\\left(0, \\frac{2}{n_\\text{in}}\\right) w∼N(0,nin 2 )\n\n 3. 梯度裁剪（Gradient Clipping）\n    \n    * 如果梯度过大，可以强行限制其大小，避免数值爆炸。\n\n----------------------------------------\n\n\n# 环境与分布偏移\n\n\n# 什么是分布偏移\n\n * 如果训练数据和测试数据分布不同，模型的泛化能力会下降，这叫 分布偏移（distribution shift）。\n\n\n# 类型\n\n 1. 协变量偏移（Covariate Shift）\n    \n    * 输入分布变了，但条件分布 (P(y|x)) 不变。\n    * 例如：训练图片很清晰，测试图片有噪声。\n\n 2. 标签偏移（Label Shift）\n    \n    * 标签的分布变了。\n    * 例如：训练集中猫狗各 50%，测试集里猫占 90%。\n\n 3. 概念偏移（Concept Shift）\n    \n    * 输入和输出的映射关系变了。\n    * 例如：医学诊断标准更新。\n\n\n# 应对方法\n\n * 数据增强，让训练数据更接近真实场景。\n * 收集更多与实际环境匹配的数据。\n * 迁移学习，把在一个任务上学到的知识迁移到另一个任务上。\n\n----------------------------------------",normalizedContent:"# 多层感知机\n\n\n# 隐藏层\n\n线性模型可能会出错，因此，我们需要在模型中加入隐藏层来增强模型与数据集的拟合。\n\n最简单的方法是将许多的全连接层堆叠在一起，每一层都输出到上面的层，直到生成最后的输出，可以把前 l−1l -1l−1 层看作表示，把最后一层看作线性预测器，这种架构通常称为多层感知机（multiayer perceptron),通常缩写为 mlp，如下图所示：\n\n\n\n\n# 激活函数\n\n激活函数（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。\n\n\n# relu函数\n\n修正线性单元（rectified linear unit，relu）\n\nrelu(x)=max⁡(x,0)(eq. 3.1) relu(x) = \\max(x, 0) \\tag{eq. 3.1} relu(x)=max(x,0)(eq. 3.1)\n\nrelu函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素，图像图下 当输入为负时，relu函数的导数为0，而当输入为正时，relu函数的导数为1\n\n\n\n\n# sigmoid函数\n\n对于一个定义域在 r\\mathbb{r}r 中的输入， sigmoid函数将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为挤压函数（squashing function）： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值：\n\nsigmoid(x)=11+exp⁡(−x)(eq. 3.2) \\text{sigmoid}(x) = \\frac{1}{1 + \\exp(-x)} \\tag{eq. 3.2} sigmoid(x)=1+exp(−x)1 (eq. 3.2)\n\nsigmoid函数在二分类问题上仍被广泛使用，但是在隐藏层中已经较少使用\n\n其图像图下： sigmoid函数的导数为下面的公式：\n\nddxsigmoid(x)=exp⁡(−x)(1+exp⁡(−x))2=sigmoid(x)(1−sigmoid(x))(eq. 3.3) \\frac{d}{dx}\\text{sigmoid}(x) = \\frac{\\exp(-x)}{\\left(1 + \\exp(-x)\\right)^2} = \\text{sigmoid}(x)\\left(1 - \\text{sigmoid}(x)\\right) \\tag{eq. 3.3} dxd sigmoid(x)=(1+exp(−x))2exp(−x) =sigmoid(x)(1−sigmoid(x))(eq. 3.3)\n\n当输入为 000 时，sigmoid函数的导数达到最大值0.25，但在任意方向越远离 000 时，导数越接近 000\n\n\n\n\n# tanh函数\n\ntanh为双曲正切函数，也能将输入压缩转换到区间 (−1,1)(-1,1)(−1,1) 上，其公式如下：\n\ntanh⁡(x)=1−exp⁡(−2x)1+exp⁡(−2x)(eq. 3.4) \\tanh(x) = \\frac{1 - \\exp(-2x)}{1 + \\exp(-2x)} \\tag{eq. 3.4} tanh(x)=1+exp(−2x)1−exp(−2x) (eq. 3.4)\n\n当输入在 000 附近时，tanh函数接近线性变换，其图像如下：\n\ntanh的导数为：\n\nddxtanh⁡(x)=1−tanh⁡2(x)(eq. 3.5) \\frac{d}{dx}\\tanh(x) = 1 - \\tanh^2(x) \\tag{eq. 3.5} dxd tanh(x)=1−tanh2(x)(eq. 3.5)\n\n当输入接近 000 时，tanh函数的导数皆尽最大值 111，输入在任意方向上原理 000 点,导数越接近 000\n\ntanh的导数图像如下：\n\n\n\n\n# 模型选择、欠拟合与过拟合\n\n在训练神经网络时，我们关心的不仅仅是训练集上的表现，而是模型在新数据上的泛化能力。\n\n * 训练误差（training error）：模型在训练集上的误差。\n * 泛化误差（generalization error）：模型在测试集或新数据上的误差。\n\n如果模型太简单，它连训练集都学不好，这叫 欠拟合（underfitting）。\n如果模型太复杂，它可能把训练数据中的噪音也记住了，导致测试集效果变差，这叫 过拟合（overfitting）。\n\n常见的应对方法：\n\n * 欠拟合：增加模型复杂度（更多层、更多隐藏单元）、训练更久、增加特征。\n * 过拟合：加入正则化（如权重衰减、dropout）、增加数据量或数据增强、提前停止（early stopping）。\n\n在模型选择过程中，通常会用 验证集 或 交叉验证 来估计泛化误差，帮助选择更合适的模型。\n\n----------------------------------------\n\n\n# 权重衰减（weight decay / l2 正则化）\n\n思想：在损失函数中对模型参数的大小进行惩罚，防止权重过大，从而缓解过拟合。\n\n修改后的损失函数形式为：\n\nl′=l+λ2∥w∥22 l' = l + \\frac{\\lambda}{2} \\| \\mathbf{w} \\|_2^2 l′=l+2λ ∥w∥22\n\n其中：\n\n * lll 是原始损失函数（如均方误差）。\n * λ\\lambdaλ 是正则化强度（超参数）。\n * ∣∣w∥22=∑iwi2|| \\mathbf{w} \\|_2^2 = \\sum_i w_i^2∣∣w∥22 =∑i wi2 表示权重平方和。\n\n直观理解：\n\n * 如果参数过大，就会增加损失，促使优化器把参数控制在较小范围内。\n * 权重衰减可以让模型更平滑，不容易记住训练数据的噪声。\n\n除了 l2 正则化，还有 l1 正则化：\n\nl′=l+λ∥w∥1 l' = l + \\lambda \\| \\mathbf{w} \\|_1 l′=l+λ∥w∥1\n\n它会使得权重稀疏（很多参数直接变成 0）。\n\n----------------------------------------\n\n\n# 暂退法（dropout）\n\n思想：在训练过程中，随机“屏蔽”一部分神经元，让网络在不同的子网络上训练，从而减少过拟合。\n\n具体做法：\n\n * 在训练时，以概率 (p) 将某些神经元的输出置零。\n * 在测试时，使用完整网络，但将输出按比例缩放，以保证期望一致。\n\n数学形式（训练阶段）：\n\nhi′={0,以概率 phi1−p,以概率 (1−p) h_i' = \\begin{cases} 0, & \\text{以概率 } p \\\\ \\frac{h_i}{1-p}, & \\text{以概率 } (1-p) \\end{cases} hi′ ={0,1−phi , 以概率 p以概率 (1−p)\n\n其中 hi\\mathbf{h_i}hi 是神经元原始输出，hi′\\mathbf{h}_{i}^{'}hi′ 是 dropout 后的输出。\n\n直观理解：\n\n * dropout 相当于“给模型加噪音”，迫使它不依赖某个特定神经元。\n * 最终效果是减少过拟合，提高泛化能力。\n\n----------------------------------------\n\n\n# 4.7 前向传播、反向传播与计算图\n\n\n# 前向传播（forward propagation）\n\n数据从输入层开始，依次通过隐藏层，最后输出预测结果。\n例如单隐层网络：\n\nh=σ(w1x+b1) \\mathbf{h} = \\sigma(\\mathbf{w}_1 \\mathbf{x} + \\mathbf{b}_1) h=σ(w1 x+b1 )\no=w2h+b2 \\mathbf{o} = \\mathbf{w}_2 \\mathbf{h} + \\mathbf{b}_2 o=w2 h+b2\n\n其中：\n\n * x\\mathbf{x}x 是输入，h\\mathbf{h}h 是隐藏层输出，o\\mathbf{o}o $是最终输出。\n * σ(⋅)\\sigma(\\cdot)σ(⋅) 表示激活函数。\n\n\n# 反向传播（backpropagation）\n\n为了更新参数，我们需要计算损失函数对每一层参数的梯度。\n梯度通过链式法则逐层传回：\n\n∂l∂w1=∂l∂h⋅∂h∂w1 \\frac{\\partial l}{\\partial \\mathbf{w}_1} = \\frac{\\partial l}{\\partial \\mathbf{h}} \\cdot \\frac{\\partial \\mathbf{h}}{\\partial \\mathbf{w}_1} ∂w1 ∂l =∂h∂l ⋅∂w1 ∂h\n\n这个过程就是反向传播。\n\n\n# 计算图（computational graph）\n\n神经网络的计算可以表示为一个有向图：\n\n * 节点：运算（如加、乘、激活）。\n * 边：张量（数据流）。\n\n前向传播：数据在图中“前进”。\n反向传播：梯度在图中“反传”。\n\n深度学习框架（pytorch、tensorflow）就是基于计算图自动完成反向传播。\n\n----------------------------------------\n\n\n# 4.8 数值稳定性与模型初始化\n\n在训练深层网络时，经常会遇到 梯度消失 或 梯度爆炸 问题。\n\n\n# 梯度消失\n\n * 当使用 sigmoid/tanh 等激活函数时，深层传播会让梯度趋近于 0。\n * 结果：前面几层参数几乎不更新。\n\n\n# 梯度爆炸\n\n * 如果权重过大或层数过深，梯度在传播过程中会指数级增大。\n * 结果：参数震荡、loss 无法收敛。\n\n\n# 解决方法\n\n 1. 合适的激活函数\n    \n    * relu 能缓解梯度消失问题。\n\n 2. 参数初始化方法\n    \n    * xavier/glorot 初始化（适合 sigmoid/tanh）:\n      \n      w∼u(−6nin+nout,6nin+nout) w \\sim u\\left(-\\sqrt{\\frac{6}{n_\\text{in} + n_\\text{out}}}, \\sqrt{\\frac{6}{n_\\text{in} + n_\\text{out}}}\\right) w∼u(−nin +nout 6 ,nin +nout 6 )\n      \n      保证前后层输出方差一致。\n    \n    * he 初始化（适合 relu）：\n      \n      w∼n(0,2nin) w \\sim \\mathcal{n}\\left(0, \\frac{2}{n_\\text{in}}\\right) w∼n(0,nin 2 )\n\n 3. 梯度裁剪（gradient clipping）\n    \n    * 如果梯度过大，可以强行限制其大小，避免数值爆炸。\n\n----------------------------------------\n\n\n# 环境与分布偏移\n\n\n# 什么是分布偏移\n\n * 如果训练数据和测试数据分布不同，模型的泛化能力会下降，这叫 分布偏移（distribution shift）。\n\n\n# 类型\n\n 1. 协变量偏移（covariate shift）\n    \n    * 输入分布变了，但条件分布 (p(y|x)) 不变。\n    * 例如：训练图片很清晰，测试图片有噪声。\n\n 2. 标签偏移（label shift）\n    \n    * 标签的分布变了。\n    * 例如：训练集中猫狗各 50%，测试集里猫占 90%。\n\n 3. 概念偏移（concept shift）\n    \n    * 输入和输出的映射关系变了。\n    * 例如：医学诊断标准更新。\n\n\n# 应对方法\n\n * 数据增强，让训练数据更接近真实场景。\n * 收集更多与实际环境匹配的数据。\n * 迁移学习，把在一个任务上学到的知识迁移到另一个任务上。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"05.LeNet",frontmatter:{title:"05.LeNet",date:"2025-09-17T17:00:49.000Z",permalink:"/pages/DP_05/"},regularPath:"/02.Dp/05.LeNet.html",relativePath:"02.Dp/05.LeNet.md",key:"v-7c9e4be6",path:"/pages/DP_05/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:167},{level:2,title:"Pytorch 代码实现",slug:"pytorch-代码实现",normalizedTitle:"pytorch 代码实现",charIndex:457},{level:3,title:"定义模型",slug:"定义模型",normalizedTitle:"定义模型",charIndex:474},{level:3,title:"模型结构检查",slug:"模型结构检查",normalizedTitle:"模型结构检查",charIndex:1618},{level:3,title:"数据集准备",slug:"数据集准备",normalizedTitle:"数据集准备",charIndex:2117},{level:3,title:"模型训练准备",slug:"模型训练准备",normalizedTitle:"模型训练准备",charIndex:2258},{level:3,title:"运行模型",slug:"运行模型",normalizedTitle:"运行模型",charIndex:4029}],headersStr:"背景 架构 Pytorch 代码实现 定义模型 模型结构检查 数据集准备 模型训练准备 运行模型",content:'# 背景\n\n * LeNet 是最早成功应用于手写数字识别（MNIST）的卷积神经网络（CNN），由 Yann LeCun 在 1990s 提出。\n * 它展示了 CNN 在图像处理上的强大能力，是现代深度学习的起点之一。\n * LeNet 的经典结构：卷积层 → 池化层 → 卷积层 → 池化层 → 全连接层 → 输出层。\n\n\n# 架构\n\n * 输入：32×32 灰度图（MNIST 原始 28×28，通常填充成 32×32）\n\n * 结构：\n   \n   1. 卷积层1：6 个 5×5 卷积核，输出通道数 = 6，特征图尺寸 28×28\n   2. 池化层1：平均池化（2×2，步幅=2），输出尺寸 14×14\n   3. 卷积层2：16 个 5×5 卷积核，输出通道数 = 16，特征图 10×10\n   4. 池化层2：平均池化，输出尺寸 5×5\n   5. 全连接层1：输入展平成向量，120 个神经元\n   6. 全连接层2：84 个神经元\n   7. 输出层：10 类（数字 0–9）\n\n\n\n\n# Pytorch 代码实现\n\n\n# 定义模型\n\nimport torch\nfrom torch import nn\nfrom d2l import torch as d2l\n\n# 定义LeNet模型\nclass LeNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        # 特征提取部分：卷积层 + 池化层\n        self.conv = nn.Sequential(\n            # 卷积层1：输入通道=1(灰度图)，输出通道=6，卷积核=5×5\n            nn.Conv2d(1, 6, kernel_size=5, padding=2), \n            nn.Sigmoid(),   # 激活函数，早期CNN常用Sigmoid/Tanh\n            nn.AvgPool2d(kernel_size=2, stride=2),  # 平均池化，降低尺寸\n\n            # 卷积层2：输入通道=6，输出通道=16\n            nn.Conv2d(6, 16, kernel_size=5),\n            nn.Sigmoid(),\n            nn.AvgPool2d(kernel_size=2, stride=2)\n        )\n\n        # 分类部分：全连接层\n        self.fc = nn.Sequential(\n            nn.Linear(16*5*5, 120),  # 输入展平成一维向量\n            nn.Sigmoid(),\n            nn.Linear(120, 84),\n            nn.Sigmoid(),\n            nn.Linear(84, 10)        # 输出10类（数字0-9）\n        )\n\n    def forward(self, x):\n        # 卷积提取特征\n        x = self.conv(x)\n        # 展平为(batch_size, 特征长度)\n        x = torch.flatten(x, 1)\n        # 全连接层分类\n        return self.fc(x)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 模型结构检查\n\n# 输入一个批次的图片：batch_size=1, 通道=1, 高=32, 宽=32\nX = torch.rand(size=(1, 1, 32, 32), dtype=torch.float32)\n\nnet = LeNet()\n\n# 逐层查看输出尺寸\nfor layer in net.conv:\n    X = layer(X)\n    print(layer.__class__.__name__, \'output shape:\\t\', X.shape)\n    \n"""\n    运行后结果一般为：\n    - Conv2d 输出: (1, 6, 32, 32)\n    \n\t- AvgPool2d 输出: (1, 6, 16, 16)\n    \n\t- Conv2d 输出: (1, 16, 12, 12)\n    \n\t- AvgPool2d 输出: (1, 16, 6, 6)\n\t    \n\t- 最后展平就是 (1, 16*5*5)。\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 数据集准备\n\n\n# 使用 Fashion-MNIST 数据集\nbatch_size = 256\ntrain_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 模型训练准备\n\n\ndef evaluate_accuracy_gpu(net, data_iter, device=None):\n    """评估准确率（支持GPU）"""\n    if isinstance(net, nn.Module):\n        net.eval()  # 评估模式（关闭Dropout等）\n        if not device:\n            device = next(iter(net.parameters())).device\n    metric = d2l.Accumulator(2)  # 正确预测数，总预测数\n    with torch.no_grad():\n        for X, y in data_iter:\n            if isinstance(X, list):\n                X = [x.to(device) for x in X]\n            else:\n                X = X.to(device)\n            y = y.to(device)\n            metric.add(d2l.accuracy(net(X), y), y.numel())\n    return metric[0] / metric[1]\n\n\ndef train_ch6(net, train_iter, test_iter, num_epochs, lr, device):\n    """训练函数"""\n    # 把模型放到指定设备上（CPU/GPU）\n    net.to(device)\n    # 使用SGD优化器\n    optimizer = torch.optim.SGD(net.parameters(), lr=lr)\n    loss = nn.CrossEntropyLoss()  # 交叉熵损失\n    animator = d2l.Animator(xlabel=\'epoch\', xlim=[1, num_epochs], \n                            legend=[\'train loss\', \'train acc\', \'test acc\'])\n\n    for epoch in range(num_epochs):\n        metric = d2l.Accumulator(3)  # 训练损失总和, 正确预测数, 总样本数\n        net.train()\n        for i, (X, y) in enumerate(train_iter):\n            X, y = X.to(device), y.to(device)\n            optimizer.zero_grad()\n            y_hat = net(X)\n            l = loss(y_hat, y)\n            l.backward()\n            optimizer.step()\n            metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0])\n\n        test_acc = evaluate_accuracy_gpu(net, test_iter)\n        animator.add(epoch+1, (metric[0]/metric[2], metric[1]/metric[2], test_acc))\n\n    print(f\'train acc {metric[1]/metric[2]:.3f}, test acc {test_acc:.3f}\')\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 运行模型\n\n\nnet = LeNet()\nlr, num_epochs = 0.9, 10\ntrain_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())\n\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# 背景\n\n * lenet 是最早成功应用于手写数字识别（mnist）的卷积神经网络（cnn），由 yann lecun 在 1990s 提出。\n * 它展示了 cnn 在图像处理上的强大能力，是现代深度学习的起点之一。\n * lenet 的经典结构：卷积层 → 池化层 → 卷积层 → 池化层 → 全连接层 → 输出层。\n\n\n# 架构\n\n * 输入：32×32 灰度图（mnist 原始 28×28，通常填充成 32×32）\n\n * 结构：\n   \n   1. 卷积层1：6 个 5×5 卷积核，输出通道数 = 6，特征图尺寸 28×28\n   2. 池化层1：平均池化（2×2，步幅=2），输出尺寸 14×14\n   3. 卷积层2：16 个 5×5 卷积核，输出通道数 = 16，特征图 10×10\n   4. 池化层2：平均池化，输出尺寸 5×5\n   5. 全连接层1：输入展平成向量，120 个神经元\n   6. 全连接层2：84 个神经元\n   7. 输出层：10 类（数字 0–9）\n\n\n\n\n# pytorch 代码实现\n\n\n# 定义模型\n\nimport torch\nfrom torch import nn\nfrom d2l import torch as d2l\n\n# 定义lenet模型\nclass lenet(nn.module):\n    def __init__(self):\n        super().__init__()\n        # 特征提取部分：卷积层 + 池化层\n        self.conv = nn.sequential(\n            # 卷积层1：输入通道=1(灰度图)，输出通道=6，卷积核=5×5\n            nn.conv2d(1, 6, kernel_size=5, padding=2), \n            nn.sigmoid(),   # 激活函数，早期cnn常用sigmoid/tanh\n            nn.avgpool2d(kernel_size=2, stride=2),  # 平均池化，降低尺寸\n\n            # 卷积层2：输入通道=6，输出通道=16\n            nn.conv2d(6, 16, kernel_size=5),\n            nn.sigmoid(),\n            nn.avgpool2d(kernel_size=2, stride=2)\n        )\n\n        # 分类部分：全连接层\n        self.fc = nn.sequential(\n            nn.linear(16*5*5, 120),  # 输入展平成一维向量\n            nn.sigmoid(),\n            nn.linear(120, 84),\n            nn.sigmoid(),\n            nn.linear(84, 10)        # 输出10类（数字0-9）\n        )\n\n    def forward(self, x):\n        # 卷积提取特征\n        x = self.conv(x)\n        # 展平为(batch_size, 特征长度)\n        x = torch.flatten(x, 1)\n        # 全连接层分类\n        return self.fc(x)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 模型结构检查\n\n# 输入一个批次的图片：batch_size=1, 通道=1, 高=32, 宽=32\nx = torch.rand(size=(1, 1, 32, 32), dtype=torch.float32)\n\nnet = lenet()\n\n# 逐层查看输出尺寸\nfor layer in net.conv:\n    x = layer(x)\n    print(layer.__class__.__name__, \'output shape:\\t\', x.shape)\n    \n"""\n    运行后结果一般为：\n    - conv2d 输出: (1, 6, 32, 32)\n    \n\t- avgpool2d 输出: (1, 6, 16, 16)\n    \n\t- conv2d 输出: (1, 16, 12, 12)\n    \n\t- avgpool2d 输出: (1, 16, 6, 6)\n\t    \n\t- 最后展平就是 (1, 16*5*5)。\n"""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 数据集准备\n\n\n# 使用 fashion-mnist 数据集\nbatch_size = 256\ntrain_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 模型训练准备\n\n\ndef evaluate_accuracy_gpu(net, data_iter, device=none):\n    """评估准确率（支持gpu）"""\n    if isinstance(net, nn.module):\n        net.eval()  # 评估模式（关闭dropout等）\n        if not device:\n            device = next(iter(net.parameters())).device\n    metric = d2l.accumulator(2)  # 正确预测数，总预测数\n    with torch.no_grad():\n        for x, y in data_iter:\n            if isinstance(x, list):\n                x = [x.to(device) for x in x]\n            else:\n                x = x.to(device)\n            y = y.to(device)\n            metric.add(d2l.accuracy(net(x), y), y.numel())\n    return metric[0] / metric[1]\n\n\ndef train_ch6(net, train_iter, test_iter, num_epochs, lr, device):\n    """训练函数"""\n    # 把模型放到指定设备上（cpu/gpu）\n    net.to(device)\n    # 使用sgd优化器\n    optimizer = torch.optim.sgd(net.parameters(), lr=lr)\n    loss = nn.crossentropyloss()  # 交叉熵损失\n    animator = d2l.animator(xlabel=\'epoch\', xlim=[1, num_epochs], \n                            legend=[\'train loss\', \'train acc\', \'test acc\'])\n\n    for epoch in range(num_epochs):\n        metric = d2l.accumulator(3)  # 训练损失总和, 正确预测数, 总样本数\n        net.train()\n        for i, (x, y) in enumerate(train_iter):\n            x, y = x.to(device), y.to(device)\n            optimizer.zero_grad()\n            y_hat = net(x)\n            l = loss(y_hat, y)\n            l.backward()\n            optimizer.step()\n            metric.add(l * x.shape[0], d2l.accuracy(y_hat, y), x.shape[0])\n\n        test_acc = evaluate_accuracy_gpu(net, test_iter)\n        animator.add(epoch+1, (metric[0]/metric[2], metric[1]/metric[2], test_acc))\n\n    print(f\'train acc {metric[1]/metric[2]:.3f}, test acc {test_acc:.3f}\')\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 运行模型\n\n\nnet = lenet()\nlr, num_epochs = 0.9, 10\ntrain_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())\n\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.Rust的变量与可变性",frontmatter:{title:"01.Rust的变量与可变性",date:"2025-08-18T10:55:00.000Z",permalink:"/pages/Rust_01/"},regularPath:"/03.Rust/01.Rust%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7.html",relativePath:"03.Rust/01.Rust的变量与可变性.md",key:"v-6b5141e8",path:"/pages/Rust_01/",headers:[{level:2,title:"一. 为什么变量默认不可变？",slug:"一-为什么变量默认不可变",normalizedTitle:"一. 为什么变量默认不可变？",charIndex:146},{level:2,title:"二. 常量：永远静止的一块值",slug:"二-常量-永远静止的一块值",normalizedTitle:"二. 常量：永远静止的一块值",charIndex:616},{level:2,title:"三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量",slug:"三-遮蔽-shadowing-使用同名变量-换壳-而不动原变量",normalizedTitle:"三. 遮蔽（shadowing）：使用同名变量“换壳”而不动原变量",charIndex:787}],headersStr:"一. 为什么变量默认不可变？ 二. 常量：永远静止的一块值 三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量",content:'# Rust 的变量与可变性：设计安全的第一步\n\nRust 与传统语言不同，它默认把所有变量锁住——不许轻易变。这种默认不可变设计帮你挡下 Pointer Bug 和数据竞争，是现代系统语言的本分。\n\n----------------------------------------\n\n\n# 一. 为什么变量默认不可变？\n\n设计选择    优势                说明\n默认不可变   消灭意外修改，代码更安全可推导   Rust 编译器帮你保障“一旦设定，不会悄悄改变”\n                          :contentReference[oaicite:0]{index=0}\n显示可变    写意且受控，修改行为更加明确    必须写 mut，才能修改变量 :contentReference[oaicite:1]{index=1}\n\n比如：\n\nlet x = 1;\nprintln!("x 是 {}", x);\nx = 2; // 编译报错：cannot assign twice to immutable variable `x`\n\n\n1\n2\n3\n\n\n这是因为 x 默认不可变。改用：\n\nlet mut x = 5;\nprintln!("x 是 {}", x);\nx = 6; // OK，编译器允许\n\n\n1\n2\n3\n\n\n把==“可变性”==明确标注出来，方便自己也方便团队理解。\n\n\n# 二. 常量：永远静止的一块值\n\n常量 (const) 与变量类似，但从来不可变，而且必须显式写类型，初始化值也只能是编译期已知的常量表达式：\n\nconst Pi: u32 = 3.1415926;\n\n\n1\n\n * 永久不变，且不可加 mut。\n * 类型必标注，编译时代入计算结果。\n * 在任何作用域都有效，适合定义全局不变参数。\n\n\n# 三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量\n\nRust 允许使用 let 重复定义变量名称，旧的就被“遮蔽”了。这与可变或常量不同，是创造新变量：\n\nlet x = 5;\nlet x = x + 1;         // x 变成 6\n{\n    let x = x * 2;     // 内部作用域里 x 是 12\n    println!("内层 x = {x}");\n}\nprintln!("外层 x = {x}"); // x 回退为 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n遮蔽的好处：\n\n * 不用 mut，还能变值；\n * 支持改变类型，如把字符串变成数值，复用变量名更干净。',normalizedContent:'# rust 的变量与可变性：设计安全的第一步\n\nrust 与传统语言不同，它默认把所有变量锁住——不许轻易变。这种默认不可变设计帮你挡下 pointer bug 和数据竞争，是现代系统语言的本分。\n\n----------------------------------------\n\n\n# 一. 为什么变量默认不可变？\n\n设计选择    优势                说明\n默认不可变   消灭意外修改，代码更安全可推导   rust 编译器帮你保障“一旦设定，不会悄悄改变”\n                          :contentreference[oaicite:0]{index=0}\n显示可变    写意且受控，修改行为更加明确    必须写 mut，才能修改变量 :contentreference[oaicite:1]{index=1}\n\n比如：\n\nlet x = 1;\nprintln!("x 是 {}", x);\nx = 2; // 编译报错：cannot assign twice to immutable variable `x`\n\n\n1\n2\n3\n\n\n这是因为 x 默认不可变。改用：\n\nlet mut x = 5;\nprintln!("x 是 {}", x);\nx = 6; // ok，编译器允许\n\n\n1\n2\n3\n\n\n把==“可变性”==明确标注出来，方便自己也方便团队理解。\n\n\n# 二. 常量：永远静止的一块值\n\n常量 (const) 与变量类似，但从来不可变，而且必须显式写类型，初始化值也只能是编译期已知的常量表达式：\n\nconst pi: u32 = 3.1415926;\n\n\n1\n\n * 永久不变，且不可加 mut。\n * 类型必标注，编译时代入计算结果。\n * 在任何作用域都有效，适合定义全局不变参数。\n\n\n# 三. 遮蔽（shadowing）：使用同名变量“换壳”而不动原变量\n\nrust 允许使用 let 重复定义变量名称，旧的就被“遮蔽”了。这与可变或常量不同，是创造新变量：\n\nlet x = 5;\nlet x = x + 1;         // x 变成 6\n{\n    let x = x * 2;     // 内部作用域里 x 是 12\n    println!("内层 x = {x}");\n}\nprintln!("外层 x = {x}"); // x 回退为 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n遮蔽的好处：\n\n * 不用 mut，还能变值；\n * 支持改变类型，如把字符串变成数值，复用变量名更干净。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.Rust的数据类型",frontmatter:{title:"02.Rust的数据类型",date:"2025-08-18T11:12:00.000Z",permalink:"/pages/Rust_02/"},regularPath:"/03.Rust/02.Rust%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.Rust/02.Rust的数据类型.md",key:"v-b5fe0ffa",path:"/pages/Rust_02/",headers:[{level:2,title:"一. 静态类型与类型推断",slug:"一-静态类型与类型推断",normalizedTitle:"一. 静态类型与类型推断",charIndex:149},{level:2,title:"二. 标量类型（Scalar Types）",slug:"二-标量类型-scalar-types",normalizedTitle:"二. 标量类型（scalar types）",charIndex:327},{level:3,title:"1.整型（Integer）",slug:"_1-整型-integer",normalizedTitle:"1.整型（integer）",charIndex:377},{level:3,title:"2.浮点型（Floating-Point）",slug:"_2-浮点型-floating-point",normalizedTitle:"2.浮点型（floating-point）",charIndex:854},{level:3,title:"3.布尔型（Boolean）",slug:"_3-布尔型-boolean",normalizedTitle:"3.布尔型（boolean）",charIndex:1005},{level:3,title:"4.字符型（Character）",slug:"_4-字符型-character",normalizedTitle:"4.字符型（character）",charIndex:1128},{level:3,title:"5.数值运算（Computing）",slug:"_5-数值运算-computing",normalizedTitle:"5.数值运算（computing）",charIndex:1423},{level:2,title:"三、复合类型（Compound Types）",slug:"三、复合类型-compound-types",normalizedTitle:"三、复合类型（compound types）",charIndex:1725},{level:3,title:"2. 数组（Array）",slug:"_2-数组-array",normalizedTitle:"2. 数组（array）",charIndex:2610}],headersStr:"一. 静态类型与类型推断 二. 标量类型（Scalar Types） 1.整型（Integer） 2.浮点型（Floating-Point） 3.布尔型（Boolean） 4.字符型（Character） 5.数值运算（Computing） 三、复合类型（Compound Types） 2. 数组（Array）",content:"# Rust 的数据类型：给每个值找个“身份”\n\n在 Rust 中，每一个值都带着标签——类型（data type），告诉编译器怎么处理它。\n\n这就是 Rust 的静态类型特性，让错误在编译期被挡在门外。\n\n----------------------------------------\n\n\n# 一. 静态类型与类型推断\n\nRust 是静态类型语言，意味着所有变量的类型必须在 编译时知道。但你通常不用写在代码里，Rust 编译器会自动推断出来：\n\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n\n\n1\n\n\n如果不写 : u32，编译器会报错说无法推断类型，需要你给个明示才行。\n\n\n# 二. 标量类型（Scalar Types）\n\n标量类型代表单一数值或字符。\n\n主要有四类：\n\n\n# 1.整型（Integer）\n\nRust 支持多种整型，每种定大小、有符号或无符号，含 i8, u8, …, i128, u128, 还有根据平台决定大小的 isize / usize。\n\n长度              有符号     无符号\n8-bit           i8      u8\n16-bit          i16     u16\n32-bit          i32     u32\n64-bit          i64     u64\n128-bit         i128    u128\n架构相关(x86/x64)   isize   usize\n\n各种字面值的示例：\n\n数字字面值                 例子\nDecimal (十进制)         54_188\nHex (十六进制)            0xff\nOctal (八进制)           0o77\nBinary (二进制)          0b1010_0101\nByte (单字节字符)(仅限于u8)   b'A'\n\n\n# 2.浮点型（Floating-Point）\n\nRust 有 f32 和 f64，默认的是 f64，因为现代 CPU 上运算速度差不离，但精度更高。\n\nlet x = 2.0;          // f64\nlet y: f32 = 3.0;     // f32，必须显式标注\n\n\n1\n2\n\n\n\n# 3.布尔型（Boolean）\n\n只有两个值：true / false，类型是 bool，占一个字节，与其他语言一样，用于控制流中的==条件表达式==。\n\nlet t = true;\nlet f: bool = false;\n\n\n1\n2\n\n\n\n# 4.字符型（Character）\n\nRust的字符型是非常^6^的，因为它使用的是Unicode编码，类型的大小为四个字节 (four bytes)，而不是传统的阿斯克码，所以，它可以表示任何字符，任何语言的字符！\n\n我们用单引号声明 char 字面值，而与之相反的是，使用双引号声明字符串字面值。\n\n// 以下字符型变量全是合法的, 只有你想不到，没有我R*哥表示不到😉\nlet c = 'c';\nlet z: char = 'ℤ'; \nlet wink = '😉';\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 5.数值运算（Computing）\n\nRust的所有类型数据都支持运算，整数的运算一般会有取舍。\n\nlet sum = 5 + 10;\t// 加法\nlet difference = 95.5 - 4.3;\t// 减法 \nlet product = 4 * 30;\t// 乘法\nlet quotient = 56.7 / 32.2;\t// 正常除法\nlet truncated = -5 / 3; // 整除，结果为 -1\nlet remainder = 43 % 5;\t// 取余\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、复合类型（Compound Types）\n\nRust 有两个原生的复合类型：元组（tuple）和数组（array）。\n\n * 元组（Tuple）：类型可以不同，长度固定，用 (a, b) 定义，访问靠 .0, .1。\n * 数组（Array）：类型相同，长度固定，用 [T; N] 定义，访问靠索引。\n\n它们是构建更复杂结构的基础，适合包裹多个相关值。\n\n# 1. 元组（Tuple）\n\n定义：元组把多种类型的若干值打包成一个整体，长度固定、元素可异构（各元素类型可不同）。\n\n# 创建与类型标注\n\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet mixed = (\"ok\", 3.14, true);\nlet single = (42,);     // 单元素元组：注意结尾的逗号\nlet not_tuple = (42);   // 这只是 42 本身，不是元组\n\n\n1\n2\n3\n4\n\n\n> 要点：单元素元组必须带逗号 (42,)，否则就是普通值。\n\n# 解构（Destructuring）\n\nlet (x, y, z) = tup;  // 模式匹配式解构\nprintln!(\"{x}, {y}, {z}\");\n\n\n1\n2\n\n * 解构会“按位”绑定新变量，仍然整体所有权转移（或拷贝，取决于元素是否 Copy）。\n\n# 索引访问\n\nlet a = tup.0;  // 500\nlet b = tup.1;  // 6.4\n\n\n1\n2\n\n * 编译期检查索引是否在范围内（超界直接编译失败）。\n\n# 单位类型（Unit Type）()\n\n * () 是一个特殊的 0 长度元组，读作 unit。\n\n * 含义：“没有有意义的值”，常见于函数不返回值的情况（返回 ()），或语句表达式的值。\n   \n   let x = ();        // x 的类型是 ()\n   fn log() { }       // 等价 fn log() -> () { }\n   \n   \n   1\n   2\n   \n\n\n# 2. 数组（Array）\n\n定义：数组是同类型元素、长度固定、在栈上连续存储的序列，类型写作 [T; N]。\n\n> 要点：长度 N 是类型的一部分——[u8; 3] 与 [u8; 4] 是不同的类型。\n\n# 创建与类型标注\n\nlet a = [1, 2, 3, 4, 5];               // 推断为 [i32; 5]\nlet b: [i32; 3] = [10, 20, 30];        // 显式类型\nlet c = [0; 8];                         // 重复语法：等价 [0,0,0,0,0,0,0,0]\nlet empty: [u8; 0] = [];                // 零长数组也合法\n\n\n1\n2\n3\n4\n\n\n# 索引与边界检查\n\nlet first = a[0];\nlet last  = a[a.len() - 1];\n\n// 越界会在**运行时 panic**\n// let x = a[999]; // 运行时触发 “index out of bounds”\n\n\n1\n2\n3\n4\n5\n\n * Rust 对数组索引运行时检查，避免越界 UB（未定义行为）。",normalizedContent:"# rust 的数据类型：给每个值找个“身份”\n\n在 rust 中，每一个值都带着标签——类型（data type），告诉编译器怎么处理它。\n\n这就是 rust 的静态类型特性，让错误在编译期被挡在门外。\n\n----------------------------------------\n\n\n# 一. 静态类型与类型推断\n\nrust 是静态类型语言，意味着所有变量的类型必须在 编译时知道。但你通常不用写在代码里，rust 编译器会自动推断出来：\n\nlet guess: u32 = \"42\".parse().expect(\"not a number!\");\n\n\n1\n\n\n如果不写 : u32，编译器会报错说无法推断类型，需要你给个明示才行。\n\n\n# 二. 标量类型（scalar types）\n\n标量类型代表单一数值或字符。\n\n主要有四类：\n\n\n# 1.整型（integer）\n\nrust 支持多种整型，每种定大小、有符号或无符号，含 i8, u8, …, i128, u128, 还有根据平台决定大小的 isize / usize。\n\n长度              有符号     无符号\n8-bit           i8      u8\n16-bit          i16     u16\n32-bit          i32     u32\n64-bit          i64     u64\n128-bit         i128    u128\n架构相关(x86/x64)   isize   usize\n\n各种字面值的示例：\n\n数字字面值                 例子\ndecimal (十进制)         54_188\nhex (十六进制)            0xff\noctal (八进制)           0o77\nbinary (二进制)          0b1010_0101\nbyte (单字节字符)(仅限于u8)   b'a'\n\n\n# 2.浮点型（floating-point）\n\nrust 有 f32 和 f64，默认的是 f64，因为现代 cpu 上运算速度差不离，但精度更高。\n\nlet x = 2.0;          // f64\nlet y: f32 = 3.0;     // f32，必须显式标注\n\n\n1\n2\n\n\n\n# 3.布尔型（boolean）\n\n只有两个值：true / false，类型是 bool，占一个字节，与其他语言一样，用于控制流中的==条件表达式==。\n\nlet t = true;\nlet f: bool = false;\n\n\n1\n2\n\n\n\n# 4.字符型（character）\n\nrust的字符型是非常^6^的，因为它使用的是unicode编码，类型的大小为四个字节 (four bytes)，而不是传统的阿斯克码，所以，它可以表示任何字符，任何语言的字符！\n\n我们用单引号声明 char 字面值，而与之相反的是，使用双引号声明字符串字面值。\n\n// 以下字符型变量全是合法的, 只有你想不到，没有我r*哥表示不到😉\nlet c = 'c';\nlet z: char = 'ℤ'; \nlet wink = '😉';\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 5.数值运算（computing）\n\nrust的所有类型数据都支持运算，整数的运算一般会有取舍。\n\nlet sum = 5 + 10;\t// 加法\nlet difference = 95.5 - 4.3;\t// 减法 \nlet product = 4 * 30;\t// 乘法\nlet quotient = 56.7 / 32.2;\t// 正常除法\nlet truncated = -5 / 3; // 整除，结果为 -1\nlet remainder = 43 % 5;\t// 取余\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、复合类型（compound types）\n\nrust 有两个原生的复合类型：元组（tuple）和数组（array）。\n\n * 元组（tuple）：类型可以不同，长度固定，用 (a, b) 定义，访问靠 .0, .1。\n * 数组（array）：类型相同，长度固定，用 [t; n] 定义，访问靠索引。\n\n它们是构建更复杂结构的基础，适合包裹多个相关值。\n\n# 1. 元组（tuple）\n\n定义：元组把多种类型的若干值打包成一个整体，长度固定、元素可异构（各元素类型可不同）。\n\n# 创建与类型标注\n\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet mixed = (\"ok\", 3.14, true);\nlet single = (42,);     // 单元素元组：注意结尾的逗号\nlet not_tuple = (42);   // 这只是 42 本身，不是元组\n\n\n1\n2\n3\n4\n\n\n> 要点：单元素元组必须带逗号 (42,)，否则就是普通值。\n\n# 解构（destructuring）\n\nlet (x, y, z) = tup;  // 模式匹配式解构\nprintln!(\"{x}, {y}, {z}\");\n\n\n1\n2\n\n * 解构会“按位”绑定新变量，仍然整体所有权转移（或拷贝，取决于元素是否 copy）。\n\n# 索引访问\n\nlet a = tup.0;  // 500\nlet b = tup.1;  // 6.4\n\n\n1\n2\n\n * 编译期检查索引是否在范围内（超界直接编译失败）。\n\n# 单位类型（unit type）()\n\n * () 是一个特殊的 0 长度元组，读作 unit。\n\n * 含义：“没有有意义的值”，常见于函数不返回值的情况（返回 ()），或语句表达式的值。\n   \n   let x = ();        // x 的类型是 ()\n   fn log() { }       // 等价 fn log() -> () { }\n   \n   \n   1\n   2\n   \n\n\n# 2. 数组（array）\n\n定义：数组是同类型元素、长度固定、在栈上连续存储的序列，类型写作 [t; n]。\n\n> 要点：长度 n 是类型的一部分——[u8; 3] 与 [u8; 4] 是不同的类型。\n\n# 创建与类型标注\n\nlet a = [1, 2, 3, 4, 5];               // 推断为 [i32; 5]\nlet b: [i32; 3] = [10, 20, 30];        // 显式类型\nlet c = [0; 8];                         // 重复语法：等价 [0,0,0,0,0,0,0,0]\nlet empty: [u8; 0] = [];                // 零长数组也合法\n\n\n1\n2\n3\n4\n\n\n# 索引与边界检查\n\nlet first = a[0];\nlet last  = a[a.len() - 1];\n\n// 越界会在**运行时 panic**\n// let x = a[999]; // 运行时触发 “index out of bounds”\n\n\n1\n2\n3\n4\n5\n\n * rust 对数组索引运行时检查，避免越界 ub（未定义行为）。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"00.Rust的基本素养",frontmatter:{title:"00.Rust的基本素养",date:"2025-08-17T22:00:00.000Z",permalink:"/pages/Rust_00/"},regularPath:"/03.Rust/00.Rust%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB.html",relativePath:"03.Rust/00.Rust的基本素养.md",key:"v-8fe40c64",path:"/pages/Rust_00/",headers:[{level:2,title:"一. 为什么选择 Rust？",slug:"一-为什么选择-rust",normalizedTitle:"一. 为什么选择 rust？",charIndex:22},{level:2,title:"二. 安装与环境准备",slug:"二-安装与环境准备",normalizedTitle:"二. 安装与环境准备",charIndex:322},{level:2,title:"三. Hello, World!",slug:"三-hello-world",normalizedTitle:"三. hello, world!",charIndex:525},{level:2,title:"四. Cargo：Rust 工程的核心",slug:"四-cargo-rust-工程的核心",normalizedTitle:"四. cargo：rust 工程的核心",charIndex:779}],headersStr:"一. 为什么选择 Rust？ 二. 安装与环境准备 三. Hello, World! 四. Cargo：Rust 工程的核心",content:"# Rust：现代系统编程的新基石\n\n\n# 一. 为什么选择 Rust？\n\nRust 是一门兼顾 性能 与 安全性 的系统级语言：\n\n语言       优势                   劣势\nC/C++    性能强大，生态成熟            内存安全问题多\nPython   开发效率高，生态丰富           性能受限，不适合底层开发\nRust     内存安全 + 高性能 + 无需 GC   上手曲线稍陡，生态在成长\n\n> Rust 之于 2025 年的嵌入式开发，就像 20 年前 C 之于单片机：新的起点，新的机会。\n\n----------------------------------------\n\n\n# 二. 安装与环境准备\n\n推荐使用 Rustup，一键安装管理工具链。\n\n安装完成后，常用命令有：\n\nrustc --version   # 查看编译器版本\ncargo --version   # 查看包管理器版本\n\n\n1\n2\n\n\nCargo 是 Rust 的“瑞士军刀”，负责 构建 / 依赖管理 / 打包发布。\n\n----------------------------------------\n\n\n# 三. Hello, World!\n\n创建新项目：\n\ncargo new hello-rust\ncd hello-rust\n\n\n1\n2\n\n\n目录结构：\n\nhello-rust\n ├── Cargo.toml    # 项目配置文件\n └── src\n     └── main.rs   # 主程序入口\n\n\n1\n2\n3\n4\n\n\n运行：\n\ncargo run\n\n\n1\n\n\n输出：\n\nHello, world!\n\n\n1\n\n\n----------------------------------------\n\n\n# 四. Cargo：Rust 工程的核心\n\n常用命令一览：\n\n命令                 功能\ncargo build        构建项目（生成可执行文件）\ncargo run          构建并运行项目\ncargo check        检查语法错误，速度更快\ncargo update       更新依赖版本\ncargo doc --open   生成文档并在浏览器打开",normalizedContent:"# rust：现代系统编程的新基石\n\n\n# 一. 为什么选择 rust？\n\nrust 是一门兼顾 性能 与 安全性 的系统级语言：\n\n语言       优势                   劣势\nc/c++    性能强大，生态成熟            内存安全问题多\npython   开发效率高，生态丰富           性能受限，不适合底层开发\nrust     内存安全 + 高性能 + 无需 gc   上手曲线稍陡，生态在成长\n\n> rust 之于 2025 年的嵌入式开发，就像 20 年前 c 之于单片机：新的起点，新的机会。\n\n----------------------------------------\n\n\n# 二. 安装与环境准备\n\n推荐使用 rustup，一键安装管理工具链。\n\n安装完成后，常用命令有：\n\nrustc --version   # 查看编译器版本\ncargo --version   # 查看包管理器版本\n\n\n1\n2\n\n\ncargo 是 rust 的“瑞士军刀”，负责 构建 / 依赖管理 / 打包发布。\n\n----------------------------------------\n\n\n# 三. hello, world!\n\n创建新项目：\n\ncargo new hello-rust\ncd hello-rust\n\n\n1\n2\n\n\n目录结构：\n\nhello-rust\n ├── cargo.toml    # 项目配置文件\n └── src\n     └── main.rs   # 主程序入口\n\n\n1\n2\n3\n4\n\n\n运行：\n\ncargo run\n\n\n1\n\n\n输出：\n\nhello, world!\n\n\n1\n\n\n----------------------------------------\n\n\n# 四. cargo：rust 工程的核心\n\n常用命令一览：\n\n命令                 功能\ncargo build        构建项目（生成可执行文件）\ncargo run          构建并运行项目\ncargo check        检查语法错误，速度更快\ncargo update       更新依赖版本\ncargo doc --open   生成文档并在浏览器打开",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"04.卷积神经网络",frontmatter:{title:"04.卷积神经网络",date:"2025-09-17T17:00:49.000Z",permalink:"/pages/DP_04/"},regularPath:"/02.Dp/04.%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html",relativePath:"02.Dp/04.卷积神经网络.md",key:"v-6642d632",path:"/pages/DP_04/",headers:[{level:2,title:"从全连接到卷积",slug:"从全连接到卷积",normalizedTitle:"从全连接到卷积",charIndex:2},{level:3,title:"卷积的定义",slug:"卷积的定义",normalizedTitle:"卷积的定义",charIndex:14},{level:3,title:"通道",slug:"通道",normalizedTitle:"通道",charIndex:494},{level:2,title:"图像卷积",slug:"图像卷积",normalizedTitle:"图像卷积",charIndex:1151},{level:3,title:"互相关运算",slug:"互相关运算",normalizedTitle:"互相关运算",charIndex:282},{level:2,title:"填充和步幅",slug:"填充和步幅",normalizedTitle:"填充和步幅",charIndex:2238},{level:3,title:"填充",slug:"填充",normalizedTitle:"填充",charIndex:2238},{level:3,title:"步幅",slug:"步幅",normalizedTitle:"步幅",charIndex:2241},{level:2,title:"多输入多输出通道",slug:"多输入多输出通道",normalizedTitle:"多输入多输出通道",charIndex:2865},{level:3,title:"多输入通道",slug:"多输入通道",normalizedTitle:"多输入通道",charIndex:2992},{level:3,title:"多输出通道",slug:"多输出通道",normalizedTitle:"多输出通道",charIndex:2868},{level:3,title:"1 x 1 卷积层",slug:"_1-x-1-卷积层",normalizedTitle:"1 x 1 卷积层",charIndex:3464},{level:2,title:"汇聚层",slug:"汇聚层",normalizedTitle:"汇聚层",charIndex:3566},{level:3,title:"最大汇聚层和平均汇聚层",slug:"最大汇聚层和平均汇聚层",normalizedTitle:"最大汇聚层和平均汇聚层",charIndex:3574}],headersStr:"从全连接到卷积 卷积的定义 通道 图像卷积 互相关运算 填充和步幅 填充 步幅 多输入多输出通道 多输入通道 多输出通道 1 x 1 卷积层 汇聚层 最大汇聚层和平均汇聚层",content:"# 从全连接到卷积\n\n\n# 卷积的定义\n\n在数学中，两个函数（如：f,g:Rd→Rf, g: \\mathbb{R}^d \\to \\mathbb{R}f,g:Rd→R）之间的卷积被定义为：\n\n(f∗g)(x)=∫f(z)g(x−z)dz. (f * g)(\\mathbf{x}) = \\int f(\\mathbf{z}) g(\\mathbf{x} - \\mathbf{z}) d\\mathbf{z}. (f∗g)(x)=∫f(z)g(x−z)dz.\n\n事实上，卷积是当把一个函数“反转”并移位 x\\mathbf{x}x 时，测量 fff 和 ggg 之间的重叠，即为互相关运算\n\n对于二维张量，其为离散的，fff的索引(a,b)(a,b)(a,b)和ggg的索引(i−a,j−b)(i-a,j-b)(i−a,j−b)上的对应加和为：\n\n(f∗g)(i,j)=∑a∑bf(a,b)g(i−a,j−b). (f * g)(i,j) = \\sum_{a} \\sum_{b} f(a,b)g(i - a,j - b). (f∗g)(i,j)=a∑ b∑ f(a,b)g(i−a,j−b).\n\n\n# 通道\n\n图像是一个由高度、宽度和颜色组成的三维张量，所以索引为 [X]i,j,k[\\mathbf{X}]_{i,j,k}[X]i,j,k ,其卷积应该调整为 [V]a,b,c[\\mathbf{V}]_{a,b,c}[V]a,b,c ,同时，隐藏表示H\\mathbf{H}H也用三位张量。\n\n通道是图像或隐藏表示中，用于体现像素多维特征（如颜色）或提取不同空间化学习特征的维度，在多通道卷积中支持特征的多层传递与处理。\n\n为了支持输入[X][\\mathbf{X}][X]和隐藏表示[H][\\mathbf{H}][H]中的多个通道，我们可在V中提添加第四个坐标，即[V]a,b,c,d[\\mathbf{V}]_{a,b,c,d}[V]a,b,c,d , 因此，就诞生了如下的等式：\n\n[H]i,j,d=∑a=−ΔΔ∑b=−ΔΔ∑c[V]a,b,c,d[X]i+a,j+b,c [\\mathbf{H}]_{i,j,d} = \\sum_{a=-\\Delta}^{\\Delta} \\sum_{b=-\\Delta}^{\\Delta} \\sum_{c} [\\mathbf{V}]_{a,b,c,d}[\\mathbf{X}]_{i+a,j+b,c} [H]i,j,d =a=−Δ∑Δ b=−Δ∑Δ c∑ [V]a,b,c,d [X]i+a,j+b,c\n\n其中隐藏表示[H][\\mathbf{H}][H]中的索引ddd表示输出通道，而随后的输出将继续以三维张量[H][\\mathbf{H}][H]作为输入进入下一个卷积层。\n\n\n# 图像卷积\n\n\n# 互相关运算\n\n在卷积层中，输入张量和核张量通过互相关运算产生输出张量。\n\n如下图： 输入是高度为333、宽度为333的二维张量（即形状为3×33 × 33×3）。卷积核的高度和宽度都是222，而卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定（即2×22 × 22×2）。\n\n在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。 当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。 在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为222、宽度为222，如下所示：\n\n0×0+1×1+3×2+4×3=0+1+6+12=191×0+2×1+4×2+5×3=0+2+8+15=253×0+4×1+6×2+7×3=0+4+12+21=374×0+5×1+7×2+8×3=0+5+14+24=43 \\begin{aligned} 0 \\times 0 + 1 \\times 1 + 3 \\times 2 + 4 \\times 3 &= 0 + 1 + 6 + 12 = 19 \\\\ 1 \\times 0 + 2 \\times 1 + 4 \\times 2 + 5 \\times 3 &= 0 + 2 + 8 + 15 = 25 \\\\ 3 \\times 0 + 4 \\times 1 + 6 \\times 2 + 7 \\times 3 &= 0 + 4 + 12 + 21 = 37 \\\\ 4 \\times 0 + 5 \\times 1 + 7 \\times 2 + 8 \\times 3 &= 0 + 5 + 14 + 24 = 43 \\end{aligned} 0×0+1×1+3×2+4×31×0+2×1+4×2+5×33×0+4×1+6×2+7×34×0+5×1+7×2+8×3 =0+1+6+12=19=0+2+8+15=25=0+4+12+21=37=0+5+14+24=43\n\n我们需要足够的空间在图像上“移动”卷积核，输出大小等于输入大小nh×nw\\mathbf{n}_h × \\mathbf{n}_wnh ×nw , 减去卷积核大小 kh×kw\\mathbf{k}_h × \\mathbf{k}_wkh ×kw ,即：\n\n(nh−kh+1)×(nw−kw+1) (n_h - k_h + 1) \\times (n_w - k_w + 1) (nh −kh +1)×(nw −kw +1)\n\n\n# 填充和步幅\n\n\n# 填充\n\n在连续应用许多卷积层之后，输入图像的边界会丢失很多像素，通常使用 填充(padding) 来解决这个问题, 一般在输入图像四周填充元素 000 。\n\n如下图，我们将 3×33 × 33×3 输入填充到 5×55 × 55×5，那么其输出就增加为 4×44×44×4：\n\n\n\n通常情况下，如果我们添加 ph{p}_hph 行填充和 pwp_wpw 列填充，则输出形状将为：\n\n(nh−kh+ph+1)×(nw−kw+pw+1) (n_h - k_h + p_h + 1) \\times (n_w - k_w + p_w + 1) (nh −kh +ph +1)×(nw −kw +pw +1)\n\n\n# 步幅\n\n卷积核在输入张量里面滑动，每次滑动的元素即为 步幅（stride），一般默认滑动 111 个元素\n\n如下图，为垂直步幅为3，水平步幅为2的二维互相关运算：\n\n\n\n通常，当垂直步幅为 shs_hsh 、水平步幅为 sws_wsw 时，输出形状为：\n\n⌊(nh−kh+ph+sh)/sh⌋×⌊(nw−kw+pw+sw)/sw⌋ \\lfloor (n_h - k_h + p_h + s_h)/s_h \\rfloor \\times \\lfloor (n_w - k_w + p_w + s_w)/s_w \\rfloor ⌊(nh −kh +ph +sh )/sh ⌋×⌊(nw −kw +pw +sw )/sw ⌋\n\n\n# 多输入多输出通道\n\n每个 RGB 输入图像具有 3×h×w3 \\times h \\times w3×h×w 的形状，称这个大小为 333 的轴为通道(channel) 维度，常用 cic_ici 来表示输入通道数，coc_oco 为输出通道数。\n\n\n# 多输入通道\n\n当 ci>1c_i > 1ci >1 时，卷积核就要构造成 ci×kh×kwc_i×k_h×k_wci ×kh ×kw 的形状，可以对每个通道输入的二位张良和卷积核的二维张量进行互相关运算，再对通道求和的到二维张量。\n\n如下图，是一个有两个输入通道的二维互相关运算的示例：\n\n\n\n计算第一个元素： (1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56(1 \\times 1 + 2 \\times 2 + 4 \\times 3 + 5 \\times 4) + (0 \\times 0 + 1 \\times 1 + 3 \\times 2 + 4 \\times 3) = 56(1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56\n\n\n# 多输出通道\n\n为了得到多输出通道，可以为每个输出通道创建一个形状为 ci×kh×kwc_i×k_h×k_wci ×kh ×kw 的卷积核张量，卷积核的形状就为 co×ci×kh×kwc_o×c_i×k_h×k_wco ×ci ×kh ×kw\n\n\n# 1 x 1 卷积层\n\n1 x 1卷积层的唯一作用在于调整通道数\n\n如下图，互相关计算使用了具有3个输入通道和2个输出通道的 1×11×11×1 卷积核。其中，输入和输出具有相同的高度和宽度。\n\n\n\n\n# 汇聚层\n\n\n# 最大汇聚层和平均汇聚层\n\n汇聚层运算符由一个固定的窗口组成，同时汇聚层不包含参数，汇聚层运算是确定的，我们通常计算窗口内所有元素的最大值或平均值，这些操作分别称为最大汇聚层(maximun pooling) 和 平均汇聚层(average pooling)\n\n如下图，汇聚窗口形状为 2×22×22×2 的最大汇聚层：\n\n",normalizedContent:"# 从全连接到卷积\n\n\n# 卷积的定义\n\n在数学中，两个函数（如：f,g:rd→rf, g: \\mathbb{r}^d \\to \\mathbb{r}f,g:rd→r）之间的卷积被定义为：\n\n(f∗g)(x)=∫f(z)g(x−z)dz. (f * g)(\\mathbf{x}) = \\int f(\\mathbf{z}) g(\\mathbf{x} - \\mathbf{z}) d\\mathbf{z}. (f∗g)(x)=∫f(z)g(x−z)dz.\n\n事实上，卷积是当把一个函数“反转”并移位 x\\mathbf{x}x 时，测量 fff 和 ggg 之间的重叠，即为互相关运算\n\n对于二维张量，其为离散的，fff的索引(a,b)(a,b)(a,b)和ggg的索引(i−a,j−b)(i-a,j-b)(i−a,j−b)上的对应加和为：\n\n(f∗g)(i,j)=∑a∑bf(a,b)g(i−a,j−b). (f * g)(i,j) = \\sum_{a} \\sum_{b} f(a,b)g(i - a,j - b). (f∗g)(i,j)=a∑ b∑ f(a,b)g(i−a,j−b).\n\n\n# 通道\n\n图像是一个由高度、宽度和颜色组成的三维张量，所以索引为 [x]i,j,k[\\mathbf{x}]_{i,j,k}[x]i,j,k ,其卷积应该调整为 [v]a,b,c[\\mathbf{v}]_{a,b,c}[v]a,b,c ,同时，隐藏表示h\\mathbf{h}h也用三位张量。\n\n通道是图像或隐藏表示中，用于体现像素多维特征（如颜色）或提取不同空间化学习特征的维度，在多通道卷积中支持特征的多层传递与处理。\n\n为了支持输入[x][\\mathbf{x}][x]和隐藏表示[h][\\mathbf{h}][h]中的多个通道，我们可在v中提添加第四个坐标，即[v]a,b,c,d[\\mathbf{v}]_{a,b,c,d}[v]a,b,c,d , 因此，就诞生了如下的等式：\n\n[h]i,j,d=∑a=−δδ∑b=−δδ∑c[v]a,b,c,d[x]i+a,j+b,c [\\mathbf{h}]_{i,j,d} = \\sum_{a=-\\delta}^{\\delta} \\sum_{b=-\\delta}^{\\delta} \\sum_{c} [\\mathbf{v}]_{a,b,c,d}[\\mathbf{x}]_{i+a,j+b,c} [h]i,j,d =a=−δ∑δ b=−δ∑δ c∑ [v]a,b,c,d [x]i+a,j+b,c\n\n其中隐藏表示[h][\\mathbf{h}][h]中的索引ddd表示输出通道，而随后的输出将继续以三维张量[h][\\mathbf{h}][h]作为输入进入下一个卷积层。\n\n\n# 图像卷积\n\n\n# 互相关运算\n\n在卷积层中，输入张量和核张量通过互相关运算产生输出张量。\n\n如下图： 输入是高度为333、宽度为333的二维张量（即形状为3×33 × 33×3）。卷积核的高度和宽度都是222，而卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定（即2×22 × 22×2）。\n\n在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。 当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。 在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为222、宽度为222，如下所示：\n\n0×0+1×1+3×2+4×3=0+1+6+12=191×0+2×1+4×2+5×3=0+2+8+15=253×0+4×1+6×2+7×3=0+4+12+21=374×0+5×1+7×2+8×3=0+5+14+24=43 \\begin{aligned} 0 \\times 0 + 1 \\times 1 + 3 \\times 2 + 4 \\times 3 &= 0 + 1 + 6 + 12 = 19 \\\\ 1 \\times 0 + 2 \\times 1 + 4 \\times 2 + 5 \\times 3 &= 0 + 2 + 8 + 15 = 25 \\\\ 3 \\times 0 + 4 \\times 1 + 6 \\times 2 + 7 \\times 3 &= 0 + 4 + 12 + 21 = 37 \\\\ 4 \\times 0 + 5 \\times 1 + 7 \\times 2 + 8 \\times 3 &= 0 + 5 + 14 + 24 = 43 \\end{aligned} 0×0+1×1+3×2+4×31×0+2×1+4×2+5×33×0+4×1+6×2+7×34×0+5×1+7×2+8×3 =0+1+6+12=19=0+2+8+15=25=0+4+12+21=37=0+5+14+24=43\n\n我们需要足够的空间在图像上“移动”卷积核，输出大小等于输入大小nh×nw\\mathbf{n}_h × \\mathbf{n}_wnh ×nw , 减去卷积核大小 kh×kw\\mathbf{k}_h × \\mathbf{k}_wkh ×kw ,即：\n\n(nh−kh+1)×(nw−kw+1) (n_h - k_h + 1) \\times (n_w - k_w + 1) (nh −kh +1)×(nw −kw +1)\n\n\n# 填充和步幅\n\n\n# 填充\n\n在连续应用许多卷积层之后，输入图像的边界会丢失很多像素，通常使用 填充(padding) 来解决这个问题, 一般在输入图像四周填充元素 000 。\n\n如下图，我们将 3×33 × 33×3 输入填充到 5×55 × 55×5，那么其输出就增加为 4×44×44×4：\n\n\n\n通常情况下，如果我们添加 ph{p}_hph 行填充和 pwp_wpw 列填充，则输出形状将为：\n\n(nh−kh+ph+1)×(nw−kw+pw+1) (n_h - k_h + p_h + 1) \\times (n_w - k_w + p_w + 1) (nh −kh +ph +1)×(nw −kw +pw +1)\n\n\n# 步幅\n\n卷积核在输入张量里面滑动，每次滑动的元素即为 步幅（stride），一般默认滑动 111 个元素\n\n如下图，为垂直步幅为3，水平步幅为2的二维互相关运算：\n\n\n\n通常，当垂直步幅为 shs_hsh 、水平步幅为 sws_wsw 时，输出形状为：\n\n⌊(nh−kh+ph+sh)/sh⌋×⌊(nw−kw+pw+sw)/sw⌋ \\lfloor (n_h - k_h + p_h + s_h)/s_h \\rfloor \\times \\lfloor (n_w - k_w + p_w + s_w)/s_w \\rfloor ⌊(nh −kh +ph +sh )/sh ⌋×⌊(nw −kw +pw +sw )/sw ⌋\n\n\n# 多输入多输出通道\n\n每个 rgb 输入图像具有 3×h×w3 \\times h \\times w3×h×w 的形状，称这个大小为 333 的轴为通道(channel) 维度，常用 cic_ici 来表示输入通道数，coc_oco 为输出通道数。\n\n\n# 多输入通道\n\n当 ci>1c_i > 1ci >1 时，卷积核就要构造成 ci×kh×kwc_i×k_h×k_wci ×kh ×kw 的形状，可以对每个通道输入的二位张良和卷积核的二维张量进行互相关运算，再对通道求和的到二维张量。\n\n如下图，是一个有两个输入通道的二维互相关运算的示例：\n\n\n\n计算第一个元素： (1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56(1 \\times 1 + 2 \\times 2 + 4 \\times 3 + 5 \\times 4) + (0 \\times 0 + 1 \\times 1 + 3 \\times 2 + 4 \\times 3) = 56(1×1+2×2+4×3+5×4)+(0×0+1×1+3×2+4×3)=56\n\n\n# 多输出通道\n\n为了得到多输出通道，可以为每个输出通道创建一个形状为 ci×kh×kwc_i×k_h×k_wci ×kh ×kw 的卷积核张量，卷积核的形状就为 co×ci×kh×kwc_o×c_i×k_h×k_wco ×ci ×kh ×kw\n\n\n# 1 x 1 卷积层\n\n1 x 1卷积层的唯一作用在于调整通道数\n\n如下图，互相关计算使用了具有3个输入通道和2个输出通道的 1×11×11×1 卷积核。其中，输入和输出具有相同的高度和宽度。\n\n\n\n\n# 汇聚层\n\n\n# 最大汇聚层和平均汇聚层\n\n汇聚层运算符由一个固定的窗口组成，同时汇聚层不包含参数，汇聚层运算是确定的，我们通常计算窗口内所有元素的最大值或平均值，这些操作分别称为最大汇聚层(maximun pooling) 和 平均汇聚层(average pooling)\n\n如下图，汇聚窗口形状为 2×22×22×2 的最大汇聚层：\n\n",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.Rust的函数与注释",frontmatter:{title:"03.Rust的函数与注释",date:"2025-08-19T10:00:00.000Z",permalink:"/pages/Rust_03/"},regularPath:"/03.Rust/03.Rust%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%B3%A8%E9%87%8A.html",relativePath:"03.Rust/03.Rust的函数和注释.md",key:"v-aac979ae",path:"/pages/Rust_03/",headers:[{level:2,title:"一、函数的基本结构",slug:"一、函数的基本结构",normalizedTitle:"一、函数的基本结构",charIndex:116},{level:2,title:"二、参数与返回值",slug:"二、参数与返回值",normalizedTitle:"二、参数与返回值",charIndex:311},{level:2,title:"三、分号与返回值",slug:"三、分号与返回值",normalizedTitle:"三、分号与返回值",charIndex:614},{level:2,title:"四、注释的写法",slug:"四、注释的写法",normalizedTitle:"四、注释的写法",charIndex:819}],headersStr:"一、函数的基本结构 二、参数与返回值 三、分号与返回值 四、注释的写法",content:'# Rust 的函数与注释\n\n在 Rust 中，函数是组织代码的基本单元，注释则是对代码意图的说明。理解这两点，可以让程序既清晰又易维护。\n\n----------------------------------------\n\n\n# 一、函数的基本结构\n\n最小化的函数形式如下：\n\nfn main() {\n    println!("Hello from Rust!");\n}\n\n\n1\n2\n3\n\n * fn 表示函数定义。\n * main 是程序入口。\n * 括号 () 表示参数列表，这里为空。\n * 花括号 {} 包裹函数体。\n\n----------------------------------------\n\n\n# 二、参数与返回值\n\nfn sum(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nfn main() {\n    let result = sum(5, 7);\n    println!("5 + 7 = {result}");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 参数写作 名称: 类型，多个参数用逗号分隔。\n * 返回值通过 -> 类型 声明。\n * 最后一行表达式自动成为返回值。\n\n如果需要显式返回，可以使用 return：\n\nreturn x + y;\n\n\n1\n\n\n----------------------------------------\n\n\n# 三、分号与返回值\n\nfn five() -> i32 {\n    5\n}\n\nfn five_wrong() -> i32 {\n    5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 没有分号：表达式的值就是返回值。\n * 有分号：变成语句，不会返回值，类型是 ()。\n\n这体现了 Rust 区分语句与表达式的方式。\n\n----------------------------------------\n\n\n# 四、注释的写法\n\nRust 支持两种常见注释：\n\n 1. 单行注释：\n    \n    // 打印一句话\n    println!("hi");\n    \n    \n    1\n    2\n    \n\n 2. 文档注释：\n    \n    /// 计算两数之和\n    fn sum(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n文档注释不仅能说明函数用途，还能通过 cargo doc --open 生成文档。',normalizedContent:'# rust 的函数与注释\n\n在 rust 中，函数是组织代码的基本单元，注释则是对代码意图的说明。理解这两点，可以让程序既清晰又易维护。\n\n----------------------------------------\n\n\n# 一、函数的基本结构\n\n最小化的函数形式如下：\n\nfn main() {\n    println!("hello from rust!");\n}\n\n\n1\n2\n3\n\n * fn 表示函数定义。\n * main 是程序入口。\n * 括号 () 表示参数列表，这里为空。\n * 花括号 {} 包裹函数体。\n\n----------------------------------------\n\n\n# 二、参数与返回值\n\nfn sum(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nfn main() {\n    let result = sum(5, 7);\n    println!("5 + 7 = {result}");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 参数写作 名称: 类型，多个参数用逗号分隔。\n * 返回值通过 -> 类型 声明。\n * 最后一行表达式自动成为返回值。\n\n如果需要显式返回，可以使用 return：\n\nreturn x + y;\n\n\n1\n\n\n----------------------------------------\n\n\n# 三、分号与返回值\n\nfn five() -> i32 {\n    5\n}\n\nfn five_wrong() -> i32 {\n    5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 没有分号：表达式的值就是返回值。\n * 有分号：变成语句，不会返回值，类型是 ()。\n\n这体现了 rust 区分语句与表达式的方式。\n\n----------------------------------------\n\n\n# 四、注释的写法\n\nrust 支持两种常见注释：\n\n 1. 单行注释：\n    \n    // 打印一句话\n    println!("hi");\n    \n    \n    1\n    2\n    \n\n 2. 文档注释：\n    \n    /// 计算两数之和\n    fn sum(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n文档注释不仅能说明函数用途，还能通过 cargo doc --open 生成文档。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"04.Rust的控制流",frontmatter:{title:"04.Rust的控制流",date:"2025-08-19T11:00:00.000Z",permalink:"/pages/Rust_04/"},regularPath:"/03.Rust/04.Rust%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81.html",relativePath:"03.Rust/04.Rust的控制流.md",key:"v-17d104cc",path:"/pages/Rust_04/",headers:[{level:2,title:"一、if 表达式",slug:"一、if-表达式",normalizedTitle:"一、if 表达式",charIndex:115},{level:2,title:"二、loop 循环",slug:"二、loop-循环",normalizedTitle:"二、loop 循环",charIndex:442},{level:2,title:"三、while 循环",slug:"三、while-循环",normalizedTitle:"三、while 循环",charIndex:872},{level:2,title:"四、for 循环",slug:"四、for-循环",normalizedTitle:"四、for 循环",charIndex:1112}],headersStr:"一、if 表达式 二、loop 循环 三、while 循环 四、for 循环",content:'# Rust 的控制流\n\n控制流指的是程序根据条件和循环来决定执行路径。Rust 提供了清晰的条件分支和循环语句，让代码逻辑更容易表达。\n\n----------------------------------------\n\n\n# 一、if 表达式\n\nfn main() {\n    let n = 7;\n\n    if n < 5 {\n        println!("小于5");\n    } else if n == 5 {\n        println!("等于5");\n    } else {\n        println!("大于5");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * if 后跟布尔表达式。\n * 分支可以有多个，用 else if。\n * else 是可选的。\n\n在 Rust 中，if 是一个 表达式，所以可以直接赋值：\n\nlet x = if n > 0 { 1 } else { -1 };\n\n\n1\n\n\n\n# 二、loop 循环\n\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count += 1;\n        if count == 3 {\n            println!("跳出循环");\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * loop 会无限执行，除非遇到 break。\n * 使用 continue 可以跳过当前这次循环，直接进入下一轮。\n\n循环还可以返回值：\n\nlet result = loop {\n    count += 1;\n    if count == 10 {\n        break count * 2; // 返回 20\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、while 循环\n\nfn main() {\n    let mut n = 3;\n\n    while n > 0 {\n        println!("{n}");\n        n -= 1;\n    }\n    println!("起飞！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 在每轮循环前检查条件。\n * 条件为 false 时循环终止。\n\n----------------------------------------\n\n\n# 四、for 循环\n\nfn main() {\n    let arr = [10, 20, 30];\n\n    for val in arr {\n        println!("值: {val}");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * for 能遍历数组、切片或迭代器。\n * 更常见的写法是使用区间：\n\nfor i in 1..=5 {\n    println!("{i}");\n}\n\n\n1\n2\n3\n\n\n这里 1..=5 表示从 1 到 5（包含 5）。如果写作 1..5，则不包含 5。',normalizedContent:'# rust 的控制流\n\n控制流指的是程序根据条件和循环来决定执行路径。rust 提供了清晰的条件分支和循环语句，让代码逻辑更容易表达。\n\n----------------------------------------\n\n\n# 一、if 表达式\n\nfn main() {\n    let n = 7;\n\n    if n < 5 {\n        println!("小于5");\n    } else if n == 5 {\n        println!("等于5");\n    } else {\n        println!("大于5");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * if 后跟布尔表达式。\n * 分支可以有多个，用 else if。\n * else 是可选的。\n\n在 rust 中，if 是一个 表达式，所以可以直接赋值：\n\nlet x = if n > 0 { 1 } else { -1 };\n\n\n1\n\n\n\n# 二、loop 循环\n\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count += 1;\n        if count == 3 {\n            println!("跳出循环");\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * loop 会无限执行，除非遇到 break。\n * 使用 continue 可以跳过当前这次循环，直接进入下一轮。\n\n循环还可以返回值：\n\nlet result = loop {\n    count += 1;\n    if count == 10 {\n        break count * 2; // 返回 20\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、while 循环\n\nfn main() {\n    let mut n = 3;\n\n    while n > 0 {\n        println!("{n}");\n        n -= 1;\n    }\n    println!("起飞！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 在每轮循环前检查条件。\n * 条件为 false 时循环终止。\n\n----------------------------------------\n\n\n# 四、for 循环\n\nfn main() {\n    let arr = [10, 20, 30];\n\n    for val in arr {\n        println!("值: {val}");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * for 能遍历数组、切片或迭代器。\n * 更常见的写法是使用区间：\n\nfor i in 1..=5 {\n    println!("{i}");\n}\n\n\n1\n2\n3\n\n\n这里 1..=5 表示从 1 到 5（包含 5）。如果写作 1..5，则不包含 5。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"05.Rust的所有权概念",frontmatter:{title:"05.Rust的所有权概念",date:"2025-08-19T12:00:00.000Z",permalink:"/pages/Rust_05/"},regularPath:"/03.Rust/05.Rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%A6%82%E5%BF%B5.html",relativePath:"03.Rust/05.Rust的所有权概念.md",key:"v-1a6776ec",path:"/pages/Rust_05/",headers:[{level:2,title:"一、栈与堆的区别",slug:"一、栈与堆的区别",normalizedTitle:"一、栈与堆的区别",charIndex:148},{level:2,title:"二、所有权三原则",slug:"二、所有权三原则",normalizedTitle:"二、所有权三原则",charIndex:723},{level:2,title:"三、作用域与资源自动释放",slug:"三、作用域与资源自动释放",normalizedTitle:"三、作用域与资源自动释放",charIndex:889},{level:2,title:"四、String类型",slug:"四、string类型",normalizedTitle:"四、string类型",charIndex:1091}],headersStr:"一、栈与堆的区别 二、所有权三原则 三、作用域与资源自动释放 四、String类型",content:'# Rust 的所有权概念\n\nRust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 Rust 安全性与效率关键的一步。\n\n----------------------------------------\n\n\n# 一、栈与堆的区别\n\n要理解所有权机制，需要先理解 栈（stack）和堆（heap） 的内存管理方式。\n\n * 栈（Stack）\n   * 特点：存取速度快，后进先出（LIFO）。\n   * 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。\n   * 生命周期：作用域结束自动弹出，无需手动管理。\n * 堆（Heap）\n   * 特点：存取灵活，但分配和回收开销更大。\n   * 存放：大小未知或运行期才确定的数据，例如 String、Vec。\n   * 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 Rust 自动释放。\n\n对比示例：\n\nlet x = 10;                  // 存在栈上\nlet s = String::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据\n\n\n1\n2\n\n\n这里的关键点：\n\n * x 是整数，直接放在栈上，访问快，作用域结束就弹出。\n * s 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 "hi" 字符串内容在堆上，释放时 Rust 会自动清理堆内存。\n\n因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。\n\n----------------------------------------\n\n\n# 二、所有权三原则\n\nRust 的所有权机制围绕三条核心规则：\n\n 1. 每一个值都有一个“==所有者==”(owner)。\n 2. 在同一时间，值只有一个所有者。\n 3. 当所有者离开作用域，值会被丢弃或者说==自动释放==（drop）。\n\n----------------------------------------\n\n\n# 三、作用域与资源自动释放\n\n作用域决定变量何时“消失”，从而决定资源何时释放，例如：\n\n{\n    let s = "hello";\n    // s 在此作用域内有效\n}\n// 出了作用域，s 被 drop，内存自动释放\n\n\n1\n2\n3\n4\n5\n\n\n这一行为像是给变量包了自动回收机制，无需显式调用释放函数。\n\n----------------------------------------\n\n\n# 四、String类型\n\n我们可以通过如下的代码创建一个String。\n\nlet mut s = String::from("hello, world!");\n\n\n1\n\n\n通常情况下，计算机不允许一个在运行之前不知道值或者在运行之后值会改变的变量被放到二进制文件之中，所以，我们使用==String==类型。\n\n对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：\n\n * 必须在运行时向内存分配器（memory allocator）请求内存。\n * 需要一个当我们处理完 String 时将内存返回给分配器的方法。\n\n前一个部分由程序员自己完成，而后面一个部分，Rust会自己动，就比如：\n\n{\n\tlet s = String::from("hello");\n\t// 这里s有效    \n}\n// 这里s就失效了，因为作用域已经结束\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# rust 的所有权概念\n\nrust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 rust 安全性与效率关键的一步。\n\n----------------------------------------\n\n\n# 一、栈与堆的区别\n\n要理解所有权机制，需要先理解 栈（stack）和堆（heap） 的内存管理方式。\n\n * 栈（stack）\n   * 特点：存取速度快，后进先出（lifo）。\n   * 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。\n   * 生命周期：作用域结束自动弹出，无需手动管理。\n * 堆（heap）\n   * 特点：存取灵活，但分配和回收开销更大。\n   * 存放：大小未知或运行期才确定的数据，例如 string、vec。\n   * 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 rust 自动释放。\n\n对比示例：\n\nlet x = 10;                  // 存在栈上\nlet s = string::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据\n\n\n1\n2\n\n\n这里的关键点：\n\n * x 是整数，直接放在栈上，访问快，作用域结束就弹出。\n * s 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 "hi" 字符串内容在堆上，释放时 rust 会自动清理堆内存。\n\n因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。\n\n----------------------------------------\n\n\n# 二、所有权三原则\n\nrust 的所有权机制围绕三条核心规则：\n\n 1. 每一个值都有一个“==所有者==”(owner)。\n 2. 在同一时间，值只有一个所有者。\n 3. 当所有者离开作用域，值会被丢弃或者说==自动释放==（drop）。\n\n----------------------------------------\n\n\n# 三、作用域与资源自动释放\n\n作用域决定变量何时“消失”，从而决定资源何时释放，例如：\n\n{\n    let s = "hello";\n    // s 在此作用域内有效\n}\n// 出了作用域，s 被 drop，内存自动释放\n\n\n1\n2\n3\n4\n5\n\n\n这一行为像是给变量包了自动回收机制，无需显式调用释放函数。\n\n----------------------------------------\n\n\n# 四、string类型\n\n我们可以通过如下的代码创建一个string。\n\nlet mut s = string::from("hello, world!");\n\n\n1\n\n\n通常情况下，计算机不允许一个在运行之前不知道值或者在运行之后值会改变的变量被放到二进制文件之中，所以，我们使用==string==类型。\n\n对于 string 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：\n\n * 必须在运行时向内存分配器（memory allocator）请求内存。\n * 需要一个当我们处理完 string 时将内存返回给分配器的方法。\n\n前一个部分由程序员自己完成，而后面一个部分，rust会自己动，就比如：\n\n{\n\tlet s = string::from("hello");\n\t// 这里s有效    \n}\n// 这里s就失效了，因为作用域已经结束\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"06.Rust的引用和借用",frontmatter:{title:"06.Rust的引用和借用",date:"2025-08-20T21:00:00.000Z",permalink:"/pages/Rust_06/"},regularPath:"/03.Rust/06.Rust%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8.html",relativePath:"03.Rust/06.Rust的引用和借用.md",key:"v-8041b53e",path:"/pages/Rust_06/",headers:[{level:2,title:"一、引用和借用的基本阐述",slug:"一、引用和借用的基本阐述",normalizedTitle:"一、引用和借用的基本阐述",charIndex:18},{level:2,title:"二、可变引用",slug:"二、可变引用",normalizedTitle:"二、可变引用",charIndex:650},{level:2,title:"三、悬垂引用（Dangling References）",slug:"三、悬垂引用-dangling-references",normalizedTitle:"三、悬垂引用（dangling references）",charIndex:1404}],headersStr:"一、引用和借用的基本阐述 二、可变引用 三、悬垂引用（Dangling References）",content:'# Rust 的引用和借用\n\n\n# 一、引用和借用的基本阐述\n\n引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。\n\n定义并使用一个calculate_length` 函数，它以一个对象的引用作为参数而不是获取值的所有权：\n\nfn main() {\n    let s1 = String::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("The length of \'{s1}\' is {len}.");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面的代码中， & 符号就是 引用，它们允许你使用值但不获取其所有权。\n\n&s1 语法让我们创建一个指向值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。\n\n----------------------------------------\n\n我们将创建一个引用的行为称为 借用（borrowing），正如在日常生活中，我们借别人一样东西，迟早是要还的，因为我们没有那件物品的所有权。\n\n同时需要注意，我们不能去修改借用的变量，那样不合法，也不道德。\n\n\n# 二、可变引用\n\n我们可以通过添加 mut 关键字的方式来让引用变得“可变”，修改一下代码：\n\nfn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样就可以实现可变了！\n\n----------------------------------------\n\n不过，可变引用有一个很大的缺点，就是同一时间不能存在多个可变引用，或者不能存在可变引用和引用同时存在的情况。\n\n这里，先阐述一下，引用的规则：\n\n * 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。\n * 引用必须总是有效的。\n\n正如此，下面的两种情况不合法：\n\n    let mut s = String::from("hello");\n\n    let r1 = &mut s;\t// 两次可变引用，答煤油！\n    let r2 = &mut s;\n\n    println!("{}, {}", r1, r2);\n\n\n1\n2\n3\n4\n5\n6\n\n\n let mut s = String::from("hello");\n\n    let r1 = &s; // 没问题\t\t\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题，鱼与熊掌不可兼得\n\n    println!("{}, {}, and {}", r1, r2, r3);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、悬垂引用（Dangling References）\n\n在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针（dangling pointer）—— 指向可能已被分配给其他用途的内存位置的指针。\n\n相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n\n简而言之，就是不能返回一个孤寡老人，下面的代码可以帮助理解：\n\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from("hello");\n\n    &s\t// s的生命周期结束，但是这个函数返回了s的指针？ 显然，十分有十一分的不合法！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# rust 的引用和借用\n\n\n# 一、引用和借用的基本阐述\n\n引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。\n\n定义并使用一个calculate_length` 函数，它以一个对象的引用作为参数而不是获取值的所有权：\n\nfn main() {\n    let s1 = string::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("the length of \'{s1}\' is {len}.");\n}\n\nfn calculate_length(s: &string) -> usize {\n    s.len()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面的代码中， & 符号就是 引用，它们允许你使用值但不获取其所有权。\n\n&s1 语法让我们创建一个指向值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。\n\n----------------------------------------\n\n我们将创建一个引用的行为称为 借用（borrowing），正如在日常生活中，我们借别人一样东西，迟早是要还的，因为我们没有那件物品的所有权。\n\n同时需要注意，我们不能去修改借用的变量，那样不合法，也不道德。\n\n\n# 二、可变引用\n\n我们可以通过添加 mut 关键字的方式来让引用变得“可变”，修改一下代码：\n\nfn main() {\n    let mut s = string::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut string) {\n    some_string.push_str(", world");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样就可以实现可变了！\n\n----------------------------------------\n\n不过，可变引用有一个很大的缺点，就是同一时间不能存在多个可变引用，或者不能存在可变引用和引用同时存在的情况。\n\n这里，先阐述一下，引用的规则：\n\n * 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。\n * 引用必须总是有效的。\n\n正如此，下面的两种情况不合法：\n\n    let mut s = string::from("hello");\n\n    let r1 = &mut s;\t// 两次可变引用，答煤油！\n    let r2 = &mut s;\n\n    println!("{}, {}", r1, r2);\n\n\n1\n2\n3\n4\n5\n6\n\n\n let mut s = string::from("hello");\n\n    let r1 = &s; // 没问题\t\t\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题，鱼与熊掌不可兼得\n\n    println!("{}, {}, and {}", r1, r2, r3);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、悬垂引用（dangling references）\n\n在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针（dangling pointer）—— 指向可能已被分配给其他用途的内存位置的指针。\n\n相比之下，在 rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n\n简而言之，就是不能返回一个孤寡老人，下面的代码可以帮助理解：\n\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &string {\n    let s = string::from("hello");\n\n    &s\t// s的生命周期结束，但是这个函数返回了s的指针？ 显然，十分有十一分的不合法！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"08.Rust的结构体类型",frontmatter:{title:"08.Rust的结构体类型",date:"2025-08-22T15:00:00.000Z",permalink:"/pages/Rust_08/"},regularPath:"/03.Rust/08.Rust%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.html",relativePath:"03.Rust/08.Rust的结构体类型.md",key:"v-a0af79c8",path:"/pages/Rust_08/",headers:[{level:2,title:"一、为什么要用结构体（Struct）",slug:"一、为什么要用结构体-struct",normalizedTitle:"一、为什么要用结构体（struct）",charIndex:157},{level:2,title:"二、如何定义与使用结构体",slug:"二、如何定义与使用结构体",normalizedTitle:"二、如何定义与使用结构体",charIndex:462},{level:3,title:"定义结构体",slug:"定义结构体",normalizedTitle:"定义结构体",charIndex:479},{level:3,title:"实例化结构体",slug:"实例化结构体",normalizedTitle:"实例化结构体",charIndex:624},{level:3,title:"修改字段",slug:"修改字段",normalizedTitle:"修改字段",charIndex:862},{level:2,title:"三、还有其他结构体变体？元组 struct、单元 struct",slug:"三、还有其他结构体变体-元组-struct、单元-struct",normalizedTitle:"三、还有其他结构体变体？元组 struct、单元 struct",charIndex:1018},{level:3,title:"元组结构体（Tuple Struct）",slug:"元组结构体-tuple-struct",normalizedTitle:"元组结构体（tuple struct）",charIndex:1072},{level:3,title:"单元结构体（Unit-like Struct）",slug:"单元结构体-unit-like-struct",normalizedTitle:"单元结构体（unit-like struct）",charIndex:1296},{level:2,title:"四、结构体在真实代码里的样子：计算矩形面积",slug:"四、结构体在真实代码里的样子-计算矩形面积",normalizedTitle:"四、结构体在真实代码里的样子：计算矩形面积",charIndex:1479},{level:2,title:"五、结构体进阶操作：复用已有实例",slug:"五、结构体进阶操作-复用已有实例",normalizedTitle:"五、结构体进阶操作：复用已有实例",charIndex:1878}],headersStr:"一、为什么要用结构体（Struct） 二、如何定义与使用结构体 定义结构体 实例化结构体 修改字段 三、还有其他结构体变体？元组 struct、单元 struct 元组结构体（Tuple Struct） 单元结构体（Unit-like Struct） 四、结构体在真实代码里的样子：计算矩形面积 五、结构体进阶操作：复用已有实例",content:'# Rust 的结构体类型：给数据贴标签让它长得像人样\n\nRust 里的结构体（struct）是你拿来把数据组织得更有意义的工具。它的作用就像给一堆数据贴上名字标签，当你再用的时候，根本不用记顺序，只要看名字就知道搞啥。\n\n----------------------------------------\n\n\n# 一、为什么要用结构体（Struct）\n\n结构体比元组更“友好”，因为你可以给每个字段起名字，不再靠位置记是什么。比如我们有一个代表用户信息的数据组：\n\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样以后你访问字段就很清楚：\n\nlet u = User { ... };\nprintln!("{}", u.email);  // 一看就知道在搞邮箱\n\n\n1\n2\n\n\n结构体就是为了让数据“有脸有名”——比元组靠谱。\n\n\n# 二、如何定义与使用结构体\n\n\n# 定义结构体\n\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n你定义的是一个模板，跟工厂图纸一样。\n\n\n# 实例化结构体\n\nlet mut user1 = User {\n    email: String::from("a@ex.com"),\n    username: String::from("alice"),\n    active: true,\n    sign_in_count: 1,\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：\n\n * 字段顺序可随意（不像元组必须按定义顺序填）\n * 要想改字段必须让整个实例是 mut（Rust 不允许只给字段加 mut）\n\n\n# 修改字段\n\nuser1.email = String::from("alice@new.com");\n\n\n1\n\n\n整个实例可变才行。\n\n— 来源参考：“定义结构体”与“实例化结构体”、修改字段 都是 Rust 基础操作\n\n----------------------------------------\n\n\n# 三、还有其他结构体变体？元组 struct、单元 struct\n\nRust 还支持其他几种结构体：\n\n\n# 元组结构体（Tuple Struct）\n\n像元组但有类型名，适合只想“命名类型”而不想写字段名的情况：\n\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\n\n1\n2\n3\n4\n5\n\n\n尽管字段类型一样，但 Color 和 Point 是不同类型，互不兼容。\n\n\n# 单元结构体（Unit-like Struct）\n\n啥都没有，就是个名字，常用于特殊场景（比如作为 trait 的实现标记）：\n\nstruct AlwaysEqual;\n\nlet x = AlwaysEqual;\n\n\n1\n2\n3\n\n\n给个名字空壳体，有啥用呢？以后你会用到。\n\n----------------------------------------\n\n\n# 四、结构体在真实代码里的样子：计算矩形面积\n\n假设你要计算矩形面积，用结构体比多个变量更清晰：\n\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn area(rect: &Rectangle) -> u32 {\n    rect.width * rect.height\n}\n\nfn main() {\n    let rect = Rectangle { width: 30, height: 50 };\n    println!("面积是 {} 像素²", area(&rect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n让人看代码时瞬间明白：这是一个矩形，有宽有高，用 area 函数算面积。太直观。\n\n----------------------------------------\n\n\n# 五、结构体进阶操作：复用已有实例\n\n如果你想在新实例里复用老实例的大部分字段，可以写：\n\nlet user2 = User {\n    email: String::from("new@ex.com"),\n    ..user1\n};\n\n\n1\n2\n3\n4\n\n\n这会把 user1 里除了 email 之外的字段直接搬过来。但要注意，不会 Copy 的字段会被 move， user1 中那些被 move 掉的字段就不能再用。',normalizedContent:'# rust 的结构体类型：给数据贴标签让它长得像人样\n\nrust 里的结构体（struct）是你拿来把数据组织得更有意义的工具。它的作用就像给一堆数据贴上名字标签，当你再用的时候，根本不用记顺序，只要看名字就知道搞啥。\n\n----------------------------------------\n\n\n# 一、为什么要用结构体（struct）\n\n结构体比元组更“友好”，因为你可以给每个字段起名字，不再靠位置记是什么。比如我们有一个代表用户信息的数据组：\n\nstruct user {\n    active: bool,\n    username: string,\n    email: string,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样以后你访问字段就很清楚：\n\nlet u = user { ... };\nprintln!("{}", u.email);  // 一看就知道在搞邮箱\n\n\n1\n2\n\n\n结构体就是为了让数据“有脸有名”——比元组靠谱。\n\n\n# 二、如何定义与使用结构体\n\n\n# 定义结构体\n\nstruct user {\n    active: bool,\n    username: string,\n    email: string,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n你定义的是一个模板，跟工厂图纸一样。\n\n\n# 实例化结构体\n\nlet mut user1 = user {\n    email: string::from("a@ex.com"),\n    username: string::from("alice"),\n    active: true,\n    sign_in_count: 1,\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：\n\n * 字段顺序可随意（不像元组必须按定义顺序填）\n * 要想改字段必须让整个实例是 mut（rust 不允许只给字段加 mut）\n\n\n# 修改字段\n\nuser1.email = string::from("alice@new.com");\n\n\n1\n\n\n整个实例可变才行。\n\n— 来源参考：“定义结构体”与“实例化结构体”、修改字段 都是 rust 基础操作\n\n----------------------------------------\n\n\n# 三、还有其他结构体变体？元组 struct、单元 struct\n\nrust 还支持其他几种结构体：\n\n\n# 元组结构体（tuple struct）\n\n像元组但有类型名，适合只想“命名类型”而不想写字段名的情况：\n\nstruct color(i32, i32, i32);\nstruct point(i32, i32, i32);\n\nlet black = color(0, 0, 0);\nlet origin = point(0, 0, 0);\n\n\n1\n2\n3\n4\n5\n\n\n尽管字段类型一样，但 color 和 point 是不同类型，互不兼容。\n\n\n# 单元结构体（unit-like struct）\n\n啥都没有，就是个名字，常用于特殊场景（比如作为 trait 的实现标记）：\n\nstruct alwaysequal;\n\nlet x = alwaysequal;\n\n\n1\n2\n3\n\n\n给个名字空壳体，有啥用呢？以后你会用到。\n\n----------------------------------------\n\n\n# 四、结构体在真实代码里的样子：计算矩形面积\n\n假设你要计算矩形面积，用结构体比多个变量更清晰：\n\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn area(rect: &rectangle) -> u32 {\n    rect.width * rect.height\n}\n\nfn main() {\n    let rect = rectangle { width: 30, height: 50 };\n    println!("面积是 {} 像素²", area(&rect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n让人看代码时瞬间明白：这是一个矩形，有宽有高，用 area 函数算面积。太直观。\n\n----------------------------------------\n\n\n# 五、结构体进阶操作：复用已有实例\n\n如果你想在新实例里复用老实例的大部分字段，可以写：\n\nlet user2 = user {\n    email: string::from("new@ex.com"),\n    ..user1\n};\n\n\n1\n2\n3\n4\n\n\n这会把 user1 里除了 email 之外的字段直接搬过来。但要注意，不会 copy 的字段会被 move， user1 中那些被 move 掉的字段就不能再用。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"07.Rust的切片（Slice）",frontmatter:{title:"07.Rust的切片（Slice）",date:"2025-08-21T10:00:00.000Z",permalink:"/pages/Rust_07/"},regularPath:"/03.Rust/07.Rust%E7%9A%84Slice%E7%B1%BB%E5%9E%8B.html",relativePath:"03.Rust/07.Rust的Slice类型.md",key:"v-2a8deef1",path:"/pages/Rust_07/",headers:[{level:2,title:"一、切片是什么？",slug:"一、切片是什么",normalizedTitle:"一、切片是什么？",charIndex:22},{level:2,title:"二、切片的简写方式",slug:"二、切片的简写方式",normalizedTitle:"二、切片的简写方式",charIndex:497},{level:2,title:"三、切片和字符串字面值",slug:"三、切片和字符串字面值",normalizedTitle:"三、切片和字符串字面值",charIndex:867},{level:2,title:"四、切片的威力：first_word 函数",slug:"四、切片的威力-first-word-函数",normalizedTitle:"四、切片的威力：first_word 函数",charIndex:1215},{level:2,title:"五、小心使用切片",slug:"五、小心使用切片",normalizedTitle:"五、小心使用切片",charIndex:1834}],headersStr:"一、切片是什么？ 二、切片的简写方式 三、切片和字符串字面值 四、切片的威力：first_word 函数 五、小心使用切片",content:'# Rust 的切片（Slice）\n\n\n# 一、切片是什么？\n\n切片（Slice）可以理解为：对集合中某一部分连续元素的引用。\n比如你有一个大西瓜 🍉，切片就是“我只想要中间那几块”。你不会把整个西瓜搬走，而只是指明：“从第几刀到第几刀之间的那块，给我留着”。\n\n在 Rust 中，切片往往出现在字符串或者数组这种顺序存储的数据结构里。\n\n一个例子：\n\nfn main() {\n    let s = String::from("hello world");\n\n    let hello = &s[0..5];   // 从索引0到5（不包含5）\n    let world = &s[6..11];  // 从索引6到11（不包含11）\n\n    println!("{}, {}", hello, world);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 &s[0..5] 和 &s[6..11] 就是切片。 注意，切片不是拷贝数据，而是“借”了一部分区域的引用，经济又实惠。\n\n----------------------------------------\n\n\n# 二、切片的简写方式\n\n切片的语法其实很直观：[起始..结束]，但是 Rust 很贴心，提供了多种写法：\n\nlet s = String::from("hello");\n\n// 从头到 2\nlet slice1 = &s[..2];\n\n// 从 3 到结尾\nlet slice2 = &s[3..];\n\n// 整个字符串\nlet slice3 = &s[..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就好比点菜时：\n\n * [..2] = “我要从头上切两片”；\n * [3..] = “我要从第三片开始到最后”；\n * [..] = “整个大盘子我都要”。\n\n是不是瞬间有画面感了？(回答：有的，兄弟，有的，这样的画面还有八个！)\n\n----------------------------------------\n\n\n# 三、切片和字符串字面值\n\n在 Rust 里，字符串字面值（比如 "hello world"）其实就是一个切片。 这也是为什么你看到它的类型是 &str，而不是 String。\n\nString 是堆上分配的可变字符串，而 &str 更轻量，本质上是对某段 UTF-8 数据的切片。\n\nfn main() {\n    let s: &str = "hello world";  // s 是一个切片\n    println!("{}", s);\n}\n\n\n1\n2\n3\n4\n\n\n这就好比：\n\n * String = 买下一整个蛋糕 🎂，想怎么切怎么切；\n * &str = 已经切好的蛋糕片 🍰，你直接吃。\n\n----------------------------------------\n\n\n# 四、切片的威力：first_word 函数\n\n假设我们要写一个函数，返回一句话中的第一个单词。 如果不用切片，可能会陷入各种复制粘贴麻烦。 但切片就很优雅：\n\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let s = String::from("hello world");\n\n    let word = first_word(&s);\n\n    println!("第一个单词是: {}", word);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n思路很简单：\n\n * 把字符串转成字节数组 as_bytes()；\n * 一边遍历，一边找空格的位置；\n * 找到后，直接返回从头到空格之前的那一片切片。\n\n结果就是：hello。 这里切片帮我们避免了数据的拷贝，直接“划块即用”。\n\n----------------------------------------\n\n\n# 五、小心使用切片\n\n切片很好用，但要记住一点：切片只是借用，不拥有数据。 所以：\n\n * 切片的生命周期不能超过原始数据；\n * 切片和原始数据之间要保持一致，不然会出大问题。\n\n换句话说，你不能一边切着吃蛋糕，一边把蛋糕扔了，这样切片就没东西指向了。',normalizedContent:'# rust 的切片（slice）\n\n\n# 一、切片是什么？\n\n切片（slice）可以理解为：对集合中某一部分连续元素的引用。\n比如你有一个大西瓜 🍉，切片就是“我只想要中间那几块”。你不会把整个西瓜搬走，而只是指明：“从第几刀到第几刀之间的那块，给我留着”。\n\n在 rust 中，切片往往出现在字符串或者数组这种顺序存储的数据结构里。\n\n一个例子：\n\nfn main() {\n    let s = string::from("hello world");\n\n    let hello = &s[0..5];   // 从索引0到5（不包含5）\n    let world = &s[6..11];  // 从索引6到11（不包含11）\n\n    println!("{}, {}", hello, world);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 &s[0..5] 和 &s[6..11] 就是切片。 注意，切片不是拷贝数据，而是“借”了一部分区域的引用，经济又实惠。\n\n----------------------------------------\n\n\n# 二、切片的简写方式\n\n切片的语法其实很直观：[起始..结束]，但是 rust 很贴心，提供了多种写法：\n\nlet s = string::from("hello");\n\n// 从头到 2\nlet slice1 = &s[..2];\n\n// 从 3 到结尾\nlet slice2 = &s[3..];\n\n// 整个字符串\nlet slice3 = &s[..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就好比点菜时：\n\n * [..2] = “我要从头上切两片”；\n * [3..] = “我要从第三片开始到最后”；\n * [..] = “整个大盘子我都要”。\n\n是不是瞬间有画面感了？(回答：有的，兄弟，有的，这样的画面还有八个！)\n\n----------------------------------------\n\n\n# 三、切片和字符串字面值\n\n在 rust 里，字符串字面值（比如 "hello world"）其实就是一个切片。 这也是为什么你看到它的类型是 &str，而不是 string。\n\nstring 是堆上分配的可变字符串，而 &str 更轻量，本质上是对某段 utf-8 数据的切片。\n\nfn main() {\n    let s: &str = "hello world";  // s 是一个切片\n    println!("{}", s);\n}\n\n\n1\n2\n3\n4\n\n\n这就好比：\n\n * string = 买下一整个蛋糕 🎂，想怎么切怎么切；\n * &str = 已经切好的蛋糕片 🍰，你直接吃。\n\n----------------------------------------\n\n\n# 四、切片的威力：first_word 函数\n\n假设我们要写一个函数，返回一句话中的第一个单词。 如果不用切片，可能会陷入各种复制粘贴麻烦。 但切片就很优雅：\n\nfn first_word(s: &string) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let s = string::from("hello world");\n\n    let word = first_word(&s);\n\n    println!("第一个单词是: {}", word);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n思路很简单：\n\n * 把字符串转成字节数组 as_bytes()；\n * 一边遍历，一边找空格的位置；\n * 找到后，直接返回从头到空格之前的那一片切片。\n\n结果就是：hello。 这里切片帮我们避免了数据的拷贝，直接“划块即用”。\n\n----------------------------------------\n\n\n# 五、小心使用切片\n\n切片很好用，但要记住一点：切片只是借用，不拥有数据。 所以：\n\n * 切片的生命周期不能超过原始数据；\n * 切片和原始数据之间要保持一致，不然会出大问题。\n\n换句话说，你不能一边切着吃蛋糕，一边把蛋糕扔了，这样切片就没东西指向了。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"09.Rust的结构体的打印与调试",frontmatter:{title:"09.Rust的结构体的打印与调试",date:"2025-08-22T20:00:00.000Z",permalink:"/pages/Rust_09/"},regularPath:"/03.Rust/09.Rust%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%89%93%E5%8D%B0%E4%B8%8E%E8%B0%83%E8%AF%95.html",relativePath:"03.Rust/09.Rust的结构体的打印与调试.md",key:"v-29a271f4",path:"/pages/Rust_09/",headers:[{level:2,title:"一、使用 {:?} 或 {:#?}",slug:"一、使用-或",normalizedTitle:"一、使用 {:?} 或 {:#?}",charIndex:506},{level:2,title:"二、[dbg! 宏]",slug:"二、-dbg-宏",normalizedTitle:"二、[dbg! 宏]",charIndex:695}],headersStr:"一、使用 {:?} 或 {:#?} 二、[dbg! 宏]",content:'# Rust的结构体的 println 该如何办？\n\n当我们写了如下代码，\n\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect = Rectangle {\n        width: 20,\n        height: 40,\n    };\n\n    println!("rect is {}", rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且尝试 cargo run时，编译器通常会抱怨：\n\nerror[E0277]: `Rectangle` doesn\'t implement `std::fmt::Display`\n\n\n1\n\n\n显然是不能这样玩的，因为编译器并不知道要用什么样的形式把它打印出来。就比如你去汉武大学的图书馆借书，你要是光跟管理员同志说一句借书，显然这位同志只会认为来的是一个糟糕的人。\n\n----------------------------------------\n\n同理，我们用 Debug 来优雅地打印出结构体。\n\n\n# 一、使用 {:?} 或 {:#?}\n\n首先，我们在程序开头添加：\n\n#[derive(Debug)]\n\n\n1\n\n\n然后，把 println! 宏改成类似于\n\nprintln!("rect1 is {rect:?}");\n\n\n1\n\n\n或者\n\nprintln!("rect1 is {rect1:#?}");\n\n\n1\n\n\n两种结果的输出是有点差异的，读者可以自己调试一哈。\n\n\n# 二、[dbg! 宏]\n\n没错，还是如下的代码：\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 4;\n    let rect = Rectangle {\n        width: dbg!(20 * scale),\n        height: 40,\n    };\n\n    dbg!(&rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样子，在cargo run之后，就会是如下的结果：\n\n[src/main.rs:10:16] 20 * scale = 80\n[src/main.rs:14:5] &rect1 = Rectangle {\n    width: 80,\n    height: 40,\n}\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# rust的结构体的 println 该如何办？\n\n当我们写了如下代码，\n\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect = rectangle {\n        width: 20,\n        height: 40,\n    };\n\n    println!("rect is {}", rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且尝试 cargo run时，编译器通常会抱怨：\n\nerror[e0277]: `rectangle` doesn\'t implement `std::fmt::display`\n\n\n1\n\n\n显然是不能这样玩的，因为编译器并不知道要用什么样的形式把它打印出来。就比如你去汉武大学的图书馆借书，你要是光跟管理员同志说一句借书，显然这位同志只会认为来的是一个糟糕的人。\n\n----------------------------------------\n\n同理，我们用 debug 来优雅地打印出结构体。\n\n\n# 一、使用 {:?} 或 {:#?}\n\n首先，我们在程序开头添加：\n\n#[derive(debug)]\n\n\n1\n\n\n然后，把 println! 宏改成类似于\n\nprintln!("rect1 is {rect:?}");\n\n\n1\n\n\n或者\n\nprintln!("rect1 is {rect1:#?}");\n\n\n1\n\n\n两种结果的输出是有点差异的，读者可以自己调试一哈。\n\n\n# 二、[dbg! 宏]\n\n没错，还是如下的代码：\n\n#[derive(debug)]\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 4;\n    let rect = rectangle {\n        width: dbg!(20 * scale),\n        height: 40,\n    };\n\n    dbg!(&rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样子，在cargo run之后，就会是如下的结果：\n\n[src/main.rs:10:16] 20 * scale = 80\n[src/main.rs:14:5] &rect1 = rectangle {\n    width: 80,\n    height: 40,\n}\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"10.Rust的方法",frontmatter:{title:"10.Rust的方法",date:"2025-08-23T11:00:00.000Z",permalink:"/pages/Rust_10/"},regularPath:"/03.Rust/10.Rust%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"03.Rust/10.Rust的方法.md",key:"v-1c87ad4a",path:"/pages/Rust_10/",headers:[{level:2,title:"一、方法是什么？",slug:"一、方法是什么",normalizedTitle:"一、方法是什么？",charIndex:141},{level:2,title:"二、示例场景：点灯的 LED",slug:"二、示例场景-点灯的-led",normalizedTitle:"二、示例场景：点灯的 led",charIndex:492},{level:2,title:"三、方法与函数区别？",slug:"三、方法与函数区别",normalizedTitle:"三、方法与函数区别？",charIndex:1278},{level:2,title:"四、方法签名细节",slug:"四、方法签名细节",normalizedTitle:"四、方法签名细节",charIndex:1467},{level:2,title:"五、关联函数（Associated Functions）：看起来像静态方法",slug:"五、关联函数-associated-functions-看起来像静态方法",normalizedTitle:"五、关联函数（associated functions）：看起来像静态方法",charIndex:1796}],headersStr:"一、方法是什么？ 二、示例场景：点灯的 LED 三、方法与函数区别？ 四、方法签名细节 五、关联函数（Associated Functions）：看起来像静态方法",content:'# Rust 的方法：让结构体会“做事”\n\nRust 的方法（methods）就像给结构体装上“功夫技能包”。我们把这些技能写在 impl 块里，让实例自己能“点名调用”，逻辑清晰又好用。\n\n----------------------------------------\n\n\n# 一、方法是什么？\n\n * 方法看起来像函数，但定义在结构体（或枚举、trait）里。\n * 它们的第一个参数总是 self（能是值、引用或可变引用）。\n * 这样你可以通过 instance.my_method() 直接调用，就像让结构体自己做事。\n\n源码里是这么写的：定义在 impl 块里，方法签名像这样：\n\nimpl TypeName {\n    fn method_name(&self, other_arg: T) -> U { ... }\n}\n\n\n1\n2\n3\n\n\n调用方式是：\n\nmy_instance.method_name(arg);\n\n\n1\n\n\n这比每次传 my_instance 更省心。\n\n----------------------------------------\n\n\n# 二、示例场景：点灯的 LED\n\n假设我们有一个 Led 结构体，代表一盏 LED 灯：\n\nstruct Led { state: bool }\n\nimpl Led {\n    /// 打开 LED\n    fn turn_on(&mut self) {\n        self.state = true;\n        println!("LED is now ON");\n    }\n\n    /// 关闭 LED\n    fn turn_off(&mut self) {\n        self.state = false;\n        println!("LED is now OFF");\n    }\n\n    /// 检查 LED 是否处于开启状态\n    fn is_on(&self) -> bool {\n        self.state\n    }\n}\n\nfn main() {\n    let mut led = Led { state: false };\n    led.turn_on();\n    println!("LED 当前状态：{}", led.is_on());\n    led.turn_off();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里有几个要点：\n\n * turn_on 和 turn_off 使用 &mut self，因为它们改变了自己的状态。\n * is_on 用 &self，只是读取，不动结构体内容。\n * 调用方式统一用 led.method()，语义贴近人类语言：“让 led 做某事”。\n\n----------------------------------------\n\n\n# 三、方法与函数区别？\n\n * 函数：通常写在外面，需要明确传参，比如 fn area(rect: &Rectangle) -> u32。\n * 方法：写在 impl 里，有 self 参数，调用更自然，组织也更清晰。\n\n这让代码逻辑像“面向对象”风格：先定义结构体，再赋能一系列方法。\n\n----------------------------------------\n\n\n# 四、方法签名细节\n\n方法有三种常见签名方式：\n\n 1. fn foo(&self) —— 不改变结构体，只读取内部内容。\n 2. fn foo(&mut self) —— 可改变结构体内部状态。\n 3. fn foo(self) —— 消费结构体本身（少见），常用于把自己转成别的类型。\n\n例如：\n\nimpl Led {\n    fn destroy(self) {\n        println!("LED destroyed, state was {}", self.state);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用后 led 就不能再用了。\n\n----------------------------------------\n\n\n# 五、关联函数（Associated Functions）：看起来像静态方法\n\n如果不加 self，它就不是方法，而是“结构体自己的函数”（常用于创建新实例）：\n\nimpl Led {\n    fn new_on() -> Self {\n        Led { state: true }\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n调用方式：\n\nlet led2 = Led::new_on();\n\n\n1\n\n\n像工厂函数，总在结构体里但不作用于实例。',normalizedContent:'# rust 的方法：让结构体会“做事”\n\nrust 的方法（methods）就像给结构体装上“功夫技能包”。我们把这些技能写在 impl 块里，让实例自己能“点名调用”，逻辑清晰又好用。\n\n----------------------------------------\n\n\n# 一、方法是什么？\n\n * 方法看起来像函数，但定义在结构体（或枚举、trait）里。\n * 它们的第一个参数总是 self（能是值、引用或可变引用）。\n * 这样你可以通过 instance.my_method() 直接调用，就像让结构体自己做事。\n\n源码里是这么写的：定义在 impl 块里，方法签名像这样：\n\nimpl typename {\n    fn method_name(&self, other_arg: t) -> u { ... }\n}\n\n\n1\n2\n3\n\n\n调用方式是：\n\nmy_instance.method_name(arg);\n\n\n1\n\n\n这比每次传 my_instance 更省心。\n\n----------------------------------------\n\n\n# 二、示例场景：点灯的 led\n\n假设我们有一个 led 结构体，代表一盏 led 灯：\n\nstruct led { state: bool }\n\nimpl led {\n    /// 打开 led\n    fn turn_on(&mut self) {\n        self.state = true;\n        println!("led is now on");\n    }\n\n    /// 关闭 led\n    fn turn_off(&mut self) {\n        self.state = false;\n        println!("led is now off");\n    }\n\n    /// 检查 led 是否处于开启状态\n    fn is_on(&self) -> bool {\n        self.state\n    }\n}\n\nfn main() {\n    let mut led = led { state: false };\n    led.turn_on();\n    println!("led 当前状态：{}", led.is_on());\n    led.turn_off();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里有几个要点：\n\n * turn_on 和 turn_off 使用 &mut self，因为它们改变了自己的状态。\n * is_on 用 &self，只是读取，不动结构体内容。\n * 调用方式统一用 led.method()，语义贴近人类语言：“让 led 做某事”。\n\n----------------------------------------\n\n\n# 三、方法与函数区别？\n\n * 函数：通常写在外面，需要明确传参，比如 fn area(rect: &rectangle) -> u32。\n * 方法：写在 impl 里，有 self 参数，调用更自然，组织也更清晰。\n\n这让代码逻辑像“面向对象”风格：先定义结构体，再赋能一系列方法。\n\n----------------------------------------\n\n\n# 四、方法签名细节\n\n方法有三种常见签名方式：\n\n 1. fn foo(&self) —— 不改变结构体，只读取内部内容。\n 2. fn foo(&mut self) —— 可改变结构体内部状态。\n 3. fn foo(self) —— 消费结构体本身（少见），常用于把自己转成别的类型。\n\n例如：\n\nimpl led {\n    fn destroy(self) {\n        println!("led destroyed, state was {}", self.state);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用后 led 就不能再用了。\n\n----------------------------------------\n\n\n# 五、关联函数（associated functions）：看起来像静态方法\n\n如果不加 self，它就不是方法，而是“结构体自己的函数”（常用于创建新实例）：\n\nimpl led {\n    fn new_on() -> self {\n        led { state: true }\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n调用方式：\n\nlet led2 = led::new_on();\n\n\n1\n\n\n像工厂函数，总在结构体里但不作用于实例。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"11.Rust的枚举",frontmatter:{title:"11.Rust的枚举",date:"2025-08-23T20:00:00.000Z",permalink:"/pages/Rust_11/"},regularPath:"/03.Rust/11.Rust%E7%9A%84%E6%9E%9A%E4%B8%BE.html",relativePath:"03.Rust/11.Rust的枚举.md",key:"v-7a1f2933",path:"/pages/Rust_11/",headers:[{level:2,title:"一、枚举（Enum）是啥？",slug:"一、枚举-enum-是啥",normalizedTitle:"一、枚举（enum）是啥？",charIndex:173},{level:2,title:"二、枚举还能带点“行李”",slug:"二、枚举还能带点-行李",normalizedTitle:"二、枚举还能带点“行李”",charIndex:417},{level:2,title:"三、Rust 内置的明星枚举：Option",slug:"三、rust-内置的明星枚举-option",normalizedTitle:"三、rust 内置的明星枚举：option",charIndex:795},{level:2,title:"四、为什么 Option 比 null 更靠谱？",slug:"四、为什么-option-比-null-更靠谱",normalizedTitle:"四、为什么 option 比 null 更靠谱？",charIndex:1210}],headersStr:"一、枚举（Enum）是啥？ 二、枚举还能带点“行李” 三、Rust 内置的明星枚举：Option 四、为什么 Option 比 null 更靠谱？",content:'# Rust 的枚举（Enum）与 Option：给数据贴标签的艺术\n\n在编程世界里，有时候我们希望数据不只是个值，还要有个“身份”或“状态”。\nRust 里就有一种强力武器：枚举（Enum）。它能把有限的几种可能性收拢起来，编译器帮你保证不会出岔子。\n\n----------------------------------------\n\n\n# 一、枚举（Enum）是啥？\n\n枚举就是一类“只能在有限选项中挑一个”的数据类型。\n想象一下，你有个状态机：红灯、绿灯、黄灯。我们可以这样写：\n\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\n\n1\n2\n3\n4\n5\n\n\n当我们定义一个变量：\n\nlet light = TrafficLight::Red;\n\n\n1\n\n\n这就表示当前信号灯是“红色”。 优势是什么？——它不可能变成什么 "blue" 之类莫名其妙的状态。\n\n\n# 二、枚举还能带点“行李”\n\n枚举不仅能表示“是哪一类”，还可以顺便带上额外数据。 举个例子：我们做一个消息系统，有三种可能：\n\n * 空消息\n * 文本消息\n * 坐标消息\n\n在 Rust 里可以这么写：\n\nenum Message {\n    Empty,\n    Text(String),\n    Position(i32, i32),\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用的时候：\n\nlet m1 = Message::Empty;\nlet m2 = Message::Text(String::from("Hello!"));\nlet m3 = Message::Position(10, 20);\n\n\n1\n2\n3\n\n\n这样数据和分类合体，逻辑更清楚。\n\n----------------------------------------\n\n\n# 三、Rust 内置的明星枚举：Option\n\n在别的语言里，如果某个值“可能没有”，通常会用 null。 但是 Rust 没有 null，而是用 Option 来表达“有或没有”。\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n\n1\n2\n3\n4\n\n\n这就是 Rust 标准库里 Option 的定义。\n\n * Some(T)：表示里面有一个值 T；\n * None：表示啥也没有。\n\n用例子感受一下：\n\nlet some_number = Some(5);\nlet some_text = Some("Hello");\nlet no_value: Option<i32> = None;\n\n\n1\n2\n3\n\n\n这里的 some_number 就是“有值 5”，no_value 就是“啥都没有”。\n\n----------------------------------------\n\n\n# 四、为什么 Option 比 null 更靠谱？\n\n * 在 Rust 里，Option 是一个显式的类型，你在写代码时必须处理“有值”和“没值”的情况；\n * 它避免了像其他语言那样，一不小心解引用 null 就崩溃的尴尬。\n\n比如说： 你写了一个函数，它要么找到某个元素返回它，要么啥也找不到。 返回 Option<T> 就再合适不过。\n\nfn find_index(arr: &[i32], target: i32) -> Option<usize> {\n    for (i, &item) in arr.iter().enumerate() {\n        if item == target {\n            return Some(i);\n        }\n    }\n    None\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样调用：\n\nlet nums = vec![10, 20, 30];\nlet pos = find_index(&nums, 20);\n\n\n1\n2\n\n\n这里 pos 的类型是 Option<usize>，要么 Some(1)，要么 None。',normalizedContent:'# rust 的枚举（enum）与 option：给数据贴标签的艺术\n\n在编程世界里，有时候我们希望数据不只是个值，还要有个“身份”或“状态”。\nrust 里就有一种强力武器：枚举（enum）。它能把有限的几种可能性收拢起来，编译器帮你保证不会出岔子。\n\n----------------------------------------\n\n\n# 一、枚举（enum）是啥？\n\n枚举就是一类“只能在有限选项中挑一个”的数据类型。\n想象一下，你有个状态机：红灯、绿灯、黄灯。我们可以这样写：\n\nenum trafficlight {\n    red,\n    yellow,\n    green,\n}\n\n\n1\n2\n3\n4\n5\n\n\n当我们定义一个变量：\n\nlet light = trafficlight::red;\n\n\n1\n\n\n这就表示当前信号灯是“红色”。 优势是什么？——它不可能变成什么 "blue" 之类莫名其妙的状态。\n\n\n# 二、枚举还能带点“行李”\n\n枚举不仅能表示“是哪一类”，还可以顺便带上额外数据。 举个例子：我们做一个消息系统，有三种可能：\n\n * 空消息\n * 文本消息\n * 坐标消息\n\n在 rust 里可以这么写：\n\nenum message {\n    empty,\n    text(string),\n    position(i32, i32),\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用的时候：\n\nlet m1 = message::empty;\nlet m2 = message::text(string::from("hello!"));\nlet m3 = message::position(10, 20);\n\n\n1\n2\n3\n\n\n这样数据和分类合体，逻辑更清楚。\n\n----------------------------------------\n\n\n# 三、rust 内置的明星枚举：option\n\n在别的语言里，如果某个值“可能没有”，通常会用 null。 但是 rust 没有 null，而是用 option 来表达“有或没有”。\n\nenum option<t> {\n    some(t),\n    none,\n}\n\n\n1\n2\n3\n4\n\n\n这就是 rust 标准库里 option 的定义。\n\n * some(t)：表示里面有一个值 t；\n * none：表示啥也没有。\n\n用例子感受一下：\n\nlet some_number = some(5);\nlet some_text = some("hello");\nlet no_value: option<i32> = none;\n\n\n1\n2\n3\n\n\n这里的 some_number 就是“有值 5”，no_value 就是“啥都没有”。\n\n----------------------------------------\n\n\n# 四、为什么 option 比 null 更靠谱？\n\n * 在 rust 里，option 是一个显式的类型，你在写代码时必须处理“有值”和“没值”的情况；\n * 它避免了像其他语言那样，一不小心解引用 null 就崩溃的尴尬。\n\n比如说： 你写了一个函数，它要么找到某个元素返回它，要么啥也找不到。 返回 option<t> 就再合适不过。\n\nfn find_index(arr: &[i32], target: i32) -> option<usize> {\n    for (i, &item) in arr.iter().enumerate() {\n        if item == target {\n            return some(i);\n        }\n    }\n    none\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样调用：\n\nlet nums = vec![10, 20, 30];\nlet pos = find_index(&nums, 20);\n\n\n1\n2\n\n\n这里 pos 的类型是 option<usize>，要么 some(1)，要么 none。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"12.Rust的match控制流结构",frontmatter:{title:"12.Rust的match控制流结构",date:"2025-08-24T06:00:00.000Z",permalink:"/pages/Rust_12/"},regularPath:"/03.Rust/12.Rust%E7%9A%84match%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84.html",relativePath:"03.Rust/12.Rust的match控制流结构.md",key:"v-3d878538",path:"/pages/Rust_12/",headers:[{level:2,title:"一、match 是什么",slug:"一、match-是什么",normalizedTitle:"一、match 是什么",charIndex:219},{level:2,title:"二、基础示例：枚举 + match",slug:"二、基础示例-枚举-match",normalizedTitle:"二、基础示例：枚举 + match",charIndex:399},{level:2,title:"三、多行分支写法",slug:"三、多行分支写法",normalizedTitle:"三、多行分支写法",charIndex:846},{level:2,title:"四、为什么 match 更靠谱？",slug:"四、为什么-match-更靠谱",normalizedTitle:"四、为什么 match 更靠谱？",charIndex:1309},{level:2,title:"五、换个例子：辨识数字范围",slug:"五、换个例子-辨识数字范围",normalizedTitle:"五、换个例子：辨识数字范围",charIndex:1488}],headersStr:"一、match 是什么 二、基础示例：枚举 + match 三、多行分支写法 四、为什么 match 更靠谱？ 五、换个例子：辨识数字范围",content:'# Rust 的 match 控制流结构：比 if/else 更“走心”的分支写法\n\n在 Rust 里，match 就像一台「值分类机」：它依次检查每个标签（模式），一旦“刚好合适”，就自动跳进对应处理逻辑里。比起 if/else，它更安全、更严谨，也让代码结构更清晰:contentReference[oaicite:0]{index=0}。\n\n----------------------------------------\n\n\n# 一、match 是什么\n\nmatch 可以拿任意类型（尤其是枚举）来做分支判断，不局限于布尔值。用 match 能让编译器帮你确保每一种情况都写到了，不会漏。\n\n形象比喻：想象你在自动分拣中心——每个分支是一个洞，值或数据“滑”过去，正好合适哪个洞，就进入哪个分支。\n\n----------------------------------------\n\n\n# 二、基础示例：枚举 + match\n\n假设你有一套“宠物”分类：\n\nenum Pet {\n    Cat,\n    Dog,\n    Rabbit,\n}\n\nfn describe(p: Pet) -> &\'static str {\n    match p {\n        Pet::Cat => "你抓到了一只喵喵～",\n        Pet::Dog => "汪汪！一只G狗！",\n        Pet::Rabbit => "蹦蹦的兔兔在这里~",\n    }\n}\n\nfn main() {\n    let p = Pet::Rabbit;\n    println!("{}", describe(p));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match p 把 p 的状态拿来对比标签；\n * 每个 => 后是该分支的处理结果；\n * 你必须写全 Cat、Dog、Rabbit 三种，否则编译不通过。\n\n\n# 三、多行分支写法\n\n有时候分支逻辑不止一个动作，比如还要打印日志：\n\nfn count_pet(p: Pet) -> u32 {\n    match p {\n        Pet::Cat => {\n            println!("统计：捕获了一只猫咪");\n            4\n        }\n        Pet::Dog => {\n            println!("统计：捕获了一只狗狗");\n            3\n        }\n        Pet::Rabbit => {\n            println!("统计：兔兔跑得快");\n            2\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 分支代码块里可以写一堆逻辑；\n * 最后一行是被 return 的“值”。\n\n----------------------------------------\n\n\n# 四、为什么 match 更靠谱？\n\n * 必须覆盖所有可能值（穷尽检查），少了一个分支直接编译报错。\n * 结构清晰，各个分支整齐排列，读着更舒服。\n * 灵活表达，以后你会看到它能和复杂模式结合使用——简直是流程控制的王牌工具doc.rust-lang.org。\n\n----------------------------------------\n\n\n# 五、换个例子：辨识数字范围\n\n假如你写个函数，根据数字区间给出评价：\n\nfn rate(num: i32) -> &\'static str {\n    match num {\n        0 => "零，不动弹",\n        1..=5 => "小于等于五",\n        6..=10 => "介于六和十之间",\n        _ => "大于十",\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 1..=5 表示从 1 到 5（包含 5）；\n * _ 是“通配符”，匹配所有剩下的数。\n\n这也体现了 match 的强大：区间、默认值一并搞定，写起来简洁又醒目。',normalizedContent:'# rust 的 match 控制流结构：比 if/else 更“走心”的分支写法\n\n在 rust 里，match 就像一台「值分类机」：它依次检查每个标签（模式），一旦“刚好合适”，就自动跳进对应处理逻辑里。比起 if/else，它更安全、更严谨，也让代码结构更清晰:contentreference[oaicite:0]{index=0}。\n\n----------------------------------------\n\n\n# 一、match 是什么\n\nmatch 可以拿任意类型（尤其是枚举）来做分支判断，不局限于布尔值。用 match 能让编译器帮你确保每一种情况都写到了，不会漏。\n\n形象比喻：想象你在自动分拣中心——每个分支是一个洞，值或数据“滑”过去，正好合适哪个洞，就进入哪个分支。\n\n----------------------------------------\n\n\n# 二、基础示例：枚举 + match\n\n假设你有一套“宠物”分类：\n\nenum pet {\n    cat,\n    dog,\n    rabbit,\n}\n\nfn describe(p: pet) -> &\'static str {\n    match p {\n        pet::cat => "你抓到了一只喵喵～",\n        pet::dog => "汪汪！一只g狗！",\n        pet::rabbit => "蹦蹦的兔兔在这里~",\n    }\n}\n\nfn main() {\n    let p = pet::rabbit;\n    println!("{}", describe(p));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match p 把 p 的状态拿来对比标签；\n * 每个 => 后是该分支的处理结果；\n * 你必须写全 cat、dog、rabbit 三种，否则编译不通过。\n\n\n# 三、多行分支写法\n\n有时候分支逻辑不止一个动作，比如还要打印日志：\n\nfn count_pet(p: pet) -> u32 {\n    match p {\n        pet::cat => {\n            println!("统计：捕获了一只猫咪");\n            4\n        }\n        pet::dog => {\n            println!("统计：捕获了一只狗狗");\n            3\n        }\n        pet::rabbit => {\n            println!("统计：兔兔跑得快");\n            2\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 分支代码块里可以写一堆逻辑；\n * 最后一行是被 return 的“值”。\n\n----------------------------------------\n\n\n# 四、为什么 match 更靠谱？\n\n * 必须覆盖所有可能值（穷尽检查），少了一个分支直接编译报错。\n * 结构清晰，各个分支整齐排列，读着更舒服。\n * 灵活表达，以后你会看到它能和复杂模式结合使用——简直是流程控制的王牌工具doc.rust-lang.org。\n\n----------------------------------------\n\n\n# 五、换个例子：辨识数字范围\n\n假如你写个函数，根据数字区间给出评价：\n\nfn rate(num: i32) -> &\'static str {\n    match num {\n        0 => "零，不动弹",\n        1..=5 => "小于等于五",\n        6..=10 => "介于六和十之间",\n        _ => "大于十",\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 1..=5 表示从 1 到 5（包含 5）；\n * _ 是“通配符”，匹配所有剩下的数。\n\n这也体现了 match 的强大：区间、默认值一并搞定，写起来简洁又醒目。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"13.Rust 的语法糖 - if let",frontmatter:{title:"13.Rust 的语法糖 - if let",date:"2025-08-25T21:00:00.000Z",permalink:"/pages/Rust_13/"},regularPath:"/03.Rust/13.Rust%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96-iflet.html",relativePath:"03.Rust/13.Rust的语法糖-iflet.md",key:"v-11435202",path:"/pages/Rust_13/",headers:[{level:2,title:"一、if let 是个啥？",slug:"一、if-let-是个啥",normalizedTitle:"一、if let 是个啥？",charIndex:25},{level:2,title:"二、举个例子：盒子开宝藏",slug:"二、举个例子-盒子开宝藏",normalizedTitle:"二、举个例子：盒子开宝藏",charIndex:204},{level:2,title:"三、Option 与 if let",slug:"三、option-与-if-let",normalizedTitle:"三、option 与 if let",charIndex:673},{level:2,title:"四、还能配合 else",slug:"四、还能配合-else",normalizedTitle:"四、还能配合 else",charIndex:990},{level:2,title:"五、什么时候用 if let，什么时候用 match？",slug:"五、什么时候用-if-let-什么时候用-match",normalizedTitle:"五、什么时候用 if let，什么时候用 match？",charIndex:1277},{level:2,title:"六、脑洞一下",slug:"六、脑洞一下",normalizedTitle:"六、脑洞一下",charIndex:1458}],headersStr:"一、if let 是个啥？ 二、举个例子：盒子开宝藏 三、Option 与 if let 四、还能配合 else 五、什么时候用 if let，什么时候用 match？ 六、脑洞一下",content:'# Rust 的语法糖 - if let\n\n\n# 一、if let 是个啥？\n\n在学习 match 的时候，你可能觉得它有点啰嗦：\n有时候我只关心一个分支，结果写一大堆 _ => ()，又长又丑。\n\n这时候，Rust 贴心地给你塞了一个小糖果：if let。\n它其实就是 “只关注一个模式的 match” 的缩写。\n\n----------------------------------------\n\n\n# 二、举个例子：盒子开宝藏\n\n假设我们有个神秘的盒子，它可能藏着一个数字宝藏，也可能什么都没有：\n\nenum Boxed {\n    Treasure(i32),\n    Empty,\n}\n\nfn main() {\n    let my_box = Boxed::Treasure(42);\n\n    // 只关心有宝藏的情况\n    if let Boxed::Treasure(v) = my_box {\n        println!("我发现了宝藏，价值 {}!", v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果写成 match 的话呢？\n\nmatch my_box {\n    Boxed::Treasure(v) => println!("我发现了宝藏，价值 {}!", v),\n    _ => (),\n}\n\n\n1\n2\n3\n4\n\n\n看出来没？if let 就是上面这坨的简洁版。\n\n----------------------------------------\n\n\n# 三、Option 与 if let\n\nOption 是 Rust 里常见的枚举，代表“可能有值，可能没有值”。 假设我们想要在有值的时候处理一下：\n\nfn main() {\n    let maybe_num = Some(10);\n\n    if let Some(x) = maybe_num {\n        println!("有数字！它是 {}", x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n相当于只关心 Some，而对 None 不想管。 如果用 match，就得多写一行 None => ()，显得很啰嗦。\n\n----------------------------------------\n\n\n# 四、还能配合 else\n\nif let 还能带个 else，就像普通 if 一样：\n\nfn main() {\n    let maybe_name = None;\n\n    if let Some(name) = maybe_name {\n        println!("你好, {}", name);\n    } else {\n        println!("没有名字，只能叫你匿名侠了！");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是不是很优雅？\n\n----------------------------------------\n\n\n# 五、什么时候用 if let，什么时候用 match？\n\n * 如果你只关心一种情况，if let 更简洁。\n * 如果你需要覆盖所有可能，必须用 match，这样编译器能帮你检查穷举。\n\n一句话总结：\n\n> if let 是 match 的快捷写法，适合偷懒的时候。\n\n----------------------------------------\n\n\n# 六、脑洞一下\n\n你可以把 if let 理解为一种“有条件的解锁”：\n\n * 如果钥匙对得上（模式匹配成功），就开门干活；\n * 如果钥匙不对（匹配失败），就悄悄走开，不打扰别人。\n\n这，就是 Rust 给我们的小小语法糖。',normalizedContent:'# rust 的语法糖 - if let\n\n\n# 一、if let 是个啥？\n\n在学习 match 的时候，你可能觉得它有点啰嗦：\n有时候我只关心一个分支，结果写一大堆 _ => ()，又长又丑。\n\n这时候，rust 贴心地给你塞了一个小糖果：if let。\n它其实就是 “只关注一个模式的 match” 的缩写。\n\n----------------------------------------\n\n\n# 二、举个例子：盒子开宝藏\n\n假设我们有个神秘的盒子，它可能藏着一个数字宝藏，也可能什么都没有：\n\nenum boxed {\n    treasure(i32),\n    empty,\n}\n\nfn main() {\n    let my_box = boxed::treasure(42);\n\n    // 只关心有宝藏的情况\n    if let boxed::treasure(v) = my_box {\n        println!("我发现了宝藏，价值 {}!", v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果写成 match 的话呢？\n\nmatch my_box {\n    boxed::treasure(v) => println!("我发现了宝藏，价值 {}!", v),\n    _ => (),\n}\n\n\n1\n2\n3\n4\n\n\n看出来没？if let 就是上面这坨的简洁版。\n\n----------------------------------------\n\n\n# 三、option 与 if let\n\noption 是 rust 里常见的枚举，代表“可能有值，可能没有值”。 假设我们想要在有值的时候处理一下：\n\nfn main() {\n    let maybe_num = some(10);\n\n    if let some(x) = maybe_num {\n        println!("有数字！它是 {}", x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n相当于只关心 some，而对 none 不想管。 如果用 match，就得多写一行 none => ()，显得很啰嗦。\n\n----------------------------------------\n\n\n# 四、还能配合 else\n\nif let 还能带个 else，就像普通 if 一样：\n\nfn main() {\n    let maybe_name = none;\n\n    if let some(name) = maybe_name {\n        println!("你好, {}", name);\n    } else {\n        println!("没有名字，只能叫你匿名侠了！");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是不是很优雅？\n\n----------------------------------------\n\n\n# 五、什么时候用 if let，什么时候用 match？\n\n * 如果你只关心一种情况，if let 更简洁。\n * 如果你需要覆盖所有可能，必须用 match，这样编译器能帮你检查穷举。\n\n一句话总结：\n\n> if let 是 match 的快捷写法，适合偷懒的时候。\n\n----------------------------------------\n\n\n# 六、脑洞一下\n\n你可以把 if let 理解为一种“有条件的解锁”：\n\n * 如果钥匙对得上（模式匹配成功），就开门干活；\n * 如果钥匙不对（匹配失败），就悄悄走开，不打扰别人。\n\n这，就是 rust 给我们的小小语法糖。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"15.Rust的Vector",frontmatter:{title:"15.Rust的Vector",date:"2025-08-28T22:00:00.000Z",permalink:"/pages/Rust_15/"},regularPath:"/03.Rust/15.Rust%E7%9A%84Vector.html",relativePath:"03.Rust/15.Rust的Vector.md",key:"v-8713be10",path:"/pages/Rust_15/",headers:[{level:2,title:"一、定义向量",slug:"一、定义向量",normalizedTitle:"一、定义向量",charIndex:114},{level:2,title:"二、向量的修改",slug:"二、向量的修改",normalizedTitle:"二、向量的修改",charIndex:355},{level:2,title:"三、访问元素",slug:"三、访问元素",normalizedTitle:"三、访问元素",charIndex:566},{level:2,title:"四、遍历向量",slug:"四、遍历向量",normalizedTitle:"四、遍历向量",charIndex:939},{level:2,title:"五、向量和枚举",slug:"五、向量和枚举",normalizedTitle:"五、向量和枚举",charIndex:1248},{level:2,title:"六、Vector 的释放",slug:"六、vector-的释放",normalizedTitle:"六、vector 的释放",charIndex:1519}],headersStr:"一、定义向量 二、向量的修改 三、访问元素 四、遍历向量 五、向量和枚举 六、Vector 的释放",content:'# Rust的Vector\n\n在 Rust 里，如果要存放一系列同类型的元素，最常用的就是 向量（Vector），对应的类型是 Vec<T>。它和 C 语言里的数组不同，不仅能存放数据，还能根据需要动态扩展，非常灵活。\n\n\n# 一、定义向量\n\n定义向量有几种方式：\n\n// 创建一个空的 i32 类型向量\nlet mut v: Vec<i32> = Vec::new();\n\n// 使用宏直接创建并初始化\nlet v = vec![1, 2, 3];\n\n\n1\n2\n3\n4\n5\n\n\n第一种方法需要显式声明类型，因为 Vec::new() 里没有数据，编译器推不出类型。 第二种方法更常见，用 vec![] 宏直接生成。\n\n----------------------------------------\n\n\n# 二、向量的修改\n\n向量是可以动态扩展的，常见操作有：\n\nlet mut numbers = Vec::new();\nnumbers.push(10);\nnumbers.push(20);\nnumbers.push(30);\n\n\n1\n2\n3\n4\n\n\n这里用 push 往里添加元素。 需要注意：要想修改，就得把向量定义成 mut。\n\n----------------------------------------\n\n\n# 三、访问元素\n\n访问向量里的值有两种方式：\n\nlet v = vec![1, 2, 3, 4];\n\n// 下标访问，直接取值\nlet third = &v[2];\nprintln!("第三个元素是 {}", third);\n\n// get 方法，更安全\nmatch v.get(2) {\n    Some(value) => println!("第三个元素是 {}", value),\n    None => println!("没有这个元素"),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n区别在于：\n\n * v[2] 如果越界会直接 panic（程序崩溃）。\n * v.get(2) 返回一个 Option，能优雅地处理越界情况。\n\n----------------------------------------\n\n\n# 四、遍历向量\n\n向量里通常要用循环读取数据：\n\nlet v = vec![100, 200, 300];\n\n// 不可变借用\nfor i in &v {\n    println!("{}", i);\n}\n\n// 可变借用，可以修改里面的值\nlet mut v = vec![1, 2, 3];\nfor i in &mut v {\n    *i += 10;\n}\nprintln!("{:?}", v);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里的 *i 是解引用，把借用拿到的值修改后写回去。\n\n----------------------------------------\n\n\n# 五、向量和枚举\n\n向量要求所有元素类型相同，如果想在一个向量里存不同类型，可以借助枚举：\n\nenum Cell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    Cell::Int(42),\n    Cell::Text(String::from("hello")),\n    Cell::Float(3.14),\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样就能在一个 Vec<Cell> 里存放不同形式的数据。\n\n\n# 六、Vector 的释放\n\nRust 的所有权机制会在向量离开作用域时自动释放内存，包括它里面的元素，不需要手动释放。这就是 Rust 带来的安全性。',normalizedContent:'# rust的vector\n\n在 rust 里，如果要存放一系列同类型的元素，最常用的就是 向量（vector），对应的类型是 vec<t>。它和 c 语言里的数组不同，不仅能存放数据，还能根据需要动态扩展，非常灵活。\n\n\n# 一、定义向量\n\n定义向量有几种方式：\n\n// 创建一个空的 i32 类型向量\nlet mut v: vec<i32> = vec::new();\n\n// 使用宏直接创建并初始化\nlet v = vec![1, 2, 3];\n\n\n1\n2\n3\n4\n5\n\n\n第一种方法需要显式声明类型，因为 vec::new() 里没有数据，编译器推不出类型。 第二种方法更常见，用 vec![] 宏直接生成。\n\n----------------------------------------\n\n\n# 二、向量的修改\n\n向量是可以动态扩展的，常见操作有：\n\nlet mut numbers = vec::new();\nnumbers.push(10);\nnumbers.push(20);\nnumbers.push(30);\n\n\n1\n2\n3\n4\n\n\n这里用 push 往里添加元素。 需要注意：要想修改，就得把向量定义成 mut。\n\n----------------------------------------\n\n\n# 三、访问元素\n\n访问向量里的值有两种方式：\n\nlet v = vec![1, 2, 3, 4];\n\n// 下标访问，直接取值\nlet third = &v[2];\nprintln!("第三个元素是 {}", third);\n\n// get 方法，更安全\nmatch v.get(2) {\n    some(value) => println!("第三个元素是 {}", value),\n    none => println!("没有这个元素"),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n区别在于：\n\n * v[2] 如果越界会直接 panic（程序崩溃）。\n * v.get(2) 返回一个 option，能优雅地处理越界情况。\n\n----------------------------------------\n\n\n# 四、遍历向量\n\n向量里通常要用循环读取数据：\n\nlet v = vec![100, 200, 300];\n\n// 不可变借用\nfor i in &v {\n    println!("{}", i);\n}\n\n// 可变借用，可以修改里面的值\nlet mut v = vec![1, 2, 3];\nfor i in &mut v {\n    *i += 10;\n}\nprintln!("{:?}", v);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里的 *i 是解引用，把借用拿到的值修改后写回去。\n\n----------------------------------------\n\n\n# 五、向量和枚举\n\n向量要求所有元素类型相同，如果想在一个向量里存不同类型，可以借助枚举：\n\nenum cell {\n    int(i32),\n    float(f64),\n    text(string),\n}\n\nlet row = vec![\n    cell::int(42),\n    cell::text(string::from("hello")),\n    cell::float(3.14),\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样就能在一个 vec<cell> 里存放不同形式的数据。\n\n\n# 六、vector 的释放\n\nrust 的所有权机制会在向量离开作用域时自动释放内存，包括它里面的元素，不需要手动释放。这就是 rust 带来的安全性。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"16.Rust的String类型基本原理",frontmatter:{title:"16.Rust的String类型基本原理",date:"2025-08-28T23:00:00.000Z",permalink:"/pages/Rust_16/"},regularPath:"/03.Rust/16.Rust%E7%9A%84String%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"03.Rust/16.Rust的String类型基本原理.md",key:"v-f0192e14",path:"/pages/Rust_16/",headers:[{level:2,title:"一、String 是什么？",slug:"一、string-是什么",normalizedTitle:"一、string 是什么？",charIndex:178},{level:2,title:"二、怎么创建 String？",slug:"二、怎么创建-string",normalizedTitle:"二、怎么创建 string？",charIndex:378},{level:2,title:"三、如何更新 String？",slug:"三、如何更新-string",normalizedTitle:"三、如何更新 string？",charIndex:572},{level:2,title:"四、拼接要当心",slug:"四、拼接要当心",normalizedTitle:"四、拼接要当心",charIndex:793},{level:2,title:"五、为什么不能像索引数组那样索引 String？",slug:"五、为什么不能像索引数组那样索引-string",normalizedTitle:"五、为什么不能像索引数组那样索引 string？",charIndex:1130},{level:2,title:"六、如果你真的想访问字符怎么办？",slug:"六、如果你真的想访问字符怎么办",normalizedTitle:"六、如果你真的想访问字符怎么办？",charIndex:1397}],headersStr:"一、String 是什么？ 二、怎么创建 String？ 三、如何更新 String？ 四、拼接要当心 五、为什么不能像索引数组那样索引 String？ 六、如果你真的想访问字符怎么办？",content:'# Rust 的 String 类型基础：为什么它既强大又狡猾？\n\nRust 的 String 可变又可增长，背后是 UTF-8，加上 Rust 注重安全，这玩意看似简单实则复杂。掌握它，你就能像撸 cursor 一样骄傲地“管住”自己的字符串，工程师体验极佳。\n\n----------------------------------------\n\n\n# 一、String 是什么？\n\n * 核心语言只有一种“字符串 slice”类型：str，只能以 &str 的形式出现。\n * String 是标准库提供的动态、可变、拥有所有权的 UTF-8 字符串，底层其实就是一个 Vec<u8>。\n * 换句话说：String = 动态字节数组 + UTF-8 智能。\n\n----------------------------------------\n\n\n# 二、怎么创建 String？\n\nlet mut s = String::new(); // 空字符串\n\nlet s = "hello".to_string();            // 从 &str 转换\nlet s = String::from("hello, world");   // 一样的效果\n\n\n\n1\n2\n3\n4\n5\n\n\n这两种方式功能相同，喜欢风格选一种就好。\n\n\n# 三、如何更新 String？\n\n你想给它加内容，可以这么干：\n\nlet mut s = String::from("foo");\ns.push_str("bar");  // 加字符串 slice\ns.push(\'!\');        // 加一个字符\n\n\n1\n2\n3\n\n\n你看这是在操作 Vec<u8>，只有你想追加时才真的改底层，效率杠杠的。\n\n----------------------------------------\n\n\n# 四、拼接要当心\n\n拼字符串挺常见，但写得不小心就容易踩坑：\n\nlet a = String::from("Hello, ");\nlet b = String::from("world!");\nlet c = a + &b; // a 被移动掉，之后不能再用 a 了\n\n\n1\n2\n3\n\n\n别忘了加 &b，Rust 会把 &String 自动转成 &str（叫 deref coercion），但 a 会被消费掉 —— 这是效率和所有权设计的结果。\n\n写得更清晰的方法是：\n\nlet c = format!("{a}-{b}-{a2}");\n\n\n1\n\n\n这样既不会动所有权，也更直观。\n\n----------------------------------------\n\n\n# 五、为什么不能像索引数组那样索引 String？\n\n尝试下面代码，你会碰壁：\n\nlet s = String::from("你好");\nlet c = s[0]; // 直接索引会编译报错\n\n\n1\n2\n\n\n原因在于：\n\n * 字符不是整齐排列的，每个字符在 UTF-8 下字节长度不定；\n * Rust 的索引期望 O(1) 访问，但为了找到一个字符，必须遍历到相应字节 —— 没法保证常数时间；\n * 为防出 bug，索引被禁止写入内核。\n\n----------------------------------------\n\n\n# 六、如果你真的想访问字符怎么办？\n\n明确告诉 Rust：我是按字符访问：\n\nfor c in "你好".chars() {\n    println!("{c}");\n}\n\n\n1\n2\n3\n\n\n如果你想看字节值：\n\nfor b in "你好".bytes() {\n    println!("{b}");\n}\n\n\n1\n2\n3\n\n\n两种表达方式清晰又安全。',normalizedContent:'# rust 的 string 类型基础：为什么它既强大又狡猾？\n\nrust 的 string 可变又可增长，背后是 utf-8，加上 rust 注重安全，这玩意看似简单实则复杂。掌握它，你就能像撸 cursor 一样骄傲地“管住”自己的字符串，工程师体验极佳。\n\n----------------------------------------\n\n\n# 一、string 是什么？\n\n * 核心语言只有一种“字符串 slice”类型：str，只能以 &str 的形式出现。\n * string 是标准库提供的动态、可变、拥有所有权的 utf-8 字符串，底层其实就是一个 vec<u8>。\n * 换句话说：string = 动态字节数组 + utf-8 智能。\n\n----------------------------------------\n\n\n# 二、怎么创建 string？\n\nlet mut s = string::new(); // 空字符串\n\nlet s = "hello".to_string();            // 从 &str 转换\nlet s = string::from("hello, world");   // 一样的效果\n\n\n\n1\n2\n3\n4\n5\n\n\n这两种方式功能相同，喜欢风格选一种就好。\n\n\n# 三、如何更新 string？\n\n你想给它加内容，可以这么干：\n\nlet mut s = string::from("foo");\ns.push_str("bar");  // 加字符串 slice\ns.push(\'!\');        // 加一个字符\n\n\n1\n2\n3\n\n\n你看这是在操作 vec<u8>，只有你想追加时才真的改底层，效率杠杠的。\n\n----------------------------------------\n\n\n# 四、拼接要当心\n\n拼字符串挺常见，但写得不小心就容易踩坑：\n\nlet a = string::from("hello, ");\nlet b = string::from("world!");\nlet c = a + &b; // a 被移动掉，之后不能再用 a 了\n\n\n1\n2\n3\n\n\n别忘了加 &b，rust 会把 &string 自动转成 &str（叫 deref coercion），但 a 会被消费掉 —— 这是效率和所有权设计的结果。\n\n写得更清晰的方法是：\n\nlet c = format!("{a}-{b}-{a2}");\n\n\n1\n\n\n这样既不会动所有权，也更直观。\n\n----------------------------------------\n\n\n# 五、为什么不能像索引数组那样索引 string？\n\n尝试下面代码，你会碰壁：\n\nlet s = string::from("你好");\nlet c = s[0]; // 直接索引会编译报错\n\n\n1\n2\n\n\n原因在于：\n\n * 字符不是整齐排列的，每个字符在 utf-8 下字节长度不定；\n * rust 的索引期望 o(1) 访问，但为了找到一个字符，必须遍历到相应字节 —— 没法保证常数时间；\n * 为防出 bug，索引被禁止写入内核。\n\n----------------------------------------\n\n\n# 六、如果你真的想访问字符怎么办？\n\n明确告诉 rust：我是按字符访问：\n\nfor c in "你好".chars() {\n    println!("{c}");\n}\n\n\n1\n2\n3\n\n\n如果你想看字节值：\n\nfor b in "你好".bytes() {\n    println!("{b}");\n}\n\n\n1\n2\n3\n\n\n两种表达方式清晰又安全。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"17.Rust的HashMap",frontmatter:{title:"17.Rust的HashMap",date:"2025-08-28T23:30:00.000Z",permalink:"/pages/Rust_17/"},regularPath:"/03.Rust/17.Rust%E7%9A%84HashMap.html",relativePath:"03.Rust/17.Rust的HashMap.md",key:"v-85746228",path:"/pages/Rust_17/",headers:[{level:2,title:"一、什么是 HashMap？",slug:"一、什么是-hashmap",normalizedTitle:"一、什么是 hashmap？",charIndex:145},{level:2,title:"二、取值和遍历",slug:"二、取值和遍历",normalizedTitle:"二、取值和遍历",charIndex:486},{level:2,title:"三、更新 HashMap",slug:"三、更新-hashmap",normalizedTitle:"三、更新 hashmap",charIndex:806},{level:3,title:"1. 直接覆盖",slug:"_1-直接覆盖",normalizedTitle:"1. 直接覆盖",charIndex:850},{level:3,title:"2. 只在键不存在时插入",slug:"_2-只在键不存在时插入",normalizedTitle:"2. 只在键不存在时插入",charIndex:924},{level:3,title:"3. 根据旧值更新",slug:"_3-根据旧值更新",normalizedTitle:"3. 根据旧值更新",charIndex:1044},{level:2,title:"四、关于所有权的细节",slug:"四、关于所有权的细节",normalizedTitle:"四、关于所有权的细节",charIndex:1414},{level:2,title:"五、总结",slug:"五、总结",normalizedTitle:"五、总结",charIndex:1784}],headersStr:"一、什么是 HashMap？ 二、取值和遍历 三、更新 HashMap 1. 直接覆盖 2. 只在键不存在时插入 3. 根据旧值更新 四、关于所有权的细节 五、总结",content:'# Rust 的 HashMap：键值对的老管家\n\nRust 的集合里，Vec 像是有序列表，String 是字符串专家，而 HashMap 就是大管家：负责把键和对应的值捆在一起，方便快速查找。\n\n----------------------------------------\n\n\n# 一、什么是 HashMap？\n\n * 本质：一个存储 键–值对 的集合。\n * 键（Key）：可以是任何实现了 Eq 和 Hash 的类型（整数、字符串常用）。\n * 值（Value）：可以是任意类型。\n * 查找效率：理论上 O(1)，也就是非常快。\n\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    scores.insert(String::from("Blue"), 10);\n    scores.insert(String::from("Red"), 50);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这段代码就建了一个球队分数表。\n\n\n# 二、取值和遍历\n\n你可以通过 get 来获取：\n\nlet team_name = String::from("Blue");\nlet score = scores.get(&team_name);\nprintln!("{:?}", score); // Some(10)\n\n\n1\n2\n3\n\n\nget 返回的是 Option<&V>，所以要么是 Some(值)，要么是 None。\n\n遍历所有键值对：\n\nfor (key, value) in &scores {\n    println!("{key}: {value}");\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 三、更新 HashMap\n\nHashMap 里的值可以覆盖，也可以按规则插入。\n\n\n# 1. 直接覆盖\n\nscores.insert(String::from("Blue"), 25); // 原来 10 变成 25\n\n\n1\n\n\n\n# 2. 只在键不存在时插入\n\n用 .entry() 方法：\n\nscores.entry(String::from("Yellow")).or_insert(30);\n\n\n1\n\n\n如果 Yellow 已经有分数，不会动；没有才会插入。\n\n\n# 3. 根据旧值更新\n\nlet text = "hello world wonderful world";\n\nlet mut map = HashMap::new();\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nprintln!("{map:?}");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个例子就是 统计词频：\n\n * entry(word) 先查看 key 是否存在；\n * .or_insert(0) 表示如果不存在就插入 0；\n * 然后 *count += 1 更新。\n\n----------------------------------------\n\n\n# 四、关于所有权的细节\n\n * 如果你把 String 当作 key 或 value 插入 HashMap，它的所有权会被移动进 Map。\n * 如果你只想借用，就要用引用类型。\n\nlet field_name = String::from("Favorite color");\nlet field_value = String::from("Blue");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n\n// field_name, field_value 已经失效\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以要么用 .clone()，要么一开始就存引用。\n\n----------------------------------------\n\n\n# 五、总结\n\n * HashMap 用来存 键值对，快速查找，查不到返回 None。\n * 常用操作：insert、get、entry().or_insert()。\n * 注意所有权问题，插进去就不能再直接用了。\n * 适合做配置表、统计、缓存等。\n\nRust 的集合三兄弟，到这儿算齐活了：\n\n * Vec 管列表，\n * String 管文本，\n * HashMap 管键值关系。',normalizedContent:'# rust 的 hashmap：键值对的老管家\n\nrust 的集合里，vec 像是有序列表，string 是字符串专家，而 hashmap 就是大管家：负责把键和对应的值捆在一起，方便快速查找。\n\n----------------------------------------\n\n\n# 一、什么是 hashmap？\n\n * 本质：一个存储 键–值对 的集合。\n * 键（key）：可以是任何实现了 eq 和 hash 的类型（整数、字符串常用）。\n * 值（value）：可以是任意类型。\n * 查找效率：理论上 o(1)，也就是非常快。\n\nuse std::collections::hashmap;\n\nfn main() {\n    let mut scores = hashmap::new();\n    scores.insert(string::from("blue"), 10);\n    scores.insert(string::from("red"), 50);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这段代码就建了一个球队分数表。\n\n\n# 二、取值和遍历\n\n你可以通过 get 来获取：\n\nlet team_name = string::from("blue");\nlet score = scores.get(&team_name);\nprintln!("{:?}", score); // some(10)\n\n\n1\n2\n3\n\n\nget 返回的是 option<&v>，所以要么是 some(值)，要么是 none。\n\n遍历所有键值对：\n\nfor (key, value) in &scores {\n    println!("{key}: {value}");\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 三、更新 hashmap\n\nhashmap 里的值可以覆盖，也可以按规则插入。\n\n\n# 1. 直接覆盖\n\nscores.insert(string::from("blue"), 25); // 原来 10 变成 25\n\n\n1\n\n\n\n# 2. 只在键不存在时插入\n\n用 .entry() 方法：\n\nscores.entry(string::from("yellow")).or_insert(30);\n\n\n1\n\n\n如果 yellow 已经有分数，不会动；没有才会插入。\n\n\n# 3. 根据旧值更新\n\nlet text = "hello world wonderful world";\n\nlet mut map = hashmap::new();\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nprintln!("{map:?}");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个例子就是 统计词频：\n\n * entry(word) 先查看 key 是否存在；\n * .or_insert(0) 表示如果不存在就插入 0；\n * 然后 *count += 1 更新。\n\n----------------------------------------\n\n\n# 四、关于所有权的细节\n\n * 如果你把 string 当作 key 或 value 插入 hashmap，它的所有权会被移动进 map。\n * 如果你只想借用，就要用引用类型。\n\nlet field_name = string::from("favorite color");\nlet field_value = string::from("blue");\n\nlet mut map = hashmap::new();\nmap.insert(field_name, field_value);\n\n// field_name, field_value 已经失效\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以要么用 .clone()，要么一开始就存引用。\n\n----------------------------------------\n\n\n# 五、总结\n\n * hashmap 用来存 键值对，快速查找，查不到返回 none。\n * 常用操作：insert、get、entry().or_insert()。\n * 注意所有权问题，插进去就不能再直接用了。\n * 适合做配置表、统计、缓存等。\n\nrust 的集合三兄弟，到这儿算齐活了：\n\n * vec 管列表，\n * string 管文本，\n * hashmap 管键值关系。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"14.Rust的模块系统",frontmatter:{title:"14.Rust的模块系统",date:"2025-08-27T22:00:00.000Z",permalink:"/pages/Rust_14/"},regularPath:"/03.Rust/14.Rust%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html",relativePath:"03.Rust/14.Rust的模块系统.md",key:"v-6082182f",path:"/pages/Rust_14/",headers:[{level:2,title:"一、包（Package）和 Crate",slug:"一、包-package-和-crate",normalizedTitle:"一、包（package）和 crate",charIndex:253},{level:2,title:"二、模块（mod）和可见性",slug:"二、模块-mod-和可见性",normalizedTitle:"二、模块（mod）和可见性",charIndex:645},{level:2,title:"三、路径（Path）",slug:"三、路径-path",normalizedTitle:"三、路径（path）",charIndex:1030},{level:2,title:"四、use 简化路径",slug:"四、use-简化路径",normalizedTitle:"四、use 简化路径",charIndex:1382},{level:2,title:"五、模块拆分到文件",slug:"五、模块拆分到文件",normalizedTitle:"五、模块拆分到文件",charIndex:1749}],headersStr:"一、包（Package）和 Crate 二、模块（mod）和可见性 三、路径（Path） 四、use 简化路径 五、模块拆分到文件",content:'# Rust 的模块系统\n\n在 Rust 里，项目不可能一直放在一个文件里，越写越多肯定会乱套。 所以语言本身提供了一整套“组织工具”来帮你：\n\n * 包（Package）和 Crate：整体的管理和构建单位\n * 模块（Module）：代码的逻辑分块\n * 路径（Path）：告诉编译器去哪儿找你写的东西\n * use：给路径起别名、简化访问\n * 分文件管理：让文件夹结构和模块结构对齐\n\n下面我们逐一来看。\n\n----------------------------------------\n\n\n# 一、包（Package）和 Crate\n\n * Crate 就是 Rust 的最小编译单元。\n   * 如果有 main 函数，它就是 二进制 Crate，能直接运行。\n   * 如果没有 main，只是提供功能，那就是 库 Crate，只能被别人引用。\n * Package 是一个或多个 Crate 的集合，它里面有 Cargo.toml 文件来说明怎么构建。\n   * 一个包最多只能有 一个库 Crate。\n   * 但可以有多个二进制 Crate（放在 src/bin/ 目录里）。\n\n👉 举个栗子：\n\nmy_project/\n ├─ Cargo.toml   # 包的配置\n └─ src/\n     └─ main.rs  # 默认的二进制 crate\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 二、模块（mod）和可见性\n\n随着项目增长，我们会用 模块（module）把代码分块。 写法是这样的：\n\nmod network {\n    fn connect() {\n        println!("connected!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里的 network 就是一个模块。 要注意，模块里的东西默认是私有的，外面用不了。\n\n想让外面能用，就要加 pub：\n\nmod network {\n    pub fn connect() {\n        println!("connected!");\n    }\n}\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 三、路径（Path）\n\n如果模块越来越多，就要学会用路径来访问。路径分两种：\n\n * 绝对路径：从 crate 根开始，比如 crate::network::connect\n * 相对路径：从当前位置开始，比如 super:: 往上，self:: 当前模块\n\nmod network {\n    pub fn connect() {}\n}\n\nfn main() {\n    // 绝对路径\n    crate::network::connect();\n\n    // 相对路径（在 main.rs 顶层）\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 四、use 简化路径\n\n如果你老是写 crate::network::connect，会很烦。 这时可以用 use：\n\nmod network {\n    pub fn connect() {}\n}\n\nuse crate::network::connect;\n\nfn main() {\n    connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以给名字起别名：\n\nuse crate::network::connect as net_connect;\n\nfn main() {\n    net_connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\n要让别人也能用这个简化路径，可以写 pub use。这叫“重导出”。\n\n----------------------------------------\n\n\n# 五、模块拆分到文件\n\n当模块越来越大，可以把它们分到不同的文件。\n\n假设你写了 mod network;，Rust 会去找：\n\n 1. network.rs 文件\n 2. 或者 network/mod.rs 文件\n\n比如目录长这样：\n\nsrc/\n ├─ main.rs\n └─ network.rs\n\n\n1\n2\n3\n\n\nmain.rs 里写：\n\nmod network;\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\nnetwork.rs 文件里写：\n\npub fn connect() {\n    println!("connected!");\n}\n\n\n1\n2\n3\n\n\n这样，模块和文件夹结构就能对上了，阅读起来很清晰。',normalizedContent:'# rust 的模块系统\n\n在 rust 里，项目不可能一直放在一个文件里，越写越多肯定会乱套。 所以语言本身提供了一整套“组织工具”来帮你：\n\n * 包（package）和 crate：整体的管理和构建单位\n * 模块（module）：代码的逻辑分块\n * 路径（path）：告诉编译器去哪儿找你写的东西\n * use：给路径起别名、简化访问\n * 分文件管理：让文件夹结构和模块结构对齐\n\n下面我们逐一来看。\n\n----------------------------------------\n\n\n# 一、包（package）和 crate\n\n * crate 就是 rust 的最小编译单元。\n   * 如果有 main 函数，它就是 二进制 crate，能直接运行。\n   * 如果没有 main，只是提供功能，那就是 库 crate，只能被别人引用。\n * package 是一个或多个 crate 的集合，它里面有 cargo.toml 文件来说明怎么构建。\n   * 一个包最多只能有 一个库 crate。\n   * 但可以有多个二进制 crate（放在 src/bin/ 目录里）。\n\n👉 举个栗子：\n\nmy_project/\n ├─ cargo.toml   # 包的配置\n └─ src/\n     └─ main.rs  # 默认的二进制 crate\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 二、模块（mod）和可见性\n\n随着项目增长，我们会用 模块（module）把代码分块。 写法是这样的：\n\nmod network {\n    fn connect() {\n        println!("connected!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里的 network 就是一个模块。 要注意，模块里的东西默认是私有的，外面用不了。\n\n想让外面能用，就要加 pub：\n\nmod network {\n    pub fn connect() {\n        println!("connected!");\n    }\n}\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 三、路径（path）\n\n如果模块越来越多，就要学会用路径来访问。路径分两种：\n\n * 绝对路径：从 crate 根开始，比如 crate::network::connect\n * 相对路径：从当前位置开始，比如 super:: 往上，self:: 当前模块\n\nmod network {\n    pub fn connect() {}\n}\n\nfn main() {\n    // 绝对路径\n    crate::network::connect();\n\n    // 相对路径（在 main.rs 顶层）\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 四、use 简化路径\n\n如果你老是写 crate::network::connect，会很烦。 这时可以用 use：\n\nmod network {\n    pub fn connect() {}\n}\n\nuse crate::network::connect;\n\nfn main() {\n    connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以给名字起别名：\n\nuse crate::network::connect as net_connect;\n\nfn main() {\n    net_connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\n要让别人也能用这个简化路径，可以写 pub use。这叫“重导出”。\n\n----------------------------------------\n\n\n# 五、模块拆分到文件\n\n当模块越来越大，可以把它们分到不同的文件。\n\n假设你写了 mod network;，rust 会去找：\n\n 1. network.rs 文件\n 2. 或者 network/mod.rs 文件\n\n比如目录长这样：\n\nsrc/\n ├─ main.rs\n └─ network.rs\n\n\n1\n2\n3\n\n\nmain.rs 里写：\n\nmod network;\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\nnetwork.rs 文件里写：\n\npub fn connect() {\n    println!("connected!");\n}\n\n\n1\n2\n3\n\n\n这样，模块和文件夹结构就能对上了，阅读起来很清晰。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.Linux 的常用命令",frontmatter:{title:"01.Linux 的常用命令",date:"2025-09-25T14:00:00.000Z",permalink:"/pages/Linux_01/"},regularPath:"/04.Linux/01.Linux%20%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"04.Linux/01.Linux 的常用命令.md",key:"v-1d58d132",path:"/pages/Linux_01/",headers:[{level:2,title:"1. 文件与目录管理",slug:"_1-文件与目录管理",normalizedTitle:"1. 文件与目录管理",charIndex:18},{level:2,title:"2. 文件查看与编辑",slug:"_2-文件查看与编辑",normalizedTitle:"2. 文件查看与编辑",charIndex:670},{level:2,title:"3. 权限与用户管理",slug:"_3-权限与用户管理",normalizedTitle:"3. 权限与用户管理",charIndex:1152},{level:2,title:"4. 进程与任务管理",slug:"_4-进程与任务管理",normalizedTitle:"4. 进程与任务管理",charIndex:1521},{level:2,title:"5. 文件搜索与内容检索",slug:"_5-文件搜索与内容检索",normalizedTitle:"5. 文件搜索与内容检索",charIndex:1854},{level:2,title:"6. 系统信息与磁盘管理",slug:"_6-系统信息与磁盘管理",normalizedTitle:"6. 系统信息与磁盘管理",charIndex:2260},{level:2,title:"7. 压缩与解压",slug:"_7-压缩与解压",normalizedTitle:"7. 压缩与解压",charIndex:2500},{level:2,title:"8. 网络工具",slug:"_8-网络工具",normalizedTitle:"8. 网络工具",charIndex:2801},{level:2,title:"9. 用户与组管理（需 root）",slug:"_9-用户与组管理-需-root",normalizedTitle:"9. 用户与组管理（需 root）",charIndex:3256},{level:2,title:"10. 包管理（Ubuntu / Debian 系）",slug:"_10-包管理-ubuntu-debian-系",normalizedTitle:"10. 包管理（ubuntu / debian 系）",charIndex:3617}],headersStr:"1. 文件与目录管理 2. 文件查看与编辑 3. 权限与用户管理 4. 进程与任务管理 5. 文件搜索与内容检索 6. 系统信息与磁盘管理 7. 压缩与解压 8. 网络工具 9. 用户与组管理（需 root） 10. 包管理（Ubuntu / Debian 系）",content:'# Linux 的常用命令\n\n\n# 1. 文件与目录管理\n\n命令      用法示例                                     说明\nls      ls -l, ls -a, ls -lh                     列出目录内容，-l 显示详细信息，-a 显示隐藏文件，-h 以人类可读的方式显示大小\ncd      cd /home/ikun/Desktop                    切换目录，cd .. 返回上级目录\npwd     pwd                                      显示当前路径\nmkdir   mkdir -p project/src                     创建目录，-p 自动创建不存在的父目录\ncp      cp file1.txt file2.txt；cp -r dir1 dir2   复制文件或目录，-r 表示递归复制\nmv      mv old.txt new.txt                       移动或重命名\nrm      rm file.txt, rm -r dir/                  删除文件或目录，-rf 强制删除\nfind    find . -name "*.txt"                     查找文件，支持通配符，. 表示当前目录\n\n----------------------------------------\n\n\n# 2. 文件查看与编辑\n\n命令     用法示例                                   说明\ncat    cat file.txt                           查看整个文件内容\nless   less big.log                           分页查看文件，q 退出\nhead   head -n 20 file.txt                    查看前 N 行，默认 10 行\ntail   tail -n 50 file.txt，tail -f file.log   查看末尾内容，-f 动态追踪日志\nvim    vim file.txt                           文本编辑器：\n                                              i 进入编辑模式，Esc 回到命令模式，:wq 保存退出，:q! 强制退出\n\n----------------------------------------\n\n\n# 3. 权限与用户管理\n\n命令       用法示例                                    说明\nchmod    chmod +x script.sh，chmod 644 file.txt   修改权限，数字形式：r=4, w=2, x=1\nchown    sudo chown user:group file.txt          修改文件所有者和所属组\nwhoami   whoami                                  显示当前用户\nid       id                                      显示用户 UID、GID 和所属组信息\n\n----------------------------------------\n\n\n# 4. 进程与任务管理\n\n命令        用法示例                 说明\nps        ps aux|grep python   \ntop       top，退出用 q            实时监控进程状态\nhtop      htop（需安装）            更友好的交互式进程管理工具\nkill      kill -9 1234         结束进程，1234 为 PID\njobs      jobs                 查看后台任务\nfg / bg   fg %1，bg %2          前后台任务切换\n\n----------------------------------------\n\n\n# 5. 文件搜索与内容检索\n\n命令        用法示例                        说明\ngrep      grep "error" logs/app.log   搜索文件内容，支持正则\ngrep -r   grep -r "TODO" ./src        递归搜索目录\ngrep -n   grep -n "main" main.c       显示匹配行号\nwhich     which python3               显示命令的路径\nwhereis   whereis ls                  查找命令的二进制/文档路径\nlocate    locate passwd               快速查找文件（基于数据库，需要 updatedb 更新）\n\n----------------------------------------\n\n\n# 6. 系统信息与磁盘管理\n\n命令         用法示例       说明\ndf -h      df -h      显示磁盘使用情况\ndu -sh     du -sh *   显示目录/文件大小\nfree -h    free -h    查看内存使用\nuname -a   uname -a   显示系统信息\nuptime     uptime     查看系统运行时长和负载\n\n----------------------------------------\n\n\n# 7. 压缩与解压\n\n命令      用法示例                            说明\ntar     tar -czvf archive.tar.gz dir/   压缩目录为 .tar.gz\ntar     tar -xzvf archive.tar.gz        解压 .tar.gz\nzip     zip -r archive.zip dir/         打包为 .zip\nunzip   unzip archive.zip               解压 .zip\n\n----------------------------------------\n\n\n# 8. 网络工具\n\n命令                   用法示例                                说明\nping                 ping -c 4 www.baidu.com             测试网络连通性\ncurl                 curl -I https://www.google.com      发送 HTTP 请求\nwget                 wget https://example.com/file.zip   下载文件\nifconfig / ip addr   ip addr show                        查看网络接口信息\nnetstat              netstat -tulnp                      查看端口占用（需安装 net-tools）\n\n----------------------------------------\n\n\n# 9. 用户与组管理（需 root）\n\n命令         用法示例                             说明\nadduser    sudo adduser testuser            添加用户\npasswd     sudo passwd testuser             修改密码\nusermod    sudo usermod -aG sudo testuser   添加用户到组\ngroupadd   sudo groupadd devs               新建组\ngroups     groups ikun                      查看用户所属组\n\n----------------------------------------\n\n\n# 10. 包管理（Ubuntu / Debian 系）\n\n命令            用法示例                       说明\napt update    sudo apt update            更新软件源索引\napt upgrade   sudo apt upgrade           更新已安装的软件\napt install   sudo apt install vim       安装软件包\napt remove    sudo apt remove package    卸载软件\napt search    apt search nginx           搜索软件包\ndpkg -i       sudo dpkg -i package.deb   安装 .deb 包',normalizedContent:'# linux 的常用命令\n\n\n# 1. 文件与目录管理\n\n命令      用法示例                                     说明\nls      ls -l, ls -a, ls -lh                     列出目录内容，-l 显示详细信息，-a 显示隐藏文件，-h 以人类可读的方式显示大小\ncd      cd /home/ikun/desktop                    切换目录，cd .. 返回上级目录\npwd     pwd                                      显示当前路径\nmkdir   mkdir -p project/src                     创建目录，-p 自动创建不存在的父目录\ncp      cp file1.txt file2.txt；cp -r dir1 dir2   复制文件或目录，-r 表示递归复制\nmv      mv old.txt new.txt                       移动或重命名\nrm      rm file.txt, rm -r dir/                  删除文件或目录，-rf 强制删除\nfind    find . -name "*.txt"                     查找文件，支持通配符，. 表示当前目录\n\n----------------------------------------\n\n\n# 2. 文件查看与编辑\n\n命令     用法示例                                   说明\ncat    cat file.txt                           查看整个文件内容\nless   less big.log                           分页查看文件，q 退出\nhead   head -n 20 file.txt                    查看前 n 行，默认 10 行\ntail   tail -n 50 file.txt，tail -f file.log   查看末尾内容，-f 动态追踪日志\nvim    vim file.txt                           文本编辑器：\n                                              i 进入编辑模式，esc 回到命令模式，:wq 保存退出，:q! 强制退出\n\n----------------------------------------\n\n\n# 3. 权限与用户管理\n\n命令       用法示例                                    说明\nchmod    chmod +x script.sh，chmod 644 file.txt   修改权限，数字形式：r=4, w=2, x=1\nchown    sudo chown user:group file.txt          修改文件所有者和所属组\nwhoami   whoami                                  显示当前用户\nid       id                                      显示用户 uid、gid 和所属组信息\n\n----------------------------------------\n\n\n# 4. 进程与任务管理\n\n命令        用法示例                 说明\nps        ps aux|grep python   \ntop       top，退出用 q            实时监控进程状态\nhtop      htop（需安装）            更友好的交互式进程管理工具\nkill      kill -9 1234         结束进程，1234 为 pid\njobs      jobs                 查看后台任务\nfg / bg   fg %1，bg %2          前后台任务切换\n\n----------------------------------------\n\n\n# 5. 文件搜索与内容检索\n\n命令        用法示例                        说明\ngrep      grep "error" logs/app.log   搜索文件内容，支持正则\ngrep -r   grep -r "todo" ./src        递归搜索目录\ngrep -n   grep -n "main" main.c       显示匹配行号\nwhich     which python3               显示命令的路径\nwhereis   whereis ls                  查找命令的二进制/文档路径\nlocate    locate passwd               快速查找文件（基于数据库，需要 updatedb 更新）\n\n----------------------------------------\n\n\n# 6. 系统信息与磁盘管理\n\n命令         用法示例       说明\ndf -h      df -h      显示磁盘使用情况\ndu -sh     du -sh *   显示目录/文件大小\nfree -h    free -h    查看内存使用\nuname -a   uname -a   显示系统信息\nuptime     uptime     查看系统运行时长和负载\n\n----------------------------------------\n\n\n# 7. 压缩与解压\n\n命令      用法示例                            说明\ntar     tar -czvf archive.tar.gz dir/   压缩目录为 .tar.gz\ntar     tar -xzvf archive.tar.gz        解压 .tar.gz\nzip     zip -r archive.zip dir/         打包为 .zip\nunzip   unzip archive.zip               解压 .zip\n\n----------------------------------------\n\n\n# 8. 网络工具\n\n命令                   用法示例                                说明\nping                 ping -c 4 www.baidu.com             测试网络连通性\ncurl                 curl -i https://www.google.com      发送 http 请求\nwget                 wget https://example.com/file.zip   下载文件\nifconfig / ip addr   ip addr show                        查看网络接口信息\nnetstat              netstat -tulnp                      查看端口占用（需安装 net-tools）\n\n----------------------------------------\n\n\n# 9. 用户与组管理（需 root）\n\n命令         用法示例                             说明\nadduser    sudo adduser testuser            添加用户\npasswd     sudo passwd testuser             修改密码\nusermod    sudo usermod -ag sudo testuser   添加用户到组\ngroupadd   sudo groupadd devs               新建组\ngroups     groups ikun                      查看用户所属组\n\n----------------------------------------\n\n\n# 10. 包管理（ubuntu / debian 系）\n\n命令            用法示例                       说明\napt update    sudo apt update            更新软件源索引\napt upgrade   sudo apt upgrade           更新已安装的软件\napt install   sudo apt install vim       安装软件包\napt remove    sudo apt remove package    卸载软件\napt search    apt search nginx           搜索软件包\ndpkg -i       sudo dpkg -i package.deb   安装 .deb 包',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.nano 编辑器",frontmatter:{title:"02.nano 编辑器",date:"2025-09-06T23:00:00.000Z",permalink:"/pages/Linux_02/"},regularPath:"/04.Linux/02.nano%20%E7%BC%96%E8%BE%91%E5%99%A8.html",relativePath:"04.Linux/02.nano 编辑器.md",key:"v-a1c9e1c2",path:"/pages/Linux_02/",headers:[{level:2,title:"以动手学形式掌握最基本用法",slug:"以动手学形式掌握最基本用法",normalizedTitle:"以动手学形式掌握最基本用法",charIndex:51},{level:2,title:"常用快捷键",slug:"常用快捷键",normalizedTitle:"常用快捷键",charIndex:308}],headersStr:"以动手学形式掌握最基本用法 常用快捷键",content:"# nano 编辑器\n\n本文介绍一下在ubuntu 20.04系统下nano文本编辑器的用法\n\n\n# 以动手学形式掌握最基本用法\n\n 1. 创建并一个文件\n    \n     nano notes.txt\n    \n    \n    1\n    \n 2. 进入编辑界面，可以在里面随便写一行文字，比如：\n    \n    这是关于nano的学习介绍\n    \n    \n    1\n    \n 3. 保存文件\n    * 按Ctrl + O\n    * 回车确认文件名 notes.txt\n    * 会提示[ Wrote 2 lines] 之类的信息\n 4. 退出nano\n    * 按Ctrl + X\n\n\n# 常用快捷键\n\n * Ctrl + G：打开帮助菜单\n * Ctrl + O：保存（Write Out）\n * Ctrl + X：退出\n * Ctrl + K：剪切一整行\n * Ctrl + U：粘贴\n * Ctrl + W：搜索\n * Ctrl + C：显示光标所在位置（行号/列号）\n * Alt + A：开始选中（标记）\n * Ctrl + _：跳转到指定行",normalizedContent:"# nano 编辑器\n\n本文介绍一下在ubuntu 20.04系统下nano文本编辑器的用法\n\n\n# 以动手学形式掌握最基本用法\n\n 1. 创建并一个文件\n    \n     nano notes.txt\n    \n    \n    1\n    \n 2. 进入编辑界面，可以在里面随便写一行文字，比如：\n    \n    这是关于nano的学习介绍\n    \n    \n    1\n    \n 3. 保存文件\n    * 按ctrl + o\n    * 回车确认文件名 notes.txt\n    * 会提示[ wrote 2 lines] 之类的信息\n 4. 退出nano\n    * 按ctrl + x\n\n\n# 常用快捷键\n\n * ctrl + g：打开帮助菜单\n * ctrl + o：保存（write out）\n * ctrl + x：退出\n * ctrl + k：剪切一整行\n * ctrl + u：粘贴\n * ctrl + w：搜索\n * ctrl + c：显示光标所在位置（行号/列号）\n * alt + a：开始选中（标记）\n * ctrl + _：跳转到指定行",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.shell 脚本",frontmatter:{title:"03.shell 脚本",date:"2025-09-28T10:00:00.000Z",permalink:"/pages/Linux_03/"},regularPath:"/04.Linux/03.shell%20%E8%84%9A%E6%9C%AC.html",relativePath:"04.Linux/03.shell 脚本.md",key:"v-45e07bf4",path:"/pages/Linux_03/",headers:[{level:2,title:"0. 约定与开头（shebang / 执行环境）",slug:"_0-约定与开头-shebang-执行环境",normalizedTitle:"0. 约定与开头（shebang / 执行环境）",charIndex:63},{level:2,title:"1. 变量（Var）：分类、命名规则与使用",slug:"_1-变量-var-分类、命名规则与使用",normalizedTitle:"1. 变量（var）：分类、命名规则与使用",charIndex:367},{level:3,title:"1.1 变量的 “三类” 概念",slug:"_1-1-变量的-三类-概念",normalizedTitle:"1.1 变量的 “三类” 概念",charIndex:393},{level:3,title:"1.2 命名规则",slug:"_1-2-命名规则",normalizedTitle:"1.2 命名规则",charIndex:627},{level:3,title:"1.3 赋值与引用",slug:"_1-3-赋值与引用",normalizedTitle:"1.3 赋值与引用",charIndex:791},{level:3,title:"1.4 导出环境变量",slug:"_1-4-导出环境变量",normalizedTitle:"1.4 导出环境变量",charIndex:960},{level:3,title:"1.5 特殊/位置变量（常用）",slug:"_1-5-特殊-位置变量-常用",normalizedTitle:"1.5 特殊/位置变量（常用）",charIndex:1068},{level:2,title:"2. 变量扩展（parameter expansion）——强烈建议掌握",slug:"_2-变量扩展-parameter-expansion-强烈建议掌握",normalizedTitle:"2. 变量扩展（parameter expansion）——强烈建议掌握",charIndex:1339},{level:2,title:"3. 引号与命令替换（务必谨记）",slug:"_3-引号与命令替换-务必谨记",normalizedTitle:"3. 引号与命令替换（务必谨记）",charIndex:1952},{level:2,title:"4. 数组（Bash 特性）",slug:"_4-数组-bash-特性",normalizedTitle:"4. 数组（bash 特性）",charIndex:2277},{level:2,title:"5. 算术计算",slug:"_5-算术计算",normalizedTitle:"5. 算术计算",charIndex:2557},{level:2,title:"6. 条件判断：[ ] vs [[ ]] vs test",slug:"_6-条件判断-vs-vs-test",normalizedTitle:"6. 条件判断：[ ] vs [[ ]] vs test",charIndex:2730},{level:2,title:"7. 循环、break 与 continue",slug:"_7-循环、break-与-continue",normalizedTitle:"7. 循环、break 与 continue",charIndex:3144},{level:3,title:"循环结构",slug:"循环结构",normalizedTitle:"循环结构",charIndex:3171},{level:3,title:"break 与 continue",slug:"break-与-continue",normalizedTitle:"break 与 continue",charIndex:3150},{level:2,title:"8. 函数（组织脚本逻辑的最好方式）",slug:"_8-函数-组织脚本逻辑的最好方式",normalizedTitle:"8. 函数（组织脚本逻辑的最好方式）",charIndex:3762},{level:2,title:"9. I/O、重定向、管道与 here-doc",slug:"_9-i-o、重定向、管道与-here-doc",normalizedTitle:"9. i/o、重定向、管道与 here-doc",charIndex:4007},{level:2,title:"10. echo vs printf",slug:"_10-echo-vs-printf",normalizedTitle:"10. echo vs printf",charIndex:4262},{level:2,title:"11. 错误处理、trap 与清理",slug:"_11-错误处理、trap-与清理",normalizedTitle:"11. 错误处理、trap 与清理",charIndex:4494},{level:2,title:"12. 常用工具/安全建议（最佳实践）",slug:"_12-常用工具-安全建议-最佳实践",normalizedTitle:"12. 常用工具/安全建议（最佳实践）",charIndex:4671},{level:2,title:"13. 参数解析：getopts（推荐）示例",slug:"_13-参数解析-getopts-推荐-示例",normalizedTitle:"13. 参数解析：getopts（推荐）示例",charIndex:4902},{level:2,title:"14. 典型脚本模板（可拷贝到任何项目）",slug:"_14-典型脚本模板-可拷贝到任何项目",normalizedTitle:"14. 典型脚本模板（可拷贝到任何项目）",charIndex:5261},{level:2,title:"15. 综合实例（把上面要点都串起来） — robust_log_tool.sh",slug:"_15-综合实例-把上面要点都串起来-robust-log-tool-sh",normalizedTitle:"15. 综合实例（把上面要点都串起来） — robust_log_tool.sh",charIndex:5901}],headersStr:"0. 约定与开头（shebang / 执行环境） 1. 变量（Var）：分类、命名规则与使用 1.1 变量的 “三类” 概念 1.2 命名规则 1.3 赋值与引用 1.4 导出环境变量 1.5 特殊/位置变量（常用） 2. 变量扩展（parameter expansion）——强烈建议掌握 3. 引号与命令替换（务必谨记） 4. 数组（Bash 特性） 5. 算术计算 6. 条件判断：[ ] vs [[ ]] vs test 7. 循环、break 与 continue 循环结构 break 与 continue 8. 函数（组织脚本逻辑的最好方式） 9. I/O、重定向、管道与 here-doc 10. echo vs printf 11. 错误处理、trap 与清理 12. 常用工具/安全建议（最佳实践） 13. 参数解析：getopts（推荐）示例 14. 典型脚本模板（可拷贝到任何项目） 15. 综合实例（把上面要点都串起来） — robust_log_tool.sh",content:'# Shell 脚本（Bash）\n\n----------------------------------------\n\n\n# 0. 约定与开头（shebang / 执行环境）\n\n#!/usr/bin/env bash\nset -euo pipefail\n\n\n1\n2\n\n * #!/usr/bin/env bash：更可移植，按 PATH 找 bash；相比 /bin/bash 更适用于共享脚本。\n * set -euo pipefail：\n   * -e：任何命令返回非0则脚本退出（避免忽略错误）。\n   * -u：未定义变量报错（避免拼写类 bug）。\n   * -o pipefail：管道中任一命令失败时返回失败（对管道很重要）。\n\n----------------------------------------\n\n\n# 1. 变量（Var）：分类、命名规则与使用\n\n\n# 1.1 变量的 “三类” 概念\n\n * 系统变量（system variables）：由操作系统/Shell 提供，通常大写，例如 PATH, HOME, SHELL, UID, PWD。\n * 环境变量（environment variables）：对当前 shell 及其子进程有效。通过 export VAR=value 设置/导出。\n * 用户（shell）变量 / 局部变量：仅在当前 shell（或函数）中有效，不会自动传递给子进程，通常不导出。\n\n\n# 1.2 命名规则\n\n * 只能包含字母、数字和下划线 _。\n * 不能以数字开头（例如 1var 错误）。\n * 推荐使用小写做脚本内部变量（例如 log_file），系统/环境变量仍用大写（PATH、HOME）。\n * 避免覆盖已有 shell 变量（例如 PATH、HOME、IFS 等），如果需要，先了解其含义。\n\n\n# 1.3 赋值与引用\n\nname="ikun"        # 赋值（注意：等号两边不能有空格）\necho "$name"      # 引用（双引号推荐）\n\n\n1\n2\n\n * 经过双引号 "$var" 的引用会保留空格并避免字段分裂。\n * 单引号 \'...\' 会完全禁止变量替换；双引号 "..."" 会允许替换但保留空格。\n\n\n# 1.4 导出环境变量\n\nexport MYVAR="hello"\n# 在当前 shell 中可见，并传递给子进程\n\n\n1\n2\n\n\n查看环境变量：\n\n * env 或 printenv 或 export -p\n\n\n# 1.5 特殊/位置变量（常用）\n\n * $0：脚本名\n * $1, $2, ...：第 1、第 2 个参数\n * $#：参数个数\n * "$@"：按独立参数扩展（推荐循环时使用）\n * "$*"：合并成一个字符串（通常不如 "$@" 安全）\n * $?：上一个命令返回值（退出状态）\n * $$：当前 shell 的 PID\n * $!：上一个后台进程的 PID\n * $PWD / $OLDPWD：当前/上一个目录\n * $UID：当前用户 id\n\n----------------------------------------\n\n\n# 2. 变量扩展（parameter expansion）——强烈建议掌握\n\n参数扩展极其强大，以 ${...} 形式为主：\n\n * ${var:-default}：如果 var 未定义或为空，则返回 default（不赋值）。\n * ${var:=default}：如果 var 未定义或为空，则把 default 赋给 var 并返回它。\n * ${var:+alt}：如果 var 已定义且非空，返回 alt，否则返回空。\n * ${var:?err}：如果 var 未设置或为空，则打印 err 并退出（常用于必需变量检查）。\n * ${#var}：字符串长度。\n * ${var:offset:length}：子串（类似 Python 切片）。\n * ${var#pattern} / ${var##pattern}：从左删最短/最长匹配（前缀）。\n * ${var%pattern} / ${var%%pattern}：从右删最短/最长匹配（后缀）。\n * ${var//search/replace}：全局替换（字符串）。\n\n示例：\n\n: "${LOG_DIR:=/var/log/myapp}"  # 如果未设置则赋默认值\necho "${FILENAME%.*}"          # 去掉文件扩展名\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 3. 引号与命令替换（务必谨记）\n\n * 单引号 \'...\'：完全原样，不做变量替换。\n * 双引号 "...""：变量和命令替换会发生，但空格不会被分割。\n * 无引号：字段会被 word-splitting（按 IFS）和 glob（通配符）扩展——危险。\n * 命令替换：\n   * $(command) 推荐（可嵌套、易读）\n   * command 旧式语法，复杂时容易出错\n\n例：\n\nfiles="$(ls -1 *.log)"\necho "There are $(wc -l < "$file") lines in $file"\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 4. 数组（Bash 特性）\n\n声明与访问：\n\ndeclare -a arr=("one" "two" "three")\necho "${arr[0]}"         # one\necho "${arr[@]}"         # 所有元素（每个作为独立字段）\necho "${#arr[@]}"        # 元素个数\n\n\n1\n2\n3\n4\n\n\n遍历：\n\nfor v in "${arr[@]}"; do\n  echo "$v"\ndone\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 5. 算术计算\n\n * 使用 $(( ... )) 或 let：\n\nx=3\ny=$(( x + 5 ))\ncount=$((count+1))\n\n\n1\n2\n3\n\n * 注意整数与浮点：Bash 本身只支持整数。浮点需用 bc、awk 或 python。\n\n----------------------------------------\n\n\n# 6. 条件判断：[ ] vs [[ ]] vs test\n\n * [ expr ] 是 POSIX test，[[ expr ]] 是 bash 扩展（更强，支持正则运算符 =~，不需要大量转义）。\n * 常用文件测试：\n   * -f file：普通文件存在\n   * -d dir：目录存在\n   * -r file：可读、-w 可写、-x 可执行\n * 字符串测试：\n   * -z str：为空\n   * -n str：非空\n   * str1 = str2 或 ==（在 [[ ]]）\n * 数值测试：\n   * -eq, -ne, -lt, -le, -gt, -ge\n * 示例：\n\nif [[ $name =~ ^[a-z][a-z0-9_]+$ ]]; then\n  echo "valid"\nfi\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 7. 循环、break 与 continue\n\n\n# 循环结构\n\n * for var in list; do ... done\n * while condition; do ... done\n * until condition; do ... done（直到条件为真时停止）\n\n\n# break 与 continue\n\n * break：跳出当前循环；break N：跳出 N 层嵌套循环（Bash 支持）。\n * continue：跳到当前循环的下次迭代；continue N：跳过 N 层循环的当前迭代（通常用 continue）。\n\n示例（嵌套循环 + break/continue）：\n\nfor i in {1..3}; do\n  for j in {a..c}; do\n    if [[ "$i$j" == "2b" ]]; then\n      echo "found 2b -> break 2"\n      break 2      # 跳出外层和内层\n    fi\n    if [[ "$j" == "a" ]]; then\n      continue    # 内层继续下一次 j\n    fi\n    echo "$i $j"\n  done\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 8. 函数（组织脚本逻辑的最好方式）\n\ngreet() {\n  local name="$1"     # local 防止污染外部变量\n  echo "Hello, $name"\n}\n\nresult=$(greet "ikun")  # 函数可以 echo 输出作为返回值\n\n\n1\n2\n3\n4\n5\n6\n\n * return N：返回整数退出码（0 表示成功）；想返回字符串用 echo 并捕获。\n\n----------------------------------------\n\n\n# 9. I/O、重定向、管道与 here-doc\n\n * > 覆盖写；>> 追加写\n * 2> 单独重定向 stderr；&> 同时重定向 stdout/stderr（非 POSIX）\n * cmd1 | cmd2 管道。使用 set -o pipefail 以确保管道失败传播。\n * Here-doc：\n\ncat <<\'EOF\' > file.txt\n多行文本，变量不替换（因为用单引号）\nEOF\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 10. echo vs printf\n\n * echo：简单打印，行为随 shell 版本和 -e 标志不同（\\n, \\t 等）。\n   * echo -n：不输出末尾换行\n   * echo -e：解释转义（不总是可移植）\n * printf：推荐用于可移植、格式化输出：\n\nprintf "Name: %s\\tScore: %d\\n" "Alice" 92\n\n\n1\n\n\n----------------------------------------\n\n\n# 11. 错误处理、trap 与清理\n\n * trap \'handler\' EXIT：无论怎样退出都会执行 handler（可用于清理临时文件）。\n * 捕获信号：\n\ntrap \'echo "Interrupted"; exit 2\' INT TERM\n\n\n1\n\n\n----------------------------------------\n\n\n# 12. 常用工具/安全建议（最佳实践）\n\n * 在脚本头使用 set -euo pipefail。\n * 使用双引号引用变量 "$var"。\n * 对外部命令结果做检查（不要盲信成功）。\n * 用 mktemp 创建临时文件，使用 trap 清理。\n * 对输入参数做校验并提供 usage()。\n * 对用户可见的信息用 printf 而非 echo（格式更稳定）。\n\n----------------------------------------\n\n\n# 13. 参数解析：getopts（推荐）示例\n\n# getopt style parsing using getopts\nwhile getopts ":f:k:h" opt; do\n  case $opt in\n    f) logfile="$OPTARG" ;;\n    k) keyword="$OPTARG" ;;\n    h) echo "usage..."; exit 0 ;;\n    \\?) printf "Invalid option -%s\\n" "$OPTARG" ; exit 1 ;;\n  esac\ndone\nshift $((OPTIND-1))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 14. 典型脚本模板（可拷贝到任何项目）\n\n#!/usr/bin/env bash\nset -euo pipefail\n\nusage() {\n  cat <<EOF\nUsage: $(basename "$0") -f logfile [-k keyword]\nEOF\n}\n\nlogfile=""\nkeyword="ERROR"\n\nwhile getopts ":f:k:h" opt; do\n  case $opt in\n    f) logfile="$OPTARG" ;;\n    k) keyword="$OPTARG" ;;\n    h) usage; exit 0 ;;\n    \\?) echo "Invalid option -$OPTARG" >&2; usage; exit 1 ;;\n  esac\ndone\n\nif [[ -z "${logfile}" ]]; then\n  echo "logfile required"\n  usage\n  exit 1\nfi\n\ntrap \'echo "Cleaning up"; rm -f "$tmpfile"\' EXIT\n\n# main logic...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n----------------------------------------\n\n\n# 15. 综合实例（把上面要点都串起来） — robust_log_tool.sh\n\n> 这是一个“工程化”脚本范例，演示变量（含默认/环境变量）、引用、函数、数组、循环、break/continue、trap、导出、getopts、printf、以及日志处理实战。\n\n#!/usr/bin/env bash\nset -euo pipefail\n\n# 默认配置（可由环境变量覆盖）\n: "${LOGFILE:=${1:-./app.log}}"\n: "${ARCHIVE_DIR:=./log_archive}"\n: "${SIZE_LIMIT:=1048576}"   # 1 MB default\n\nusage() {\n  cat <<EOF\nUsage: $(basename "$0") [-f logfile] [-s size_limit_bytes]\nEnvironment:\n  LOGFILE    default: ./app.log or first positional arg\n  ARCHIVE_DIR default: ./log_archive\nEOF\n}\n\n# 参数解析（简单示例）\nwhile getopts ":f:s:h" opt; do\n  case $opt in\n    f) LOGFILE="$OPTARG" ;;\n    s) SIZE_LIMIT="$OPTARG" ;;\n    h) usage; exit 0 ;;\n    \\?) echo "Invalid option -$OPTARG" >&2; usage; exit 1 ;;\n  esac\ndone\n\n# 依赖检查\ncommand -v gzip >/dev/null 2>&1 || { echo "gzip required"; exit 1; }\n\n# 函数：归档日志（如果过大）\narchive_log() {\n  local file="$1"\n  local dir="$2"\n  mkdir -p "$dir"\n  local ts\n  ts=$(date +"%Y%m%dT%H%M%S")\n  local base\n  base=$(basename "$file")\n  mv "$file" "${dir}/${base}.${ts}"\n  gzip -f "${dir}/${base}.${ts}"\n  printf "Archived %s -> %s/%s.%s.gz\\n" "$file" "$dir" "$base" "$ts"\n}\n\n# 函数：统计并打印基本信息\nsummarize_log() {\n  local file="$1"\n  if [[ ! -f "$file" ]]; then\n    echo "No log file: $file"\n    return 0\n  fi\n  printf "Summary for %s\\n" "$file"\n  printf "  Lines: %d\\n" "$(wc -l < "$file")"\n  printf "  ERROR: %d\\n" "$(grep -c -E \'ERROR|error\' "$file" || true)"\n  printf "  WARN: %d\\n" "$(grep -c -E \'WARN|warn|WARNING\' "$file" || true)"\n}\n\n# 主逻辑：如果文件大于 SIZE_LIMIT 则归档\nif [[ -f "$LOGFILE" ]]; then\n  size=$(stat -c%s "$LOGFILE")\n  if (( size > SIZE_LIMIT )); then\n    archive_log "$LOGFILE" "$ARCHIVE_DIR"\n    # 创建新的空文件\n    : > "$LOGFILE"\n  fi\nfi\n\n# 遍历日志，演示 break/continue：\n# 找到第一个 ERROR 就停止（break），跳过 DEBUG lines（continue）\nif [[ -f "$LOGFILE" ]]; then\n  while IFS= read -r line; do\n    # skip empty lines\n    [[ -z "$line" ]] && continue\n    # skip debug\n    if [[ "$line" =~ DEBUG ]]; then\n      continue\n    fi\n    echo "LINE: $line"\n    if [[ "$line" =~ ERROR|error ]]; then\n      echo "Found first error, stopping scan."\n      break\n    fi\n  done < "$LOGFILE"\nfi\n\n# 最后打印摘要\nsummarize_log "$LOGFILE"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n * 说明：\n   * : > "$LOGFILE" 用来重建或清空文件（冒号是个 no-op command）。\n   * stat -c%s 用于获取文件字节大小（Linux）。\n   * grep -c ... || true 以防找不到匹配导致非0退出（因为 set -e）。',normalizedContent:'# shell 脚本（bash）\n\n----------------------------------------\n\n\n# 0. 约定与开头（shebang / 执行环境）\n\n#!/usr/bin/env bash\nset -euo pipefail\n\n\n1\n2\n\n * #!/usr/bin/env bash：更可移植，按 path 找 bash；相比 /bin/bash 更适用于共享脚本。\n * set -euo pipefail：\n   * -e：任何命令返回非0则脚本退出（避免忽略错误）。\n   * -u：未定义变量报错（避免拼写类 bug）。\n   * -o pipefail：管道中任一命令失败时返回失败（对管道很重要）。\n\n----------------------------------------\n\n\n# 1. 变量（var）：分类、命名规则与使用\n\n\n# 1.1 变量的 “三类” 概念\n\n * 系统变量（system variables）：由操作系统/shell 提供，通常大写，例如 path, home, shell, uid, pwd。\n * 环境变量（environment variables）：对当前 shell 及其子进程有效。通过 export var=value 设置/导出。\n * 用户（shell）变量 / 局部变量：仅在当前 shell（或函数）中有效，不会自动传递给子进程，通常不导出。\n\n\n# 1.2 命名规则\n\n * 只能包含字母、数字和下划线 _。\n * 不能以数字开头（例如 1var 错误）。\n * 推荐使用小写做脚本内部变量（例如 log_file），系统/环境变量仍用大写（path、home）。\n * 避免覆盖已有 shell 变量（例如 path、home、ifs 等），如果需要，先了解其含义。\n\n\n# 1.3 赋值与引用\n\nname="ikun"        # 赋值（注意：等号两边不能有空格）\necho "$name"      # 引用（双引号推荐）\n\n\n1\n2\n\n * 经过双引号 "$var" 的引用会保留空格并避免字段分裂。\n * 单引号 \'...\' 会完全禁止变量替换；双引号 "..."" 会允许替换但保留空格。\n\n\n# 1.4 导出环境变量\n\nexport myvar="hello"\n# 在当前 shell 中可见，并传递给子进程\n\n\n1\n2\n\n\n查看环境变量：\n\n * env 或 printenv 或 export -p\n\n\n# 1.5 特殊/位置变量（常用）\n\n * $0：脚本名\n * $1, $2, ...：第 1、第 2 个参数\n * $#：参数个数\n * "$@"：按独立参数扩展（推荐循环时使用）\n * "$*"：合并成一个字符串（通常不如 "$@" 安全）\n * $?：上一个命令返回值（退出状态）\n * $$：当前 shell 的 pid\n * $!：上一个后台进程的 pid\n * $pwd / $oldpwd：当前/上一个目录\n * $uid：当前用户 id\n\n----------------------------------------\n\n\n# 2. 变量扩展（parameter expansion）——强烈建议掌握\n\n参数扩展极其强大，以 ${...} 形式为主：\n\n * ${var:-default}：如果 var 未定义或为空，则返回 default（不赋值）。\n * ${var:=default}：如果 var 未定义或为空，则把 default 赋给 var 并返回它。\n * ${var:+alt}：如果 var 已定义且非空，返回 alt，否则返回空。\n * ${var:?err}：如果 var 未设置或为空，则打印 err 并退出（常用于必需变量检查）。\n * ${#var}：字符串长度。\n * ${var:offset:length}：子串（类似 python 切片）。\n * ${var#pattern} / ${var##pattern}：从左删最短/最长匹配（前缀）。\n * ${var%pattern} / ${var%%pattern}：从右删最短/最长匹配（后缀）。\n * ${var//search/replace}：全局替换（字符串）。\n\n示例：\n\n: "${log_dir:=/var/log/myapp}"  # 如果未设置则赋默认值\necho "${filename%.*}"          # 去掉文件扩展名\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 3. 引号与命令替换（务必谨记）\n\n * 单引号 \'...\'：完全原样，不做变量替换。\n * 双引号 "...""：变量和命令替换会发生，但空格不会被分割。\n * 无引号：字段会被 word-splitting（按 ifs）和 glob（通配符）扩展——危险。\n * 命令替换：\n   * $(command) 推荐（可嵌套、易读）\n   * command 旧式语法，复杂时容易出错\n\n例：\n\nfiles="$(ls -1 *.log)"\necho "there are $(wc -l < "$file") lines in $file"\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 4. 数组（bash 特性）\n\n声明与访问：\n\ndeclare -a arr=("one" "two" "three")\necho "${arr[0]}"         # one\necho "${arr[@]}"         # 所有元素（每个作为独立字段）\necho "${#arr[@]}"        # 元素个数\n\n\n1\n2\n3\n4\n\n\n遍历：\n\nfor v in "${arr[@]}"; do\n  echo "$v"\ndone\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 5. 算术计算\n\n * 使用 $(( ... )) 或 let：\n\nx=3\ny=$(( x + 5 ))\ncount=$((count+1))\n\n\n1\n2\n3\n\n * 注意整数与浮点：bash 本身只支持整数。浮点需用 bc、awk 或 python。\n\n----------------------------------------\n\n\n# 6. 条件判断：[ ] vs [[ ]] vs test\n\n * [ expr ] 是 posix test，[[ expr ]] 是 bash 扩展（更强，支持正则运算符 =~，不需要大量转义）。\n * 常用文件测试：\n   * -f file：普通文件存在\n   * -d dir：目录存在\n   * -r file：可读、-w 可写、-x 可执行\n * 字符串测试：\n   * -z str：为空\n   * -n str：非空\n   * str1 = str2 或 ==（在 [[ ]]）\n * 数值测试：\n   * -eq, -ne, -lt, -le, -gt, -ge\n * 示例：\n\nif [[ $name =~ ^[a-z][a-z0-9_]+$ ]]; then\n  echo "valid"\nfi\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 7. 循环、break 与 continue\n\n\n# 循环结构\n\n * for var in list; do ... done\n * while condition; do ... done\n * until condition; do ... done（直到条件为真时停止）\n\n\n# break 与 continue\n\n * break：跳出当前循环；break n：跳出 n 层嵌套循环（bash 支持）。\n * continue：跳到当前循环的下次迭代；continue n：跳过 n 层循环的当前迭代（通常用 continue）。\n\n示例（嵌套循环 + break/continue）：\n\nfor i in {1..3}; do\n  for j in {a..c}; do\n    if [[ "$i$j" == "2b" ]]; then\n      echo "found 2b -> break 2"\n      break 2      # 跳出外层和内层\n    fi\n    if [[ "$j" == "a" ]]; then\n      continue    # 内层继续下一次 j\n    fi\n    echo "$i $j"\n  done\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 8. 函数（组织脚本逻辑的最好方式）\n\ngreet() {\n  local name="$1"     # local 防止污染外部变量\n  echo "hello, $name"\n}\n\nresult=$(greet "ikun")  # 函数可以 echo 输出作为返回值\n\n\n1\n2\n3\n4\n5\n6\n\n * return n：返回整数退出码（0 表示成功）；想返回字符串用 echo 并捕获。\n\n----------------------------------------\n\n\n# 9. i/o、重定向、管道与 here-doc\n\n * > 覆盖写；>> 追加写\n * 2> 单独重定向 stderr；&> 同时重定向 stdout/stderr（非 posix）\n * cmd1 | cmd2 管道。使用 set -o pipefail 以确保管道失败传播。\n * here-doc：\n\ncat <<\'eof\' > file.txt\n多行文本，变量不替换（因为用单引号）\neof\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 10. echo vs printf\n\n * echo：简单打印，行为随 shell 版本和 -e 标志不同（\\n, \\t 等）。\n   * echo -n：不输出末尾换行\n   * echo -e：解释转义（不总是可移植）\n * printf：推荐用于可移植、格式化输出：\n\nprintf "name: %s\\tscore: %d\\n" "alice" 92\n\n\n1\n\n\n----------------------------------------\n\n\n# 11. 错误处理、trap 与清理\n\n * trap \'handler\' exit：无论怎样退出都会执行 handler（可用于清理临时文件）。\n * 捕获信号：\n\ntrap \'echo "interrupted"; exit 2\' int term\n\n\n1\n\n\n----------------------------------------\n\n\n# 12. 常用工具/安全建议（最佳实践）\n\n * 在脚本头使用 set -euo pipefail。\n * 使用双引号引用变量 "$var"。\n * 对外部命令结果做检查（不要盲信成功）。\n * 用 mktemp 创建临时文件，使用 trap 清理。\n * 对输入参数做校验并提供 usage()。\n * 对用户可见的信息用 printf 而非 echo（格式更稳定）。\n\n----------------------------------------\n\n\n# 13. 参数解析：getopts（推荐）示例\n\n# getopt style parsing using getopts\nwhile getopts ":f:k:h" opt; do\n  case $opt in\n    f) logfile="$optarg" ;;\n    k) keyword="$optarg" ;;\n    h) echo "usage..."; exit 0 ;;\n    \\?) printf "invalid option -%s\\n" "$optarg" ; exit 1 ;;\n  esac\ndone\nshift $((optind-1))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 14. 典型脚本模板（可拷贝到任何项目）\n\n#!/usr/bin/env bash\nset -euo pipefail\n\nusage() {\n  cat <<eof\nusage: $(basename "$0") -f logfile [-k keyword]\neof\n}\n\nlogfile=""\nkeyword="error"\n\nwhile getopts ":f:k:h" opt; do\n  case $opt in\n    f) logfile="$optarg" ;;\n    k) keyword="$optarg" ;;\n    h) usage; exit 0 ;;\n    \\?) echo "invalid option -$optarg" >&2; usage; exit 1 ;;\n  esac\ndone\n\nif [[ -z "${logfile}" ]]; then\n  echo "logfile required"\n  usage\n  exit 1\nfi\n\ntrap \'echo "cleaning up"; rm -f "$tmpfile"\' exit\n\n# main logic...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n----------------------------------------\n\n\n# 15. 综合实例（把上面要点都串起来） — robust_log_tool.sh\n\n> 这是一个“工程化”脚本范例，演示变量（含默认/环境变量）、引用、函数、数组、循环、break/continue、trap、导出、getopts、printf、以及日志处理实战。\n\n#!/usr/bin/env bash\nset -euo pipefail\n\n# 默认配置（可由环境变量覆盖）\n: "${logfile:=${1:-./app.log}}"\n: "${archive_dir:=./log_archive}"\n: "${size_limit:=1048576}"   # 1 mb default\n\nusage() {\n  cat <<eof\nusage: $(basename "$0") [-f logfile] [-s size_limit_bytes]\nenvironment:\n  logfile    default: ./app.log or first positional arg\n  archive_dir default: ./log_archive\neof\n}\n\n# 参数解析（简单示例）\nwhile getopts ":f:s:h" opt; do\n  case $opt in\n    f) logfile="$optarg" ;;\n    s) size_limit="$optarg" ;;\n    h) usage; exit 0 ;;\n    \\?) echo "invalid option -$optarg" >&2; usage; exit 1 ;;\n  esac\ndone\n\n# 依赖检查\ncommand -v gzip >/dev/null 2>&1 || { echo "gzip required"; exit 1; }\n\n# 函数：归档日志（如果过大）\narchive_log() {\n  local file="$1"\n  local dir="$2"\n  mkdir -p "$dir"\n  local ts\n  ts=$(date +"%y%m%dt%h%m%s")\n  local base\n  base=$(basename "$file")\n  mv "$file" "${dir}/${base}.${ts}"\n  gzip -f "${dir}/${base}.${ts}"\n  printf "archived %s -> %s/%s.%s.gz\\n" "$file" "$dir" "$base" "$ts"\n}\n\n# 函数：统计并打印基本信息\nsummarize_log() {\n  local file="$1"\n  if [[ ! -f "$file" ]]; then\n    echo "no log file: $file"\n    return 0\n  fi\n  printf "summary for %s\\n" "$file"\n  printf "  lines: %d\\n" "$(wc -l < "$file")"\n  printf "  error: %d\\n" "$(grep -c -e \'error|error\' "$file" || true)"\n  printf "  warn: %d\\n" "$(grep -c -e \'warn|warn|warning\' "$file" || true)"\n}\n\n# 主逻辑：如果文件大于 size_limit 则归档\nif [[ -f "$logfile" ]]; then\n  size=$(stat -c%s "$logfile")\n  if (( size > size_limit )); then\n    archive_log "$logfile" "$archive_dir"\n    # 创建新的空文件\n    : > "$logfile"\n  fi\nfi\n\n# 遍历日志，演示 break/continue：\n# 找到第一个 error 就停止（break），跳过 debug lines（continue）\nif [[ -f "$logfile" ]]; then\n  while ifs= read -r line; do\n    # skip empty lines\n    [[ -z "$line" ]] && continue\n    # skip debug\n    if [[ "$line" =~ debug ]]; then\n      continue\n    fi\n    echo "line: $line"\n    if [[ "$line" =~ error|error ]]; then\n      echo "found first error, stopping scan."\n      break\n    fi\n  done < "$logfile"\nfi\n\n# 最后打印摘要\nsummarize_log "$logfile"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n * 说明：\n   * : > "$logfile" 用来重建或清空文件（冒号是个 no-op command）。\n   * stat -c%s 用于获取文件字节大小（linux）。\n   * grep -c ... || true 以防找不到匹配导致非0退出（因为 set -e）。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.numpy 模块",frontmatter:{title:"01.numpy 模块",date:"2025-09-26T22:00:00.000Z",permalink:"/pages/Python_01/"},regularPath:"/05.python/01.numpy%20%E6%A8%A1%E5%9D%97.html",relativePath:"05.python/01.numpy 模块.md",key:"v-385042bf",path:"/pages/Python_01/",headers:[{level:2,title:"NumPy简介",slug:"numpy简介",normalizedTitle:"numpy简介",charIndex:15},{level:2,title:"📌 NumPy 常用方法（方法签名 + 参数解释）",slug:"📌-numpy-常用方法-方法签名-参数解释",normalizedTitle:"📌 numpy 常用方法（方法签名 + 参数解释）",charIndex:348},{level:3,title:"数组创建",slug:"数组创建",normalizedTitle:"数组创建",charIndex:379},{level:3,title:"数组属性",slug:"数组属性",normalizedTitle:"数组属性",charIndex:1034},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:1182},{level:3,title:"索引与切片",slug:"索引与切片",normalizedTitle:"索引与切片",charIndex:1483},{level:3,title:"运算",slug:"运算",normalizedTitle:"运算",charIndex:111},{level:3,title:"统计函数",slug:"统计函数",normalizedTitle:"统计函数",charIndex:119},{level:3,title:"线性代数",slug:"线性代数",normalizedTitle:"线性代数",charIndex:114},{level:3,title:"文件读写",slug:"文件读写",normalizedTitle:"文件读写",charIndex:2444},{level:2,title:"主要方法与功能示例",slug:"主要方法与功能示例",normalizedTitle:"主要方法与功能示例",charIndex:2696},{level:3,title:"1. 数组的创建方式",slug:"_1-数组的创建方式",normalizedTitle:"1. 数组的创建方式",charIndex:2820},{level:3,title:"2. 数组属性查看 / 维度操作",slug:"_2-数组属性查看-维度操作",normalizedTitle:"2. 数组属性查看 / 维度操作",charIndex:3717},{level:3,title:"3. 数组运算（元素级运算）",slug:"_3-数组运算-元素级运算",normalizedTitle:"3. 数组运算（元素级运算）",charIndex:4289},{level:3,title:"4. 数据统计函数",slug:"_4-数据统计函数",normalizedTitle:"4. 数据统计函数",charIndex:4468},{level:3,title:"5. 索引与切片",slug:"_5-索引与切片",normalizedTitle:"5. 索引与切片",charIndex:4863},{level:3,title:"6. 数组堆叠 / 拆分",slug:"_6-数组堆叠-拆分",normalizedTitle:"6. 数组堆叠 / 拆分",charIndex:5202},{level:3,title:"7. 保存 / 加载数组",slug:"_7-保存-加载数组",normalizedTitle:"7. 保存 / 加载数组",charIndex:5496}],headersStr:"NumPy简介 📌 NumPy 常用方法（方法签名 + 参数解释） 数组创建 数组属性 基本操作 索引与切片 运算 统计函数 线性代数 文件读写 主要方法与功能示例 1. 数组的创建方式 2. 数组属性查看 / 维度操作 3. 数组运算（元素级运算） 4. 数据统计函数 5. 索引与切片 6. 数组堆叠 / 拆分 7. 保存 / 加载数组",content:"# numpy 模块\n\n\n# NumPy简介\n\nNumPy（Numerical Python 的简称）是 Python 中用于高效数值计算的基础库。它提供了一个核心类型 ndarray（多维数组），并在其上封装了大量向量化运算、线性代数、统计函数、广播机制、索引切片、随机数生成等功能。它在科学计算、机器学习、信号处理等领域都非常关键。\n\n特点包括：\n\n * 高效：底层用 C 实现，运算速度比纯 Python 的 list 快很多\n * 支持多维数组（向量、矩阵、张量）\n * 广播机制（不同形状数组做运算时自动对齐维度）\n * 与其他数据科学库（Pandas、SciPy、Matplotlib）兼容\n\n----------------------------------------\n\n\n# 📌 NumPy 常用方法（方法签名 + 参数解释）\n\n\n# 数组创建\n\n * np.array(object, dtype=None, copy=True, ndmin=0) → 从列表/元组/嵌套结构创建数组。\n   * dtype：数据类型\n   * copy：是否复制数据\n   * ndmin：最小维度\n * np.zeros(shape, dtype=float) → 创建全 0 数组。\n * np.ones(shape, dtype=float) → 创建全 1 数组。\n * np.full(shape, fill_value, dtype=None) → 创建指定值数组。\n * np.eye(N, M=None, k=0, dtype=float) → 创建单位矩阵（对角线上为1）。\n   * N：行数\n   * M：列数（默认等于 N）\n   * k：对角线偏移\n * np.arange([start, ]stop, step=1, dtype=None) → 类似 Python range，生成等差序列。\n * np.linspace(start, stop, num=50, endpoint=True, dtype=None) → 生成等间距序列。\n * np.random.rand(d0, d1, …) → 生成 [0,1) 区间的均匀分布随机数。\n * np.random.randn(d0, d1, …) → 生成标准正态分布随机数。\n\n----------------------------------------\n\n\n# 数组属性\n\n * arr.shape → 返回数组形状 (tuple)。\n * arr.ndim → 返回数组维度。\n * arr.size → 元素总数。\n * arr.dtype → 元素数据类型。\n\n----------------------------------------\n\n\n# 基本操作\n\n * np.reshape(arr, newshape, order='C') → 改变数组形状。\n * np.transpose(arr, axes=None) / arr.T → 转置数组。\n * np.concatenate((a1, a2, ...), axis=0) → 拼接数组。\n * np.split(ary, indices_or_sections, axis=0) → 拆分数组。\n * np.hstack(tup) / np.vstack(tup) → 水平 / 垂直拼接。\n\n----------------------------------------\n\n\n# 索引与切片\n\n * arr[start:stop:step] → 一维切片。\n * arr[rows, cols] → 二维索引（行，列）。\n * arr[...] → 使用 ... 表示剩余所有维度。\n * arr[arr > 0] → 布尔索引。\n\n----------------------------------------\n\n\n# 运算\n\n * np.add(x1, x2) / x1 + x2\n * np.subtract(x1, x2) / x1 - x2\n * np.multiply(x1, x2) / x1 * x2\n * np.divide(x1, x2) / x1 / x2\n * np.power(x1, x2) / x1 ** x2\n * np.mod(x1, x2) / x1 % x2\n\n→ 向量化计算，按元素执行。\n\n----------------------------------------\n\n\n# 统计函数\n\n * np.sum(a, axis=None) → 求和。\n * np.mean(a, axis=None) → 均值。\n * np.median(a, axis=None) → 中位数。\n * np.std(a, axis=None) → 标准差。\n * np.var(a, axis=None) → 方差。\n * np.max(a, axis=None) / np.min(a, axis=None) → 最大/最小值。\n * np.argmax(a, axis=None) / np.argmin(a, axis=None) → 最大/最小值索引。\n\n----------------------------------------\n\n\n# 线性代数\n\n * np.dot(a, b) → 矩阵乘法 / 点积。\n * np.matmul(a, b) / a @ b → 矩阵乘法（推荐写法）。\n * np.linalg.inv(a) → 矩阵求逆。\n * np.linalg.det(a) → 行列式。\n * np.linalg.eig(a) → 特征值与特征向量。\n\n----------------------------------------\n\n\n# 文件读写\n\n * np.loadtxt(fname, dtype=float, delimiter=None, skiprows=0) → 从文本加载数据。\n * np.savetxt(fname, X, fmt='%.18e', delimiter=' ') → 保存为文本文件。\n * np.save(file, arr, allow_pickle=True) → 保存为 .npy 文件。\n * np.load(file, allow_pickle=True) → 加载 .npy 文件。\n\n\n# 主要方法与功能示例\n\n下面是文章中提到（或涵盖）的几个重要方法 / 功能。我给出代码 + 注释说明输出。\n\nimport numpy as np\n\n\n1\n\n\n----------------------------------------\n\n\n# 1. 数组的创建方式\n\n# 1.1 np.array\n\na = np.array([1, 2, 3, 4])\nprint(a)  \n# 输出： [1 2 3 4]\n\nb = np.array([[1, 2, 3, 4], [4, 5, 6, 7]])\nprint(b)\n# 输出： \n# [[1 2 3 4]\n#  [4 5 6 7]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 1.2 全零 / 全一 / 空数组\n\nz = np.zeros((3, 4))\nprint(z)\n# 输出：\n# [[0. 0. 0. 0.]\n#  [0. 0. 0. 0.]\n#  [0. 0. 0. 0.]]\n\no = np.ones((2, 5))\nprint(o)\n# 输出：\n# [[1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]]\n\ne = np.empty((2, 3))\nprint(e)\n# 输出：内容未被初始化，可能是随机值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1.3 arange 与 linspace\n\nr = np.arange(10, 16, 2)\nprint(r)\n# 输出： [10 12 14]\n\nls = np.linspace(1, 10, 5)\nprint(ls)\n# 输出： [ 1.     3.25   5.5    7.75  10.   ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 1.4 随机数组\n\nrand = np.random.rand(3, 4)\nprint(rand)\n# 输出：3×4 的浮点随机数数组，例如：\n# [[0.567 0.123 ...]\n#  ...]\n\nri = np.random.randint(2, 5, size=(4, 5))\nprint(ri)\n# 输出：4×5 的整数数组，值在 [2,5) 区间内\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 2. 数组属性查看 / 维度操作\n\na = np.array([1, 2, 3, 4])\nprint(a.ndim)      # 维度（轴数） → 输出：1\nprint(a.shape)     # 形状 → 输出：(4,)\nprint(a.size)      # 元素总数 → 输出：4\nprint(a.dtype)     # 元素类型 → 输出：dtype('int64') 或类似类型\n\n# reshape 重塑形状\nb = np.array([[1,2,3],[4,5,6]])\nprint(b.shape)     # (2,3)\nc = b.reshape((3,2))\nprint(c.shape, c)\n# 输出：\n# (3, 2) [[1 2]\n#        [3 4]\n#        [5 6]]\n\n# 转置\nd = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(d.T)\n# 输出：\n# [[1 4 7]\n#  [2 5 8]\n#  [3 6 9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 数组运算（元素级运算）\n\nx = np.array([1,2,3])\ny = np.array([4,5,6])\nprint(x + y)     # 输出：[5 7 9]\nprint(x * y)     # 输出：[4 10 18]\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 4. 数据统计函数\n\narr = np.array([1, 5, 6, 9])\nprint(np.mean(arr))     # 平均值 → 5.25\nprint(np.median(arr))   # 中位数 → 5.5（视具体数据而定）\nprint(np.std(arr))      # 标准差\nprint(np.var(arr))      # 方差\nprint(np.min(arr), np.max(arr))  # 最小值、最大值\nprint(np.sum(arr))      # 总和\nprint(np.prod(arr))     # 所有元素乘积\nprint(np.cumsum(arr))   # 累积和（prefix sum）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 5. 索引与切片\n\narr = np.array([1,2,3,4,5])\nprint(arr[1:4])           # 输出 [2 3 4]\n\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(m[0:2, 1:3])\n# 输出：\n# [[2 3]\n#  [5 6]]\n\n# 多维切片示例：假设一个三维数组 data\ndata = np.arange(2*3*4).reshape((2,3,4))\nprint(data[:, :, 0:2])  # 取最后一维的前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 6. 数组堆叠 / 拆分\n\na = np.array([[1,2],[3,4]])\nb = np.array([[5,6],[7,8]])\nv = np.vstack((a, b))\nprint(v)\n# 输出：\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n\nh = np.hstack((a, b))\nprint(h)\n# 输出：\n# [[1 2 5 6]\n#  [3 4 7 8]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 7. 保存 / 加载数组\n\nnp.save('my_array.npy', a)          # 保存到 .npy 文件\nloaded = np.load('my_array.npy')\nprint(loaded)                        # 输出：与 a 相同的数组\n\n\n1\n2\n3\n",normalizedContent:"# numpy 模块\n\n\n# numpy简介\n\nnumpy（numerical python 的简称）是 python 中用于高效数值计算的基础库。它提供了一个核心类型 ndarray（多维数组），并在其上封装了大量向量化运算、线性代数、统计函数、广播机制、索引切片、随机数生成等功能。它在科学计算、机器学习、信号处理等领域都非常关键。\n\n特点包括：\n\n * 高效：底层用 c 实现，运算速度比纯 python 的 list 快很多\n * 支持多维数组（向量、矩阵、张量）\n * 广播机制（不同形状数组做运算时自动对齐维度）\n * 与其他数据科学库（pandas、scipy、matplotlib）兼容\n\n----------------------------------------\n\n\n# 📌 numpy 常用方法（方法签名 + 参数解释）\n\n\n# 数组创建\n\n * np.array(object, dtype=none, copy=true, ndmin=0) → 从列表/元组/嵌套结构创建数组。\n   * dtype：数据类型\n   * copy：是否复制数据\n   * ndmin：最小维度\n * np.zeros(shape, dtype=float) → 创建全 0 数组。\n * np.ones(shape, dtype=float) → 创建全 1 数组。\n * np.full(shape, fill_value, dtype=none) → 创建指定值数组。\n * np.eye(n, m=none, k=0, dtype=float) → 创建单位矩阵（对角线上为1）。\n   * n：行数\n   * m：列数（默认等于 n）\n   * k：对角线偏移\n * np.arange([start, ]stop, step=1, dtype=none) → 类似 python range，生成等差序列。\n * np.linspace(start, stop, num=50, endpoint=true, dtype=none) → 生成等间距序列。\n * np.random.rand(d0, d1, …) → 生成 [0,1) 区间的均匀分布随机数。\n * np.random.randn(d0, d1, …) → 生成标准正态分布随机数。\n\n----------------------------------------\n\n\n# 数组属性\n\n * arr.shape → 返回数组形状 (tuple)。\n * arr.ndim → 返回数组维度。\n * arr.size → 元素总数。\n * arr.dtype → 元素数据类型。\n\n----------------------------------------\n\n\n# 基本操作\n\n * np.reshape(arr, newshape, order='c') → 改变数组形状。\n * np.transpose(arr, axes=none) / arr.t → 转置数组。\n * np.concatenate((a1, a2, ...), axis=0) → 拼接数组。\n * np.split(ary, indices_or_sections, axis=0) → 拆分数组。\n * np.hstack(tup) / np.vstack(tup) → 水平 / 垂直拼接。\n\n----------------------------------------\n\n\n# 索引与切片\n\n * arr[start:stop:step] → 一维切片。\n * arr[rows, cols] → 二维索引（行，列）。\n * arr[...] → 使用 ... 表示剩余所有维度。\n * arr[arr > 0] → 布尔索引。\n\n----------------------------------------\n\n\n# 运算\n\n * np.add(x1, x2) / x1 + x2\n * np.subtract(x1, x2) / x1 - x2\n * np.multiply(x1, x2) / x1 * x2\n * np.divide(x1, x2) / x1 / x2\n * np.power(x1, x2) / x1 ** x2\n * np.mod(x1, x2) / x1 % x2\n\n→ 向量化计算，按元素执行。\n\n----------------------------------------\n\n\n# 统计函数\n\n * np.sum(a, axis=none) → 求和。\n * np.mean(a, axis=none) → 均值。\n * np.median(a, axis=none) → 中位数。\n * np.std(a, axis=none) → 标准差。\n * np.var(a, axis=none) → 方差。\n * np.max(a, axis=none) / np.min(a, axis=none) → 最大/最小值。\n * np.argmax(a, axis=none) / np.argmin(a, axis=none) → 最大/最小值索引。\n\n----------------------------------------\n\n\n# 线性代数\n\n * np.dot(a, b) → 矩阵乘法 / 点积。\n * np.matmul(a, b) / a @ b → 矩阵乘法（推荐写法）。\n * np.linalg.inv(a) → 矩阵求逆。\n * np.linalg.det(a) → 行列式。\n * np.linalg.eig(a) → 特征值与特征向量。\n\n----------------------------------------\n\n\n# 文件读写\n\n * np.loadtxt(fname, dtype=float, delimiter=none, skiprows=0) → 从文本加载数据。\n * np.savetxt(fname, x, fmt='%.18e', delimiter=' ') → 保存为文本文件。\n * np.save(file, arr, allow_pickle=true) → 保存为 .npy 文件。\n * np.load(file, allow_pickle=true) → 加载 .npy 文件。\n\n\n# 主要方法与功能示例\n\n下面是文章中提到（或涵盖）的几个重要方法 / 功能。我给出代码 + 注释说明输出。\n\nimport numpy as np\n\n\n1\n\n\n----------------------------------------\n\n\n# 1. 数组的创建方式\n\n# 1.1 np.array\n\na = np.array([1, 2, 3, 4])\nprint(a)  \n# 输出： [1 2 3 4]\n\nb = np.array([[1, 2, 3, 4], [4, 5, 6, 7]])\nprint(b)\n# 输出： \n# [[1 2 3 4]\n#  [4 5 6 7]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 1.2 全零 / 全一 / 空数组\n\nz = np.zeros((3, 4))\nprint(z)\n# 输出：\n# [[0. 0. 0. 0.]\n#  [0. 0. 0. 0.]\n#  [0. 0. 0. 0.]]\n\no = np.ones((2, 5))\nprint(o)\n# 输出：\n# [[1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]]\n\ne = np.empty((2, 3))\nprint(e)\n# 输出：内容未被初始化，可能是随机值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1.3 arange 与 linspace\n\nr = np.arange(10, 16, 2)\nprint(r)\n# 输出： [10 12 14]\n\nls = np.linspace(1, 10, 5)\nprint(ls)\n# 输出： [ 1.     3.25   5.5    7.75  10.   ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 1.4 随机数组\n\nrand = np.random.rand(3, 4)\nprint(rand)\n# 输出：3×4 的浮点随机数数组，例如：\n# [[0.567 0.123 ...]\n#  ...]\n\nri = np.random.randint(2, 5, size=(4, 5))\nprint(ri)\n# 输出：4×5 的整数数组，值在 [2,5) 区间内\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 2. 数组属性查看 / 维度操作\n\na = np.array([1, 2, 3, 4])\nprint(a.ndim)      # 维度（轴数） → 输出：1\nprint(a.shape)     # 形状 → 输出：(4,)\nprint(a.size)      # 元素总数 → 输出：4\nprint(a.dtype)     # 元素类型 → 输出：dtype('int64') 或类似类型\n\n# reshape 重塑形状\nb = np.array([[1,2,3],[4,5,6]])\nprint(b.shape)     # (2,3)\nc = b.reshape((3,2))\nprint(c.shape, c)\n# 输出：\n# (3, 2) [[1 2]\n#        [3 4]\n#        [5 6]]\n\n# 转置\nd = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(d.t)\n# 输出：\n# [[1 4 7]\n#  [2 5 8]\n#  [3 6 9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 数组运算（元素级运算）\n\nx = np.array([1,2,3])\ny = np.array([4,5,6])\nprint(x + y)     # 输出：[5 7 9]\nprint(x * y)     # 输出：[4 10 18]\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 4. 数据统计函数\n\narr = np.array([1, 5, 6, 9])\nprint(np.mean(arr))     # 平均值 → 5.25\nprint(np.median(arr))   # 中位数 → 5.5（视具体数据而定）\nprint(np.std(arr))      # 标准差\nprint(np.var(arr))      # 方差\nprint(np.min(arr), np.max(arr))  # 最小值、最大值\nprint(np.sum(arr))      # 总和\nprint(np.prod(arr))     # 所有元素乘积\nprint(np.cumsum(arr))   # 累积和（prefix sum）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 5. 索引与切片\n\narr = np.array([1,2,3,4,5])\nprint(arr[1:4])           # 输出 [2 3 4]\n\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(m[0:2, 1:3])\n# 输出：\n# [[2 3]\n#  [5 6]]\n\n# 多维切片示例：假设一个三维数组 data\ndata = np.arange(2*3*4).reshape((2,3,4))\nprint(data[:, :, 0:2])  # 取最后一维的前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 6. 数组堆叠 / 拆分\n\na = np.array([[1,2],[3,4]])\nb = np.array([[5,6],[7,8]])\nv = np.vstack((a, b))\nprint(v)\n# 输出：\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n\nh = np.hstack((a, b))\nprint(h)\n# 输出：\n# [[1 2 5 6]\n#  [3 4 7 8]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 7. 保存 / 加载数组\n\nnp.save('my_array.npy', a)          # 保存到 .npy 文件\nloaded = np.load('my_array.npy')\nprint(loaded)                        # 输出：与 a 相同的数组\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.pandas 模块",frontmatter:{title:"02.pandas 模块",date:"2025-09-26T22:30:00.000Z",permalink:"/pages/Python_02/"},regularPath:"/05.python/02.pandas%20%E6%A8%A1%E5%9D%97.html",relativePath:"05.python/02.pandas 模块.md",key:"v-cc2c3696",path:"/pages/Python_02/",headers:[{level:2,title:"Pandas 简介",slug:"pandas-简介",normalizedTitle:"pandas 简介",charIndex:16},{level:2,title:"📌 Pandas 常用方法（方法签名 + 参数解释）",slug:"📌-pandas-常用方法-方法签名-参数解释",normalizedTitle:"📌 pandas 常用方法（方法签名 + 参数解释）",charIndex:512},{level:3,title:"创建对象",slug:"创建对象",normalizedTitle:"创建对象",charIndex:544},{level:3,title:"查看信息",slug:"查看信息",normalizedTitle:"查看信息",charIndex:949},{level:3,title:"选择与切片",slug:"选择与切片",normalizedTitle:"选择与切片",charIndex:1256},{level:3,title:"增删改",slug:"增删改",normalizedTitle:"增删改",charIndex:1524},{level:3,title:"缺失值处理",slug:"缺失值处理",normalizedTitle:"缺失值处理",charIndex:388},{level:3,title:"重复值处理",slug:"重复值处理",normalizedTitle:"重复值处理",charIndex:2182},{level:3,title:"分组与聚合",slug:"分组与聚合",normalizedTitle:"分组与聚合",charIndex:2436},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:2637},{level:3,title:"合并拼接",slug:"合并拼接",normalizedTitle:"合并拼接",charIndex:2853},{level:3,title:"输入输出",slug:"输入输出",normalizedTitle:"输入输出",charIndex:3165},{level:2,title:"pandas 主要方法与功能示例",slug:"pandas-主要方法与功能示例",normalizedTitle:"pandas 主要方法与功能示例",charIndex:3447},{level:3,title:"1. pandas 认识：Series 与 DataFrame",slug:"_1-pandas-认识-series-与-dataframe",normalizedTitle:"1. pandas 认识：series 与 dataframe",charIndex:3583},{level:3,title:"2. DataFrame",slug:"_2-dataframe",normalizedTitle:"2. dataframe",charIndex:4317},{level:3,title:"3. 基本操作：增、删、改、查",slug:"_3-基本操作-增、删、改、查",normalizedTitle:"3. 基本操作：增、删、改、查",charIndex:5051},{level:3,title:"4. 缺失值 & 重复值处理",slug:"_4-缺失值-重复值处理",normalizedTitle:"4. 缺失值 &amp; 重复值处理",charIndex:null},{level:3,title:"5. 分组与聚合（GroupBy）",slug:"_5-分组与聚合-groupby",normalizedTitle:"5. 分组与聚合（groupby）",charIndex:5792},{level:3,title:"6. 合并 / 连接 / 拼接",slug:"_6-合并-连接-拼接",normalizedTitle:"6. 合并 / 连接 / 拼接",charIndex:6152},{level:3,title:"7. 时间序列操作（简要）",slug:"_7-时间序列操作-简要",normalizedTitle:"7. 时间序列操作（简要）",charIndex:6689},{level:3,title:"8. 读取 / 存储数据",slug:"_8-读取-存储数据",normalizedTitle:"8. 读取 / 存储数据",charIndex:7070}],headersStr:"Pandas 简介 📌 Pandas 常用方法（方法签名 + 参数解释） 创建对象 查看信息 选择与切片 增删改 缺失值处理 重复值处理 分组与聚合 排序 合并拼接 输入输出 pandas 主要方法与功能示例 1. pandas 认识：Series 与 DataFrame 2. DataFrame 3. 基本操作：增、删、改、查 4. 缺失值 & 重复值处理 5. 分组与聚合（GroupBy） 6. 合并 / 连接 / 拼接 7. 时间序列操作（简要） 8. 读取 / 存储数据",content:"# pandas 模块\n\n\n# Pandas 简介\n\nPandas（来源于 Panel Data）是基于 NumPy 的一个强大数据分析与处理库。它提供了两个核心数据结构：\n\n * Series：一维带标签的数组（类似带索引的一列数据）\n * DataFrame：二维表格型数据（类似 Excel 表格 / SQL 表）\n\nPandas 在数据清洗、分析、特征工程、金融建模等领域应用广泛，是 Python 数据科学与机器学习的核心库之一。\n\n特点包括：\n\n * 高效的数据结构：Series 和 DataFrame 基于 NumPy，支持高效存储与计算\n * 灵活的数据索引与切片：支持按标签（label）、位置（position）访问数据\n * 丰富的数据操作：分组（groupby）、聚合（aggregate）、透视表（pivot_table）等\n * 数据清洗与处理：缺失值处理、数据类型转换、字符串与时间序列处理\n * 文件读写能力：支持 CSV、Excel、SQL、JSON 等多种格式的高效读写\n * 与其他科学计算库兼容：可与 NumPy、Matplotlib、Scikit-learn 等无缝结合\n\n\n# 📌 Pandas 常用方法（方法签名 + 参数解释）\n\n\n# 创建对象\n\n * pd.Series(data=None, index=None, dtype=None, name=None, copy=False) → 创建一维数组结构。\n   * data：数据，可为list/ndarray/dict等\n   * index：索引标签\n   * dtype：数据类型\n   * name：Series 名称\n   * copy：是否复制数据\n * pd.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) → 创建二维表格结构。\n   * data：二维数据（dict/ndarray等）\n   * index：行索引\n   * columns：列索引\n   * dtype：数据类型\n\n----------------------------------------\n\n\n# 查看信息\n\n * df.head(n=5) → 返回前 n 行。\n * df.tail(n=5) → 返回后 n 行。\n * df.info(verbose=None, buf=None, max_cols=None, memory_usage=None, show_counts=None) → 显示数据表概况。\n * df.describe(percentiles=None, include=None, exclude=None, datetime_is_numeric=False) → 生成数值型列的统计信息。\n\n----------------------------------------\n\n\n# 选择与切片\n\n * df.loc[row_indexer, col_indexer] → 按 标签 选择数据。\n * df.iloc[row_indexer, col_indexer] → 按 位置 选择数据。\n * df.query(expr, inplace=False, **kwargs) → 用表达式筛选数据。\n   * expr：字符串表达式（如 \"col > 3 & col < 10\"）\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 增删改\n\n * df.drop(labels=None, axis=0, index=None, columns=None, inplace=False) → 删除行或列。\n   * labels：要删除的行/列名\n   * axis：0=行, 1=列\n   * inplace：是否原地修改\n * df.rename(mapper=None, index=None, columns=None, inplace=False) → 重命名行/列。\n   * columns：字典，旧列名→新列名\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 缺失值处理\n\n * df.isnull() → 返回布尔值 DataFrame，标记缺失值。\n * df.fillna(value=None, method=None, inplace=False, limit=None) → 填充缺失值。\n   * value：填充值\n   * method：填充方式（'ffill' 向前填充, 'bfill' 向后填充）\n * df.dropna(axis=0, how='any', inplace=False) → 删除含缺失值的行/列。\n   * axis：0=行, 1=列\n   * how：'any'=任意NaN删除, 'all'=全NaN删除\n\n----------------------------------------\n\n\n# 重复值处理\n\n * df.duplicated(subset=None, keep='first') → 返回布尔Series，标记重复行。\n * df.drop_duplicates(subset=None, keep='first', inplace=False) → 删除重复行。\n   * subset：指定检查的列\n   * keep：保留哪一个（'first' / 'last' / False 全删）\n\n----------------------------------------\n\n\n# 分组与聚合\n\n * df.groupby(by=None, axis=0, as_index=True) → 分组对象。\n   * by：列名/函数/数组\n   * as_index：是否返回索引为分组键\n * grouped.agg(func=None, *args, **kwargs) → 多函数聚合。\n\n----------------------------------------\n\n\n# 排序\n\n * df.sort_values(by, axis=0, ascending=True, inplace=False) → 按列值排序。\n   * by：列名\n   * ascending：是否升序\n * df.sort_index(axis=0, ascending=True, inplace=False) → 按索引排序。\n\n----------------------------------------\n\n\n# 合并拼接\n\n * pd.concat(objs, axis=0, join='outer', ignore_index=False) → 沿某维拼接对象。\n   * objs：列表/字典\n   * axis：0=纵向, 1=横向\n * pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None) → 类似SQL join的合并。\n   * how：'inner' / 'outer' / 'left' / 'right'\n   * on：公共列\n\n----------------------------------------\n\n\n# 输入输出\n\n * pd.read_csv(filepath, sep=',', header='infer', encoding=None) → 从 CSV 文件读取数据。\n * df.to_csv(path, sep=',', index=True, encoding='utf-8') → 保存为 CSV。\n * pd.read_excel(io, sheet_name=0) → 读取 Excel。\n * df.to_excel(excel_writer, sheet_name='Sheet1', index=True) → 保存为 Excel。\n\n\n# pandas 主要方法与功能示例\n\n在使用pandas之前，需要确保已经import\n\nimport numpy as np\nimport pandas as pd\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 1. pandas 认识：Series 与 DataFrame\n\n# 1.1 Series\n\n# 用列表创建 Series（带默认索引 0,1,2...）\ns = pd.Series([10, 20, 30, 40])\nprint(s)\n# 输出：\n# 0    10\n# 1    20\n# 2    30\n# 3    40\n# dtype: int64\n\n# 用自定义索引\ns2 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\nprint(s2['a'])  # 输出：1\nprint(s2.loc['b'])  # 输出：2\nprint(s2.iloc[1])  # 输出：2\n\n# 从 numpy 数组创建 Series（共享底层数据）\narr = np.array([5, 6, 7])\ns3 = pd.Series(arr)\nprint(s3)\n# 修改原数组也影响 Series\narr[1] = 100\nprint(s3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 1.2 用字典创建 Series\n\nd = {'name': '张三', 'age': 18, 'sex': '男'}\ns_dict = pd.Series(d)\nprint(s_dict)\n# 输出：\n# name    张三\n# age       18\n# sex       男\n# dtype: object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n\n# 2. DataFrame\n\n# 用字典创建 DataFrame（每个键对应一列）\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'score': [88.5, 92.0, 85.0]\n})\nprint(df)\n# 输出：\n#       name  age  score\n# 0    Alice   25   88.5\n# 1      Bob   30   92.0\n# 2  Charlie   35   85.0\n\n# 查看属性\nprint(df.shape)       # 输出：(3, 3)\nprint(df.columns)     # 输出：Index(['name', 'age', 'score'], dtype='object')\nprint(df.index)       # 输出：RangeIndex(start=0, stop=3, step=1)\nprint(df.dtypes)      # 输出每列的数据类型\n\n# 访问列与行\nprint(df['name'])        # 这会返回一个 Series\nprint(df.loc[1])         # 第 1 行数据（标签位置）\nprint(df.iloc[0:2, 0:2])  # 用位置切片：前两行，前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 基本操作：增、删、改、查\n\n# 新增列\ndf['newcol'] = df['age'] * 2\nprint(df)\n\n# 删除列\ndf2 = df.drop(columns=['newcol'])\nprint(df2)\n\n# 修改值\ndf.at[1, 'age'] = 31\nprint(df.loc[1])\n\n# 条件过滤 / 布尔索引\ndf_filtered = df[df['score'] > 90]\nprint(df_filtered)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 缺失值 & 重复值处理\n\n# 构造带 NaN 的 DataFrame\ndf_missing = pd.DataFrame({\n    'A': [1, np.nan, 3],\n    'B': [4, 5, np.nan]\n})\nprint(df_missing)\n\n# 检查缺失值\nprint(df_missing.isnull())\nprint(df_missing.isnull().sum())\n\n# 填充缺失值\ndf_fill0 = df_missing.fillna(0)\nprint(df_fill0)\n\n# 删除含缺失值的行/列\ndf_drop = df_missing.dropna(axis=0)  # 删除行\nprint(df_drop)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 5. 分组与聚合（GroupBy）\n\n# 示例 DataFrame\ndf3 = pd.DataFrame({\n    'key': ['A', 'B', 'A', 'B'],\n    'value': [10, 20, 15, 25]\n})\n\ngrouped = df3.groupby('key')\nprint(grouped.sum())\n# 输出：\n#      value\n# key       \n# A        25\n# B        45\n\nprint(grouped['value'].mean())\n# 输出平均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 6. 合并 / 连接 / 拼接\n\ndf1 = pd.DataFrame({'id': [1,2,3], 'x': ['a','b','c']})\ndf2 = pd.DataFrame({'id': [2,3,4], 'y': [20, 30, 40]})\n\n# 内连接（类似 SQL 的 inner join）\ndf_join = pd.merge(df1, df2, on='id', how='inner')\nprint(df_join)\n\n# 外连接\ndf_outer = pd.merge(df1, df2, on='id', how='outer')\nprint(df_outer)\n\n# 拼接（上下 / 左右方向）\ndf_vert = pd.concat([df1, df2], axis=0, ignore_index=True)\nprint(df_vert)\n\ndf_horiz = pd.concat([df1, df2], axis=1)\nprint(df_horiz)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 7. 时间序列操作（简要）\n\ndates = pd.date_range('2025-01-01', periods=6, freq='D')\ndf_ts = pd.DataFrame({\n    'date': dates,\n    'value': [10, 12, 11, 15, 14, 13]\n})\ndf_ts = df_ts.set_index('date')\nprint(df_ts)\n\n# 重采样 / 滚动窗口\nprint(df_ts.resample('2D').mean())   # 每两天取平均\nprint(df_ts.rolling(window=3).mean())  # 滑动窗口均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 8. 读取 / 存储数据\n\n# 读取 CSV\ndf_csv = pd.read_csv('data.csv')\n# 写入 CSV\ndf_csv.to_csv('out.csv', index=False)\n\n# 读取 Excel\n# df_excel = pd.read_excel('data.xlsx', sheet_name='Sheet1')\n# 写入 Excel\n# df_excel.to_excel('out.xlsx', index=False)\n\n# 读取 / 写入 JSON\n# df_json = pd.read_json('data.json')\n# df_csv.to_json('out.json')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# pandas 模块\n\n\n# pandas 简介\n\npandas（来源于 panel data）是基于 numpy 的一个强大数据分析与处理库。它提供了两个核心数据结构：\n\n * series：一维带标签的数组（类似带索引的一列数据）\n * dataframe：二维表格型数据（类似 excel 表格 / sql 表）\n\npandas 在数据清洗、分析、特征工程、金融建模等领域应用广泛，是 python 数据科学与机器学习的核心库之一。\n\n特点包括：\n\n * 高效的数据结构：series 和 dataframe 基于 numpy，支持高效存储与计算\n * 灵活的数据索引与切片：支持按标签（label）、位置（position）访问数据\n * 丰富的数据操作：分组（groupby）、聚合（aggregate）、透视表（pivot_table）等\n * 数据清洗与处理：缺失值处理、数据类型转换、字符串与时间序列处理\n * 文件读写能力：支持 csv、excel、sql、json 等多种格式的高效读写\n * 与其他科学计算库兼容：可与 numpy、matplotlib、scikit-learn 等无缝结合\n\n\n# 📌 pandas 常用方法（方法签名 + 参数解释）\n\n\n# 创建对象\n\n * pd.series(data=none, index=none, dtype=none, name=none, copy=false) → 创建一维数组结构。\n   * data：数据，可为list/ndarray/dict等\n   * index：索引标签\n   * dtype：数据类型\n   * name：series 名称\n   * copy：是否复制数据\n * pd.dataframe(data=none, index=none, columns=none, dtype=none, copy=false) → 创建二维表格结构。\n   * data：二维数据（dict/ndarray等）\n   * index：行索引\n   * columns：列索引\n   * dtype：数据类型\n\n----------------------------------------\n\n\n# 查看信息\n\n * df.head(n=5) → 返回前 n 行。\n * df.tail(n=5) → 返回后 n 行。\n * df.info(verbose=none, buf=none, max_cols=none, memory_usage=none, show_counts=none) → 显示数据表概况。\n * df.describe(percentiles=none, include=none, exclude=none, datetime_is_numeric=false) → 生成数值型列的统计信息。\n\n----------------------------------------\n\n\n# 选择与切片\n\n * df.loc[row_indexer, col_indexer] → 按 标签 选择数据。\n * df.iloc[row_indexer, col_indexer] → 按 位置 选择数据。\n * df.query(expr, inplace=false, **kwargs) → 用表达式筛选数据。\n   * expr：字符串表达式（如 \"col > 3 & col < 10\"）\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 增删改\n\n * df.drop(labels=none, axis=0, index=none, columns=none, inplace=false) → 删除行或列。\n   * labels：要删除的行/列名\n   * axis：0=行, 1=列\n   * inplace：是否原地修改\n * df.rename(mapper=none, index=none, columns=none, inplace=false) → 重命名行/列。\n   * columns：字典，旧列名→新列名\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 缺失值处理\n\n * df.isnull() → 返回布尔值 dataframe，标记缺失值。\n * df.fillna(value=none, method=none, inplace=false, limit=none) → 填充缺失值。\n   * value：填充值\n   * method：填充方式（'ffill' 向前填充, 'bfill' 向后填充）\n * df.dropna(axis=0, how='any', inplace=false) → 删除含缺失值的行/列。\n   * axis：0=行, 1=列\n   * how：'any'=任意nan删除, 'all'=全nan删除\n\n----------------------------------------\n\n\n# 重复值处理\n\n * df.duplicated(subset=none, keep='first') → 返回布尔series，标记重复行。\n * df.drop_duplicates(subset=none, keep='first', inplace=false) → 删除重复行。\n   * subset：指定检查的列\n   * keep：保留哪一个（'first' / 'last' / false 全删）\n\n----------------------------------------\n\n\n# 分组与聚合\n\n * df.groupby(by=none, axis=0, as_index=true) → 分组对象。\n   * by：列名/函数/数组\n   * as_index：是否返回索引为分组键\n * grouped.agg(func=none, *args, **kwargs) → 多函数聚合。\n\n----------------------------------------\n\n\n# 排序\n\n * df.sort_values(by, axis=0, ascending=true, inplace=false) → 按列值排序。\n   * by：列名\n   * ascending：是否升序\n * df.sort_index(axis=0, ascending=true, inplace=false) → 按索引排序。\n\n----------------------------------------\n\n\n# 合并拼接\n\n * pd.concat(objs, axis=0, join='outer', ignore_index=false) → 沿某维拼接对象。\n   * objs：列表/字典\n   * axis：0=纵向, 1=横向\n * pd.merge(left, right, how='inner', on=none, left_on=none, right_on=none) → 类似sql join的合并。\n   * how：'inner' / 'outer' / 'left' / 'right'\n   * on：公共列\n\n----------------------------------------\n\n\n# 输入输出\n\n * pd.read_csv(filepath, sep=',', header='infer', encoding=none) → 从 csv 文件读取数据。\n * df.to_csv(path, sep=',', index=true, encoding='utf-8') → 保存为 csv。\n * pd.read_excel(io, sheet_name=0) → 读取 excel。\n * df.to_excel(excel_writer, sheet_name='sheet1', index=true) → 保存为 excel。\n\n\n# pandas 主要方法与功能示例\n\n在使用pandas之前，需要确保已经import\n\nimport numpy as np\nimport pandas as pd\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 1. pandas 认识：series 与 dataframe\n\n# 1.1 series\n\n# 用列表创建 series（带默认索引 0,1,2...）\ns = pd.series([10, 20, 30, 40])\nprint(s)\n# 输出：\n# 0    10\n# 1    20\n# 2    30\n# 3    40\n# dtype: int64\n\n# 用自定义索引\ns2 = pd.series([1, 2, 3], index=['a', 'b', 'c'])\nprint(s2['a'])  # 输出：1\nprint(s2.loc['b'])  # 输出：2\nprint(s2.iloc[1])  # 输出：2\n\n# 从 numpy 数组创建 series（共享底层数据）\narr = np.array([5, 6, 7])\ns3 = pd.series(arr)\nprint(s3)\n# 修改原数组也影响 series\narr[1] = 100\nprint(s3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 1.2 用字典创建 series\n\nd = {'name': '张三', 'age': 18, 'sex': '男'}\ns_dict = pd.series(d)\nprint(s_dict)\n# 输出：\n# name    张三\n# age       18\n# sex       男\n# dtype: object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n\n# 2. dataframe\n\n# 用字典创建 dataframe（每个键对应一列）\ndf = pd.dataframe({\n    'name': ['alice', 'bob', 'charlie'],\n    'age': [25, 30, 35],\n    'score': [88.5, 92.0, 85.0]\n})\nprint(df)\n# 输出：\n#       name  age  score\n# 0    alice   25   88.5\n# 1      bob   30   92.0\n# 2  charlie   35   85.0\n\n# 查看属性\nprint(df.shape)       # 输出：(3, 3)\nprint(df.columns)     # 输出：index(['name', 'age', 'score'], dtype='object')\nprint(df.index)       # 输出：rangeindex(start=0, stop=3, step=1)\nprint(df.dtypes)      # 输出每列的数据类型\n\n# 访问列与行\nprint(df['name'])        # 这会返回一个 series\nprint(df.loc[1])         # 第 1 行数据（标签位置）\nprint(df.iloc[0:2, 0:2])  # 用位置切片：前两行，前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 基本操作：增、删、改、查\n\n# 新增列\ndf['newcol'] = df['age'] * 2\nprint(df)\n\n# 删除列\ndf2 = df.drop(columns=['newcol'])\nprint(df2)\n\n# 修改值\ndf.at[1, 'age'] = 31\nprint(df.loc[1])\n\n# 条件过滤 / 布尔索引\ndf_filtered = df[df['score'] > 90]\nprint(df_filtered)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 缺失值 & 重复值处理\n\n# 构造带 nan 的 dataframe\ndf_missing = pd.dataframe({\n    'a': [1, np.nan, 3],\n    'b': [4, 5, np.nan]\n})\nprint(df_missing)\n\n# 检查缺失值\nprint(df_missing.isnull())\nprint(df_missing.isnull().sum())\n\n# 填充缺失值\ndf_fill0 = df_missing.fillna(0)\nprint(df_fill0)\n\n# 删除含缺失值的行/列\ndf_drop = df_missing.dropna(axis=0)  # 删除行\nprint(df_drop)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 5. 分组与聚合（groupby）\n\n# 示例 dataframe\ndf3 = pd.dataframe({\n    'key': ['a', 'b', 'a', 'b'],\n    'value': [10, 20, 15, 25]\n})\n\ngrouped = df3.groupby('key')\nprint(grouped.sum())\n# 输出：\n#      value\n# key       \n# a        25\n# b        45\n\nprint(grouped['value'].mean())\n# 输出平均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 6. 合并 / 连接 / 拼接\n\ndf1 = pd.dataframe({'id': [1,2,3], 'x': ['a','b','c']})\ndf2 = pd.dataframe({'id': [2,3,4], 'y': [20, 30, 40]})\n\n# 内连接（类似 sql 的 inner join）\ndf_join = pd.merge(df1, df2, on='id', how='inner')\nprint(df_join)\n\n# 外连接\ndf_outer = pd.merge(df1, df2, on='id', how='outer')\nprint(df_outer)\n\n# 拼接（上下 / 左右方向）\ndf_vert = pd.concat([df1, df2], axis=0, ignore_index=true)\nprint(df_vert)\n\ndf_horiz = pd.concat([df1, df2], axis=1)\nprint(df_horiz)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 7. 时间序列操作（简要）\n\ndates = pd.date_range('2025-01-01', periods=6, freq='d')\ndf_ts = pd.dataframe({\n    'date': dates,\n    'value': [10, 12, 11, 15, 14, 13]\n})\ndf_ts = df_ts.set_index('date')\nprint(df_ts)\n\n# 重采样 / 滚动窗口\nprint(df_ts.resample('2d').mean())   # 每两天取平均\nprint(df_ts.rolling(window=3).mean())  # 滑动窗口均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 8. 读取 / 存储数据\n\n# 读取 csv\ndf_csv = pd.read_csv('data.csv')\n# 写入 csv\ndf_csv.to_csv('out.csv', index=false)\n\n# 读取 excel\n# df_excel = pd.read_excel('data.xlsx', sheet_name='sheet1')\n# 写入 excel\n# df_excel.to_excel('out.xlsx', index=false)\n\n# 读取 / 写入 json\n# df_json = pd.read_json('data.json')\n# df_csv.to_json('out.json')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.matplotlib 模块",frontmatter:{title:"03.matplotlib 模块",date:"2025-09-27T14:30:00.000Z",permalink:"/pages/Python_03/"},regularPath:"/05.python/03.matplotlib%20%E6%A8%A1%E5%9D%97.html",relativePath:"05.python/03.matplotlib 模块.md",key:"v-31773509",path:"/pages/Python_03/",headers:[{level:2,title:"Matplotlib 简介",slug:"matplotlib-简介",normalizedTitle:"matplotlib 简介",charIndex:20},{level:2,title:"一、绘图基础",slug:"一、绘图基础",normalizedTitle:"一、绘图基础",charIndex:392},{level:3,title:"1.1 导入与接口风格",slug:"_1-1-导入与接口风格",normalizedTitle:"1.1 导入与接口风格",charIndex:403},{level:3,title:"1.2 Figure / Axes / Axis 概念",slug:"_1-2-figure-axes-axis-概念",normalizedTitle:"1.2 figure / axes / axis 概念",charIndex:675},{level:3,title:"1.3 显示与保存",slug:"_1-3-显示与保存",normalizedTitle:"1.3 显示与保存",charIndex:1025},{level:2,title:"二、常见图表（函数归纳 + 示例）",slug:"二、常见图表-函数归纳-示例",normalizedTitle:"二、常见图表（函数归纳 + 示例）",charIndex:1281},{level:3,title:"2.1 折线图（Line Plot）",slug:"_2-1-折线图-line-plot",normalizedTitle:"2.1 折线图（line plot）",charIndex:1324},{level:3,title:"2.2 散点图（Scatter）",slug:"_2-2-散点图-scatter",normalizedTitle:"2.2 散点图（scatter）",charIndex:1682},{level:3,title:"2.3 柱状图（Bar）",slug:"_2-3-柱状图-bar",normalizedTitle:"2.3 柱状图（bar）",charIndex:2030},{level:3,title:"2.4 直方图（Histogram）",slug:"_2-4-直方图-histogram",normalizedTitle:"2.4 直方图（histogram）",charIndex:2535},{level:3,title:"2.5 饼图（Pie）",slug:"_2-5-饼图-pie",normalizedTitle:"2.5 饼图（pie）",charIndex:2826},{level:3,title:"2.6 箱型图（Boxplot）",slug:"_2-6-箱型图-boxplot",normalizedTitle:"2.6 箱型图（boxplot）",charIndex:3116},{level:3,title:"2.7 小提琴图（Violinplot）",slug:"_2-7-小提琴图-violinplot",normalizedTitle:"2.7 小提琴图（violinplot）",charIndex:3341},{level:2,title:"三、进阶绘图",slug:"三、进阶绘图",normalizedTitle:"三、进阶绘图",charIndex:3620},{level:3,title:"3.1 双轴（twinx / twiny）",slug:"_3-1-双轴-twinx-twiny",normalizedTitle:"3.1 双轴（twinx / twiny）",charIndex:3631},{level:3,title:"3.2 多子图与布局控制",slug:"_3-2-多子图与布局控制",normalizedTitle:"3.2 多子图与布局控制",charIndex:3829},{level:3,title:"3.3 等高线（Contour）与热力图（Heatmap）",slug:"_3-3-等高线-contour-与热力图-heatmap",normalizedTitle:"3.3 等高线（contour）与热力图（heatmap）",charIndex:4180},{level:3,title:"3.4 向量场（Quiver）",slug:"_3-4-向量场-quiver",normalizedTitle:"3.4 向量场（quiver）",charIndex:4519},{level:3,title:"3.5 3D 绘图（简要）",slug:"_3-5-3d-绘图-简要",normalizedTitle:"3.5 3d 绘图（简要）",charIndex:4721},{level:2,title:"四、美化与增强（提高可读性与出版级图表）",slug:"四、美化与增强-提高可读性与出版级图表",normalizedTitle:"四、美化与增强（提高可读性与出版级图表）",charIndex:5005},{level:3,title:"4.1 坐标轴与刻度控制",slug:"_4-1-坐标轴与刻度控制",normalizedTitle:"4.1 坐标轴与刻度控制",charIndex:5030},{level:3,title:"4.2 边框（Spines）与坐标比例",slug:"_4-2-边框-spines-与坐标比例",normalizedTitle:"4.2 边框（spines）与坐标比例",charIndex:5278},{level:3,title:"4.3 图例（Legend）",slug:"_4-3-图例-legend",normalizedTitle:"4.3 图例（legend）",charIndex:5409},{level:3,title:"4.4 文本与注释（text / annotate）",slug:"_4-4-文本与注释-text-annotate",normalizedTitle:"4.4 文本与注释（text / annotate）",charIndex:5671},{level:3,title:"4.5 数学公式（MathText）",slug:"_4-5-数学公式-mathtext",normalizedTitle:"4.5 数学公式（mathtext）",charIndex:5933},{level:3,title:"4.6 颜色与色图（colormap）",slug:"_4-6-颜色与色图-colormap",normalizedTitle:"4.6 颜色与色图（colormap）",charIndex:6053},{level:3,title:"4.7 图像读写（imread / imsave / imshow）",slug:"_4-7-图像读写-imread-imsave-imshow",normalizedTitle:"4.7 图像读写（imread / imsave / imshow）",charIndex:6270},{level:3,title:"4.8 坐标转换（Transforms）",slug:"_4-8-坐标转换-transforms",normalizedTitle:"4.8 坐标转换（transforms）",charIndex:6444}],headersStr:"Matplotlib 简介 一、绘图基础 1.1 导入与接口风格 1.2 Figure / Axes / Axis 概念 1.3 显示与保存 二、常见图表（函数归纳 + 示例） 2.1 折线图（Line Plot） 2.2 散点图（Scatter） 2.3 柱状图（Bar） 2.4 直方图（Histogram） 2.5 饼图（Pie） 2.6 箱型图（Boxplot） 2.7 小提琴图（Violinplot） 三、进阶绘图 3.1 双轴（twinx / twiny） 3.2 多子图与布局控制 3.3 等高线（Contour）与热力图（Heatmap） 3.4 向量场（Quiver） 3.5 3D 绘图（简要） 四、美化与增强（提高可读性与出版级图表） 4.1 坐标轴与刻度控制 4.2 边框（Spines）与坐标比例 4.3 图例（Legend） 4.4 文本与注释（text / annotate） 4.5 数学公式（MathText） 4.6 颜色与色图（colormap） 4.7 图像读写（imread / imsave / imshow） 4.8 坐标转换（Transforms）",content:"# Matplotlib 模块\n\n\n# Matplotlib 简介\n\nMatplotlib 是 Python 中最常用的可视化库之一，尤其是其中的 pyplot 模块， 提供了类似 Matlab 的绘图接口。它适合快速绘制折线图、散点图、柱状图、直方图、饼图等， 并且可以对图像进行灵活的修饰（标题、坐标轴、图例、网格、子图等）。\n\n特点：\n\n * 功能全面：支持常见 2D 图表和部分 3D 图表\n * 使用灵活：可以快捷调用 pyplot 画图，也可以精细控制 Figure 和 Axes\n * 与 NumPy / Pandas / SciPy 无缝结合\n * 丰富的自定义：颜色、线型、标记、布局等均可调整\n\n通常的下载方法：\n\npip install matplotlib\n\n\n1\n\n\n----------------------------------------\n\n\n# 一、绘图基础\n\n\n# 1.1 导入与接口风格\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n1\n2\n\n\nMatplotlib 常见有两种接口风格：\n\n * Pyplot（状态机）接口：plt.plot(...)，快捷，适合交互与一次性小图。类似 MATLAB 风格。\n * 面向对象（OO）接口：先创建 Figure / Axes，然后在 Axes 上调用方法（如 ax.plot(...)）。更灵活、适合复杂布局和脚本化绘图。\n\n建议以 OO 接口为主，必要时在交互中使用 plt 快捷方法。\n\n\n# 1.2 Figure / Axes / Axis 概念\n\n * Figure：整个图像（画布）。\n * Axes：绘图区域（包含坐标轴、刻度、标题、图例等）。一个 Figure 可包含多个 Axes。\n * Axis：坐标轴（x、y、z），负责刻度和刻度标签。\n\n创建方式：\n\nfig, ax = plt.subplots(figsize=(8,5), dpi=100)\n# 多子图\nfig, axes = plt.subplots(2, 2, figsize=(10,8))\n\n\n1\n2\n3\n\n\nfigsize 单位为英寸 (inch)，图像像素大小 = figsize * dpi。tight_layout() 或 constrained_layout=True 用于自动调整子图间距。\n\n\n# 1.3 显示与保存\n\nplt.show()  # 在交互式环境显示\nfig.savefig('out.png', dpi=300, bbox_inches='tight', transparent=False)\n\n\n1\n2\n\n\n常用 savefig 参数：\n\n * dpi：分辨率\n * bbox_inches='tight'：紧凑边界，避免标签被截断\n * transparent=True：透明背景（适合嵌入网页）\n\n----------------------------------------\n\n\n# 二、常见图表（函数归纳 + 示例）\n\n> 每个小节都给出常用参数与最小示例。\n\n\n# 2.1 折线图（Line Plot）\n\n函数：ax.plot(x, y, **kwargs)\n\n常用参数：color/c、linestyle/ls、linewidth/lw、marker、markersize/ms、label\n\nx = np.linspace(0, 2*np.pi, 200)\ny = np.sin(x)\nfig, ax = plt.subplots()\nax.plot(x, y, label=r'$y=\\sin x$', lw=2, ls='-', marker=None)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n备注：可绘多条线，常与 ax.fill_between（区域填充）配合。\n\n\n# 2.2 散点图（Scatter）\n\n函数：ax.scatter(x, y, c=None, s=None, marker=None, cmap=None, alpha=None)\n\n * c：颜色或数值数组（配合 cmap）\n * s：点大小（或数组）\n * alpha：透明度\n\nx = np.random.rand(100)\ny = np.random.rand(100)\ns = 50 * np.random.rand(100)\nfig, ax = plt.subplots()\nax.scatter(x, y, c=y, s=s, cmap='viridis', alpha=0.8)\nax.set_title('Scatter example')\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 柱状图（Bar）\n\n函数：ax.bar(x, height, width=0.8, bottom=None, align='center', **kwargs) 或 ax.barh（水平柱状）\n\n * 分组条形图：移动 x 的偏移量；堆叠条形图：使用 bottom 指定下边界\n\nlabels = ['A','B','C']\nval1 = [10, 15, 7]\nval2 = [5, 8, 3]\nind = np.arange(len(labels))\nwidth = 0.35\nfig, ax = plt.subplots()\nax.bar(ind - width/2, val1, width, label='G1')\nax.bar(ind + width/2, val2, width, label='G2')\nax.set_xticks(ind)\nax.set_xticklabels(labels)\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n堆叠示例：ax.bar(x, val1); ax.bar(x, val2, bottom=val1)\n\n\n# 2.4 直方图（Histogram）\n\n函数：ax.hist(data, bins=10, range=None, density=False, histtype='bar', alpha=0.7)\n\n * density=True 将 y 转为概率密度\n * bins 可为整数或序列（自定义切分区间）\n\ndata = np.random.normal(loc=0, scale=1, size=1000)\nfig, ax = plt.subplots()\nax.hist(data, bins=30, density=True, alpha=0.6)\n\n\n1\n2\n3\n\n\n\n# 2.5 饼图（Pie）\n\n函数：ax.pie(sizes, labels=None, autopct=None, startangle=0, explode=None)\n\n * autopct='%.1f%%' 自动显示百分比\n\nsizes = [30, 45, 25]\nlabels = ['A','B','C']\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%.1f%%', startangle=90)\nax.axis('equal')  # 使饼图为圆形\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.6 箱型图（Boxplot）\n\n函数：ax.boxplot(data, notch=False, patch_artist=False)\n\n * 展示中位数、四分位、异常值\n\ndata = [np.random.normal(i, 1, 200) for i in range(3)]\nfig, ax = plt.subplots()\nax.boxplot(data, labels=['G1','G2','G3'])\n\n\n1\n2\n3\n\n\n\n# 2.7 小提琴图（Violinplot）\n\n函数：ax.violinplot(dataset, showmeans=False, showmedians=True)\n\n * 能显示数据分布的核密度估计，比箱型图更直观地展现分布形态\n\nfig, ax = plt.subplots()\nax.violinplot(data)\nax.set_xticks([1,2,3])\nax.set_xticklabels(['G1','G2','G3'])\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 三、进阶绘图\n\n\n# 3.1 双轴（twinx / twiny）\n\n> 用于 x 轴共享但 y 轴单位不同的情况。\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax1.plot(x, y1, 'g-', label='y1')\nax2.plot(x, y2, 'b--', label='y2')\n\n\n1\n2\n3\n4\n\n\n要注意图例可分别处理或手动合并图例条目。\n\n\n# 3.2 多子图与布局控制\n\n * plt.subplots(nrows, ncols, figsize=...)\n * GridSpec / plt.subplot2grid：更灵活的网格控制\n * constrained_layout=True 或 fig.tight_layout()：自动收紧布局\n\nfrom matplotlib.gridspec import GridSpec\nfig = plt.figure(figsize=(8,6))\ngs = GridSpec(3, 3, figure=fig)\nax_main = fig.add_subplot(gs[0:2, :])\nax_bottom = fig.add_subplot(gs[2, :])\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 等高线（Contour）与热力图（Heatmap）\n\nX = np.linspace(-3, 3, 200)\nY = np.linspace(-3, 3, 200)\nX, Y = np.meshgrid(X, Y)\nZ = np.sin(np.sqrt(X**2 + Y**2))\nfig, ax = plt.subplots()\ncf = ax.contourf(X, Y, Z, levels=40, cmap='viridis')\nfig.colorbar(cf, ax=ax)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n热力图（imshow）适合规则网格数据或图像显示：ax.imshow(array, origin='lower', cmap='hot')\n\n\n# 3.4 向量场（Quiver）\n\nx = np.linspace(0, 2*np.pi, 20)\ny = np.linspace(0, 2*np.pi, 20)\nX, Y = np.meshgrid(x, y)\nU = np.cos(X)\nV = np.sin(Y)\nfig, ax = plt.subplots()\nax.quiver(X, Y, U, V)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.5 3D 绘图（简要）\n\n启用 3D 投影：ax = fig.add_subplot(111, projection='3d')，然后使用 plot3D、scatter3D、plot_surface 等。\n\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot3D(x, y, z)\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 四、美化与增强（提高可读性与出版级图表）\n\n\n# 4.1 坐标轴与刻度控制\n\nax.set_xlim(0, 10)\nax.set_ylim(-1.5, 1.5)\nax.set_xticks([0, 2, 4, 6, 8, 10])\nax.set_xticklabels(['0','2','4','6','8','10'], rotation=45)\n\n\n1\n2\n3\n4\n\n\n进阶：使用 matplotlib.ticker 中的 MaxNLocator, AutoMinorLocator, FuncFormatter 来精细控制刻度。\n\n\n# 4.2 边框（Spines）与坐标比例\n\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.set_aspect('equal')\n\n\n1\n2\n3\n\n\n\n# 4.3 图例（Legend）\n\nax.legend(loc='best', fontsize=10, frameon=False)\n# 合并多个 axes 的 legend 示例\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines + lines2, labels + labels2, loc='best')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4 文本与注释（text / annotate）\n\nax.text(0.1, 0.9, '注释示例', transform=ax.transAxes)\nax.annotate('峰值', xy=(x0,y0), xytext=(x0+0.5,y0+0.5),\n            arrowprops=dict(arrowstyle='->', lw=1.5))\n\n\n1\n2\n3\n\n\n注意 transform：可使用 ax.transAxes（以轴为坐标，0-1）或 ax.transData（数据坐标）。\n\n\n# 4.5 数学公式（MathText）\n\n使用 $...$ 包裹 LaTeX 风格表达式：\n\nax.set_title(r'$E=mc^2$')\nax.set_ylabel(r'$\\alpha + \\beta x$')\n\n\n1\n2\n\n\n\n# 4.6 颜色与色图（colormap）\n\n * 常用 colormap：viridis, plasma, inferno, magma, cividis, coolwarm 等。\n * plt.cm.get_cmap('viridis') 获取 colormap 对象。\n\nsc = ax.scatter(x, y, c=vals, cmap='plasma')\nfig.colorbar(sc, ax=ax)\n\n\n1\n2\n\n\n\n# 4.7 图像读写（imread / imsave / imshow）\n\nimport matplotlib.image as mpimg\nimg = mpimg.imread('image.png')\nax.imshow(img, origin='lower')\nplt.imsave('out.png', img)\n\n\n1\n2\n3\n4\n\n\n\n# 4.8 坐标转换（Transforms）\n\n常用变换对象：\n\n * ax.transData（数据坐标）\n * ax.transAxes（轴坐标，范围 0-1）\n * fig.transFigure（图形坐标）\n\n使用例子：在轴内比例位置添加文本 ax.text(0.5, 0.1, 'foo', transform=ax.transAxes)。",normalizedContent:"# matplotlib 模块\n\n\n# matplotlib 简介\n\nmatplotlib 是 python 中最常用的可视化库之一，尤其是其中的 pyplot 模块， 提供了类似 matlab 的绘图接口。它适合快速绘制折线图、散点图、柱状图、直方图、饼图等， 并且可以对图像进行灵活的修饰（标题、坐标轴、图例、网格、子图等）。\n\n特点：\n\n * 功能全面：支持常见 2d 图表和部分 3d 图表\n * 使用灵活：可以快捷调用 pyplot 画图，也可以精细控制 figure 和 axes\n * 与 numpy / pandas / scipy 无缝结合\n * 丰富的自定义：颜色、线型、标记、布局等均可调整\n\n通常的下载方法：\n\npip install matplotlib\n\n\n1\n\n\n----------------------------------------\n\n\n# 一、绘图基础\n\n\n# 1.1 导入与接口风格\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n1\n2\n\n\nmatplotlib 常见有两种接口风格：\n\n * pyplot（状态机）接口：plt.plot(...)，快捷，适合交互与一次性小图。类似 matlab 风格。\n * 面向对象（oo）接口：先创建 figure / axes，然后在 axes 上调用方法（如 ax.plot(...)）。更灵活、适合复杂布局和脚本化绘图。\n\n建议以 oo 接口为主，必要时在交互中使用 plt 快捷方法。\n\n\n# 1.2 figure / axes / axis 概念\n\n * figure：整个图像（画布）。\n * axes：绘图区域（包含坐标轴、刻度、标题、图例等）。一个 figure 可包含多个 axes。\n * axis：坐标轴（x、y、z），负责刻度和刻度标签。\n\n创建方式：\n\nfig, ax = plt.subplots(figsize=(8,5), dpi=100)\n# 多子图\nfig, axes = plt.subplots(2, 2, figsize=(10,8))\n\n\n1\n2\n3\n\n\nfigsize 单位为英寸 (inch)，图像像素大小 = figsize * dpi。tight_layout() 或 constrained_layout=true 用于自动调整子图间距。\n\n\n# 1.3 显示与保存\n\nplt.show()  # 在交互式环境显示\nfig.savefig('out.png', dpi=300, bbox_inches='tight', transparent=false)\n\n\n1\n2\n\n\n常用 savefig 参数：\n\n * dpi：分辨率\n * bbox_inches='tight'：紧凑边界，避免标签被截断\n * transparent=true：透明背景（适合嵌入网页）\n\n----------------------------------------\n\n\n# 二、常见图表（函数归纳 + 示例）\n\n> 每个小节都给出常用参数与最小示例。\n\n\n# 2.1 折线图（line plot）\n\n函数：ax.plot(x, y, **kwargs)\n\n常用参数：color/c、linestyle/ls、linewidth/lw、marker、markersize/ms、label\n\nx = np.linspace(0, 2*np.pi, 200)\ny = np.sin(x)\nfig, ax = plt.subplots()\nax.plot(x, y, label=r'$y=\\sin x$', lw=2, ls='-', marker=none)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n备注：可绘多条线，常与 ax.fill_between（区域填充）配合。\n\n\n# 2.2 散点图（scatter）\n\n函数：ax.scatter(x, y, c=none, s=none, marker=none, cmap=none, alpha=none)\n\n * c：颜色或数值数组（配合 cmap）\n * s：点大小（或数组）\n * alpha：透明度\n\nx = np.random.rand(100)\ny = np.random.rand(100)\ns = 50 * np.random.rand(100)\nfig, ax = plt.subplots()\nax.scatter(x, y, c=y, s=s, cmap='viridis', alpha=0.8)\nax.set_title('scatter example')\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 柱状图（bar）\n\n函数：ax.bar(x, height, width=0.8, bottom=none, align='center', **kwargs) 或 ax.barh（水平柱状）\n\n * 分组条形图：移动 x 的偏移量；堆叠条形图：使用 bottom 指定下边界\n\nlabels = ['a','b','c']\nval1 = [10, 15, 7]\nval2 = [5, 8, 3]\nind = np.arange(len(labels))\nwidth = 0.35\nfig, ax = plt.subplots()\nax.bar(ind - width/2, val1, width, label='g1')\nax.bar(ind + width/2, val2, width, label='g2')\nax.set_xticks(ind)\nax.set_xticklabels(labels)\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n堆叠示例：ax.bar(x, val1); ax.bar(x, val2, bottom=val1)\n\n\n# 2.4 直方图（histogram）\n\n函数：ax.hist(data, bins=10, range=none, density=false, histtype='bar', alpha=0.7)\n\n * density=true 将 y 转为概率密度\n * bins 可为整数或序列（自定义切分区间）\n\ndata = np.random.normal(loc=0, scale=1, size=1000)\nfig, ax = plt.subplots()\nax.hist(data, bins=30, density=true, alpha=0.6)\n\n\n1\n2\n3\n\n\n\n# 2.5 饼图（pie）\n\n函数：ax.pie(sizes, labels=none, autopct=none, startangle=0, explode=none)\n\n * autopct='%.1f%%' 自动显示百分比\n\nsizes = [30, 45, 25]\nlabels = ['a','b','c']\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%.1f%%', startangle=90)\nax.axis('equal')  # 使饼图为圆形\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.6 箱型图（boxplot）\n\n函数：ax.boxplot(data, notch=false, patch_artist=false)\n\n * 展示中位数、四分位、异常值\n\ndata = [np.random.normal(i, 1, 200) for i in range(3)]\nfig, ax = plt.subplots()\nax.boxplot(data, labels=['g1','g2','g3'])\n\n\n1\n2\n3\n\n\n\n# 2.7 小提琴图（violinplot）\n\n函数：ax.violinplot(dataset, showmeans=false, showmedians=true)\n\n * 能显示数据分布的核密度估计，比箱型图更直观地展现分布形态\n\nfig, ax = plt.subplots()\nax.violinplot(data)\nax.set_xticks([1,2,3])\nax.set_xticklabels(['g1','g2','g3'])\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 三、进阶绘图\n\n\n# 3.1 双轴（twinx / twiny）\n\n> 用于 x 轴共享但 y 轴单位不同的情况。\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax1.plot(x, y1, 'g-', label='y1')\nax2.plot(x, y2, 'b--', label='y2')\n\n\n1\n2\n3\n4\n\n\n要注意图例可分别处理或手动合并图例条目。\n\n\n# 3.2 多子图与布局控制\n\n * plt.subplots(nrows, ncols, figsize=...)\n * gridspec / plt.subplot2grid：更灵活的网格控制\n * constrained_layout=true 或 fig.tight_layout()：自动收紧布局\n\nfrom matplotlib.gridspec import gridspec\nfig = plt.figure(figsize=(8,6))\ngs = gridspec(3, 3, figure=fig)\nax_main = fig.add_subplot(gs[0:2, :])\nax_bottom = fig.add_subplot(gs[2, :])\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 等高线（contour）与热力图（heatmap）\n\nx = np.linspace(-3, 3, 200)\ny = np.linspace(-3, 3, 200)\nx, y = np.meshgrid(x, y)\nz = np.sin(np.sqrt(x**2 + y**2))\nfig, ax = plt.subplots()\ncf = ax.contourf(x, y, z, levels=40, cmap='viridis')\nfig.colorbar(cf, ax=ax)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n热力图（imshow）适合规则网格数据或图像显示：ax.imshow(array, origin='lower', cmap='hot')\n\n\n# 3.4 向量场（quiver）\n\nx = np.linspace(0, 2*np.pi, 20)\ny = np.linspace(0, 2*np.pi, 20)\nx, y = np.meshgrid(x, y)\nu = np.cos(x)\nv = np.sin(y)\nfig, ax = plt.subplots()\nax.quiver(x, y, u, v)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.5 3d 绘图（简要）\n\n启用 3d 投影：ax = fig.add_subplot(111, projection='3d')，然后使用 plot3d、scatter3d、plot_surface 等。\n\nfrom mpl_toolkits.mplot3d import axes3d\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot3d(x, y, z)\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 四、美化与增强（提高可读性与出版级图表）\n\n\n# 4.1 坐标轴与刻度控制\n\nax.set_xlim(0, 10)\nax.set_ylim(-1.5, 1.5)\nax.set_xticks([0, 2, 4, 6, 8, 10])\nax.set_xticklabels(['0','2','4','6','8','10'], rotation=45)\n\n\n1\n2\n3\n4\n\n\n进阶：使用 matplotlib.ticker 中的 maxnlocator, autominorlocator, funcformatter 来精细控制刻度。\n\n\n# 4.2 边框（spines）与坐标比例\n\nax.spines['top'].set_visible(false)\nax.spines['right'].set_visible(false)\nax.set_aspect('equal')\n\n\n1\n2\n3\n\n\n\n# 4.3 图例（legend）\n\nax.legend(loc='best', fontsize=10, frameon=false)\n# 合并多个 axes 的 legend 示例\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines + lines2, labels + labels2, loc='best')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4 文本与注释（text / annotate）\n\nax.text(0.1, 0.9, '注释示例', transform=ax.transaxes)\nax.annotate('峰值', xy=(x0,y0), xytext=(x0+0.5,y0+0.5),\n            arrowprops=dict(arrowstyle='->', lw=1.5))\n\n\n1\n2\n3\n\n\n注意 transform：可使用 ax.transaxes（以轴为坐标，0-1）或 ax.transdata（数据坐标）。\n\n\n# 4.5 数学公式（mathtext）\n\n使用 $...$ 包裹 latex 风格表达式：\n\nax.set_title(r'$e=mc^2$')\nax.set_ylabel(r'$\\alpha + \\beta x$')\n\n\n1\n2\n\n\n\n# 4.6 颜色与色图（colormap）\n\n * 常用 colormap：viridis, plasma, inferno, magma, cividis, coolwarm 等。\n * plt.cm.get_cmap('viridis') 获取 colormap 对象。\n\nsc = ax.scatter(x, y, c=vals, cmap='plasma')\nfig.colorbar(sc, ax=ax)\n\n\n1\n2\n\n\n\n# 4.7 图像读写（imread / imsave / imshow）\n\nimport matplotlib.image as mpimg\nimg = mpimg.imread('image.png')\nax.imshow(img, origin='lower')\nplt.imsave('out.png', img)\n\n\n1\n2\n3\n4\n\n\n\n# 4.8 坐标转换（transforms）\n\n常用变换对象：\n\n * ax.transdata（数据坐标）\n * ax.transaxes（轴坐标，范围 0-1）\n * fig.transfigure（图形坐标）\n\n使用例子：在轴内比例位置添加文本 ax.text(0.5, 0.1, 'foo', transform=ax.transaxes)。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.C语言的编译过程",frontmatter:{title:"01.C语言的编译过程",date:"2025-10-08T23:00:00.000Z",permalink:"/pages/C_01/"},regularPath:"/06.C/01.C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html",relativePath:"06.C/01.C语言的编译过程.md",key:"v-36a51484",path:"/pages/C_01/",headers:[{level:2,title:"1、预处理(Preprocessing)",slug:"_1、预处理-preprocessing",normalizedTitle:"1、预处理(preprocessing)",charIndex:95},{level:2,title:"2、编译(Complilation)",slug:"_2、编译-complilation",normalizedTitle:"2、编译(complilation)",charIndex:394},{level:2,title:"3、汇编(Assembly)",slug:"_3、汇编-assembly",normalizedTitle:"3、汇编(assembly)",charIndex:575},{level:2,title:"4、链接(Linking)",slug:"_4、链接-linking",normalizedTitle:"4、链接(linking)",charIndex:664}],headersStr:"1、预处理(Preprocessing) 2、编译(Complilation) 3、汇编(Assembly) 4、链接(Linking)",content:'C语言编译的过程一般分为四个步骤：\n\n * 预处理(Preprocessing)\n * 编译(Compliation)\n * 汇编(Assembly)\n * 链接(Linking)\n\n\n# 1、预处理(Preprocessing)\n\n如下是一个最简单的C语言代码:\n\n#include <stdio>\n\nint main()\n{\n\tprintf("Hello World!");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 本程序中，#include <stdio.h>是一个预处理指令，告诉编译器要引入标准输入输出的头文件\n * 预处理器会处理这些指令，包括替换所有的宏定义、处理文件包含（#include）、处理条件编译指令(#if, #else,#endif)\n\n预处理之后，会把stdio.h的内容插入到源代码里面，文件的后缀为.i，准备进行编译。\n\n\n# 2、编译(Complilation)\n\n编译器将预处理后的源代码转换成汇编语言代码。其主要任务是：\n\n * 语法分析：检查C语言源代码的语法规则\n * 语义分析：变量的使用、数据类型\n * 优化：尽可能提高程序的效率\n\n本阶段后，代码变成如下的形式，真·精简版汇编，以.s位后缀：\n\nMOV R0, #0\nMOV R1, #1\n...\n\n\n1\n2\n3\n\n\n\n# 3、汇编(Assembly)\n\n将编译过后的机器码转换成由0和1构成的机器码，也可叫做目标文件，通常以.o或者.obj结尾，这个文件包含了计算机能够直接执行的机器代码。\n\n\n# 4、链接(Linking)\n\n连接器负责将程序中引用的外部库和其他源文件链接到目标文件中。比如，printf是定义在stdio库中的，而编译过后的目标文件没有，因此连接器会：\n\n * 查找库函数代码\n * 将多个目标文件连接成一个完整的可执行文件\n * 处理符号引用 最后，形成一个可执行文件，一般是a.out或a.exe,这时候，代码就可以运行了，黑色终端里面就printf出了Hello World。',normalizedContent:'c语言编译的过程一般分为四个步骤：\n\n * 预处理(preprocessing)\n * 编译(compliation)\n * 汇编(assembly)\n * 链接(linking)\n\n\n# 1、预处理(preprocessing)\n\n如下是一个最简单的c语言代码:\n\n#include <stdio>\n\nint main()\n{\n\tprintf("hello world!");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 本程序中，#include <stdio.h>是一个预处理指令，告诉编译器要引入标准输入输出的头文件\n * 预处理器会处理这些指令，包括替换所有的宏定义、处理文件包含（#include）、处理条件编译指令(#if, #else,#endif)\n\n预处理之后，会把stdio.h的内容插入到源代码里面，文件的后缀为.i，准备进行编译。\n\n\n# 2、编译(complilation)\n\n编译器将预处理后的源代码转换成汇编语言代码。其主要任务是：\n\n * 语法分析：检查c语言源代码的语法规则\n * 语义分析：变量的使用、数据类型\n * 优化：尽可能提高程序的效率\n\n本阶段后，代码变成如下的形式，真·精简版汇编，以.s位后缀：\n\nmov r0, #0\nmov r1, #1\n...\n\n\n1\n2\n3\n\n\n\n# 3、汇编(assembly)\n\n将编译过后的机器码转换成由0和1构成的机器码，也可叫做目标文件，通常以.o或者.obj结尾，这个文件包含了计算机能够直接执行的机器代码。\n\n\n# 4、链接(linking)\n\n连接器负责将程序中引用的外部库和其他源文件链接到目标文件中。比如，printf是定义在stdio库中的，而编译过后的目标文件没有，因此连接器会：\n\n * 查找库函数代码\n * 将多个目标文件连接成一个完整的可执行文件\n * 处理符号引用 最后，形成一个可执行文件，一般是a.out或a.exe,这时候，代码就可以运行了，黑色终端里面就printf出了hello world。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"03.C语言的字符串",frontmatter:{title:"03.C语言的字符串",date:"2025-10-10T15:00:00.000Z",permalink:"/pages/C_03/"},regularPath:"/06.C/03.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"06.C/03.C语言的字符串.md",key:"v-461cfdea",path:"/pages/C_03/",headersStr:null,content:'C 语言中，字符串实际上是使用空字符 \\0 结尾的一维字符数组。因此，\\0 是用于标记字符串的结束。\n\n空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。\n\n下面的四个函数常用与字符串的处理，使用之前需要 #include <string.h>\n\n序号   函数 & 功能\n1    strcpy(s1, s2); 复制字符串 s2 到字符串 s1。\n2    strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。\n3    strlen(s1); 返回字符串 s1 的长度。\n4    strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果\n     s1>s2 则返回大于 0。\n\n如下是使用上述的四个函数的示例代码：\n\n#include <stdio.h>\n#include <string.h>\n\nint main ()\n{\n   char str1[14] = "ikun";\n   char str2[14] = "xiaoheizi";\n   char str3[14];\n   int  len ;\n\n   /* 复制 str1 到 str3 */\n   strcpy(str3, str1);\n   printf("strcpy( str3, str1) :  %s\\n", str3 );\n\n   /* 连接 str1 和 str2 */\n   strcat( str1, str2);\n   printf("strcat( str1, str2):   %s\\n", str1 );\n\n   /* 连接后，str1 的总长度 */\n   len = strlen(str1);\n   printf("strlen(str1) :  %d\\n", len );\n\n   if(strcmp(str1, str2) == 0)\n   {\n       printf("str1 as same as str2\\n");\n   }\n   else\n   {\n       printf("str1 not as same as str2\\n");\n   }\n\n   return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',normalizedContent:'c 语言中，字符串实际上是使用空字符 \\0 结尾的一维字符数组。因此，\\0 是用于标记字符串的结束。\n\n空字符（null character）又称结束符，缩写 nul，是一个数值为 0 的控制字符，\\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。\n\n下面的四个函数常用与字符串的处理，使用之前需要 #include <string.h>\n\n序号   函数 & 功能\n1    strcpy(s1, s2); 复制字符串 s2 到字符串 s1。\n2    strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。\n3    strlen(s1); 返回字符串 s1 的长度。\n4    strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果\n     s1>s2 则返回大于 0。\n\n如下是使用上述的四个函数的示例代码：\n\n#include <stdio.h>\n#include <string.h>\n\nint main ()\n{\n   char str1[14] = "ikun";\n   char str2[14] = "xiaoheizi";\n   char str3[14];\n   int  len ;\n\n   /* 复制 str1 到 str3 */\n   strcpy(str3, str1);\n   printf("strcpy( str3, str1) :  %s\\n", str3 );\n\n   /* 连接 str1 和 str2 */\n   strcat( str1, str2);\n   printf("strcat( str1, str2):   %s\\n", str1 );\n\n   /* 连接后，str1 的总长度 */\n   len = strlen(str1);\n   printf("strlen(str1) :  %d\\n", len );\n\n   if(strcmp(str1, str2) == 0)\n   {\n       printf("str1 as same as str2\\n");\n   }\n   else\n   {\n       printf("str1 not as same as str2\\n");\n   }\n\n   return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"04.C语言的结构体和共用体",frontmatter:{title:"04.C语言的结构体和共用体",date:"2025-10-15T23:00:00.000Z",permalink:"/pages/C_04/"},regularPath:"/06.C/04.C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93.html",relativePath:"06.C/04.C语言的结构体和共用体.md",key:"v-b34af184",path:"/pages/C_04/",headers:[{level:2,title:"一、结构体（struct）——把不同类型的数据“打包”在一起",slug:"一、结构体-struct-把不同类型的数据-打包-在一起",normalizedTitle:"一、结构体（struct）——把不同类型的数据“打包”在一起",charIndex:173},{level:3,title:"🔹1. 定义方式",slug:"🔹1-定义方式",normalizedTitle:"🔹1. 定义方式",charIndex:208},{level:3,title:"🔹2. 定义变量的几种方式",slug:"🔹2-定义变量的几种方式",normalizedTitle:"🔹2. 定义变量的几种方式",charIndex:369},{level:3,title:"🔹3. 初始化与访问",slug:"🔹3-初始化与访问",normalizedTitle:"🔹3. 初始化与访问",charIndex:752},{level:3,title:"🔹4. 结构体嵌套与数组",slug:"🔹4-结构体嵌套与数组",normalizedTitle:"🔹4. 结构体嵌套与数组",charIndex:1243},{level:3,title:"🔹5. 注意点与常见坑",slug:"🔹5-注意点与常见坑",normalizedTitle:"🔹5. 注意点与常见坑",charIndex:1478},{level:2,title:"二、共用体（union）——多种成员共享同一段内存",slug:"二、共用体-union-多种成员共享同一段内存",normalizedTitle:"二、共用体（union）——多种成员共享同一段内存",charIndex:1808},{level:3,title:"🔹1. 定义与特点",slug:"🔹1-定义与特点",normalizedTitle:"🔹1. 定义与特点",charIndex:1838},{level:3,title:"🔹2. 示例：理解内存共享",slug:"🔹2-示例-理解内存共享",normalizedTitle:"🔹2. 示例：理解内存共享",charIndex:2063},{level:3,title:"🔹3. 常见用途",slug:"🔹3-常见用途",normalizedTitle:"🔹3. 常见用途",charIndex:2580},{level:3,title:"🔹4. 注意事项",slug:"🔹4-注意事项",normalizedTitle:"🔹4. 注意事项",charIndex:2829}],headersStr:"一、结构体（struct）——把不同类型的数据“打包”在一起 🔹1. 定义方式 🔹2. 定义变量的几种方式 🔹3. 初始化与访问 🔹4. 结构体嵌套与数组 🔹5. 注意点与常见坑 二、共用体（union）——多种成员共享同一段内存 🔹1. 定义与特点 🔹2. 示例：理解内存共享 🔹3. 常见用途 🔹4. 注意事项",content:'# C语言结构体与共用体\n\n在C语言中，除了基本数据类型（如int、float、char）外，我们还需要描述由多个不同类型组成的复杂数据，比如学生信息、坐标点、寄存器状态等。 这时就要用到两位老朋友——结构体（struct） 和 共用体（union）。\n\n----------------------------------------\n\n\n# 一、结构体（struct）——把不同类型的数据“打包”在一起\n\n\n# 🔹1. 定义方式\n\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n};\n\n\n1\n2\n3\n4\n5\n\n\n这定义了一个叫 Student 的结构体类型，包含三个成员：name、age、score。 但注意！这样定义还没有创建变量。\n\n\n# 🔹2. 定义变量的几种方式\n\n# ✅ 方法1：先定义类型，再定义变量\n\nstruct Student s1;\n\n\n1\n\n\n# ✅ 方法2：定义时直接声明变量\n\nstruct Student {\n    char name[20];\n    int age;\n    float score;\n} s1, s2;\n\n\n1\n2\n3\n4\n5\n\n\n# ✅ 方法3：使用 typedef 简化写法\n\n这是最常见的写法，尤其在嵌入式中。\n\ntypedef struct {\n    char name[20];\n    int age;\n    float score;\n} Student;\n\nStudent s1; // 不用再写 struct\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 🔹3. 初始化与访问\n\n#include <stdio.h>\n\ntypedef struct {\n    char name[20];\n    int age;\n    float score;\n} Student;\n\nint main() {\n    Student stu1 = {"ZhangSan", 20, 95.5};\n\n    // 访问结构体成员\n    printf("姓名：%s\\n", stu1.name);\n    printf("年龄：%d\\n", stu1.age);\n    printf("成绩：%.1f\\n", stu1.score);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结构体成员访问用 点运算符 .。 如果是指针，则用 箭头运算符 ->：\n\nStudent *p = &stu1;\nprintf("姓名：%s\\n", p->name);\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 🔹4. 结构体嵌套与数组\n\n结构体可以嵌套定义，也可以作为数组使用：\n\ntypedef struct {\n    char name[20];\n    int age;\n} Student;\n\ntypedef struct {\n    Student leader;\n    Student members[3];\n} Group;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 🔹5. 注意点与常见坑\n\n⚠️注意事项                说明\n内存对齐                  结构体的成员可能会因对齐规则而导致内存中有“空洞”。顺序不同会影响大小。\n初始化顺序                 必须按照定义顺序初始化。\n结构体赋值                 同类型结构体可以直接赋值，如 stu2 = stu1;。\n函数传参                  若结构体较大，推荐用指针传递，否则会复制整个结构体。\n与 #pragma pack() 配合   在嵌入式开发中可控制对齐方式以节省空间或匹配寄存器格式。\n\n----------------------------------------\n\n\n# 二、共用体（union）——多种成员共享同一段内存\n\n\n# 🔹1. 定义与特点\n\n共用体（联合体）与结构体类似，但所有成员共用一块内存。\n\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\n\n1\n2\n3\n4\n5\n\n\n特点：\n\n * 所有成员从内存的同一个地址开始；\n * 共用体的大小 = 最大成员的大小；\n * 同一时刻只存储一个成员的有效值。\n\n----------------------------------------\n\n\n# 🔹2. 示例：理解内存共享\n\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nint main() {\n    union Data data;\n\n    data.i = 10;\n    printf("data.i = %d\\n", data.i);\n\n    data.f = 3.14;\n    printf("data.f = %.2f\\n", data.f);\n    printf("data.i = %d\\n", data.i);  // ⚠️现在 data.i 的值已被覆盖！\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n输出可能是：\n\ndata.i = 10\ndata.f = 3.14\ndata.i = 1078523331\n\n\n1\n2\n3\n\n\n这是因为 data.f 覆盖了与 data.i 共享的内存。\n\n----------------------------------------\n\n\n# 🔹3. 常见用途\n\n用途                    说明\n节省内存                  例如在嵌入式系统中，一个数据包可以不同格式解析，共用同一存储区。\n类型重解释（Type Punning）   在驱动或底层通信中，通过 union 把一段字节解释为不同类型数据。\n寄存器映射                 例如 MCU 的控制寄存器常用结构体+共用体混合表示不同位字段。\n\n----------------------------------------\n\n\n# 🔹4. 注意事项\n\n⚠️风险点            说明\n只有一个成员有效         同一时间只能使用最后一次写入的成员。\n类型安全风险           用于类型重解释时需小心不同平台的字节序（Endian）。\n结构体与共用体嵌套要小心对齐   特别是在嵌入式寄存器定义中，需配合 #pragma pack 或手动填充字节。',normalizedContent:'# c语言结构体与共用体\n\n在c语言中，除了基本数据类型（如int、float、char）外，我们还需要描述由多个不同类型组成的复杂数据，比如学生信息、坐标点、寄存器状态等。 这时就要用到两位老朋友——结构体（struct） 和 共用体（union）。\n\n----------------------------------------\n\n\n# 一、结构体（struct）——把不同类型的数据“打包”在一起\n\n\n# 🔹1. 定义方式\n\nstruct student {\n    char name[20];\n    int age;\n    float score;\n};\n\n\n1\n2\n3\n4\n5\n\n\n这定义了一个叫 student 的结构体类型，包含三个成员：name、age、score。 但注意！这样定义还没有创建变量。\n\n\n# 🔹2. 定义变量的几种方式\n\n# ✅ 方法1：先定义类型，再定义变量\n\nstruct student s1;\n\n\n1\n\n\n# ✅ 方法2：定义时直接声明变量\n\nstruct student {\n    char name[20];\n    int age;\n    float score;\n} s1, s2;\n\n\n1\n2\n3\n4\n5\n\n\n# ✅ 方法3：使用 typedef 简化写法\n\n这是最常见的写法，尤其在嵌入式中。\n\ntypedef struct {\n    char name[20];\n    int age;\n    float score;\n} student;\n\nstudent s1; // 不用再写 struct\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 🔹3. 初始化与访问\n\n#include <stdio.h>\n\ntypedef struct {\n    char name[20];\n    int age;\n    float score;\n} student;\n\nint main() {\n    student stu1 = {"zhangsan", 20, 95.5};\n\n    // 访问结构体成员\n    printf("姓名：%s\\n", stu1.name);\n    printf("年龄：%d\\n", stu1.age);\n    printf("成绩：%.1f\\n", stu1.score);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结构体成员访问用 点运算符 .。 如果是指针，则用 箭头运算符 ->：\n\nstudent *p = &stu1;\nprintf("姓名：%s\\n", p->name);\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 🔹4. 结构体嵌套与数组\n\n结构体可以嵌套定义，也可以作为数组使用：\n\ntypedef struct {\n    char name[20];\n    int age;\n} student;\n\ntypedef struct {\n    student leader;\n    student members[3];\n} group;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 🔹5. 注意点与常见坑\n\n⚠️注意事项                说明\n内存对齐                  结构体的成员可能会因对齐规则而导致内存中有“空洞”。顺序不同会影响大小。\n初始化顺序                 必须按照定义顺序初始化。\n结构体赋值                 同类型结构体可以直接赋值，如 stu2 = stu1;。\n函数传参                  若结构体较大，推荐用指针传递，否则会复制整个结构体。\n与 #pragma pack() 配合   在嵌入式开发中可控制对齐方式以节省空间或匹配寄存器格式。\n\n----------------------------------------\n\n\n# 二、共用体（union）——多种成员共享同一段内存\n\n\n# 🔹1. 定义与特点\n\n共用体（联合体）与结构体类似，但所有成员共用一块内存。\n\nunion data {\n    int i;\n    float f;\n    char str[20];\n};\n\n\n1\n2\n3\n4\n5\n\n\n特点：\n\n * 所有成员从内存的同一个地址开始；\n * 共用体的大小 = 最大成员的大小；\n * 同一时刻只存储一个成员的有效值。\n\n----------------------------------------\n\n\n# 🔹2. 示例：理解内存共享\n\n#include <stdio.h>\n\nunion data {\n    int i;\n    float f;\n    char str[20];\n};\n\nint main() {\n    union data data;\n\n    data.i = 10;\n    printf("data.i = %d\\n", data.i);\n\n    data.f = 3.14;\n    printf("data.f = %.2f\\n", data.f);\n    printf("data.i = %d\\n", data.i);  // ⚠️现在 data.i 的值已被覆盖！\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n输出可能是：\n\ndata.i = 10\ndata.f = 3.14\ndata.i = 1078523331\n\n\n1\n2\n3\n\n\n这是因为 data.f 覆盖了与 data.i 共享的内存。\n\n----------------------------------------\n\n\n# 🔹3. 常见用途\n\n用途                    说明\n节省内存                  例如在嵌入式系统中，一个数据包可以不同格式解析，共用同一存储区。\n类型重解释（type punning）   在驱动或底层通信中，通过 union 把一段字节解释为不同类型数据。\n寄存器映射                 例如 mcu 的控制寄存器常用结构体+共用体混合表示不同位字段。\n\n----------------------------------------\n\n\n# 🔹4. 注意事项\n\n⚠️风险点            说明\n只有一个成员有效         同一时间只能使用最后一次写入的成员。\n类型安全风险           用于类型重解释时需小心不同平台的字节序（endian）。\n结构体与共用体嵌套要小心对齐   特别是在嵌入式寄存器定义中，需配合 #pragma pack 或手动填充字节。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"05.C 语言的可变参数",frontmatter:{title:"05.C 语言的可变参数",date:"2025-10-15T23:00:00.000Z",permalink:"/pages/C_05/"},regularPath:"/06.C/05.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0.html",relativePath:"06.C/05.C语言的可变参数.md",key:"v-4edd7f5c",path:"/pages/C_05/",headersStr:null,content:'# C 语言的可变参数\n\n有时我们并不确定将要输入的参数有几个，比如 头文件<stdio.h>中的printf函数，因此，我们就需要使用一个名为可变参数的高级方法\n\n使用可变参数，我们要引用头文件 <stdarg.h>,该文件提供了实现可变参数功能的函数和宏,具体的实现步骤如下：\n\n * 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。\n * 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。\n * 使用 int 参数和 va_start() 宏来初始化 va_list 变量为一个参数列表。宏 va_start() 是在 stdarg.h 头文件中定义的。\n * 使用 va_arg() 宏和 va_list 变量来访问参数列表中的每个项。\n * 使用宏 va_end() 来清理赋予 va_list 变量的内存。\n\n常用的宏有：\n\n * **va_start(ap, last_arg)**：初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。\n * **va_arg(ap, type)**：获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。\n * **va_end(ap)**：结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 NULL。\n\n下面的程序演示了一个实现计算平均值的方法：\n\n#include <stdio.h>\n#include <stdarg.h>  // 使用可变参数要包含这个头文件\n\n// 定义一个函数，求n个数的平均值\ndouble average(int count, ...) {\n    va_list args;     // 定义一个可变参数列表变量\n    double sum = 0.0;\n\n    va_start(args, count);  // 初始化，可变参数从count后面开始取\n\n    for (int i = 0; i < count; i++) \n    {\n        double num = va_arg(args, double);  // 依次取出每个参数（注意类型要匹配）\n        sum += num;\n    }\n\n    va_end(args);  // 结束可变参数的访问\n\n    return sum / count;\n}\n\nint main(void) {\n    double avg1 = average(3, 10.0, 20.0, 30.0);\n    double avg2 = average(5, 1.0, 2.0, 3.0, 4.0, 5.0);\n\n    printf("avg1 = %.2f\\n", avg1);\n    printf("avg2 = %.2f\\n", avg2);\n\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'# c 语言的可变参数\n\n有时我们并不确定将要输入的参数有几个，比如 头文件<stdio.h>中的printf函数，因此，我们就需要使用一个名为可变参数的高级方法\n\n使用可变参数，我们要引用头文件 <stdarg.h>,该文件提供了实现可变参数功能的函数和宏,具体的实现步骤如下：\n\n * 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。\n * 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。\n * 使用 int 参数和 va_start() 宏来初始化 va_list 变量为一个参数列表。宏 va_start() 是在 stdarg.h 头文件中定义的。\n * 使用 va_arg() 宏和 va_list 变量来访问参数列表中的每个项。\n * 使用宏 va_end() 来清理赋予 va_list 变量的内存。\n\n常用的宏有：\n\n * **va_start(ap, last_arg)**：初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。\n * **va_arg(ap, type)**：获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。\n * **va_end(ap)**：结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 null。\n\n下面的程序演示了一个实现计算平均值的方法：\n\n#include <stdio.h>\n#include <stdarg.h>  // 使用可变参数要包含这个头文件\n\n// 定义一个函数，求n个数的平均值\ndouble average(int count, ...) {\n    va_list args;     // 定义一个可变参数列表变量\n    double sum = 0.0;\n\n    va_start(args, count);  // 初始化，可变参数从count后面开始取\n\n    for (int i = 0; i < count; i++) \n    {\n        double num = va_arg(args, double);  // 依次取出每个参数（注意类型要匹配）\n        sum += num;\n    }\n\n    va_end(args);  // 结束可变参数的访问\n\n    return sum / count;\n}\n\nint main(void) {\n    double avg1 = average(3, 10.0, 20.0, 30.0);\n    double avg2 = average(5, 1.0, 2.0, 3.0, 4.0, 5.0);\n\n    printf("avg1 = %.2f\\n", avg1);\n    printf("avg2 = %.2f\\n", avg2);\n\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"02.C语言的输入输出",frontmatter:{title:"02.C语言的输入输出",date:"2025-10-17T22:00:00.000Z",permalink:"/pages/C_02/"},regularPath:"/06.C/02.C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html",relativePath:"06.C/02.C语言的输入输出.md",key:"v-c5ed5e9c",path:"/pages/C_02/",headers:[{level:2,title:"一、C 语言输入输出的本质",slug:"一、c-语言输入输出的本质",normalizedTitle:"一、c 语言输入输出的本质",charIndex:132},{level:2,title:"二、最常用的输入输出函数",slug:"二、最常用的输入输出函数",normalizedTitle:"二、最常用的输入输出函数",charIndex:384},{level:3,title:"1. 输出：printf()",slug:"_1-输出-printf",normalizedTitle:"1. 输出：printf()",charIndex:401},{level:3,title:"2. 输入：scanf()",slug:"_2-输入-scanf",normalizedTitle:"2. 输入：scanf()",charIndex:941},{level:2,title:"三、字符输入输出：单个字符操作",slug:"三、字符输入输出-单个字符操作",normalizedTitle:"三、字符输入输出：单个字符操作",charIndex:1313},{level:2,title:"四、字符串输入输出：整行文本的处理",slug:"四、字符串输入输出-整行文本的处理",normalizedTitle:"四、字符串输入输出：整行文本的处理",charIndex:1646}],headersStr:"一、C 语言输入输出的本质 二、最常用的输入输出函数 1. 输出：printf() 2. 输入：scanf() 三、字符输入输出：单个字符操作 四、字符串输入输出：整行文本的处理",content:'# C语言输入与输出\n\n在学习 C 语言时，“输入与输出”是你和程序交互的第一步。 掌握它不仅能让程序有“生命力”，还能帮你理解数据流、缓冲机制、文件操作等更深层的概念。\n\n----------------------------------------\n\n\n# 一、C 语言输入输出的本质\n\nC 的输入输出（I/O）基于 标准库 stdio.h 提供的函数完成。 所有的 I/O 操作——无论是键盘、屏幕，还是文件——都被抽象为一种叫 流（stream） 的概念。\n\n常见的三种标准流如下：\n\n名称       类型      默认用途\nstdin    输入流     键盘输入\nstdout   输出流     屏幕输出\nstderr   错误输出流   错误信息输出\n\n----------------------------------------\n\n\n# 二、最常用的输入输出函数\n\n\n# 1. 输出：printf()\n\n用于将格式化的文本输出到屏幕。\n\n#include <stdio.h>\n\nint main() {\n    int age = 20;\n    float score = 95.5;\n    printf("年龄：%d\\n成绩：%.1f\\n", age, score);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n格式说明符：\n\n类型      说明           示例\n%d      整型           int a = 5;\n%f      浮点型          float x = 1.23;\n%c      字符           \'A\'\n%s      字符串          "Hello"\n%p      指针地址         printf("%p", ptr);\n%x/%o   十六进制 / 八进制   printf("%x", num);\n\n💡 小技巧：\n\n * %.2f 表示保留两位小数。\n * %5d 表示整数宽度为 5，不足补空格。\n * %-10s 表示字符串左对齐。\n\n----------------------------------------\n\n\n# 2. 输入：scanf()\n\n从键盘读取格式化的数据。\n\n#include <stdio.h>\n\nint main() {\n    int age;\n    char name[20];\n    printf("请输入姓名和年龄：");\n    scanf("%s %d", name, &age);\n    printf("你好，%s，今年 %d 岁。\\n", name, age);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意点：\n\n * 每个输入变量前都要加 & 取地址符（字符串除外）。\n * 输入时，空格或回车会分隔不同的数据。\n * scanf 不擅长读取带空格的字符串，如 张 三 会被截断。\n\n----------------------------------------\n\n\n# 三、字符输入输出：单个字符操作\n\n在某些应用（如命令解析、文件处理）中，你可能需要按字符读写。\n\n函数           作用\ngetchar()    从标准输入读取一个字符\nputchar(c)   输出一个字符到屏幕\n\n示例：\n\n#include <stdio.h>\n\nint main() {\n    char ch;\n    printf("输入一个字符：");\n    ch = getchar();\n    printf("你输入的是：");\n    putchar(ch);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 四、字符串输入输出：整行文本的处理\n\n推荐使用 fgets()。\n\n#include <stdio.h>\n\nint main() {\n    char str[50];\n    printf("请输入一句话：");\n    fgets(str, sizeof(str), stdin);\n    printf("你输入的是：%s", str);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# c语言输入与输出\n\n在学习 c 语言时，“输入与输出”是你和程序交互的第一步。 掌握它不仅能让程序有“生命力”，还能帮你理解数据流、缓冲机制、文件操作等更深层的概念。\n\n----------------------------------------\n\n\n# 一、c 语言输入输出的本质\n\nc 的输入输出（i/o）基于 标准库 stdio.h 提供的函数完成。 所有的 i/o 操作——无论是键盘、屏幕，还是文件——都被抽象为一种叫 流（stream） 的概念。\n\n常见的三种标准流如下：\n\n名称       类型      默认用途\nstdin    输入流     键盘输入\nstdout   输出流     屏幕输出\nstderr   错误输出流   错误信息输出\n\n----------------------------------------\n\n\n# 二、最常用的输入输出函数\n\n\n# 1. 输出：printf()\n\n用于将格式化的文本输出到屏幕。\n\n#include <stdio.h>\n\nint main() {\n    int age = 20;\n    float score = 95.5;\n    printf("年龄：%d\\n成绩：%.1f\\n", age, score);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n格式说明符：\n\n类型      说明           示例\n%d      整型           int a = 5;\n%f      浮点型          float x = 1.23;\n%c      字符           \'a\'\n%s      字符串          "hello"\n%p      指针地址         printf("%p", ptr);\n%x/%o   十六进制 / 八进制   printf("%x", num);\n\n💡 小技巧：\n\n * %.2f 表示保留两位小数。\n * %5d 表示整数宽度为 5，不足补空格。\n * %-10s 表示字符串左对齐。\n\n----------------------------------------\n\n\n# 2. 输入：scanf()\n\n从键盘读取格式化的数据。\n\n#include <stdio.h>\n\nint main() {\n    int age;\n    char name[20];\n    printf("请输入姓名和年龄：");\n    scanf("%s %d", name, &age);\n    printf("你好，%s，今年 %d 岁。\\n", name, age);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意点：\n\n * 每个输入变量前都要加 & 取地址符（字符串除外）。\n * 输入时，空格或回车会分隔不同的数据。\n * scanf 不擅长读取带空格的字符串，如 张 三 会被截断。\n\n----------------------------------------\n\n\n# 三、字符输入输出：单个字符操作\n\n在某些应用（如命令解析、文件处理）中，你可能需要按字符读写。\n\n函数           作用\ngetchar()    从标准输入读取一个字符\nputchar(c)   输出一个字符到屏幕\n\n示例：\n\n#include <stdio.h>\n\nint main() {\n    char ch;\n    printf("输入一个字符：");\n    ch = getchar();\n    printf("你输入的是：");\n    putchar(ch);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 四、字符串输入输出：整行文本的处理\n\n推荐使用 fgets()。\n\n#include <stdio.h>\n\nint main() {\n    char str[50];\n    printf("请输入一句话：");\n    fgets(str, sizeof(str), stdin);\n    printf("你输入的是：%s", str);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"06.C语言动态内存管理",frontmatter:{title:"06.C语言动态内存管理",date:"2025-10-16T10:00:00.000Z",permalink:"/pages/C_06/"},regularPath:"/06.C/06.C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",relativePath:"06.C/06.C语言动态内存管理.md",key:"v-99ec5b4c",path:"/pages/C_06/",headersStr:null,content:'众所周知，C语言可以动态地管理内存，至于，怎么分配，分配多少，这取决于程序员自己的决定。进行内存管理操作时，要引入标准库头文件 <stdlib.h>\n\nC语言提供了如下的几个函数用于优雅地进行内存管理操作：\n\n * void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。\n * **void free(void *address); ** 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。\n * void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。\n * void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。\n\n如下是一个将若干名字保存到动态内存中的例子：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int count;\n    printf("请输入名字的数量: ");\n    scanf("%d", &count);\n\n    // 分配指针数组\n    char **names = malloc(count * sizeof(char *));\n    if (names == NULL) {\n        fprintf(stderr, "内存分配失败！\\n");\n        return 1;\n    }\n\n    // 为每个名字分配空间\n    for (int i = 0; i < count; i++) {\n        char temp[100];\n        printf("请输入第 %d 个名字: ", i + 1);\n        scanf("%s", temp);\n\n        names[i] = malloc(strlen(temp) + 1);\n        if (names[i] == NULL) {\n            fprintf(stderr, "内存分配失败！\\n");\n            return 1;\n        }\n        strcpy(names[i], temp);\n    }\n\n    printf("\\n--- 你输入的名字如下 ---\\n");\n    for (int i = 0; i < count; i++) {\n        printf("%s\\n", names[i]);\n        free(names[i]);  // 释放每个名字的内存\n    }\n\n    free(names);  // 释放指针数组\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n',normalizedContent:'众所周知，c语言可以动态地管理内存，至于，怎么分配，分配多少，这取决于程序员自己的决定。进行内存管理操作时，要引入标准库头文件 <stdlib.h>\n\nc语言提供了如下的几个函数用于优雅地进行内存管理操作：\n\n * void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。\n * **void free(void *address); ** 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。\n * void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。\n * void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。\n\n如下是一个将若干名字保存到动态内存中的例子：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int count;\n    printf("请输入名字的数量: ");\n    scanf("%d", &count);\n\n    // 分配指针数组\n    char **names = malloc(count * sizeof(char *));\n    if (names == null) {\n        fprintf(stderr, "内存分配失败！\\n");\n        return 1;\n    }\n\n    // 为每个名字分配空间\n    for (int i = 0; i < count; i++) {\n        char temp[100];\n        printf("请输入第 %d 个名字: ", i + 1);\n        scanf("%s", temp);\n\n        names[i] = malloc(strlen(temp) + 1);\n        if (names[i] == null) {\n            fprintf(stderr, "内存分配失败！\\n");\n            return 1;\n        }\n        strcpy(names[i], temp);\n    }\n\n    printf("\\n--- 你输入的名字如下 ---\\n");\n    for (int i = 0; i < count; i++) {\n        printf("%s\\n", names[i]);\n        free(names[i]);  // 释放每个名字的内存\n    }\n\n    free(names);  // 释放指针数组\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"08.C语言的位操作",frontmatter:{title:"08.C语言的位操作",date:"2025-10-18T11:00:00.000Z",permalink:"/pages/C_08/"},regularPath:"/06.C/08.C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C.html",relativePath:"06.C/08.C语言的位操作.md",key:"v-67e1f5a6",path:"/pages/C_08/",headers:[{level:2,title:"一、什么是位运算？",slug:"一、什么是位运算",normalizedTitle:"一、什么是位运算？",charIndex:163},{level:2,title:"二、按位运算的基本示例",slug:"二、按位运算的基本示例",normalizedTitle:"二、按位运算的基本示例",charIndex:541},{level:2,title:"三、位运算的常见用途",slug:"三、位运算的常见用途",normalizedTitle:"三、位运算的常见用途",charIndex:1129},{level:3,title:"🔹1. 标志位控制（Flags）",slug:"🔹1-标志位控制-flags",normalizedTitle:"🔹1. 标志位控制（flags）",charIndex:1144},{level:3,title:"🔹2. 高低字节分离与合并",slug:"🔹2-高低字节分离与合并",normalizedTitle:"🔹2. 高低字节分离与合并",charIndex:1647},{level:3,title:"🔹3. 提取或修改某一位",slug:"🔹3-提取或修改某一位",normalizedTitle:"🔹3. 提取或修改某一位",charIndex:2002},{level:3,title:"🔹4. 高级用法：寄存器与协议解析",slug:"🔹4-高级用法-寄存器与协议解析",normalizedTitle:"🔹4. 高级用法：寄存器与协议解析",charIndex:2384}],headersStr:"一、什么是位运算？ 二、按位运算的基本示例 三、位运算的常见用途 🔹1. 标志位控制（Flags） 🔹2. 高低字节分离与合并 🔹3. 提取或修改某一位 🔹4. 高级用法：寄存器与协议解析",content:'# C语言位运算详解：掌握底层的力量\n\n位运算是C语言最具“底层味”的部分之一。 它让你直接操作二进制位，从而实现高效的运算、标志控制、寄存器管理、加密与协议解析等功能。 无论是搞嵌入式、芯片驱动，还是高性能算法，位操作都绕不过去。\n\n----------------------------------------\n\n\n# 一、什么是位运算？\n\nC语言中的位运算是针对整数类型（int、char、short、long）**按**二进制位进行的操作。 这些运算不会改变数据类型，只是改变二进制的比特位。\n\n常见的位运算符如下👇：\n\n运算符   含义     示例       作用说明\n&     按位与    a & b    两位都为1才为1\n|     按位或    按位或      两位有一位为1就为1\n^     按位异或   a ^ b    相同为0，不同为1\n~     按位取反   ~a       0变1，1变0\n<<    左移     a << n   所有位左移n位，右边补0\n>>    右移     a >> n   所有位右移n位（符号位视情况保持）\n\n----------------------------------------\n\n\n# 二、按位运算的基本示例\n\n#include <stdio.h>\n\nint main() {\n    unsigned char a = 0b10101010; // 170\n    unsigned char b = 0b11001100; // 204\n\n    printf("a & b = 0x%X\\n", a & b); // 按位与\n    printf("a | b = 0x%X\\n", a | b); // 按位或\n    printf("a ^ b = 0x%X\\n", a ^ b); // 按位异或\n    printf("~a = 0x%X\\n", ~a);       // 取反\n    printf("a << 1 = 0x%X\\n", a << 1);\n    printf("b >> 2 = 0x%X\\n", b >> 2);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n🧩 输出示例：\n\na & b = 0xA8\na | b = 0xEE\na ^ b = 0x46\n~a = 0x55\na << 1 = 0x54\nb >> 2 = 0x33\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、位运算的常见用途\n\n\n# 🔹1. 标志位控制（Flags）\n\n在嵌入式开发中，常用一个字节或整型变量的各个bit表示不同的开关状态。\n\n#define FLAG_READ  0x01  // 0000 0001\n#define FLAG_WRITE 0x02  // 0000 0010\n#define FLAG_EXEC  0x04  // 0000 0100\n\nunsigned char flag = 0;\n\n// 设置标志\nflag |= FLAG_READ;   // 开启READ\nflag |= FLAG_WRITE;  // 开启WRITE\n\n// 检查标志\nif (flag & FLAG_READ) {\n    printf("Read enabled\\n");\n}\n\n// 清除标志\nflag &= ~FLAG_WRITE; // 关闭WRITE\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 💡技巧： 用 | 设置，用 &~ 清除，用 & 检查，用 ^ 切换。\n\n----------------------------------------\n\n\n# 🔹2. 高低字节分离与合并\n\n位运算是拆分数据最直接的方式。\n\nunsigned short data = 0x1234;\n\nunsigned char high = (data >> 8) & 0xFF;\nunsigned char low  = data & 0xFF;\n\nprintf("高字节: 0x%X, 低字节: 0x%X\\n", high, low);\n\n// 合并\nunsigned short combine = ((unsigned short)high << 8) | low;\nprintf("合并结果: 0x%X\\n", combine);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 🔹3. 提取或修改某一位\n\n我们可以通过位掩码（mask）来操作单个位。\n\nunsigned char x = 0b10110010;\n\n// 取第3位（从0开始）\nint bit3 = (x >> 3) & 1;  // 结果：0\n\n// 设置第2位为1\nx |= (1 << 2);\n\n// 清除第7位\nx &= ~(1 << 7);\n\n// 翻转第0位\nx ^= 1 << 0;\n\nprintf("x = 0b");\nfor (int i = 7; i >= 0; i--)\n    printf("%d", (x >> i) & 1);\nprintf("\\n");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 🔹4. 高级用法：寄存器与协议解析\n\n在硬件寄存器映射中，位运算是基础操作：\n\ntypedef union {\n    struct {\n        unsigned char BIT0 : 1;\n        unsigned char BIT1 : 1;\n        unsigned char MODE : 2;\n        unsigned char ENABLE : 1;\n        unsigned char RESERVED : 3;\n    } bits;\n    unsigned char reg;\n} ControlReg;\n\nint main() {\n    ControlReg ctrl = {0};\n    ctrl.bits.ENABLE = 1;\n    ctrl.bits.MODE = 2;\n\n    printf("寄存器值 = 0x%02X\\n", ctrl.reg);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n输出：\n\n寄存器值 = 0x14\n\n\n1\n\n\n这种写法在STM32、FPGA外围驱动等领域极其常见。 结构体配合位运算可以同时兼顾代码可读性与硬件精度控制。',normalizedContent:'# c语言位运算详解：掌握底层的力量\n\n位运算是c语言最具“底层味”的部分之一。 它让你直接操作二进制位，从而实现高效的运算、标志控制、寄存器管理、加密与协议解析等功能。 无论是搞嵌入式、芯片驱动，还是高性能算法，位操作都绕不过去。\n\n----------------------------------------\n\n\n# 一、什么是位运算？\n\nc语言中的位运算是针对整数类型（int、char、short、long）**按**二进制位进行的操作。 这些运算不会改变数据类型，只是改变二进制的比特位。\n\n常见的位运算符如下👇：\n\n运算符   含义     示例       作用说明\n&     按位与    a & b    两位都为1才为1\n|     按位或    按位或      两位有一位为1就为1\n^     按位异或   a ^ b    相同为0，不同为1\n~     按位取反   ~a       0变1，1变0\n<<    左移     a << n   所有位左移n位，右边补0\n>>    右移     a >> n   所有位右移n位（符号位视情况保持）\n\n----------------------------------------\n\n\n# 二、按位运算的基本示例\n\n#include <stdio.h>\n\nint main() {\n    unsigned char a = 0b10101010; // 170\n    unsigned char b = 0b11001100; // 204\n\n    printf("a & b = 0x%x\\n", a & b); // 按位与\n    printf("a | b = 0x%x\\n", a | b); // 按位或\n    printf("a ^ b = 0x%x\\n", a ^ b); // 按位异或\n    printf("~a = 0x%x\\n", ~a);       // 取反\n    printf("a << 1 = 0x%x\\n", a << 1);\n    printf("b >> 2 = 0x%x\\n", b >> 2);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n🧩 输出示例：\n\na & b = 0xa8\na | b = 0xee\na ^ b = 0x46\n~a = 0x55\na << 1 = 0x54\nb >> 2 = 0x33\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、位运算的常见用途\n\n\n# 🔹1. 标志位控制（flags）\n\n在嵌入式开发中，常用一个字节或整型变量的各个bit表示不同的开关状态。\n\n#define flag_read  0x01  // 0000 0001\n#define flag_write 0x02  // 0000 0010\n#define flag_exec  0x04  // 0000 0100\n\nunsigned char flag = 0;\n\n// 设置标志\nflag |= flag_read;   // 开启read\nflag |= flag_write;  // 开启write\n\n// 检查标志\nif (flag & flag_read) {\n    printf("read enabled\\n");\n}\n\n// 清除标志\nflag &= ~flag_write; // 关闭write\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 💡技巧： 用 | 设置，用 &~ 清除，用 & 检查，用 ^ 切换。\n\n----------------------------------------\n\n\n# 🔹2. 高低字节分离与合并\n\n位运算是拆分数据最直接的方式。\n\nunsigned short data = 0x1234;\n\nunsigned char high = (data >> 8) & 0xff;\nunsigned char low  = data & 0xff;\n\nprintf("高字节: 0x%x, 低字节: 0x%x\\n", high, low);\n\n// 合并\nunsigned short combine = ((unsigned short)high << 8) | low;\nprintf("合并结果: 0x%x\\n", combine);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n----------------------------------------\n\n\n# 🔹3. 提取或修改某一位\n\n我们可以通过位掩码（mask）来操作单个位。\n\nunsigned char x = 0b10110010;\n\n// 取第3位（从0开始）\nint bit3 = (x >> 3) & 1;  // 结果：0\n\n// 设置第2位为1\nx |= (1 << 2);\n\n// 清除第7位\nx &= ~(1 << 7);\n\n// 翻转第0位\nx ^= 1 << 0;\n\nprintf("x = 0b");\nfor (int i = 7; i >= 0; i--)\n    printf("%d", (x >> i) & 1);\nprintf("\\n");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 🔹4. 高级用法：寄存器与协议解析\n\n在硬件寄存器映射中，位运算是基础操作：\n\ntypedef union {\n    struct {\n        unsigned char bit0 : 1;\n        unsigned char bit1 : 1;\n        unsigned char mode : 2;\n        unsigned char enable : 1;\n        unsigned char reserved : 3;\n    } bits;\n    unsigned char reg;\n} controlreg;\n\nint main() {\n    controlreg ctrl = {0};\n    ctrl.bits.enable = 1;\n    ctrl.bits.mode = 2;\n\n    printf("寄存器值 = 0x%02x\\n", ctrl.reg);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n输出：\n\n寄存器值 = 0x14\n\n\n1\n\n\n这种写法在stm32、fpga外围驱动等领域极其常见。 结构体配合位运算可以同时兼顾代码可读性与硬件精度控制。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"07.C语言文件操作",frontmatter:{title:"07.C语言文件操作",date:"2025-10-18T10:00:00.000Z",permalink:"/pages/C_07/"},regularPath:"/06.C/07.C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html",relativePath:"06.C/07.C语言文件操作.md",key:"v-4035c28f",path:"/pages/C_07/",headers:[{level:2,title:"一、文件操作的基本概念与模式",slug:"一、文件操作的基本概念与模式",normalizedTitle:"一、文件操作的基本概念与模式",charIndex:151},{level:3,title:"1. 文件是字节序列（stream of bytes）",slug:"_1-文件是字节序列-stream-of-bytes",normalizedTitle:"1. 文件是字节序列（stream of bytes）",charIndex:170},{level:3,title:"2. 打开 / 关闭文件：fopen() / fclose()",slug:"_2-打开-关闭文件-fopen-fclose",normalizedTitle:"2. 打开 / 关闭文件：fopen() / fclose()",charIndex:320},{level:2,title:"二、文本 I/O：按字符 / 按行 / 格式化写读",slug:"二、文本-i-o-按字符-按行-格式化写读",normalizedTitle:"二、文本 i/o：按字符 / 按行 / 格式化写读",charIndex:955},{level:3,title:"1. 写入字符 / 字符串：fputc(), fputs(), fprintf()",slug:"_1-写入字符-字符串-fputc-fputs-fprintf",normalizedTitle:"1. 写入字符 / 字符串：fputc(), fputs(), fprintf()",charIndex:1006},{level:3,title:"2. 读取字符 / 行 / 格式化读：fgetc(), fgets(), fscanf()",slug:"_2-读取字符-行-格式化读-fgetc-fgets-fscanf",normalizedTitle:"2. 读取字符 / 行 / 格式化读：fgetc(), fgets(), fscanf()",charIndex:1268},{level:3,title:"3. 检测文件结尾、错误",slug:"_3-检测文件结尾、错误",normalizedTitle:"3. 检测文件结尾、错误",charIndex:1601},{level:2,title:"三、二进制 I/O：fread() / fwrite()",slug:"三、二进制-i-o-fread-fwrite",normalizedTitle:"三、二进制 i/o：fread() / fwrite()",charIndex:1781},{level:2,title:"四、定位 / 偏移：fseek(), ftell(), rewind()",slug:"四、定位-偏移-fseek-ftell-rewind",normalizedTitle:"四、定位 / 偏移：fseek(), ftell(), rewind()",charIndex:2236},{level:2,title:"五、典型代码示例",slug:"五、典型代码示例",normalizedTitle:"五、典型代码示例",charIndex:2652},{level:2,title:"六、常见坑点 / 注意事项",slug:"六、常见坑点-注意事项",normalizedTitle:"六、常见坑点 / 注意事项",charIndex:4476}],headersStr:"一、文件操作的基本概念与模式 1. 文件是字节序列（stream of bytes） 2. 打开 / 关闭文件：fopen() / fclose() 二、文本 I/O：按字符 / 按行 / 格式化写读 1. 写入字符 / 字符串：fputc(), fputs(), fprintf() 2. 读取字符 / 行 / 格式化读：fgetc(), fgets(), fscanf() 3. 检测文件结尾、错误 三、二进制 I/O：fread() / fwrite() 四、定位 / 偏移：fseek(), ftell(), rewind() 五、典型代码示例 六、常见坑点 / 注意事项",content:'# C 语言文件操作详解：读写、定位、文本 vs 二进制\n\n在 C 语言里，文件操作是把程序的数据持久化、与外部资源交换的重要方式。 无论你做的是日志、配置、序列化、还是读写二进制协议，都离不开文件 I/O。\n\n----------------------------------------\n\n\n# 一、文件操作的基本概念与模式\n\n\n# 1. 文件是字节序列（stream of bytes）\n\n在 C 里，不论是“文本文件”还是“二进制文件”，在磁盘上都只是字节流。C 标准库把它抽象成 流（stream），每个流都由一个 FILE * 指针来管理。\n\nstdio.h 里定义了关于流、缓冲、EOF、各种读写函数等的标准接口。\n\n\n# 2. 打开 / 关闭文件：fopen() / fclose()\n\nFILE *fopen(const char *filename, const char *mode);\nint fclose(FILE *fp);\n\n\n1\n2\n\n * fopen：给定文件名和打开模式，返回一个 FILE* 流指针；若打开失败，返回 NULL。\n * fclose：关闭文件流、刷新缓冲、释放资源。成功返回 0，失败返回 EOF。\n\n模式     含义（文本模式）            备注\n"r"    只读，文件必须存在           读取模式，从文件头开始\n"w"    只写，若不存在则创建；若存在则清空   写模式会先清空原内容\n"a"    追加写，若不存在则创建         写入总是从文件尾开始\n"r+"   读写模式，文件必须存在         不清空，既可读也可写\n"w+"   读写模式，若已存在则清空        文件存在即被截断\n"a+"   读/追加写               可以读取，也可以一直追加写入\n\n如果是二进制文件，还要在模式里加 b，如 "rb", "wb+" 等。\n\n⚠️ 在 Windows 平台上，若不加 b，写入或读取可能会把 \\n 做成 \\r\\n 或反之等转换。文本 vs 二进制模式的区别在于是否进行换行符的自动转换。\n\n----------------------------------------\n\n\n# 二、文本 I/O：按字符 / 按行 / 格式化写读\n\n这是最容易上手、最常用的一类文件操作。\n\n\n# 1. 写入字符 / 字符串：fputc(), fputs(), fprintf()\n\n * int fputc(int c, FILE *fp);：写一个字符到文件。成功返回写入字符，否则返回 EOF。\n * int fputs(const char *s, FILE *fp);：写一个以 \\0 结尾的字符串（不附加换行符）。成功返回非负值，失败返回 EOF。\n * int fprintf(FILE *fp, const char *format, ...);：类似 printf，带格式化功能，写入到文件流。\n\n\n# 2. 读取字符 / 行 / 格式化读：fgetc(), fgets(), fscanf()\n\n * int fgetc(FILE *fp);：从文件中读取一个字符。返回该字符（以 int 形式），若遇错误或 EOF 返回 EOF\n * char *fgets(char *buf, int n, FILE *fp);：从流读取最多 n-1 个字符，遇换行符或 EOF 停止，最后在字符串后加 \\0。如果读到 EOF 且没有读到字符则返回 NULL。\n * int fscanf(FILE *fp, const char *format, ...);：类似 scanf，按格式从文件中读取数据。遇空格、换行、格式不匹配等会停止。返回成功解析的项数或 EOF。\n\n\n# 3. 检测文件结尾、错误\n\n * int feof(FILE *fp);：检查是否已到文件末尾，若是返回非零。\n * int ferror(FILE *fp);：检测流的错误状态。\n * void clearerr(FILE *fp);：清除流的错误/EOF 标志。\n\n----------------------------------------\n\n\n# 三、二进制 I/O：fread() / fwrite()\n\n当你要以“块”为单位读写内存（如数组、结构体、图像数据、网络协议包等），用文本 I/O 有时不合适，二进制 I/O 更高效、精确。\n\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n\n1\n2\n\n * ptr：内存地址，读入或写出的目标\n * size：单个元素的字节大小\n * nmemb：元素个数\n * 返回值：成功读写的元素数目（不是字节数）\n\n例如，用 fwrite(&obj, sizeof(obj), 1, fp) 把结构体写入文件；用 fread(&obj2, sizeof(obj2), 1, fp) 读回来。\n\n----------------------------------------\n\n\n# 四、定位 / 偏移：fseek(), ftell(), rewind()\n\n有时候你不希望按顺序读写，而是“跳转”到文件某个位置去操作。\n\n * int fseek(FILE *stream, long offset, int whence);：移动文件内部指针\n   * SEEK_SET 从文件头开始\n   * SEEK_CUR 从当前位置\n   * SEEK_END 从文件尾\n * long ftell(FILE *stream);：返回当前文件指针相对于文件开头的偏移（字节数）\n * void rewind(FILE *stream);：等价于 fseek(stream, 0, SEEK_SET)，把指针移到文件头。博客园+1\n\n例如，可以用 fseek(fp, 0, SEEK_END) + ftell() 来测文件大小。\n\n----------------------------------------\n\n\n# 五、典型代码示例\n\n下面是一个综合示例，演示文本读写 + 二进制读写 + 定位操作：\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} Record;\n\nint main() {\n    FILE *fp;\n    // ——————— 写文本 + 写二进制 ———————\n    fp = fopen("data.txt", "w");\n    if (fp == NULL) {\n        perror("打开 data.txt 失败");\n        return 1;\n    }\n    fprintf(fp, "Hello, 文件操作!\\n");\n    fputs("再写一行文本。\\n", fp);\n    fclose(fp);\n\n    fp = fopen("data.bin", "wb");\n    if (fp == NULL) {\n        perror("打开 data.bin 失败");\n        return 1;\n    }\n    Record rec1 = {100, 3.14f};\n    // 把结构体写入二进制文件\n    if (fwrite(&rec1, sizeof(Record), 1, fp) != 1) {\n        perror("fwrite 失败");\n    }\n    fclose(fp);\n\n    // ——————— 读文本文件 ———————\n    fp = fopen("data.txt", "r");\n    if (fp == NULL) {\n        perror("打开 data.txt 失败");\n        return 1;\n    }\n    char buf[128];\n    while (fgets(buf, sizeof(buf), fp) != NULL) {\n        printf("读到一行：%s", buf);\n    }\n    fclose(fp);\n\n    // ——————— 读二进制 + 定位测试 ———————\n    fp = fopen("data.bin", "rb");\n    if (fp == NULL) {\n        perror("打开 data.bin 失败");\n        return 1;\n    }\n    // 找到文件末尾，测大小\n    fseek(fp, 0, SEEK_END);\n    long sz = ftell(fp);\n    printf("data.bin 的大小 = %ld 字节\\n", sz);\n\n    rewind(fp);  // 指针回到头\n    Record rec2;\n    if (fread(&rec2, sizeof(Record), 1, fp) == 1) {\n        printf("读取结构体：id = %d, value = %.2f\\n",\n               rec2.id, rec2.value);\n    } else {\n        perror("fread 失败");\n    }\n    fclose(fp);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n说明要点：\n\n * 我们用 fprintf / fputs 写文本，用 fgets 读文本；\n * 用 fwrite / fread 写/读结构体（二进制）；\n * 用 fseek + ftell 得到文件大小；\n * 用 rewind 重置文件位置。\n\n----------------------------------------\n\n\n# 六、常见坑点 / 注意事项\n\n⚠️ 问题                       说明 / 经验教训\n检查 fopen 返回值                打开失败要马上处理，别拿 NULL 去读写。\n缓冲刷新 / 数据丢失                 写操作最后要 fclose() 或 fflush()，否则缓冲里的数据可能没写到文件上。\n文本 vs 二进制模式差异               在 Windows 上，不加 b 模式可能造成 \\n ↔ \\r\\n 转换。\n结构体二进制可移植性                  结构体的内存布局可能因对齐、字节序（Endian）、编译器差异而不同，不宜在不同平台直接用二进制方式交换结构体。\n不要混用文本和二进制读写                若用文本函数去读写二进制数据可能出错。最好明确一个文件是“纯文本”或“纯二进制”。\nfseek 在追加模式下不总能改变写入位置       如果文件以 append 模式打开（如 "a" 或 "a+"），写入操作仍然可能强制在文件尾。\nftell / fseek 的返回值 / 错误情况   ftell 出错返回 -1L，要检查；fseek 成功返回 0，失败返回非零。\n循环读写判断 EOF                  使用 while (fgets(...) != NULL)、或 while (fread(...) ==\n                            expected_count)，避免用 feof 作为主循环条件。\n文件名 / 路径                    使用完整路径、注意操作系统的路径分隔符（Linux /，Windows \\ 或 /），以及目录是否存在。',normalizedContent:'# c 语言文件操作详解：读写、定位、文本 vs 二进制\n\n在 c 语言里，文件操作是把程序的数据持久化、与外部资源交换的重要方式。 无论你做的是日志、配置、序列化、还是读写二进制协议，都离不开文件 i/o。\n\n----------------------------------------\n\n\n# 一、文件操作的基本概念与模式\n\n\n# 1. 文件是字节序列（stream of bytes）\n\n在 c 里，不论是“文本文件”还是“二进制文件”，在磁盘上都只是字节流。c 标准库把它抽象成 流（stream），每个流都由一个 file * 指针来管理。\n\nstdio.h 里定义了关于流、缓冲、eof、各种读写函数等的标准接口。\n\n\n# 2. 打开 / 关闭文件：fopen() / fclose()\n\nfile *fopen(const char *filename, const char *mode);\nint fclose(file *fp);\n\n\n1\n2\n\n * fopen：给定文件名和打开模式，返回一个 file* 流指针；若打开失败，返回 null。\n * fclose：关闭文件流、刷新缓冲、释放资源。成功返回 0，失败返回 eof。\n\n模式     含义（文本模式）            备注\n"r"    只读，文件必须存在           读取模式，从文件头开始\n"w"    只写，若不存在则创建；若存在则清空   写模式会先清空原内容\n"a"    追加写，若不存在则创建         写入总是从文件尾开始\n"r+"   读写模式，文件必须存在         不清空，既可读也可写\n"w+"   读写模式，若已存在则清空        文件存在即被截断\n"a+"   读/追加写               可以读取，也可以一直追加写入\n\n如果是二进制文件，还要在模式里加 b，如 "rb", "wb+" 等。\n\n⚠️ 在 windows 平台上，若不加 b，写入或读取可能会把 \\n 做成 \\r\\n 或反之等转换。文本 vs 二进制模式的区别在于是否进行换行符的自动转换。\n\n----------------------------------------\n\n\n# 二、文本 i/o：按字符 / 按行 / 格式化写读\n\n这是最容易上手、最常用的一类文件操作。\n\n\n# 1. 写入字符 / 字符串：fputc(), fputs(), fprintf()\n\n * int fputc(int c, file *fp);：写一个字符到文件。成功返回写入字符，否则返回 eof。\n * int fputs(const char *s, file *fp);：写一个以 \\0 结尾的字符串（不附加换行符）。成功返回非负值，失败返回 eof。\n * int fprintf(file *fp, const char *format, ...);：类似 printf，带格式化功能，写入到文件流。\n\n\n# 2. 读取字符 / 行 / 格式化读：fgetc(), fgets(), fscanf()\n\n * int fgetc(file *fp);：从文件中读取一个字符。返回该字符（以 int 形式），若遇错误或 eof 返回 eof\n * char *fgets(char *buf, int n, file *fp);：从流读取最多 n-1 个字符，遇换行符或 eof 停止，最后在字符串后加 \\0。如果读到 eof 且没有读到字符则返回 null。\n * int fscanf(file *fp, const char *format, ...);：类似 scanf，按格式从文件中读取数据。遇空格、换行、格式不匹配等会停止。返回成功解析的项数或 eof。\n\n\n# 3. 检测文件结尾、错误\n\n * int feof(file *fp);：检查是否已到文件末尾，若是返回非零。\n * int ferror(file *fp);：检测流的错误状态。\n * void clearerr(file *fp);：清除流的错误/eof 标志。\n\n----------------------------------------\n\n\n# 三、二进制 i/o：fread() / fwrite()\n\n当你要以“块”为单位读写内存（如数组、结构体、图像数据、网络协议包等），用文本 i/o 有时不合适，二进制 i/o 更高效、精确。\n\nsize_t fread(void *ptr, size_t size, size_t nmemb, file *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, file *stream);\n\n\n1\n2\n\n * ptr：内存地址，读入或写出的目标\n * size：单个元素的字节大小\n * nmemb：元素个数\n * 返回值：成功读写的元素数目（不是字节数）\n\n例如，用 fwrite(&obj, sizeof(obj), 1, fp) 把结构体写入文件；用 fread(&obj2, sizeof(obj2), 1, fp) 读回来。\n\n----------------------------------------\n\n\n# 四、定位 / 偏移：fseek(), ftell(), rewind()\n\n有时候你不希望按顺序读写，而是“跳转”到文件某个位置去操作。\n\n * int fseek(file *stream, long offset, int whence);：移动文件内部指针\n   * seek_set 从文件头开始\n   * seek_cur 从当前位置\n   * seek_end 从文件尾\n * long ftell(file *stream);：返回当前文件指针相对于文件开头的偏移（字节数）\n * void rewind(file *stream);：等价于 fseek(stream, 0, seek_set)，把指针移到文件头。博客园+1\n\n例如，可以用 fseek(fp, 0, seek_end) + ftell() 来测文件大小。\n\n----------------------------------------\n\n\n# 五、典型代码示例\n\n下面是一个综合示例，演示文本读写 + 二进制读写 + 定位操作：\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    float value;\n} record;\n\nint main() {\n    file *fp;\n    // ——————— 写文本 + 写二进制 ———————\n    fp = fopen("data.txt", "w");\n    if (fp == null) {\n        perror("打开 data.txt 失败");\n        return 1;\n    }\n    fprintf(fp, "hello, 文件操作!\\n");\n    fputs("再写一行文本。\\n", fp);\n    fclose(fp);\n\n    fp = fopen("data.bin", "wb");\n    if (fp == null) {\n        perror("打开 data.bin 失败");\n        return 1;\n    }\n    record rec1 = {100, 3.14f};\n    // 把结构体写入二进制文件\n    if (fwrite(&rec1, sizeof(record), 1, fp) != 1) {\n        perror("fwrite 失败");\n    }\n    fclose(fp);\n\n    // ——————— 读文本文件 ———————\n    fp = fopen("data.txt", "r");\n    if (fp == null) {\n        perror("打开 data.txt 失败");\n        return 1;\n    }\n    char buf[128];\n    while (fgets(buf, sizeof(buf), fp) != null) {\n        printf("读到一行：%s", buf);\n    }\n    fclose(fp);\n\n    // ——————— 读二进制 + 定位测试 ———————\n    fp = fopen("data.bin", "rb");\n    if (fp == null) {\n        perror("打开 data.bin 失败");\n        return 1;\n    }\n    // 找到文件末尾，测大小\n    fseek(fp, 0, seek_end);\n    long sz = ftell(fp);\n    printf("data.bin 的大小 = %ld 字节\\n", sz);\n\n    rewind(fp);  // 指针回到头\n    record rec2;\n    if (fread(&rec2, sizeof(record), 1, fp) == 1) {\n        printf("读取结构体：id = %d, value = %.2f\\n",\n               rec2.id, rec2.value);\n    } else {\n        perror("fread 失败");\n    }\n    fclose(fp);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n说明要点：\n\n * 我们用 fprintf / fputs 写文本，用 fgets 读文本；\n * 用 fwrite / fread 写/读结构体（二进制）；\n * 用 fseek + ftell 得到文件大小；\n * 用 rewind 重置文件位置。\n\n----------------------------------------\n\n\n# 六、常见坑点 / 注意事项\n\n⚠️ 问题                       说明 / 经验教训\n检查 fopen 返回值                打开失败要马上处理，别拿 null 去读写。\n缓冲刷新 / 数据丢失                 写操作最后要 fclose() 或 fflush()，否则缓冲里的数据可能没写到文件上。\n文本 vs 二进制模式差异               在 windows 上，不加 b 模式可能造成 \\n ↔ \\r\\n 转换。\n结构体二进制可移植性                  结构体的内存布局可能因对齐、字节序（endian）、编译器差异而不同，不宜在不同平台直接用二进制方式交换结构体。\n不要混用文本和二进制读写                若用文本函数去读写二进制数据可能出错。最好明确一个文件是“纯文本”或“纯二进制”。\nfseek 在追加模式下不总能改变写入位置       如果文件以 append 模式打开（如 "a" 或 "a+"），写入操作仍然可能强制在文件尾。\nftell / fseek 的返回值 / 错误情况   ftell 出错返回 -1l，要检查；fseek 成功返回 0，失败返回非零。\n循环读写判断 eof                  使用 while (fgets(...) != null)、或 while (fread(...) ==\n                            expected_count)，避免用 feof 作为主循环条件。\n文件名 / 路径                    使用完整路径、注意操作系统的路径分隔符（linux /，windows \\ 或 /），以及目录是否存在。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.testBench的编写规范",frontmatter:{title:"01.testBench的编写规范",date:"2025-12-06T10:30:00.000Z",permalink:"/pages/Verilog_20/"},regularPath:"/07.Chip_Verification/1.testBench%E7%9A%84%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83.html",relativePath:"07.Chip_Verification/1.testBench的编写规范.md",key:"v-75a0de9c",path:"/pages/Verilog_20/",headers:[{level:2,title:"一、为什么需要 TestBench？",slug:"一、为什么需要-testbench",normalizedTitle:"一、为什么需要 testbench？",charIndex:37},{level:2,title:"1. timescale",slug:"_1-timescale",normalizedTitle:"1. timescale",charIndex:1335},{level:2,title:"2. 信号声明（TestBench 的输入用 reg，输出用 wire）",slug:"_2-信号声明-testbench-的输入用-reg-输出用-wire",normalizedTitle:"2. 信号声明（testbench 的输入用 reg，输出用 wire）",charIndex:1469},{level:2,title:"3. 实例化被测模块（DUT）",slug:"_3-实例化被测模块-dut",normalizedTitle:"3. 实例化被测模块（dut）",charIndex:1691},{level:2,title:"4. 时钟生成",slug:"_4-时钟生成",normalizedTitle:"4. 时钟生成",charIndex:1873},{level:2,title:"5. 激励序列（给输入信号）",slug:"_5-激励序列-给输入信号",normalizedTitle:"5. 激励序列（给输入信号）",charIndex:2035},{level:2,title:"6. 监控打印（可选，但很有用）",slug:"_6-监控打印-可选-但很有用",normalizedTitle:"6. 监控打印（可选，但很有用）",charIndex:2294},{level:2,title:"① 计数器模块（counter4.v）",slug:"_1-计数器模块-counter4-v",normalizedTitle:"① 计数器模块（counter4.v）",charIndex:2566},{level:2,title:"② TestBench（tb_counter4.v）",slug:"_2-testbench-tb-counter4-v",normalizedTitle:"② testbench（tb_counter4.v）",charIndex:2898}],headersStr:"一、为什么需要 TestBench？ 1. timescale 2. 信号声明（TestBench 的输入用 reg，输出用 wire） 3. 实例化被测模块（DUT） 4. 时钟生成 5. 激励序列（给输入信号） 6. 监控打印（可选，但很有用） ① 计数器模块（counter4.v） ② TestBench（tb_counter4.v）",content:'# Verilog TestBench 入门教程（超适合初学者）\n\n\n# 一、为什么需要 TestBench？\n\n在 FPGA/ASIC 的开发流程中，TestBench 就是用来测试你写的 Verilog 模块的“仿真脚本”。 它的任务很简单：\n\n * 给你的模块 输入信号\n * 观察 输出信号\n * 判断模块行为是否正确（用波形或打印）\n\n不用上板，不用烧录，就能提前把 bug 查出来。\n\n只要你写 RTL，就必须会写 TestBench。\n\n----------------------------------------\n\n\n# 二、TestBench 的基本框架\n\n下面是一份最常见、最基础的 TestBench 模板，初学者只要理解这个结构，就能搞定 90% 的仿真需求。\n\n`timescale 1ns/1ps\n\nmodule tb;\n\n    // ========= 1. 声明信号（输入用 reg，输出用 wire） =========\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // ========= 2. 实例化被测模块 (DUT) =========\n    counter4 dut (\n        .clk  (clk),\n        .rst_n(rst_n),\n        .out  (out)\n    );\n\n    // ========= 3. 时钟生成 =========\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;   // 10ns 一周期\n    end\n\n    // ========= 4. 激励任务（给输入信号） =========\n    initial begin\n        rst_n = 0;       // 上电复位\n        #20;\n        rst_n = 1;       // 释放复位\n\n        // ……后续可以加更多测试序列\n\n        #200 $finish;    // 结束仿真\n    end\n\n    // ========= 5. 可选：监控输出 =========\n    initial begin\n        $monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n----------------------------------------\n\n\n# 三、框架各个部分说明\n\n下面我用最简单、最人话的解释，把每一步讲清楚。\n\n----------------------------------------\n\n\n# 1. timescale\n\n`timescale 1ns/1ps\n\n\n1\n\n\n表示：\n\n * 仿真时间单位：1ns\n * 时间精度：1ps（用于延迟取整）\n\n这是仿真必写项。\n\n----------------------------------------\n\n\n# 2. 信号声明（TestBench 的输入用 reg，输出用 wire）\n\nreg clk;\nreg rst_n;\nwire [3:0] out;\n\n\n1\n2\n3\n\n\n为什么输入用 reg？ 因为 TestBench 自己要给这些信号赋值，赋值只能给 reg。\n\n为什么输出用 wire？ 因为输出是 DUT 驱动的，不是 TestBench 驱动。\n\n----------------------------------------\n\n\n# 3. 实例化被测模块（DUT）\n\ncounter4 dut (\n    .clk  (clk),\n    .rst_n(rst_n),\n    .out  (out)\n);\n\n\n1\n2\n3\n4\n5\n\n\nTestBench 最核心的一步： 把你写的模块“放进测试环境里”。\n\n----------------------------------------\n\n\n# 4. 时钟生成\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n\n1\n2\n3\n4\n\n\n这段代码生成一个周期为 10ns 的时钟。 基本是所有同步逻辑仿真必备。\n\n----------------------------------------\n\n\n# 5. 激励序列（给输入信号）\n\ninitial begin\n    rst_n = 0;\n    #20;\n    rst_n = 1;\n    #200 $finish;\nend\n\n\n1\n2\n3\n4\n5\n6\n\n * 设置输入信号\n * 等待一段时间（用 # 延迟）\n * 继续设置下一组输入信号\n * 最后用 $finish 结束仿真\n\n这块就是“TestBench 的灵魂”：你给它什么输入，它就会在波形中跑出对应行为。\n\n----------------------------------------\n\n\n# 6. 监控打印（可选，但很有用）\n\n$monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n\n\n1\n\n\n波形能看得出来，但有时打印更方便。\n\n----------------------------------------\n\n\n# 四、完整示例：4 位同步计数器 + TestBench\n\n下面来一个真正能跑的例子 —— 从 RTL 到 TestBench，初学者一看就懂。\n\n----------------------------------------\n\n\n# ① 计数器模块（counter4.v）\n\nmodule counter4(\n    input clk,\n    input rst_n,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 0;\n        else\n            out <= out + 1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# ② TestBench（tb_counter4.v）\n\n`timescale 1ns/1ps\n\nmodule tb_counter4;\n\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // 实例化DUT\n    counter4 dut(\n        .clk(clk),\n        .rst_n(rst_n),\n        .out(out)\n    );\n\n    // 时钟\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // 激励\n    initial begin\n        rst_n = 0;\n        #20;\n        rst_n = 1;\n\n        // 运行 16 个计数周期\n        #200;\n\n        $finish;\n    end\n\n    // 监控输出\n    initial begin\n        $monitor("time=%0t  clk=%b  rst_n=%b  out=%d", \n                    $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n\n# 五、波形应该长这样（逻辑上）\n\nrst_n:  _____-----------......\nclk  : _-_-_-_-_-_-_-_-_-_....\nout  : 0000 0001 0010 ... 1111 再回到 0000\n\n\n1\n2\n3\n\n\n只要你看到计数正常累加，就说明 DUT 正常。',normalizedContent:'# verilog testbench 入门教程（超适合初学者）\n\n\n# 一、为什么需要 testbench？\n\n在 fpga/asic 的开发流程中，testbench 就是用来测试你写的 verilog 模块的“仿真脚本”。 它的任务很简单：\n\n * 给你的模块 输入信号\n * 观察 输出信号\n * 判断模块行为是否正确（用波形或打印）\n\n不用上板，不用烧录，就能提前把 bug 查出来。\n\n只要你写 rtl，就必须会写 testbench。\n\n----------------------------------------\n\n\n# 二、testbench 的基本框架\n\n下面是一份最常见、最基础的 testbench 模板，初学者只要理解这个结构，就能搞定 90% 的仿真需求。\n\n`timescale 1ns/1ps\n\nmodule tb;\n\n    // ========= 1. 声明信号（输入用 reg，输出用 wire） =========\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // ========= 2. 实例化被测模块 (dut) =========\n    counter4 dut (\n        .clk  (clk),\n        .rst_n(rst_n),\n        .out  (out)\n    );\n\n    // ========= 3. 时钟生成 =========\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;   // 10ns 一周期\n    end\n\n    // ========= 4. 激励任务（给输入信号） =========\n    initial begin\n        rst_n = 0;       // 上电复位\n        #20;\n        rst_n = 1;       // 释放复位\n\n        // ……后续可以加更多测试序列\n\n        #200 $finish;    // 结束仿真\n    end\n\n    // ========= 5. 可选：监控输出 =========\n    initial begin\n        $monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n----------------------------------------\n\n\n# 三、框架各个部分说明\n\n下面我用最简单、最人话的解释，把每一步讲清楚。\n\n----------------------------------------\n\n\n# 1. timescale\n\n`timescale 1ns/1ps\n\n\n1\n\n\n表示：\n\n * 仿真时间单位：1ns\n * 时间精度：1ps（用于延迟取整）\n\n这是仿真必写项。\n\n----------------------------------------\n\n\n# 2. 信号声明（testbench 的输入用 reg，输出用 wire）\n\nreg clk;\nreg rst_n;\nwire [3:0] out;\n\n\n1\n2\n3\n\n\n为什么输入用 reg？ 因为 testbench 自己要给这些信号赋值，赋值只能给 reg。\n\n为什么输出用 wire？ 因为输出是 dut 驱动的，不是 testbench 驱动。\n\n----------------------------------------\n\n\n# 3. 实例化被测模块（dut）\n\ncounter4 dut (\n    .clk  (clk),\n    .rst_n(rst_n),\n    .out  (out)\n);\n\n\n1\n2\n3\n4\n5\n\n\ntestbench 最核心的一步： 把你写的模块“放进测试环境里”。\n\n----------------------------------------\n\n\n# 4. 时钟生成\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n\n1\n2\n3\n4\n\n\n这段代码生成一个周期为 10ns 的时钟。 基本是所有同步逻辑仿真必备。\n\n----------------------------------------\n\n\n# 5. 激励序列（给输入信号）\n\ninitial begin\n    rst_n = 0;\n    #20;\n    rst_n = 1;\n    #200 $finish;\nend\n\n\n1\n2\n3\n4\n5\n6\n\n * 设置输入信号\n * 等待一段时间（用 # 延迟）\n * 继续设置下一组输入信号\n * 最后用 $finish 结束仿真\n\n这块就是“testbench 的灵魂”：你给它什么输入，它就会在波形中跑出对应行为。\n\n----------------------------------------\n\n\n# 6. 监控打印（可选，但很有用）\n\n$monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n\n\n1\n\n\n波形能看得出来，但有时打印更方便。\n\n----------------------------------------\n\n\n# 四、完整示例：4 位同步计数器 + testbench\n\n下面来一个真正能跑的例子 —— 从 rtl 到 testbench，初学者一看就懂。\n\n----------------------------------------\n\n\n# ① 计数器模块（counter4.v）\n\nmodule counter4(\n    input clk,\n    input rst_n,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 0;\n        else\n            out <= out + 1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# ② testbench（tb_counter4.v）\n\n`timescale 1ns/1ps\n\nmodule tb_counter4;\n\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // 实例化dut\n    counter4 dut(\n        .clk(clk),\n        .rst_n(rst_n),\n        .out(out)\n    );\n\n    // 时钟\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // 激励\n    initial begin\n        rst_n = 0;\n        #20;\n        rst_n = 1;\n\n        // 运行 16 个计数周期\n        #200;\n\n        $finish;\n    end\n\n    // 监控输出\n    initial begin\n        $monitor("time=%0t  clk=%b  rst_n=%b  out=%d", \n                    $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n\n# 五、波形应该长这样（逻辑上）\n\nrst_n:  _____-----------......\nclk  : _-_-_-_-_-_-_-_-_-_....\nout  : 0000 0001 0010 ... 1111 再回到 0000\n\n\n1\n2\n3\n\n\n只要你看到计数正常累加，就说明 dut 正常。',charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-01b5feb6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/12/30, 18:44:23"},{title:"Home",frontmatter:{home:!0,heroImage:"/img/base/LOGO.png",tagline:"系统编程技术博客，积跬步以至千里，致敬每个爱学习的你。",heroText:"原码纪事",actionText:"开始浏览 →",actionLink:"/pages/Notes/",bannerBg:"none",postList:"simple",features:[{title:"博客笔记",details:"带来不一样的你",link:"/pages/Notes/"},{title:"项目",details:"工程速览",link:"/pages/Projects/"},{title:"吐槽",details:"世上本来没有吐槽，只因吐的人多了...",link:"/pages/Teasting/"}]},regularPath:"/",relativePath:"index.md",key:"v-58b44ebe",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/12/30, 18:44:23"},{title:"留言板",frontmatter:{title:"留言板",date:"2025-05-25T18:38:46.000Z",permalink:"/message-board"},regularPath:"/message_board/%E7%95%99%E8%A8%80%E6%9D%BF.html",relativePath:"message_board/留言板.md",key:"v-c9bd4b28",path:"/message-board/",headersStr:null,content:"你可以在这里留下想说的内容。",normalizedContent:"你可以在这里留下想说的内容。",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"},{title:"01.可恶的wifi频段",frontmatter:{title:"01.可恶的wifi频段",date:"2025-09-25T15:00:00.000Z",permalink:"/pages/Teasting_01/"},regularPath:"/teasting/01.%E5%8F%AF%E6%81%B6%E7%9A%84wifi%E9%A2%91%E6%AE%B5.html",relativePath:"teasting/01.可恶的wifi频段.md",key:"v-acf2df8a",path:"/pages/Teasting_01/",headersStr:null,content:"咪的天，为什么我的开发板连不上5G频段的WIFI，还得我自己开热点，我可怜的流量！\n\n",normalizedContent:"咪的天，为什么我的开发板连不上5g频段的wifi，还得我自己开热点，我可怜的流量！\n\n",charsets:{cjk:!0},lastUpdated:"2025/12/30, 18:44:23"}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"博客笔记",link:"/pages/Notes/"},{text:"工程",link:"/pages/Projects/"},{text:"吐槽",link:"/pages/Teasting/"},{text:"留言板",link:"/message-board/"},{text:"我的博客",link:"https://blog.yuanmajishi.top/"}],sidebarDepth:2,logo:"/img/base/bar.png",searchMaxSuggestions:10,lastUpdated:"上次更新",editLinks:!0,docsDir:"docs",docsBranch:"main",editLinkText:"帮助我们改善此页面",searchPlaceholder:"按下 𝑺 搜索",comment:!1,category:!1,tag:!1,sidebar:{"/01.Verilog/":[["01.Verilog HDL基本要素.md","01.Verilog HDL语言基本要素","/pages/Verilog_01/"],["02.Verilog HDL基本数据类型.md","02.Verilog HDL基本数据类型","/pages/Verilog_02/"],["03.Verilog运算符和表达式.md","03.Verilog HDL运算符和表达式","/pages/Verilog_03/"],["04.Verilog HDL的模块.md","04.Verilog HDL模块","/pages/Verilog_04/"],["05.VerilogHDL程序设计和描述方式.md","05.Verilog HDL程序设计和描述方式","/pages/Verilog_05/"],["06.Verilog HDL程序设计思想概览.md","06.Verilog HDL程序设计思想概览","/pages/Verilog_06/"],["07.Verilog HDL组合电路设计的方法.md","07.Verilog HDL组合电路设计的方法","/pages/Verilog_07/"],["08.verilog HDL组合电路之数字加法器.md","08.verilog HDL组合电路之数字加法器","/pages/Verilog_08/"],["09.Verilog HDL组合电路之数据比较器.md","09.Verilog HDL组合电路之数据比较器","/pages/Verilog_09/"],["10.Verilog HDL组合电路之数据选择器.md","10.Verilog HDL组合电路之数据选择器","/pages/Verilog_10/"],["11.verilog HDL组合电路之数字编码器.md","11.verilog HDL组合电路之数字编码器","/pages/Verilog_11/"],["12.verilog HDL组合电路之数字译码器.md","12.verilog HDL组合电路之数字译码器","/pages/Verilog_12/"],["13.verilog HDL组合电路之奇偶校验器.md","13.verilog HDL组合电路之奇偶校验器","/pages/Verilog_13/"],["14.Verilog HDL时序电路设计基础.md","14.Verilog HDL时序电路设计基础","/pages/Verilog_14/"],["15.Verilog HDL时序电路之基本触发器.md","15.Verilog HDL触发器设计","/pages/Verilog_15/"],["16.Verilog HDL时序逻辑电路之计数器.md","16.Verilog HDL计数器设计","/pages/Verilog_16/"],["17.Verilog HDL时序逻辑电路之移位寄存器.md","17.Verilog HDL移位寄存器","/pages/Verilog_17/"],["18.Verilog HDL时序逻辑电路之信号发生器.md","18.Verilog HDL序列信号发生器","/pages/Verilog_18/"],["19.Verilog HDL有限状态机（FSM）设计基础.md","19.Verilog HDL有限状态机（FSM）设计基础","/pages/Verilog_19/"]],catalogue:{},"/02.Dp/":[["01.线性回归.md","01.线性回归","/pages/DP_01/"],["02.SoftMax回归.md","02.SoftMax回归","/pages/DP_02/"],["03.多层感知机.md","03.多层感知机","/pages/DP_03/"],["04.卷积神经网络.md","04.卷积神经网络","/pages/DP_04/"],["05.LeNet.md","05.LeNet","/pages/DP_05/"]],"/03.Rust/":[["00.Rust的基本素养.md","00.Rust的基本素养","/pages/Rust_00/"],["01.Rust的变量与可变性.md","01.Rust的变量与可变性","/pages/Rust_01/"],["02.Rust的数据类型.md","02.Rust的数据类型","/pages/Rust_02/"],["03.Rust的函数和注释.md","03.Rust的函数与注释","/pages/Rust_03/"],["04.Rust的控制流.md","04.Rust的控制流","/pages/Rust_04/"],["05.Rust的所有权概念.md","05.Rust的所有权概念","/pages/Rust_05/"],["06.Rust的引用和借用.md","06.Rust的引用和借用","/pages/Rust_06/"],["07.Rust的Slice类型.md","07.Rust的切片（Slice）","/pages/Rust_07/"],["08.Rust的结构体类型.md","08.Rust的结构体类型","/pages/Rust_08/"],["09.Rust的结构体的打印与调试.md","09.Rust的结构体的打印与调试","/pages/Rust_09/"],["10.Rust的方法.md","10.Rust的方法","/pages/Rust_10/"],["11.Rust的枚举.md","11.Rust的枚举","/pages/Rust_11/"],["12.Rust的match控制流结构.md","12.Rust的match控制流结构","/pages/Rust_12/"],["13.Rust的语法糖-iflet.md","13.Rust 的语法糖 - if let","/pages/Rust_13/"],["14.Rust的模块系统.md","14.Rust的模块系统","/pages/Rust_14/"],["15.Rust的Vector.md","15.Rust的Vector","/pages/Rust_15/"],["16.Rust的String类型基本原理.md","16.Rust的String类型基本原理","/pages/Rust_16/"],["17.Rust的HashMap.md","17.Rust的HashMap","/pages/Rust_17/"]],"/04.Linux/":[["01.Linux 的常用命令.md","01.Linux 的常用命令","/pages/Linux_01/"],["02.nano 编辑器.md","02.nano 编辑器","/pages/Linux_02/"],["03.shell 脚本.md","03.shell 脚本","/pages/Linux_03/"]],"/05.python/":[["01.numpy 模块.md","01.numpy 模块","/pages/Python_01/"],["02.pandas 模块.md","02.pandas 模块","/pages/Python_02/"],["03.matplotlib 模块.md","03.matplotlib 模块","/pages/Python_03/"]],"/06.C/":[["01.C语言的编译过程.md","01.C语言的编译过程","/pages/C_01/"],["02.C语言的输入输出.md","02.C语言的输入输出","/pages/C_02/"],["03.C语言的字符串.md","03.C语言的字符串","/pages/C_03/"],["04.C语言的结构体和共用体.md","04.C语言的结构体和共用体","/pages/C_04/"],["05.C语言的可变参数.md","05.C 语言的可变参数","/pages/C_05/"],["06.C语言动态内存管理.md","06.C语言动态内存管理","/pages/C_06/"],["07.C语言文件操作.md","07.C语言文件操作","/pages/C_07/"],["08.C语言的位操作.md","08.C语言的位操作","/pages/C_08/"]],"/07.Chip_Verification/":[["1.testBench的编写规范.md","01.testBench的编写规范","/pages/Verilog_20/"]],"/teasting/":[["01.可恶的wifi频段.md","01.可恶的wifi频段","/pages/Teasting_01/"]]},pageStyle:"line",updateBar:{showToArticle:!1},author:{name:"猎户f",link:"https://github.com/liehuf/"},social:{icons:[{iconClass:"icon-github",title:"GitHub",link:"https://github.com/liehuf"},{iconClass:"icon-youjian",title:"发邮件",link:"mailto:17715076182@163.com"},{iconClass:"icon-csdn",title:"CSDN",link:"https://blog.csdn.net/liehuf"},{iconClass:"icon-zhihu",title:"知乎",link:"https://www.zhihu.com/people/44-97-46-49"}]},footer:{createYear:2025,copyrightInfo:'liehuf | <a href="https://github.com/liehuf/liehuf-notes/blob/main/LICENSE" target="_blank">MIT License</a>'}}};var cl=t(72),ul=t(128),dl=t(129),pl=t(20);var fl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(pl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(pl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(pl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(pl.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(pl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(ul.default),Gt.component(dl.default);function hl(n){return n.toString().padStart(2,"0")}t(289);Gt.component("FloatingSocialIcons",()=>Promise.resolve().then(t.bind(null,72))),Gt.component("GiscusComment",()=>t.e(5).then(t.bind(null,441))),Gt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,442))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,128))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,129)));t(290);var ml={props:{color:{required:!1,default:"rgb(66, 185, 131)"}}},gl=(t(291),Object(al.a)(ml,(function(){return(0,this._self._c)("div",{staticClass:"spinner",style:{background:this.color}})}),[],!1,null,"1bbcb91a",null).exports);const vl={name:"Mermaid",props:{id:{type:String,required:!1,default:()=>"diagram_"+Date.now()},graph:{type:String,required:!1}},data:()=>({svg:void 0}),computed:{graphData(){return this.graph?this.graph:this.$slots.default[0].text}},render(n){return void 0===this.svg?n("Loading"):n("div",{class:["mermaid-diagram"],domProps:{innerHTML:this.svg,style:"width: 100%"}})},mounted(){t.e(70).then(t.t.bind(null,374,7)).then(n=>{n.initialize({startOnLoad:!0}),n.render(this.id,this.graphData,n=>{this.svg=n})})},components:{Loading:gl}};var bl={name:"Eqn"},_l=Object(al.a)(bl,(function(){return(0,this._self._c)("div",{staticClass:"vuepress-eqn"},[this._t("default")],2)}),[],!1,null,null,null).exports,yl={name:"Eq"},xl=Object(al.a)(yl,(function(){return(0,this._self._c)("span",{staticClass:"vuepress-eq"},[this._t("default")],2)}),[],!1,null,null,null).exports,wl=[({Vue:n,options:e,router:t,siteData:r})=>{n.component("FloatingSocialIcons",cl.default),n.mixin({mounted(){"undefined"!=typeof window&&this.$nextTick(()=>{this.addFloatingSocialIcons()})},methods:{addFloatingSocialIcons(){if(document.querySelector(".floating-social-icons"))return;const e=document.createElement("div");e.id="floating-social-container";const t=new(n.extend(cl.default));t.$mount(),e.appendChild(t.$el),document.body.appendChild(e)}}})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${hl(n.getUTCMonth()+1)}-${hl(n.getUTCDate())} ${hl(n.getUTCHours())}:${hl(n.getUTCMinutes())}:${hl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(fl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n})=>{n.component(vl.name,vl)},({Vue:n})=>{n.component("Eqn",_l),n.component("Eq",xl)}],kl=[];class El extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(El.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:us});var Tl={install(n){const e=new El;n.$vuepress=e,n.prototype.$vuepress=e}};function zl(n,e){return n.options.routes.filter(n=>n.path.toLowerCase()===e.toLowerCase()).length>0}var Cl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ps("pageKey",e),Gt.component(e)||Gt.component(e,ss(e)),Gt.component(e)?n(e):n("")}},Il={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Rl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},$l=(t(292),t(293),Object(al.a)(Rl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Sl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use(Uo),Gt.use(Tl),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ll)),Gt.component("Content",Cl),Gt.component("ContentSlotsDistributor",Il),Gt.component("OutboundLink",$l),Gt.component("ClientOnly",Sl),Gt.component("Layout",ls("Layout")),Gt.component("NotFound",ls("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.0",hash:"889fb16"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ll.routerBase||ll.base,t=new Uo({base:e,mode:"history",fallback:!1,routes:sl,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(zl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";zl(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";zl(n,i)?r(i):zl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(wl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:r,router:t,siteData:ll,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},kl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);