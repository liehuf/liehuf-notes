(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],u=e[2],d=0,p=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(c&&c(e);p.length;)p.shift()();return a.push.apply(a,u||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"e2bf2c87",3:"60eaade5",4:"a8f5cda8",5:"ecc908a0",6:"b26be405",7:"0701bfd8",8:"e2c5cf45",9:"5eb1580a",10:"2b896a4f",11:"9671bed4",12:"6dd44963",13:"cadc9fd8",14:"20aa7c6d",15:"ae728e94",16:"05e6aae6",17:"9bcfd6f2",18:"eca2e313",19:"b2cd9a49",20:"c3aa8387",21:"393603cc",22:"7e530825",23:"5300cb21",24:"7da3683c",25:"edfec696",26:"8bc120fc",27:"20bd8a53",28:"3752bf95",29:"4593e885",30:"84c8a6bf",31:"cc30f8ea",32:"a62fb1dd",33:"04a4c174",34:"f4b015e5",35:"f3669ef2",36:"908931b4",37:"47576913",38:"fe8222f2",39:"c7578485",40:"f33eb4ed",41:"bc5b615c",42:"2467c462",43:"e3e0b2e4",44:"32f759bc",45:"97ddba2a",46:"3567d5f9",47:"5209bad5",48:"29c27605",49:"314ee784",50:"f4677eef",51:"621dfa8a",52:"60649510",53:"2a9026b3",54:"fb608b46",55:"ca7e95a2",56:"bd4972f0",57:"f4f338c3"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(u);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var u=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var u=0;u<s.length;u++)e(s[u]);var c=l;a.push([134,0]),t()}([function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,u="function"==typeof n?n.options:n;if(e&&(u.render=e,u.staticRenderFns=t,u._compiled=!0),r&&(u.functional=!0),a&&(u._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},u._ssrRegister=l):i&&(l=s?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(u.functional){u._injectStyles=l;var c=u.render;u.render=function(n,e){return l.call(e),c(n,e)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:u}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,a=i.call,o=r&&i.bind.bind(a,a);n.exports=r?o:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var r=t(9),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not an object")}},function(n,e,t){"use strict";var r=t(34),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var r=t(11),i=t(4),a=t(149),o=t(5),s=t(1),l=t(90),u=t(131),c=t(91),d=t(0),p=t(10),f=t(17),h=t(92).IteratorPrototype,m=t(7),g=t(26),v=f("toStringTag"),_=TypeError,b=i.Iterator,x=g||!s(b)||b.prototype!==h||!d((function(){b({})})),y=function(){if(a(this,h),l(this)===h)throw new _("Abstract class Iterator not directly constructable")},w=function(n,e){m?u(h,n,{configurable:!0,get:function(){return e},set:function(e){if(o(this),this===h)throw new _("You can't redefine this property");p(this,n)?this[n]=e:c(this,n,e)}}):h[n]=e};p(h,v)||w(v,"Iterator"),!x&&p(h,"constructor")&&h.constructor!==Object||w("constructor",y),y.prototype=h,r({global:!0,constructor:!0,forced:x},{Iterator:y})},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){"use strict";var r=t(3),i=t(33),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){"use strict";var r=t(4),i=t(77).f,a=t(27),o=t(47),s=t(55),l=t(87),u=t(148);n.exports=function(n,e){var t,c,d,p,f,h=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[h]||s(h,{}):r[h]&&r[h].prototype)for(c in e){if(p=e[c],d=n.dontCallGetSet?(f=i(t,c))&&f.value:t[c],!u(m?c:h+(g?".":"#")+c,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),o(t,c,p,n)}}},function(n,e,t){"use strict";var r=t(1),i=t(53),a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(i(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(12),o=t(5),s=t(28),l=t(93),u=t(94),c=t(26),d=t(14),p=t(95),f=t(29),h=!c&&!p("filter",(function(){})),m=!c&&!h&&f("filter",TypeError),g=c||h||m,v=l((function(){for(var n,e,t=this.iterator,r=this.predicate,a=this.next;;){if(n=o(i(a,t)),this.done=!!n.done)return;if(e=n.value,u(t,r,[e,this.counter++],!0))return e}}));r({target:"Iterator",proto:!0,real:!0,forced:g},{filter:function(n){o(this);try{a(n)}catch(n){d(this,"throw",n)}return m?i(m,this,n):new v(s(this),{predicate:n})}})},function(n,e,t){"use strict";var r=t(6),i=t(5),a=t(39);n.exports=function(n,e,t){var o,s;i(n);try{if(!(o=a(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return i(o),t}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(102),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";var r=t(4),i=t(82),a=t(10),o=t(56),s=t(38),l=t(79),u=r.Symbol,c=i("wks"),d=l?u.for||u:u&&u.withoutSetter||o;n.exports=function(n){return a(c,n)||(c[n]=s&&a(u,n)?u[n]:d("Symbol."+n)),c[n]}},function(n,e,t){"use strict";var r=t(7),i=t(83),a=t(85),o=t(5),s=t(78),l=TypeError,u=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=c(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(o(n),e=s(e),o(t),i)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(203),i=t(206);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return u})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return _})),t.d(e,"a",(function(){return x}));t(46),t(8),t(13),t(22),t(21);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function u(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:i,themeConfig:a}=t,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return m(n);const s=o.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?m(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function m(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function _(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return b(e)-b(n)}},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(12),o=t(5),s=t(28),l=t(93),u=t(94),c=t(14),d=t(95),p=t(29),f=t(26),h=!f&&!d("map",(function(){})),m=!f&&!h&&p("map",TypeError),g=f||h||m,v=l((function(){var n=this.iterator,e=o(i(this.next,n));if(!(this.done=!!e.done))return u(n,this.mapper,[e.value,this.counter++],!0)}));r({target:"Iterator",proto:!0,real:!0,forced:g},{map:function(n){o(this);try{a(n)}catch(n){c(this,"throw",n)}return m?i(m,this,n):new v(s(this),{mapper:n})}})},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(48),o=t(12),s=t(5),l=t(28),u=t(14),c=t(29)("forEach",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:c},{forEach:function(n){s(this);try{o(n)}catch(n){u(this,"throw",n)}if(c)return i(c,this,n);var e=l(this),t=0;a(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(3),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){"use strict";var r=t(4),i=t(1),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(7),i=t(18),a=t(35);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=r.Iterator,i=t&&t.prototype,a=i&&i[n],o=!1;if(a)try{a.call({next:function(){return{done:!0}},return:function(){o=!0}},-1)}catch(n){n instanceof e||(o=!1)}if(!o)return a}},function(n,e,t){"use strict";var r=t(146);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(32),i=t(188),a=t(189),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(16).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(50),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(73),i=t(50);n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(80),i=t(0),a=t(4).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r=t(12),i=t(51);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e,t){var r=t(193),i=t(194),a=t(195),o=t(196),s=t(197);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(104);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(19)(Object,"create");n.exports=r},function(n,e,t){var r=t(215);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(70);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),u=l.querySelector(r.barSelector),c=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(u,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,c,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");u(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),c=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),c!=document.body&&u(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function u(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function c(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(11),i=t(33),a=t(30),o=t(179),s=t(180);r({target:"Array",proto:!0,arity:1,forced:t(0)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){"use strict";var r=t(1),i=t(18),a=t(86),o=t(55);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,u=void 0!==s.name?s.name:e;if(r(t)&&a(t,u,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(132),i=t(6),a=t(5),o=t(53),s=t(163),l=t(30),u=t(37),c=t(164),d=t(97),p=t(14),f=TypeError,h=function(n,e){this.stopped=n,this.result=e},m=h.prototype;n.exports=function(n,e,t){var g,v,_,b,x,y,w,k=t&&t.that,T=!(!t||!t.AS_ENTRIES),S=!(!t||!t.IS_RECORD),P=!(!t||!t.IS_ITERATOR),R=!(!t||!t.INTERRUPTED),I=r(e,k),C=function(n){return g&&p(g,"normal"),new h(!0,n)},z=function(n){return T?(a(n),R?I(n[0],n[1],C):I(n[0],n[1])):R?I(n,C):I(n)};if(S)g=n.iterator;else if(P)g=n;else{if(!(v=d(n)))throw new f(o(n)+" is not iterable");if(s(v)){for(_=0,b=l(n);b>_;_++)if((x=z(n[_]))&&u(m,x))return x;return new h(!1)}g=c(n,v)}for(y=S?n.next:g.next;!(w=i(y,g)).done;){try{x=z(w.value)}catch(n){p(g,"throw",n)}if("object"==typeof x&&x&&u(m,x))return x}return new h(!1)}},function(n,e,t){"use strict";var r=t(98),i=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){"use strict";var r=t(51),i=TypeError;n.exports=function(n){if(r(n))throw new i("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(25),i=t(1),a=t(37),o=t(79),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,s(n))}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(26),i=t(4),a=t(55),o=n.exports=i["__core-js_shared__"]||a("__core-js_shared__",{});(o.versions||(o.versions=[])).push({version:"3.48.0",mode:r?"pure":"global",copyright:"© 2013–2025 Denis Pushkarev (zloirock.ru), 2025–2026 CoreJS Company (core-js.io). All rights reserved.",license:"https://github.com/zloirock/core-js/blob/v3.48.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(4),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";var r=t(3),i=0,a=Math.random(),o=r(1.1.toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){"use strict";var r,i,a,o=t(140),s=t(4),l=t(9),u=t(27),c=t(10),d=t(54),p=t(58),f=t(59),h=s.TypeError,m=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new m);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},i=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=p("state");f[v]=!0,r=function(n,e){if(c(n,v))throw new h("Object already initialized");return e.facade=n,u(n,v,e),e},i=function(n){return c(n,v)?n[v]:{}},a=function(n){return c(n,v)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(82),i=t(56),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(24);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){var r=t(187),i=t(23),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(19)(t(16),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(207),i=t(214),a=t(216),o=t(217),s=t(218);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(15),i=t(70),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(31),i=t(23);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);var r={name:"FloatingSocialIcons",data:()=>({qrVisible:{bilibili:!1,wechat:!1}}),methods:{showQR(n){this.qrVisible[n]=!0},hideQR(n){this.qrVisible[n]=!1}}},i=(t(285),t(2)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"floating-social-icons"},[e("div",{staticClass:"social-item",on:{mouseenter:function(e){return n.showQR("bilibili")},mouseleave:function(e){return n.hideQR("bilibili")}}},[e("svg",{staticClass:"social-icon bilibili",attrs:{viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg"}},[e("path",{attrs:{d:"M6.5 4.5C5.7 4.5 5 5.2 5 6v12c0 .8.7 1.5 1.5 1.5h11c.8 0 1.5-.7 1.5-1.5V6c0-.8-.7-1.5-1.5-1.5h-11z",fill:"currentColor"}}),n._v(" "),e("rect",{attrs:{x:"7",y:"7",width:"10",height:"6",rx:"1",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"9.5",cy:"9.5",r:"0.8",fill:"#00a1d6"}}),n._v(" "),e("circle",{attrs:{cx:"14.5",cy:"9.5",r:"0.8",fill:"#00a1d6"}}),n._v(" "),e("path",{attrs:{d:"M10.5 11.5c1 0 2 .5 2.5 1h-5c.5-.5 1.5-1 2.5-1z",fill:"#00a1d6"}}),n._v(" "),e("circle",{attrs:{cx:"8",cy:"3",r:"1",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"16",cy:"3",r:"1",fill:"currentColor"}}),n._v(" "),e("path",{attrs:{d:"M8 4V3M16 4V3",stroke:"currentColor","stroke-width":"1","stroke-linecap":"round"}}),n._v(" "),e("circle",{attrs:{cx:"9",cy:"16",r:"1",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"15",cy:"16",r:"1",fill:"white"}})]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.qrVisible.bilibili,expression:"qrVisible.bilibili"}],staticClass:"qr-dropdown"},[e("img",{attrs:{src:"/img/base/bilibili-qr.png",alt:"B站二维码"}}),n._v(" "),e("p",[n._v("欢迎关注小破站")])])]),n._v(" "),e("div",{staticClass:"social-item",on:{mouseenter:function(e){return n.showQR("wechat")},mouseleave:function(e){return n.hideQR("wechat")}}},[e("svg",{staticClass:"social-icon wechat",attrs:{viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg"}},[e("path",{attrs:{d:"M8.5 5C5.5 5 3 7.2 3 10c0 1.5.7 2.8 2 3.7L4.5 16l2.3-1.2c.6.2 1.2.2 1.8.2.2 0 .4 0 .6-.1-.1-.4-.2-.8-.2-1.2 0-2.8 2.5-5 5.5-5 .2 0 .4 0 .6.1C14.5 6.7 11.8 5 8.5 5z",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"6.5",cy:"9.5",r:"0.8",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"10.5",cy:"9.5",r:"0.8",fill:"white"}}),n._v(" "),e("path",{attrs:{d:"M14.5 9.5c-2.5 0-4.5 1.7-4.5 3.8s2 3.8 4.5 3.8c.5 0 1-.1 1.4-.3L17.5 18l-.4-1.2c1-.7 1.6-1.7 1.6-2.8 0-2.1-2-3.8-4.5-3.8z",fill:"currentColor"}}),n._v(" "),e("circle",{attrs:{cx:"13",cy:"12.5",r:"0.5",fill:"white"}}),n._v(" "),e("circle",{attrs:{cx:"16",cy:"12.5",r:"0.5",fill:"white"}})]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.qrVisible.wechat,expression:"qrVisible.wechat"}],staticClass:"qr-dropdown"},[e("img",{attrs:{src:"/img/base/wechat-qr.png",alt:"微信公众号二维码"}}),n._v(" "),e("p",[n._v("欢迎关注公众号")])])])])}),[],!1,null,"cb9e887a",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(3),i=t(0),a=t(24),o=Object,s=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"===a(n)?s(n,""):o(n)}:o},function(n,e,t){"use strict";var r,i=t(5),a=t(151),o=t(60),s=t(59),l=t(153),u=t(84),c=t(58),d=c("IE_PROTO"),p=function(){},f=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},m=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;m="undefined"!=typeof document?document.domain&&r?h(r):((e=u("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):h(r);for(var t=o.length;t--;)delete m.prototype[o[t]];return m()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[d]=n):t=m(),void 0===e?t:a.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,u=s||l||Function("return this")(),c=Object.prototype.toString,d=Math.max,p=Math.min,f=function(){return u.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,u=0,c=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function _(e){var t=r,a=i;return r=i=void 0,u=e,o=n.apply(a,t)}function b(n){return u=n,s=setTimeout(y,e),c?_(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-u>=a}function y(){var n=f();if(x(n))return w(n);s=setTimeout(y,function(n){var t=e-(n-l);return g?p(t,a-(n-u)):t}(n))}function w(n){return s=void 0,v&&r?_(n):(r=i=void 0,o)}function k(){var n=f(),t=x(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return b(l);if(g)return s=setTimeout(y,e),_(l)}return void 0===s&&(s=setTimeout(y,e)),o}return e=m(e)||0,h(t)&&(c=!!t.leading,a=(g="maxWait"in t)?d(m(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),k.cancel=function(){void 0!==s&&clearTimeout(s),u=0,r=l=i=s=void 0},k.flush=function(){return void 0===s?o:w(f())},k}},function(n,e,t){"use strict";var r=t(7),i=t(6),a=t(135),o=t(35),s=t(36),l=t(78),u=t(10),c=t(83),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),c)try{return d(n,e)}catch(n){}if(u(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){"use strict";var r=t(136),i=t(52);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){"use strict";var r=t(38);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r,i,a=t(4),o=t(81),s=a.process,l=a.Deno,u=s&&s.versions||l&&l.version,c=u&&u.v8;c&&(i=(r=c.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){"use strict";var r=t(4).navigator,i=r&&r.userAgent;n.exports=i?String(i):""},function(n,e,t){"use strict";var r=t(54);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";var r=t(7),i=t(0),a=t(84);n.exports=!r&&!i((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(4),i=t(9),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){"use strict";var r=t(7),i=t(0);n.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(3),i=t(0),a=t(1),o=t(10),s=t(7),l=t(138).CONFIGURABLE,u=t(139),c=t(57),d=c.enforce,p=c.get,f=String,h=Object.defineProperty,m=r("".slice),g=r("".replace),v=r([].join),_=s&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),b=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===m(f(e),0,7)&&(e="["+g(f(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),_&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return o(r,"source")||(r.source=v(b,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return a(this)&&p(this).source||u(this)}),"toString")},function(n,e,t){"use strict";var r=t(10),i=t(141),a=t(77),o=t(18);n.exports=function(n,e,t){for(var s=i(e),l=o.f,u=a.f,c=0;c<s.length;c++){var d=s[c];r(n,d)||t&&r(t,d)||l(n,d,u(e,d))}}},function(n,e,t){"use strict";var r=t(3),i=t(10),a=t(36),o=t(143).indexOf,s=t(59),l=r([].push);n.exports=function(n,e){var t,r=a(n),u=0,c=[];for(t in r)!i(s,t)&&i(r,t)&&l(c,t);for(;e.length>u;)i(r,t=e[u++])&&(~o(c,t)||l(c,t));return c}},function(n,e,t){"use strict";var r=t(145);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(10),i=t(1),a=t(33),o=t(58),s=t(150),l=o("IE_PROTO"),u=Object,c=u.prototype;n.exports=s?u.getPrototypeOf:function(n){var e=a(n);if(r(e,l))return e[l];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof u?c:null}},function(n,e,t){"use strict";var r=t(7),i=t(18),a=t(35);n.exports=function(n,e,t){r?i.f(n,e,a(0,t)):n[e]=t}},function(n,e,t){"use strict";var r,i,a,o=t(0),s=t(1),l=t(9),u=t(74),c=t(90),d=t(47),p=t(17),f=t(26),h=p("iterator"),m=!1;[].keys&&("next"in(a=[].keys())?(i=c(c(a)))!==Object.prototype&&(r=i):m=!0),!l(r)||o((function(){var n={};return r[h].call(n)!==n}))?r={}:f&&(r=u(r)),s(r[h])||d(r,h,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){"use strict";var r=t(6),i=t(74),a=t(27),o=t(154),s=t(17),l=t(57),u=t(39),c=t(92).IteratorPrototype,d=t(155),p=t(14),f=t(156),h=s("toStringTag"),m=l.set,g=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return o(i(c),{next:function(){var t=e(this);if(n)return t.nextHandler();if(t.done)return d(void 0,!0);try{var r=t.nextHandler();return t.returnHandlerResult?r:d(r,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),i=t.iterator;if(t.done=!0,n){var a=u(i,"return");return a?r(a,i):d(void 0,!0)}if(t.inner)try{p(t.inner.iterator,"normal")}catch(n){return p(i,"throw",n)}if(t.openIters)try{f(t.openIters,"normal")}catch(n){return p(i,"throw",n)}return i&&p(i,"normal"),d(void 0,!0)}})},v=g(!0),_=g(!1);a(_,h,"Iterator Helper"),n.exports=function(n,e,t){var r=function(r,i){i?(i.iterator=r.iterator,i.next=r.next):i=r,i.type=e?"WrapForValidIterator":"IteratorHelper",i.returnHandlerResult=!!t,i.nextHandler=n,i.counter=0,i.done=!1,m(this,i)};return r.prototype=e?v:_,r}},function(n,e,t){"use strict";var r=t(5),i=t(14);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";n.exports=function(n,e){var t="function"==typeof Iterator&&Iterator.prototype[n];if(t)try{t.call({next:null},e).next()}catch(n){return!0}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var r=t(98),i=t(39),a=t(51),o=t(96),s=t(17)("iterator");n.exports=function(n){if(!a(n))return i(n,s)||i(n,"@@iterator")||o[r(n)]}},function(n,e,t){"use strict";var r=t(165),i=t(1),a=t(24),o=t(17)("toStringTag"),s=Object,l="Arguments"===a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?a(e):"Object"===(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r=t(169),i=t(9),a=t(50),o=t(170);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),i(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e,t){"use strict";var r=t(3),i=t(10),a=SyntaxError,o=parseInt,s=String.fromCharCode,l=r("".charAt),u=r("".slice),c=r(/./.exec),d={'\\"':'"',"\\\\":"\\","\\/":"/","\\b":"\b","\\f":"\f","\\n":"\n","\\r":"\r","\\t":"\t"},p=/^[\da-f]{4}$/i,f=/^[\u0000-\u001F]$/;n.exports=function(n,e){for(var t=!0,r="";e<n.length;){var h=l(n,e);if("\\"===h){var m=u(n,e,e+2);if(i(d,m))r+=d[m],e+=2;else{if("\\u"!==m)throw new a('Unknown escape sequence: "'+m+'"');var g=u(n,e+=2,e+4);if(!c(p,g))throw new a("Bad Unicode escape at: "+e);r+=s(o(g,16)),e+=4}}else{if('"'===h){t=!1,e++;break}if(c(f,h))throw new a("Bad control character in string literal at: "+e);r+=h,e++}}if(t)throw new a("Unterminated string at: "+e);return{value:r,end:e}}},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(40),i=t(198),a=t(199),o=t(200),s=t(201),l=t(202);function u(n){var e=this.__data__=new r(n);this.size=e.size}u.prototype.clear=i,u.prototype.delete=a,u.prototype.get=o,u.prototype.has=s,u.prototype.set=l,n.exports=u},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(31),i=t(65);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(219),i=t(23);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(109),i=t(222),a=t(110);n.exports=function(n,e,t,o,s,l){var u=1&t,c=n.length,d=e.length;if(c!=d&&!(u&&d>c))return!1;var p=l.get(n),f=l.get(e);if(p&&f)return p==e&&f==n;var h=-1,m=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<c;){var v=n[h],_=e[h];if(o)var b=u?o(_,v,h,e,n,l):o(v,_,h,n,e,l);if(void 0!==b){if(b)continue;m=!1;break}if(g){if(!i(e,(function(n,e){if(!a(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){m=!1;break}}else if(v!==_&&!s(v,_,t,o,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(66),i=t(220),a=t(221);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(232),i=t(238),a=t(115);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(16),i=t(234),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(75)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(235),i=t(236),a=t(237),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(105),i=t(68);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(19)(t(16),"Set");n.exports=r},function(n,e,t){var r=t(65);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(120),i=t(44);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(15),i=t(69),a=t(249),o=t(252);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(185),i=t(190),a=t(261),o=t(269),s=t(278),l=t(133),u=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=u},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(286),t(2)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(8),t(13),t(22),t(21);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(287),t(2)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(11),i=t(6),a=t(48),o=t(12),s=t(5),l=t(28),u=t(14),c=t(29)("some",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:c},{some:function(n){s(this);try{o(n)}catch(n){u(this,"throw",n)}if(c)return i(c,this,n);var e=l(this),t=0;return a(e,(function(e,r){if(n(e,t++))return r()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){"use strict";var r=t(86),i=t(18);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){"use strict";var r=t(162),i=t(12),a=t(34),o=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(293)},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(6),i=t(9),a=t(52),o=t(39),s=t(137),l=t(17),u=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,l=o(n,c);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||a(t))return t;throw new u("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";var r=t(6),i=t(1),a=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!a(s=r(t,n)))return s;if(i(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!a(s=r(t,n)))return s;throw new o("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(7),i=t(10),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,u=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:u}},function(n,e,t){"use strict";var r=t(3),i=t(1),a=t(54),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){"use strict";var r=t(4),i=t(1),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){"use strict";var r=t(25),i=t(3),a=t(142),o=t(147),s=t(5),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(88),i=t(60).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(36),i=t(144),a=t(30),o=function(n){return function(e,t,o){var s=r(e),l=a(s);if(0===l)return!n&&-1;var u,c=i(o,l);if(n&&t!=t){for(;l>c;)if((u=s[c++])!=u)return!0}else for(;l>c;c++)if((n||c in s)&&s[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){"use strict";var r=t(89),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:r)(e)}},function(n,e,t){"use strict";var r=t(89),i=Math.min;n.exports=function(n){var e=r(n);return e>0?i(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(0),i=t(1),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t===c||t!==u&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},u=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var r=t(37),i=TypeError;n.exports=function(n,e){if(r(e,n))return n;throw new i("Incorrect invocation")}},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var r=t(7),i=t(85),a=t(18),o=t(5),s=t(36),l=t(152);e.f=r&&!i?Object.defineProperties:function(n,e){o(n);for(var t,r=s(e),i=l(e),u=i.length,c=0;u>c;)a.f(n,t=i[c++],r[t]);return n}},function(n,e,t){"use strict";var r=t(88),i=t(60);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(25);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(47);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var r=t(14);n.exports=function(n,e,t){for(var i=n.length-1;i>=0;i--)if(void 0!==n[i])try{t=r(n[i].iterator,e,t)}catch(n){e="throw",t=n}if("throw"===e)throw t;return t}},function(n,e,t){"use strict";var r=t(11),i=t(158).left,a=t(159),o=t(80);r({target:"Array",proto:!0,forced:!t(160)&&o>79&&o<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(12),i=t(33),a=t(73),o=t(30),s=TypeError,l="Reduce of empty array with no initial value",u=function(n){return function(e,t,u,c){var d=i(e),p=a(d),f=o(d);if(r(t),0===f&&u<2)throw new s(l);var h=n?f-1:0,m=n?-1:1;if(u<2)for(;;){if(h in p){c=p[h],h+=m;break}if(h+=m,n?h<0:f<=h)throw new s(l)}for(;n?h>=0:f>h;h+=m)h in p&&(c=t(c,p[h],h,d));return c}};n.exports={left:u(!1),right:u(!0)}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(161);n.exports="NODE"===r},function(n,e,t){"use strict";var r=t(4),i=t(81),a=t(24),o=function(n){return i.slice(0,n.length)===n};n.exports=o("Bun/")?"BUN":o("Cloudflare-Workers")?"CLOUDFLARE":o("Deno/")?"DENO":o("Node.js/")?"NODE":r.Bun&&"string"==typeof Bun.version?"BUN":r.Deno&&"object"==typeof Deno.version?"DENO":"process"===a(r.process)?"NODE":r.window&&r.document?"BROWSER":"REST"},function(n,e,t){"use strict";var r=t(24),i=t(3);n.exports=function(n){if("Function"===r(n))return i(n)}},function(n,e,t){"use strict";var r=t(17),i=t(96),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,e,t){"use strict";var r=t(6),i=t(12),a=t(5),o=t(53),s=t(97),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return a(r(t,n));throw new l(o(n)+" is not iterable")}},function(n,e,t){"use strict";var r={};r[t(17)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(11),i=t(48),a=t(12),o=t(5),s=t(28),l=t(14),u=t(29),c=t(61),d=t(0),p=TypeError,f=d((function(){[].keys().reduce((function(){}),void 0)})),h=!f&&u("reduce",p);r({target:"Iterator",proto:!0,real:!0,forced:f||h},{reduce:function(n){o(this);try{a(n)}catch(n){l(this,"throw",n)}var e=arguments.length<2,t=e?void 0:arguments[1];if(h)return c(h,this,e?[n]:[n,t]);var r=s(this),u=0;if(i(r,(function(r){e?(e=!1,t=r):t=n(t,r,u),u++}),{IS_RECORD:!0}),e)throw new p("Reduce of empty iterator with no initial value");return t}})},function(n,e,t){"use strict";var r=t(11),i=t(4),a=t(61),o=t(168),s=i.WebAssembly,l=7!==new Error("e",{cause:7}).cause,u=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};u("Error",(function(n){return function(e){return a(n,this,arguments)}})),u("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),u("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),u("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),u("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),u("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),u("URIError",(function(n){return function(e){return a(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(25),i=t(10),a=t(27),o=t(37),s=t(99),l=t(87),u=t(172),c=t(173),d=t(174),p=t(175),f=t(176),h=t(7),m=t(26);n.exports=function(n,e,t,g){var v=g?2:1,_=n.split("."),b=_[_.length-1],x=r.apply(null,_);if(x){var y=x.prototype;if(!m&&i(y,"cause")&&delete y.cause,!t)return x;var w=r("Error"),k=e((function(n,e){var t=d(g?e:n,void 0),r=g?new x(n):new x;return void 0!==t&&a(r,"message",t),f(r,k,r.stack,2),this&&o(y,this)&&c(r,this,k),arguments.length>v&&p(r,arguments[v]),r}));if(k.prototype=y,"Error"!==b?s?s(k,w):l(k,w,{name:!0}):h&&"stackTraceLimit"in x&&(u(k,x,"stackTraceLimit"),u(k,x,"prepareStackTrace")),l(k,x),!m)try{y.name!==b&&a(y,"name",b),y.constructor=k}catch(n){}return k}}},function(n,e,t){"use strict";var r=t(3),i=t(12);n.exports=function(n,e,t){try{return r(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(171),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(9);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(18).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(9),a=t(99);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){"use strict";var r=t(49);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(9),i=t(27);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(27),i=t(177),a=t(178),o=Error.captureStackTrace;n.exports=function(n,e,t,s){a&&(o?o(n,e):r(n,"stack",i(t,s)))}},function(n,e,t){"use strict";var r=t(3),i=Error,a=r("".replace),o=String(new i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){"use strict";var r=t(0),i=t(35);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(7),i=t(62),a=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!o(n,"length").writable)throw new a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var r=t(11),i=t(25),a=t(61),o=t(6),s=t(3),l=t(0),u=t(62),c=t(1),d=t(182),p=t(52),f=t(24),h=t(49),m=t(183),g=t(100),v=t(56),_=t(38),b=t(184),x=String,y=i("JSON","stringify"),w=s(/./.exec),k=s("".charAt),T=s("".charCodeAt),S=s("".replace),P=s("".slice),R=s([].push),I=s(1.1.toString),C=/[\uD800-\uDFFF]/g,z=/^[\uD800-\uDBFF]$/,A=/^[\uDC00-\uDFFF]$/,L=v(),E=L.length,O=!_||l((function(){var n=i("Symbol")("stringify detection");return"[null]"!==y([n])||"{}"!==y({a:n})||"{}"!==y(Object(n))})),N=l((function(){return'"\\udf06\\ud834"'!==y("\udf06\ud834")||'"\\udead"'!==y("\udead")})),$=O?function(n,e){var t=m(arguments),r=D(e);if(c(r)||void 0!==n&&!p(n))return t[1]=function(n,e){if(c(r)&&(e=o(r,this,x(n),e)),!p(e))return e},a(y,null,t)}:y,j=function(n,e,t){var r=k(t,e-1),i=k(t,e+1);return w(z,n)&&!w(A,i)||w(A,n)&&!w(z,r)?"\\u"+I(T(n,0),16):n},D=function(n){if(c(n))return n;if(u(n)){for(var e=n.length,t=[],r=0;r<e;r++){var i=n[r];"string"==typeof i?R(t,i):"number"!=typeof i&&"Number"!==f(i)&&"String"!==f(i)||R(t,h(i))}var a=t.length,o=!0;return function(n,e){if(o)return o=!1,e;if(u(this))return e;for(var r=0;r<a;r++)if(t[r]===n)return e}}};y&&r({target:"JSON",stat:!0,arity:3,forced:O||N||!b},{stringify:function(n,e,t){var r=D(e),i=[],a=$(n,(function(n,e){var t=c(r)?o(r,this,x(n),e):e;return!b&&d(t)?L+(R(i,t.rawJSON)-1):t}),t);if("string"!=typeof a)return a;if(N&&(a=S(a,C,j)),b)return a;for(var s="",l=a.length,u=0;u<l;u++){var p=k(a,u);if('"'===p){var f=g(a,++u).end-1,h=P(a,u,f);s+=P(h,0,E)===L?i[P(h,E)]:'"'+h+'"',u=f}else s+=p}return s}})},function(n,e,t){"use strict";var r=t(9),i=t(57).get;n.exports=function(n){if(!r(n))return!1;var e=i(n);return!!e&&"RawJSON"===e.type}},function(n,e,t){"use strict";var r=t(3);n.exports=r([].slice)},function(n,e,t){"use strict";var r=t(0);n.exports=!r((function(){var n=JSON.rawJSON("9007199254740993");return!JSON.isRawJSON(n)||"9007199254740993"!==JSON.stringify(n)}))},function(n,e,t){var r=t(101),i=t(186);n.exports=function n(e,t,a,o,s){var l=-1,u=e.length;for(a||(a=i),s||(s=[]);++l<u;){var c=e[l];t>0&&a(c)?t>1?n(c,t-1,a,o,s):r(s,c):o||(s[s.length]=c)}return s}},function(n,e,t){var r=t(32),i=t(63),a=t(15),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(31),i=t(23);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(32),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(191),i=t(247),a=t(71),o=t(15),s=t(258);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(192),i=t(246),a=t(118);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(103),i=t(107);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var u=t[o];if(l&&u[2]?u[1]!==n[u[0]]:!(u[0]in n))return!1}for(;++o<s;){var c=(u=t[o])[0],d=n[c],p=u[1];if(l&&u[2]){if(void 0===d&&!(c in n))return!1}else{var f=new r;if(a)var h=a(d,p,c,n,e,f);if(!(void 0===h?i(p,d,3,a,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(41),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(41);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(41);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(41);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(40);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(40),i=t(64),a=t(66);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(105),i=t(204),a=t(65),o=t(106),s=/^\[object .+?Constructor\]$/,l=Function.prototype,u=Object.prototype,c=l.toString,d=u.hasOwnProperty,p=RegExp("^"+c.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:s).test(o(n))}},function(n,e,t){var r,i=t(205),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(16)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(208),i=t(40),a=t(64);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(209),i=t(210),a=t(211),o=t(212),s=t(213);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(42);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(42);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(43);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(43);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(103),i=t(108),a=t(223),o=t(226),s=t(242),l=t(15),u=t(112),c=t(114),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,m){var g=l(n),v=l(e),_=g?"[object Array]":s(n),b=v?"[object Array]":s(e),x=(_="[object Arguments]"==_?d:_)==d,y=(b="[object Arguments]"==b?d:b)==d,w=_==b;if(w&&u(n)){if(!u(e))return!1;g=!0,x=!1}if(w&&!x)return m||(m=new r),g||c(n)?i(n,e,t,f,h,m):a(n,e,_,t,f,h,m);if(!(1&t)){var k=x&&p.call(n,"__wrapped__"),T=y&&p.call(e,"__wrapped__");if(k||T){var S=k?n.value():n,P=T?e.value():e;return m||(m=new r),h(S,P,t,f,m)}}return!!w&&(m||(m=new r),o(n,e,t,f,h,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(32),i=t(224),a=t(104),o=t(108),s=t(225),l=t(67),u=r?r.prototype:void 0,c=u?u.valueOf:void 0;n.exports=function(n,e,t,r,u,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var m=p.get(n);if(m)return m==e;r|=2,p.set(n,e);var g=o(f(n),f(e),r,u,d,p);return p.delete(n),g;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var r=t(16).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(227),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,u=r(n),c=u.length;if(c!=r(e).length&&!l)return!1;for(var d=c;d--;){var p=u[d];if(!(l?p in e:i.call(e,p)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var m=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<c;){var v=n[p=u[d]],_=e[p];if(a)var b=l?a(_,v,p,e,n,s):a(v,_,p,n,e,s);if(!(void 0===b?v===_||o(v,_,t,a,s):b)){m=!1;break}g||(g="constructor"==p)}if(m&&!g){var x=n.constructor,y=e.constructor;x==y||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof y&&y instanceof y||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(228),i=t(229),a=t(111);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(101),i=t(15);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(230),i=t(231),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(233),i=t(63),a=t(15),o=t(112),s=t(113),l=t(114),u=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),c=!t&&i(n),d=!t&&!c&&o(n),p=!t&&!c&&!d&&l(n),f=t||c||d||p,h=f?r(n.length,String):[],m=h.length;for(var g in n)!e&&!u.call(n,g)||f&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,m))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(31),i=t(68),a=t(23),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(102),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(75)(n))},function(n,e,t){var r=t(239),i=t(240),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(241)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(243),i=t(64),a=t(244),o=t(116),s=t(245),l=t(31),u=t(106),c=u(r),d=u(i),p=u(a),f=u(o),h=u(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||a&&"[object Promise]"!=m(a.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?u(t):"";if(r)switch(r){case c:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(19)(t(16),"DataView");n.exports=r},function(n,e,t){var r=t(19)(t(16),"Promise");n.exports=r},function(n,e,t){var r=t(19)(t(16),"WeakMap");n.exports=r},function(n,e,t){var r=t(117),i=t(111);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(107),i=t(248),a=t(255),o=t(69),s=t(117),l=t(118),u=t(44);n.exports=function(n,e){return o(n)&&s(e)?l(u(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(119);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(250),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(251);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(66);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(253);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(32),i=t(254),a=t(15),o=t(70),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(256),i=t(257);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(120),i=t(63),a=t(15),o=t(113),s=t(68),l=t(44);n.exports=function(n,e,t){for(var u=-1,c=(e=r(e,n)).length,d=!1;++u<c;){var p=l(e[u]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++u!=c?d:!!(c=null==n?0:n.length)&&s(c)&&o(p,c)&&(a(n)||i(n))}},function(n,e,t){var r=t(259),i=t(260),a=t(69),o=t(44);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(119);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(71),i=t(262),a=t(264);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(263),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var u=Array(e+1);++o<e;)u[o]=a[o];return u[e]=t(l),r(n,this,u)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(265),i=t(268)(r);n.exports=i},function(n,e,t){var r=t(266),i=t(267),a=t(71),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(19),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(109),i=t(270),a=t(275),o=t(110),s=t(276),l=t(67);n.exports=function(n,e,t){var u=-1,c=i,d=n.length,p=!0,f=[],h=f;if(t)p=!1,c=a;else if(d>=200){var m=e?null:s(n);if(m)return l(m);p=!1,c=o,h=new r}else h=e?[]:f;n:for(;++u<d;){var g=n[u],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var _=h.length;_--;)if(h[_]===v)continue n;e&&h.push(v),f.push(g)}else c(h,v,t)||(h!==f&&h.push(v),f.push(g))}return f}},function(n,e,t){var r=t(271);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(272),i=t(273),a=t(274);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(116),i=t(277),a=t(67),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(115),i=t(23);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=t(11),i=t(7),a=t(4),o=t(25),s=t(3),l=t(6),u=t(1),c=t(9),d=t(62),p=t(10),f=t(49),h=t(30),m=t(91),g=t(0),v=t(100),_=t(38),b=a.JSON,x=a.Number,y=a.SyntaxError,w=b&&b.parse,k=o("Object","keys"),T=Object.getOwnPropertyDescriptor,S=s("".charAt),P=s("".slice),R=s(/./.exec),I=s([].push),C=/^\d$/,z=/^[1-9]$/,A=/^[\d-]$/,L=/^[\t\n\r ]$/,E=function(n,e,t,r){var i,a,o,s,u,f=n[e],m=r&&f===r.value,g=m&&"string"==typeof r.source?{source:r.source}:{};if(c(f)){var v=d(f),_=m?r.nodes:v?[]:{};if(v)for(i=_.length,o=h(f),s=0;s<o;s++)O(f,s,E(f,""+s,t,s<i?_[s]:void 0));else for(a=k(f),o=h(a),s=0;s<o;s++)u=a[s],O(f,u,E(f,u,t,p(_,u)?_[u]:void 0))}return l(t,n,e,f,g)},O=function(n,e,t){if(i){var r=T(n,e);if(r&&!r.configurable)return}void 0===t?delete n[e]:m(n,e,t)},N=function(n,e,t,r){this.value=n,this.end=e,this.source=t,this.nodes=r},$=function(n,e){this.source=n,this.index=e};$.prototype={fork:function(n){return new $(this.source,n)},parse:function(){var n=this.source,e=this.skip(L,this.index),t=this.fork(e),r=S(n,e);if(R(A,r))return t.number();switch(r){case"{":return t.object();case"[":return t.array();case'"':return t.string();case"t":return t.keyword(!0);case"f":return t.keyword(!1);case"n":return t.keyword(null)}throw new y('Unexpected character: "'+r+'" at: '+e)},node:function(n,e,t,r,i){return new N(e,r,n?null:P(this.source,t,r),i)},object:function(){for(var n=this.source,e=this.index+1,t=!1,r={},i={};e<n.length;){if(e=this.until(['"',"}"],e),"}"===S(n,e)&&!t){e++;break}var a=this.fork(e).string(),o=a.value;e=a.end,e=this.until([":"],e)+1,e=this.skip(L,e),a=this.fork(e).parse(),m(i,o,a),m(r,o,a.value),e=this.until([",","}"],a.end);var s=S(n,e);if(","===s)t=!0,e++;else if("}"===s){e++;break}}return this.node(1,r,this.index,e,i)},array:function(){for(var n=this.source,e=this.index+1,t=!1,r=[],i=[];e<n.length;){if(e=this.skip(L,e),"]"===S(n,e)&&!t){e++;break}var a=this.fork(e).parse();if(I(i,a),I(r,a.value),e=this.until([",","]"],a.end),","===S(n,e))t=!0,e++;else if("]"===S(n,e)){e++;break}}return this.node(1,r,this.index,e,i)},string:function(){var n=this.index,e=v(this.source,this.index+1);return this.node(0,e.value,n,e.end)},number:function(){var n=this.source,e=this.index,t=e;if("-"===S(n,t)&&t++,"0"===S(n,t))t++;else{if(!R(z,S(n,t)))throw new y("Failed to parse number at: "+t);t=this.skip(C,t+1)}if(("."===S(n,t)&&(t=this.skip(C,t+1)),"e"===S(n,t)||"E"===S(n,t))&&(t++,"+"!==S(n,t)&&"-"!==S(n,t)||t++,t===(t=this.skip(C,t))))throw new y("Failed to parse number's exponent value at: "+t);return this.node(0,x(P(n,e,t)),e,t)},keyword:function(n){var e=""+n,t=this.index,r=t+e.length;if(P(this.source,t,r)!==e)throw new y("Failed to parse value at: "+t);return this.node(0,n,t,r)},skip:function(n,e){for(var t=this.source;e<t.length&&R(n,S(t,e));e++);return e},until:function(n,e){e=this.skip(L,e);for(var t=S(this.source,e),r=0;r<n.length;r++)if(n[r]===t)return e;throw new y('Unexpected character: "'+t+'" at: '+e)}};var j=g((function(){var n;return w("9007199254740993",(function(e,t,r){n=r.source})),"9007199254740993"!==n})),D=_&&!g((function(){return 1/w("-0 \t")!=-1/0}));r({target:"JSON",stat:!0,forced:j},{parse:function(n,e){return D&&!u(e)?w(n):function(n,e){n=f(n);var t=new $(n,0,""),r=t.parse(),i=r.value,a=t.skip(L,r.end);if(a<n.length)throw new y('Unexpected extra character: "'+S(n,a)+'" after the parsed data at: '+a);return u(e)?E({"":i},"",e,r):i}(n,e)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(121)},function(n,e,t){"use strict";t(122)},function(n,e,t){"use strict";t(123)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(124)},function(n,e,t){"use strict";t(125)},function(n,e,t){"use strict";t(126)},function(n,e,t){"use strict";t.r(e);t(8),t(13),t(21);var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function u(n){return"function"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function f(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,v,2):String(n)}function v(n,e){return e&&e.__v_isRef?e.value:e}function _(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var x=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,P=T((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),R=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,C=T((function(n){return n.replace(I,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function L(n,e){for(var t in e)n[t]=e[t];return n}function E(n){for(var e={},t=0;t<n.length;t++)n[t]&&L(e,n[t]);return e}function O(n,e,t){}var N=function(n,e,t){return!1},$=function(n){return n};function j(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return j(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return j(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(j(n[t],e))return t;return-1}function F(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function B(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var M=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],G={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:N,isReservedAttr:N,isUnknownElement:N,getTagNamespace:O,parsePlatformTagName:$,mustUseProp:N,async:!0,_lifecycleHooks:U},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(q.source,".$_\\d]"));var X="__proto__"in{},Z="undefined"!=typeof window,K=Z&&window.navigator.userAgent.toLowerCase(),Y=K&&/msie|trident/.test(K),Q=K&&K.indexOf("msie 9.0")>0,J=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var nn=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var en,tn=K&&K.match(/firefox\/(\d+)/),rn={}.watch,an=!1;if(Z)try{var on={};Object.defineProperty(on,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===en&&(en=!Z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=Z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function un(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&un(Symbol)&&"undefined"!=typeof Reflect&&un(Reflect.ownKeys);cn="undefined"!=typeof Set&&un(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function fn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function gn(n){return new hn(void 0,void 0,void 0,String(n))}function vn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var _n=0,bn=[],xn=function(){function n(){this._pending=!1,this.id=_n++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var yn=[];function wn(n){yn.push(n),xn.target=n}function kn(){yn.pop(),xn.target=yn[yn.length-1]}var Tn=Array.prototype,Sn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];H(Sn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var Pn=Object.getOwnPropertyNames(Sn),Rn={},In=!0;function Cn(n){In=n}var zn={notify:O,depend:O,addSub:O,removeSub:O},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new xn,this.vmCount=0,H(n,"__ob__",this),i(n)){if(!t)if(X)n.__proto__=Sn;else for(var r=0,a=Pn.length;r<a;r++){H(n,s=Pn[r],Sn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;En(n,s=o[r],Rn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Ln(n[e],!1,this.mock)},n}();function Ln(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!In||!t&&sn()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Bn(n)||n instanceof hn?void 0:new An(n,e,t)}function En(n,e,t,r,a,o,s){void 0===s&&(s=!1);var l=new xn,u=Object.getOwnPropertyDescriptor(n,e);if(!u||!1!==u.configurable){var c=u&&u.get,d=u&&u.set;c&&!d||t!==Rn&&2!==arguments.length||(t=n[e]);var p=a?t&&t.__ob__:Ln(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return xn.target&&(l.depend(),p&&(p.dep.depend(),i(e)&&$n(e))),Bn(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(B(r,e)){if(d)d.call(n,e);else{if(c)return;if(!a&&Bn(r)&&!Bn(e))return void(r.value=e);t=e}p=a?e&&e.__ob__:Ln(e,!1,o),l.notify()}}}),l}}function On(n,e,t){if(!Fn(n)){var r=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Ln(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(En(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Nn(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Fn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function $n(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&$n(e)}function jn(n){return Dn(n,!0),H(n,"__v_isShallow",!0),n}function Dn(n,e){if(!Fn(n)){Ln(n,e,sn());0}}function Fn(n){return!(!n||!n.__v_isReadonly)}function Bn(n){return!(!n||!0!==n.__v_isRef)}function Mn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Bn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Bn(r)&&!Bn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Gn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function qn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!i(n))return Ie(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Ie(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,i,o){var l,u,c,d;for(l in n)u=n[l],c=e[l],d=Vn(l),a(u)||(a(c)?(a(u.fns)&&(u=n[l]=Hn(u,o)),s(d.once)&&(u=n[l]=i(d.name,u,d.capture)),t(d.name,u,d.capture,d.passive,d.params)):u!==c&&(c.fns=u,n[l]=c));for(l in e)a(n[l])&&r((d=Vn(l)).name,e[l],d.capture)}function Xn(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}a(i)?r=Hn([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=Hn([i,l]),r.merged=!0,n[e]=r}function Zn(n,e,t,r,i){if(o(e)){if(k(e,t))return n[t]=e[t],i||delete e[t],!0;if(k(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Kn(n){return l(n)?[gn(n)]:i(n)?function n(e,t){var r,u,c,d,p=[];for(r=0;r<e.length;r++)a(u=e[r])||"boolean"==typeof u||(c=p.length-1,d=p[c],i(u)?u.length>0&&(Yn((u=n(u,"".concat(t||"","_").concat(r)))[0])&&Yn(d)&&(p[c]=gn(d.text+u[0].text),u.shift()),p.push.apply(p,u)):l(u)?Yn(d)?p[c]=gn(d.text+u):""!==u&&p.push(gn(u)):Yn(u)&&Yn(d)?p[c]=gn(d.text+u.text):(s(e._isVList)&&o(u.tag)&&a(u.key)&&o(t)&&(u.key="__vlist".concat(t,"_").concat(r,"__")),p.push(u)));return p}(n):void 0}function Yn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Qn(n,e){var t,r,a,s,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(c(n))if(dn&&n[Symbol.iterator]){l=[];for(var u=n[Symbol.iterator](),d=u.next();!d.done;)l.push(e(d.value,l.length)),d=u.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Jn(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=L(L({},r),t)),i=a(t)||(u(e)?e():e)):i=this.$slots[n]||(u(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function ne(n){return At(this.$options,"filters",n,!0)||$}function ee(n,e){return i(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,i){var a=G.keyCodes[e]||t;return i&&r&&!G.keyCodes[e]?ee(i,r):a?ee(a,n):r?C(r)!==e:void 0===n}function re(n,e,t,r,a){if(t)if(c(t)){i(t)&&(t=E(t));var o=void 0,s=function(i){if("class"===i||"style"===i||x(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||G.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=P(i),u=C(i);l in o||u in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)s(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?L({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function ue(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];i(o)?ue(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=ae,n._n=_,n._s=g,n._l=Qn,n._t=Jn,n._q=j,n._i=D,n._m=ie,n._f=ne,n._k=te,n._b=re,n._v=gn,n._e=mn,n._u=ue,n._g=le,n._d=ce,n._p=de}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var u in t)t[u].every(he)&&delete t[u];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,i){var a,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==r&&l===i.$key&&!o&&!i.$hasNormal)return i;for(var u in a={},e)e[u]&&"$"!==u[0]&&(a[u]=ve(n,t,u,e[u]))}else a={};for(var c in t)c in a||(a[c]=_e(t,c));return e&&Object.isExtensible(e)&&(e._normalized=a),H(a,"$stable",s),H(a,"$key",l),H(a,"$hasNormal",o),a}function ve(n,e,t,r){var a=function(){var e=pn;fn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:Kn(t))&&t[0];return fn(e),t&&(!a||1===t.length&&a.isComment&&!me(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function _e(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Mn(n,e,t)}))}}}function xe(n,e,t,r,i){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,ye(n,o,r,i));for(var o in n)o in e||(a=!0,delete n[o]);return a}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function Te(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Se(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||me(t)))return t}}function Pe(n,e,t,r,d,p){return(i(t)||l(t))&&(d=r,r=t,t=void 0),s(p)&&(d=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return mn();o(t)&&o(t.is)&&(e=t.is);if(!e)return mn();0;i(r)&&u(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Kn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,p;if("string"==typeof e){var f=void 0;p=n.$vnode&&n.$vnode.ns||G.getTagNamespace(e),d=G.isReservedTag(e)?new hn(G.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(f=At(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):yt(f,t,n,r,e)}else d=yt(e,t,n,r);return i(d)?d:o(d)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var u=e.children[i];o(u.tag)&&(a(u.ns)||s(r)&&"svg"!==u.tag)&&n(u,t,r)}}(d,p),o(t)&&function(n){c(n.style)&&Ge(n.style);c(n.class)&&Ge(n.class)}(t),d):mn()}(n,e,t,r,d)}function Re(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Ce(n,r,"errorCaptured hook")}}Ce(n,e,t)}finally{kn()}}function Ie(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&m(a)&&!a._handled&&(a.catch((function(n){return Re(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Re(n,r,i)}return a}function Ce(n,e,t){if(G.errorHandler)try{return G.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!Z||"undefined"==typeof console)throw n;console.error(n)}var Ae,Le=!1,Ee=[],Oe=!1;function Ne(){Oe=!1;var n=Ee.slice(0);Ee.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&un(Promise)){var $e=Promise.resolve();Ae=function(){$e.then(Ne),nn&&setTimeout(O)},Le=!0}else if(Y||"undefined"==typeof MutationObserver||!un(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&un(setImmediate)?function(){setImmediate(Ne)}:function(){setTimeout(Ne,0)};else{var je=1,De=new MutationObserver(Ne),Fe=document.createTextNode(String(je));De.observe(Fe,{characterData:!0}),Ae=function(){je=(je+1)%2,Fe.data=String(je)},Le=!0}function Be(n,e){var t;if(Ee.push((function(){if(n)try{n.call(e)}catch(n){Re(n,e,"nextTick")}else t&&t(e)})),Oe||(Oe=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Me(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=Rt(r[e],t)}(t,n,e)}}Me("beforeMount"),Me("mounted"),Me("beforeUpdate"),Me("updated"),Me("beforeDestroy"),Me("destroyed"),Me("activated"),Me("deactivated"),Me("serverPrefetch"),Me("renderTracked"),Me("renderTriggered"),Me("errorCaptured");var Ue=new cn;function Ge(n){return function n(e,t){var r,a,o=i(e);if(!o&&!c(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Bn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Ue),Ue.clear(),n}var qe,Ve=0,He=function(){function n(n,e,t,r,i){var a,o;a=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",u(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Re(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ge(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ft(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){qe.$on(n,e)}function Xe(n,e){qe.$off(n,e)}function Ze(n,e){var t=qe;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Ke(n,e,t){qe=n,Wn(e,t||{},We,Xe,Ze,n),qe=void 0}var Ye=null;function Qe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),wn();var i=pn,a=Un;r&&fn(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var l=0,u=o.length;l<u;l++)Ie(o[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&(fn(i),a&&a.on()),kn()}var tt=[],rt=[],it={},at=!1,ot=!1,st=0;var lt=0,ut=Date.now;if(Z&&!Y){var ct=window.performance;ct&&"function"==typeof ct.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ut(),ot=!0,tt.sort(dt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,it={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),ln&&G.devtools&&ln.emit("flush")}function ft(n){var e=n.id;if(null==it[e]&&(n!==xn.target||!n.noRecurse)){if(it[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,Be(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var o=n[a].from;if(o in e._provided)t[a]=e._provided[o];else if("default"in n[a]){var s=n[a].default;t[a]=u(s)?s.call(e):s}else 0}}return t}}function mt(n,e,t,a,o){var l,u=this,c=o.options;k(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=s(c._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=ht(c.inject,a),this.slots=function(){return u.$slots||ge(a,n.scopedSlots,u.$slots=fe(t,a)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var o=Pe(l,n,e,t,r,p);return o&&!i(o)&&(o.fnScopeId=c._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return Pe(l,n,e,t,r,p)}}function gt(n,e,t,r,i){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function vt(n,e){for(var t in e)n[P(t)]=e[t]}function _t(n){return n.name||n.__name||n._componentTag}pe(mt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var o=i.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),u=!!(a||n.$options._renderChildren||l),c=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var d=i.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,d,c.data&&c.data.attrs||r,n,"$attrs")&&(u=!0),n.$attrs=d,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){Cn(!1);for(var f=n._props,h=n.$options._propKeys||[],m=0;m<h.length;m++){var g=h[m],v=n.$options.props;f[g]=Lt(g,v,e,n)}Cn(!0),n.$options.propsData=e}u&&(n.$slots=fe(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Je(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(bt);function yt(n,e,t,l,u){if(!a(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=ke;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,l=null,u=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},p=F((function(t){n.resolved=Te(t,e),i?r.length=0:d(!0)})),f=F((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,f);return c(h)&&(m(h)?a(n.resolved)&&h.then(p,f):m(h.component)&&(h.component.then(p,f),o(h.error)&&(n.errorComp=Te(h.error,e)),o(h.loading)&&(n.loadingComp=Te(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),o(h.timeout)&&(u=setTimeout((function(){u=null,a(n.resolved)&&f(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,r,i){var a=mn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(p,e,t,l,u);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;o(s)?(i(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var u in r){var c=C(u);Zn(i,l,u,c,!0)||Zn(i,s,u,c,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,u={},c=l.props;if(o(c))for(var d in c)u[d]=Lt(d,c,e||r);else o(t.attrs)&&vt(u,t.attrs),o(t.props)&&vt(u,t.props);var p=new mt(t,u,s,a,n),f=l.render.call(null,p._c,p);if(f instanceof hn)return gt(f,t,p.parent,l,p);if(i(f)){for(var h=Kn(f)||[],m=new Array(h.length),g=0;g<h.length;g++)m[g]=gt(h[g],t,p.parent,l,p);return m}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],i=e[r],a=bt[r];i===a||i&&i._merged||(e[r]=i?wt(a,i):a)}}(e);var v=_t(n.options)||u;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:u,children:l},p)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=O,Tt=G.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(i=n[r],a=e[r],t&&k(n,r)?i!==a&&p(i)&&p(a)&&St(i,a):On(n,r,a));return n}function Pt(n,e,t){return t?function(){var r=u(e)?e.call(t,t):e,i=u(n)?n.call(t,t):n;return r?St(r,i):i}:e?n?function(){return St(u(e)?e.call(this,this):e,u(n)?n.call(this,this):n)}:e:n}function Rt(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,r){var i=Object.create(n||null);return e?L(i,e):i}Tt.data=function(n,e,t){return t?Pt(n,e,t):e&&"function"!=typeof e?n:Pt(n,e)},U.forEach((function(n){Tt[n]=Rt})),M.forEach((function(n){Tt[n+"s"]=It})),Tt.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in L(a,n),e){var s=a[o],l=e[o];s&&!i(s)&&(s=[s]),a[o]=s?s.concat(l):i(l)?l:[l]}return a},Tt.props=Tt.methods=Tt.inject=Tt.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return L(i,n),e&&L(i,e),i},Tt.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,u(n)?n.call(this):n),e&&St(t,u(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(u(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[P(a)]={type:null});else if(p(t))for(var s in t)a=t[s],o[P(s)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var s=t[o];r[o]=p(s)?L({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];u(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=zt(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)k(n,o)||l(o);function l(r){var i=Tt[r]||Ct;s[r]=i(n[r],e[r],t,r)}return s}function At(n,e,t,r){if("string"==typeof t){var i=n[e];if(k(i,t))return i[t];var a=P(t);if(k(i,a))return i[a];var o=R(a);return k(i,o)?i[o]:i[t]||i[a]||i[o]}}function Lt(n,e,t,r){var i=e[n],a=!k(t,n),o=t[n],s=$t(Boolean,i.type);if(s>-1)if(a&&!k(i,"default"))o=!1;else if(""===o||o===C(n)){var l=$t(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return u(r)&&"Function"!==Ot(e.type)?r.call(n):r}(r,i,n);var c=In;Cn(!0),Ln(o),Cn(c)}return o}var Et=/^\s*function (\w+)/;function Ot(n){var e=n&&n.toString().match(Et);return e?e[1]:""}function Nt(n,e){return Ot(n)===Ot(e)}function $t(n,e){if(!i(e))return Nt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Nt(e[t],n))return t;return-1}var jt={enumerable:!0,configurable:!0,get:O,set:O};function Dt(n,e,t){jt.get=function(){return this[e][t]},jt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,jt)}function Ft(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=jn({}),i=n.$options._propKeys=[];n.$parent&&Cn(!1);var a=function(a){i.push(a);var o=Lt(a,e,t,n);En(r,a,o,void 0,!0),a in n||Dt(n,"_props",a)};for(var o in e)a(o);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);fn(n),wn();var i=Ie(t,null,[n._props||jn({}),r],n,"setup");if(kn(),fn(),u(i))e.render=i;else if(c(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var o in i)"__sfc"!==o&&Mn(a,i,o)}else for(var o in i)V(o)||Mn(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?O:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=u(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Re(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&k(r,a)||V(a)||Dt(n,"_data",a)}var o=Ln(e);o&&o.vmCount++}(n);else{var t=Ln(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var i in e){var a=e[i],o=u(a)?a:a.get;0,r||(t[i]=new He(n,o||O,O,Bt)),i in n||Mt(n,i,a)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)qt(n,t,r[a]);else qt(n,t,r)}}(n,e.watch)}var Bt={lazy:!0};function Mt(n,e,t){var r=!sn();u(t)?(jt.get=r?Ut(e):Gt(t),jt.set=O):(jt.get=t.get?r&&!1!==t.cache?Ut(e):Gt(t.get):O,jt.set=t.set||O),Object.defineProperty(n,e,jt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Gt(n){return function(){return n.call(this,this)}}function qt(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&L(n.extendOptions,r),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Xt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=_t(n)||_t(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=zt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Dt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Mt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,M.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=L({},o.options),i[r]=o,o}}function Zt(n){return n&&(_t(n.Ctor.options)||n.tag)}function Kt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Yt(n,e){var t=n.cache,r=n.keys,i=n._vnode,a=n.$vnode;for(var o in t){var s=t[o];if(s){var l=s.name;l&&!e(l)&&Qt(t,o,r,i)}}a.componentOptions.children=void 0}function Qt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,y(t,e)}Wt.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Gn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=fe(e._renderChildren,i),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return Pe(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Pe(n,e,t,r,i,!0)};var a=t&&t.data;En(n,"$attrs",a&&a.attrs||r,null,!0),En(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){En(n,t,e[t])})),Cn(!0))}(e),Ft(e),function(n){var e=n.$options.provide;if(e){var t=u(e)?e.call(n):e;if(!c(t))return;for(var r=qn(n),i=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var o=i[a];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=Nn,n.prototype.$watch=function(n,e,t){if(p(e))return qt(this,n,e,t);(t=t||{}).user=!0;var r=new He(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');wn(),Ie(e,this,[r.value],this,i),kn()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),i='event handler for "'.concat(n,'"'),a=0,o=t.length;a<o;a++)Ie(t[a],e,r,e,i)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Qe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Be(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=ge(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&we(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var a,o=pn,s=ke;try{fn(n),ke=n,a=t.call(n._renderProxy,n.$createElement)}catch(e){Re(e,n,"render"),a=n._vnode}finally{ke=s,fn(o)}return i(a)&&1===a.length&&(a=a[0]),a instanceof hn||(a=mn()),a.parent=r,a}}(Wt);var Jt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jt,exclude:Jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Zt(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Qt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Zt(t),i=this.include,a=this.exclude;if(i&&(!r||!Kt(i,r))||a&&r&&Kt(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return G}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:L,mergeOptions:zt,defineReactive:En},n.set=On,n.delete=Nn,n.nextTick=Be,n.observable=function(n){return Ln(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,L(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),u(n.install)?n.install.apply(n,t):u(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Xt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&u(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:sn}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:mt}),Wt.version="2.7.16";var er=b("style,class"),tr=b("input,textarea,option,select,progress"),rr=b("contenteditable,draggable,spellcheck"),ir=b("events,caret,typing,plaintext-only"),ar=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return sr(n)?n.slice(6,n.length):""},ur=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return pr(n,fr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:pr(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function pr(n,e){return n?e?n+" "+e:n:e||""}function fr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=fr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},mr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return mr(n)||gr(n)};var _r=Object.create(null);var br=b("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(u(t))Ie(t,r,[s],r,"template ref function");else{var c=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Bn(t),f=r.$refs;if(d||p)if(c){var h=d?f[t]:t.value;e?i(h)&&y(h,a):i(h)?h.includes(a)||h.push(a):d?(f[t]=[a],kr(r,t,f[t])):t.value=[a]}else if(d){if(e&&f[t]!==a)return;f[t]=l,kr(r,t,s)}else if(p){if(e&&t.value!==a)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Bn(r[e])?r[e].value=t:r[e]=t)}var Tr=new hn("",{},[]),Sr=["create","activate","update","remove","destroy"];function Pr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||br(r)&&br(i)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Rr(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var Ir={create:Cr,update:Cr,destroy:function(n){Cr(n,Tr)}};function Cr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===Tr,o=e===Tr,s=Ar(n.data.directives,n.context),l=Ar(e.data.directives,e.context),u=[],c=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Er(i,"update",e,n),i.def&&i.def.componentUpdated&&c.push(i)):(Er(i,"bind",e,n),i.def&&i.def.inserted&&u.push(i));if(u.length){var d=function(){for(var t=0;t<u.length;t++)Er(u[t],"inserted",e,n)};a?Xn(e,"insert",d):d()}c.length&&Xn(e,"postpatch",(function(){for(var t=0;t<c.length;t++)Er(c[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Er(s[t],"unbind",n,n,o)}(n,e)}var zr=Object.create(null);function Ar(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=zr),i[Lr(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||At(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||At(e.$options,"directives",r.name)}return i}function Lr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Er(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Re(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Or=[yr,Ir];function Nr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,u=n.data.attrs||{},c=e.data.attrs||{};for(r in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.attrs=L({},c)),c)i=c[r],u[r]!==i&&$r(l,r,i,e.data.pre);for(r in(Y||J)&&c.value!==u.value&&$r(l,"value",c.value),u)a(c[r])&&(sr(r)?l.removeAttributeNS(or,lr(r)):rr(r)||l.removeAttribute(r))}}function $r(n,e,t,r){r||n.tagName.indexOf("-")>-1?jr(n,e,t):ar(e)?ur(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return ur(e)||"false"===e?"false":"contenteditable"===n&&ir(e)?e:"true"}(e,t)):sr(e)?ur(t)?n.removeAttributeNS(or,lr(e)):n.setAttributeNS(or,e,t):jr(n,e,t)}function jr(n,e,t){if(ur(t))n.removeAttribute(e);else{if(Y&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Dr={create:Nr,update:Nr};function Fr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=cr(e),l=t._transitionClasses;o(l)&&(s=pr(s,fr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Br,Mr={create:Fr,update:Fr};function Ur(n,e,t){var r=Br;return function i(){var a=e.apply(null,arguments);null!==a&&Vr(n,i,t,r)}}var Gr=Le&&!(tn&&Number(tn[1])<=53);function qr(n,e,t,r){if(Gr){var i=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Br.addEventListener(n,e,an?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||Br).removeEventListener(n,e._wrapper||e,t)}function Hr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Br=e.elm||n.elm,function(n){if(o(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,qr,Vr,Ur,e.context),Br=void 0}}var Wr,Xr={create:Hr,update:Hr,destroy:function(n){return Hr(n,Tr)}};function Zr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},u=e.data.domProps||{};for(t in(o(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.domProps=L({},u)),l)t in u||(i[t]="");for(t in u){if(r=u[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=a(r)?"":String(r);Kr(i,c)&&(i.value=c)}else if("innerHTML"===t&&gr(i.tagName)&&a(i.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Wr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Kr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return _(t)!==_(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yr={create:Zr,update:Zr},Qr=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Jr(n){var e=ni(n.style);return n.staticStyle?L(n.staticStyle,e):e}function ni(n){return Array.isArray(n)?E(n):"string"==typeof n?Qr(n):n}var ei,ti=/^--/,ri=/\s*!important$/,ii=function(n,e,t){if(ti.test(e))n.style.setProperty(e,t);else if(ri.test(t))n.style.setProperty(C(e),t.replace(ri,""),"important");else{var r=oi(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ai=["Webkit","Moz","ms"],oi=T((function(n){if(ei=ei||document.createElement("div").style,"filter"!==(n=P(n))&&n in ei)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ai.length;t++){var r=ai[t]+e;if(r in ei)return r}}));function si(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,u=r.staticStyle,c=r.normalizedStyle||r.style||{},d=u||c,p=ni(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?L({},p):p;var f=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Jr(i.data))&&L(r,t);(t=Jr(n.data))&&L(r,t);for(var a=n;a=a.parent;)a.data&&(t=Jr(a.data))&&L(r,t);return r}(e,!0);for(s in d)a(f[s])&&ii(l,s,"");for(s in f)i=f[s],ii(l,s,null==i?"":i)}}var li={create:si,update:si},ui=/\s+/;function ci(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ui).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ui).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pi(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&L(e,fi(n.name||"v")),L(e,n),e}return"string"==typeof n?fi(n):void 0}}var fi=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hi=Z&&!Q,mi="transition",gi="transitionend",vi="animation",_i="animationend";hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vi="WebkitAnimation",_i="webkitAnimationEnd"));var bi=Z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xi(n){bi((function(){bi(n)}))}function yi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ci(n,e))}function wi(n,e){n._transitionClasses&&y(n._transitionClasses,e),di(n,e)}function ki(n,e,t){var r=Si(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?gi:_i,l=0,u=function(){n.removeEventListener(s,c),t()},c=function(e){e.target===n&&++l>=o&&u()};setTimeout((function(){l<o&&u()}),a+1),n.addEventListener(s,c)}var Ti=/\b(transform|all)(,|$)/;function Si(n,e){var t,r=window.getComputedStyle(n),i=(r[mi+"Delay"]||"").split(", "),a=(r[mi+"Duration"]||"").split(", "),o=Pi(i,a),s=(r[vi+"Delay"]||"").split(", "),l=(r[vi+"Duration"]||"").split(", "),u=Pi(s,l),c=0,d=0;return"transition"===e?o>0&&(t="transition",c=o,d=a.length):"animation"===e?u>0&&(t="animation",c=u,d=l.length):d=(t=(c=Math.max(o,u))>0?o>u?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:c,propCount:d,hasTransform:"transition"===t&&Ti.test(r[mi+"Property"])}}function Pi(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ri(e)+Ri(n[t])})))}function Ri(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ii(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=pi(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,p=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,v=r.enter,b=r.afterEnter,x=r.enterCancelled,y=r.beforeAppear,w=r.appear,k=r.afterAppear,T=r.appearCancelled,S=r.duration,P=Ye,R=Ye.$vnode;R&&R.parent;)P=R.context,R=R.parent;var I=!P._isMounted||!n.isRootInsert;if(!I||w||""===w){var C=I&&f?f:l,z=I&&m?m:p,A=I&&h?h:d,L=I&&y||g,E=I&&u(w)?w:v,O=I&&k||b,N=I&&T||x,$=_(c(S)?S.enter:S);0;var j=!1!==i&&!Q,D=Ai(E),B=t._enterCb=F((function(){j&&(wi(t,A),wi(t,z)),B.cancelled?(j&&wi(t,C),N&&N(t)):O&&O(t),t._enterCb=null}));n.data.show||Xn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),E&&E(t,B)})),L&&L(t),j&&(yi(t,C),yi(t,z),xi((function(){wi(t,C),B.cancelled||(yi(t,A),D||(zi($)?setTimeout(B,$):ki(t,s,B)))}))),n.data.show&&(e&&e(),E&&E(t,B)),j||D||B()}}}function Ci(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=pi(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,v=r.duration,b=!1!==i&&!Q,x=Ai(f),y=_(c(v)?v.leave:v);0;var w=t._leaveCb=F((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(wi(t,u),wi(t,d)),w.cancelled?(b&&wi(t,l),m&&m(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(k):k()}function k(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(yi(t,l),yi(t,d),xi((function(){wi(t,l),w.cancelled||(yi(t,u),x||(zi(y)?setTimeout(w,y):ki(t,s,w)))}))),f&&f(t,w),b||x||w())}}function zi(n){return"number"==typeof n&&!isNaN(n)}function Ai(n){if(a(n))return!1;var e=n.fns;return o(e)?Ai(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Li(n,e){!0!==e.data.show&&Ii(e)}var Ei=function(n){var e,t,r={},u=n.modules,c=n.nodeOps;for(e=0;e<Sr.length;++e)for(r[Sr[e]]=[],t=0;t<u.length;++t)o(u[t][Sr[e]])&&r[Sr[e]].push(u[t][Sr[e]]);function d(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function p(n,e,t,i,a,l,u){if(o(n.elm)&&o(l)&&(n=l[u]=vn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var l=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return f(n,e),h(t,n.elm,i),s(l)&&function(n,e,t,i){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(a=s.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Tr,s);e.push(s);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?c.createElementNS(n.ns,g):c.createElement(g,n),_(n),m(n,p,e),o(d)&&v(n,e),h(t,n.elm,i)):s(n.isComment)?(n.elm=c.createComment(n.text),h(t,n.elm,i)):(n.elm=c.createTextNode(n.text),h(t,n.elm,i))}}function f(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),_(n)):(wr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function m(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var i=0;i<r.create.length;++i)r.create[i](Tr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Tr,n),o(e.insert)&&t.push(n))}function _(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function x(n,e,t,r,i,a){for(;r<=i;++r)p(t[r],a,n,e,!1,t,r)}function y(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)y(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),y(r)):d(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function T(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&Pr(n,a))return i}}function S(n,e,t,i,l,u){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=vn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;o(h)&&o(f=h.hook)&&o(f=f.prepatch)&&f(n,e);var m=n.children,v=e.children;if(o(h)&&g(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);o(f=h.hook)&&o(f=f.update)&&f(n,e)}a(e.text)?o(m)&&o(v)?m!==v&&function(n,e,t,r,i){var s,l,u,d=0,f=0,h=e.length-1,m=e[0],g=e[h],v=t.length-1,_=t[0],b=t[v],y=!i;for(0;d<=h&&f<=v;)a(m)?m=e[++d]:a(g)?g=e[--h]:Pr(m,_)?(S(m,_,r,t,f),m=e[++d],_=t[++f]):Pr(g,b)?(S(g,b,r,t,v),g=e[--h],b=t[--v]):Pr(m,b)?(S(m,b,r,t,v),y&&c.insertBefore(n,m.elm,c.nextSibling(g.elm)),m=e[++d],b=t[--v]):Pr(g,_)?(S(g,_,r,t,f),y&&c.insertBefore(n,g.elm,m.elm),g=e[--h],_=t[++f]):(a(s)&&(s=Rr(e,d,h)),a(l=o(_.key)?s[_.key]:T(_,e,d,h))?p(_,r,n,m.elm,!1,t,f):Pr(u=e[l],_)?(S(u,_,r,t,f),e[l]=void 0,y&&c.insertBefore(n,u.elm,m.elm)):p(_,r,n,m.elm,!1,t,f),_=t[++f]);d>h?x(n,a(t[v+1])?null:t[v+1].elm,t,f,v,r):f>v&&w(e,d,h)}(d,m,v,t,u):o(v)?(o(n.text)&&c.setTextContent(d,""),x(d,null,v,0,v.length-1,t)):o(m)?w(m,0,m.length-1):o(n.text)&&c.setTextContent(d,""):n.text!==e.text&&c.setTextContent(d,e.text),o(h)&&o(f=h.hook)&&o(f=f.postpatch)&&f(n,e)}}}function P(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var R=b("attrs,class,staticClass,staticStyle,key");function I(n,e,t,r){var i,a=e.tag,l=e.data,u=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return f(e,t),!0;if(o(a)){if(o(u))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var c=!0,d=n.firstChild,p=0;p<u.length;p++){if(!d||!I(d,u[p],t,r)){c=!1;break}d=d.nextSibling}if(!c||d)return!1}else m(e,u,t);if(o(l)){var h=!1;for(var g in l)if(!R(g)){h=!0,v(e,t);break}!h&&l.class&&Ge(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,u=!1,d=[];if(a(n))u=!0,p(e,d);else{var f=o(n.nodeType);if(!f&&Pr(n,e))S(n,e,d,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&I(n,e,d))return P(e,d,!0),n;l=n,n=new hn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,m=c.parentNode(h);if(p(e,d,h._leaveCb?null:m,c.nextSibling(h)),o(e.parent))for(var v=e.parent,_=g(e);v;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](v);if(v.elm=e.elm,_){for(var x=0;x<r.create.length;++x)r.create[x](Tr,v);var k=v.data.hook.insert;if(k.merged)for(var T=k.fns.slice(1),R=0;R<T.length;R++)T[R]()}else wr(v);v=v.parent}o(m)?w([n],0,0):o(n.tag)&&y(n)}}return P(e,d,u),e.elm}o(n)&&y(n)}}({nodeOps:xr,modules:[Dr,Mr,Xr,Yr,li,Z?{create:Li,activate:Li,remove:function(n,e){!0!==n.data.show?Ci(n,e):e()}}:{}].concat(Or)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Mi(n,"input")}));var Oi={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Xn(t,"postpatch",(function(){Oi.componentUpdated(n,e,t)})):Ni(n,e,t.context),n._vOptions=[].map.call(n.options,Di)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Fi),n.addEventListener("compositionend",Bi),n.addEventListener("change",Bi),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ni(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Di);if(i.some((function(n,e){return!j(n,r[e])})))(n.multiple?e.value.some((function(n){return ji(n,i)})):e.value!==e.oldValue&&ji(e.value,i))&&Mi(n,"change")}}};function Ni(n,e,t){$i(n,e,t),(Y||J)&&setTimeout((function(){$i(n,e,t)}),0)}function $i(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=D(r,Di(o))>-1,o.selected!==a&&(o.selected=a);else if(j(Di(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function ji(n,e){return e.every((function(e){return!j(e,n)}))}function Di(n){return"_value"in n?n._value:n.value}function Fi(n){n.target.composing=!0}function Bi(n){n.target.composing&&(n.target.composing=!1,Mi(n.target,"input"))}function Mi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ui(n){return!n.componentInstance||n.data&&n.data.transition?n:Ui(n.componentInstance._vnode)}var Gi={model:Oi,show:{bind:function(n,e,t){var r=e.value,i=(t=Ui(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Ii(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ui(t)).data&&t.data.transition?(t.data.show=!0,r?Ii(t,(function(){n.style.display=n.__vOriginalDisplay})):Ci(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},qi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Vi(Se(e.children)):n}function Hi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[P(r)]=i[r];return e}function Wi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Xi=function(n){return n.tag||me(n)},Zi=function(n){return"show"===n.name},Ki={name:"transition",props:qi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Xi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Vi(i);if(!a)return i;if(this._leaving)return Wi(n,i);var o="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=Hi(this),u=this._vnode,c=Vi(u);if(a.data.directives&&a.data.directives.some(Zi)&&(a.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,c)&&!me(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var d=c.data.transition=L({},s);if("out-in"===r)return this._leaving=!0,Xn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wi(n,i);if("in-out"===r){if(me(a))return u;var p,f=function(){p()};Xn(s,"afterEnter",f),Xn(s,"enterCancelled",f),Xn(d,"delayLeave",(function(n){p=n}))}}return i}}},Yi=L({tag:String,moveClass:String},qi);function Qi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function na(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete Yi.mode;var ea={Transition:Ki,TransitionGroup:{props:Yi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Hi(this),s=0;s<i.length;s++){if((c=i[s]).tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),t[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(r){var l=[],u=[];for(s=0;s<r.length;s++){var c;(c=r[s]).data.transition=o,c.data.pos=c.elm.getBoundingClientRect(),t[c.key]?l.push(c):u.push(c)}this.kept=n(e,null,l),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qi),n.forEach(Ji),n.forEach(na),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;yi(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(gi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(gi,n),t._moveCb=null,wi(t,e))})}})))},methods:{hasMove:function(n,e){if(!hi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),ci(t,e),t.style.display="none",this.$el.appendChild(t);var r=Si(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ta(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=vr,Wt.config.isReservedAttr=er,Wt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!Z)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=_r[n])return _r[n];var e=document.createElement(n);return n.indexOf("-")>-1?_r[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:_r[n]=/HTMLUnknownElement/.test(e.toString())},L(Wt.options.directives,Gi),L(Wt.options.components,ea),Wt.prototype.__patch__=Z?Ei:O,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=mn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new He(n,r,O,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&Z?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Z&&setTimeout((function(){G.devtools&&ln&&ln.emit("init",Wt)}),0);var ra=/[!'()*]/g,ia=function(n){return"%"+n.charCodeAt(0).toString(16)},aa=/%2C/g,oa=function(n){return encodeURIComponent(n).replace(ra,ia).replace(aa,",")};function sa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var la=function(n){return null==n||"object"==typeof n?n:String(n)};function ua(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=sa(t.shift()),i=t.length>0?sa(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function ca(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oa(e)):r.push(oa(e)+"="+oa(n)))})),r.join("&")}return oa(e)+"="+oa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function pa(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=fa(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ga(e,i),matched:n?ma(n):[]};return t&&(o.redirectedFrom=ga(t,i)),Object.freeze(o)}function fa(n){if(Array.isArray(n))return n.map(fa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=fa(n[t]);return e}return n}var ha=pa(null,{path:"/"});function ma(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ga(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||ca)(r)+i}function va(n,e,t){return e===ha?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&_a(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&_a(n.query,e.query)&&_a(n.params,e.params))))}function _a(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?_a(a,o):String(a)===String(o)}))}function ba(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var xa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,s=t.name,l=i.$route,u=i._routerViewCache||(i._routerViewCache={}),c=0,d=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&c++,p.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(a.routerViewDepth=c,d){var f=u[s],h=f&&f.component;return h?(f.configProps&&ya(h,a,f.route,f.configProps),o(h,a,r)):o()}var m=l.matched[c],g=m&&m.components[s];if(!m||!g)return u[s]=null,o();u[s]={component:g},a.registerRouteInstance=function(n,e){var t=m.instances[s];(e&&t!==n||!e&&t===n)&&(m.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){m.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),ba(l)};var v=m.props&&m.props[s];return v&&(ta(u[s],{route:l,configProps:v}),ya(g,a,l,v)),o(g,a,r)}};function ya(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ta({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function wa(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ka(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ta=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Sa=Fa,Pa=Aa,Ra=function(n,e){return Ea(Aa(n,e),e)},Ia=Ea,Ca=Da,za=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Aa(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=za.exec(n));){var l=t[0],u=t[1],c=t.index;if(o+=n.slice(a,c),a=c+l.length,u)o+=u[1];else{var d=n[a],p=t[2],f=t[3],h=t[4],m=t[5],g=t[6],v=t[7];o&&(r.push(o),o="");var _=null!=p&&null!=d&&d!==p,b="+"===g||"*"===g,x="?"===g||"*"===g,y=t[2]||s,w=h||m;r.push({name:f||i++,prefix:p||"",delimiter:y,optional:x,repeat:b,partial:_,asterisk:!!v,pattern:w?Na(w):v?".*":"[^"+Oa(y)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function La(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Ea(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",ja(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?La:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var u,c=a[l.name];if(null==c){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Ta(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<c.length;d++){if(u=o(c[d]),!t[s].test(u))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(u)+"`");i+=(0===d?l.prefix:l.delimiter)+u}}else{if(u=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[s].test(u))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+u+'"');i+=l.prefix+u}}else i+=l}return i}}function Oa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Na(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function $a(n,e){return n.keys=e,n}function ja(n){return n&&n.sensitive?"":"i"}function Da(n,e,t){Ta(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=Oa(s);else{var l=Oa(s.prefix),u="(?:"+s.pattern+")";e.push(s),s.repeat&&(u+="(?:"+l+u+")*"),a+=u=s.optional?s.partial?l+"("+u+")?":"(?:"+l+"("+u+"))?":l+"("+u+")"}}var c=Oa(t.delimiter||"/"),d=a.slice(-c.length)===c;return r||(a=(d?a.slice(0,-c.length):a)+"(?:"+c+"(?=$))?"),a+=i?"$":r&&d?"":"(?="+c+"|$)",$a(new RegExp("^"+a,ja(t)),e)}function Fa(n,e,t){return Ta(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return $a(n,e)}(n,e):Ta(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(Fa(n[i],e,t).source);return $a(new RegExp("(?:"+r.join("|")+")",ja(t)),e)}(n,e,t):function(n,e,t){return Da(Aa(n,t),e,t)}(n,e,t)}Sa.parse=Pa,Sa.compile=Ra,Sa.tokensToFunction=Ia,Sa.tokensToRegExp=Ca;var Ba=Object.create(null);function Ma(n,e,t){e=e||{};try{var r=Ba[n]||(Ba[n]=Sa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ua(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ta({},n)).params;return a&&"object"==typeof a&&(i.params=ta({},a)),i}if(!i.path&&i.params&&e){(i=ta({},i))._normalized=!0;var o=ta(ta({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=Ma(s,o,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),u=e&&e.path||"/",c=l.path?wa(l.path,u,t||i.append):u,d=function(n,e,t){void 0===e&&(e={});var r,i=t||ua;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(la):la(o)}return r}(l.query,i.query,r&&r.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:c,query:d,hash:p}}var Ga,qa=function(){},Va={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,l={},u=t.options.linkActiveClass,c=t.options.linkExactActiveClass,d=null==u?"router-link-active":u,p=null==c?"router-link-exact-active":c,f=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,m=o.redirectedFrom?pa(null,Ua(o.redirectedFrom),null,t):o;l[h]=va(r,m,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Ha(n)&&(e.replace?t.replace(a,qa):t.push(a,qa))},_={click:Ha};Array.isArray(this.event)?this.event.forEach((function(n){_[n]=v})):_[this.event]=v;var b={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[f],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)b.on=_,b.attrs={href:s,"aria-current":g};else{var y=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(y){y.isStatic=!1;var w=y.data=ta({},y.data);for(var k in w.on=w.on||{},w.on){var T=w.on[k];k in _&&(w.on[k]=Array.isArray(T)?T:[T])}for(var S in _)S in w.on?w.on[S].push(_[S]):w.on[S]=v;var P=y.data.attrs=ta({},y.data.attrs);P.href=s,P["aria-current"]=g}else b.on=_}return n(this.tag,b,this.$slots.default)}};function Ha(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wa="undefined"!=typeof window;function Xa(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var u=i.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ka(e.path+"/"+n)}(s,a,u.strict);"boolean"==typeof i.caseSensitive&&(u.sensitive=i.caseSensitive);var d={path:c,regex:Za(c,u),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ka(o+"/"+i.path):void 0;n(e,t,r,i,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<p.length;++f){0;var h={path:p[f],children:i.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,o,s,n,i)}));for(var l=0,u=a.length;l<u;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),u--,l--);return{pathList:a,pathMap:o,nameMap:s}}function Za(n,e){return Sa(n,[],e)}function Ka(n,e){var t=Xa(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=Ua(n,t,!1,e),u=s.name;if(u){var c=a[u];if(!c)return l(null,s);var d=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Ma(c.path,s.params),l(c,s,o)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Ya(m.regex,s.path,s.params))return l(m,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(pa(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,u=s.name,c=s.path,d=t.query,p=t.hash,f=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,f=s.hasOwnProperty("params")?s.params:f,u){a[u];return o({_normalized:!0,name:u,query:d,hash:p,params:f},void 0,t)}if(c){var h=function(n,e){return wa(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:Ma(h,f),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Ma(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):pa(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Xa([e||n],r,i,a,t),t&&t.alias.length&&Xa(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Xa(n,r,i,a)}}}function Ya(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?sa(r[i]):r[i])}return!0}var Qa=Wa&&window.performance&&window.performance.now?window.performance:Date;function Ja(){return Qa.now().toFixed(3)}var no=Ja();function eo(){return no}function to(n){return no=n}var ro=Object.create(null);function io(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ta({},window.history.state);return t.key=eo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",so),function(){window.removeEventListener("popstate",so)}}function ao(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=eo();if(n)return ro[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){fo(n,a)})).catch((function(n){0})):fo(o,a))}))}}function oo(){var n=eo();n&&(ro[n]={x:window.pageXOffset,y:window.pageYOffset})}function so(n){oo(),n.state&&n.state.key&&to(n.state.key)}function lo(n){return co(n.x)||co(n.y)}function uo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var po=/^#\d/;function fo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:co((t=a).x)?t.x:0,y:co(t.y)?t.y:0})}else lo(n)&&(e=uo(n))}else r&&lo(n)&&(e=uo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ho,mo=Wa&&((-1===(ho=window.navigator.userAgent).indexOf("Android 2.")&&-1===ho.indexOf("Android 4.0")||-1===ho.indexOf("Mobile Safari")||-1!==ho.indexOf("Chrome")||-1!==ho.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){oo();var t=window.history;try{if(e){var r=ta({},t.state);r.key=eo(),t.replaceState(r,"",n)}else t.pushState({key:to(Ja())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vo(n){go(n,!0)}var _o={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return yo(n,e,_o.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xo(n,e){return yo(n,e,_o.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function yo(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var wo=["params","query","hash"];function ko(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function To(n,e){return ko(n)&&n._isRouter&&(null==e||n.type===e)}function So(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Po(n){return function(e,t,r){var i=!1,a=0,o=null;Ro(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,u=zo((function(e){var i;((i=e).__esModule||Co&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ga.extend(e),t.components[s]=e,--a<=0&&r()})),c=zo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=ko(n)?n:new Error(e),r(o))}));try{l=n(u,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(u,c);else{var d=l.component;d&&"function"==typeof d.then&&d.then(u,c)}}})),i||r()}}function Ro(n,e){return Io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Io(n){return Array.prototype.concat.apply([],n)}var Co="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ao=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ha,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Lo(n,e,t,r){var i=Ro(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=Ga.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return Io(r?i.reverse():i)}function Eo(n,e){if(e)return function(){return n.apply(e,arguments)}}Ao.prototype.listen=function(n){this.cb=n},Ao.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ao.prototype.onError=function(n){this.errorCbs.push(n)},Ao.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(To(n,_o.redirected)&&a===ha||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ao.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!To(n)&&ko(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,u=i.matched.length-1;if(va(n,i)&&l===u&&n.matched[l]===i.matched[u])return this.ensureURL(),n.hash&&ao(this.router,i,n,!1),s(((o=yo(a=i,n,_o.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=c.updated,p=c.deactivated,f=c.activated,h=[].concat(function(n){return Lo(n,"beforeRouteLeave",Eo,!0)}(p),this.router.beforeHooks,function(n){return Lo(n,"beforeRouteUpdate",Eo)}(d),f.map((function(n){return n.beforeEnter})),Po(f)),m=function(e,t){if(r.pending!==n)return s(xo(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return yo(n,e,_o.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):ko(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bo(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};So(h,m,(function(){So(function(n){return Lo(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(xo(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){ba(n)}))}))}))},Ao.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ao.prototype.setupListeners=function(){},Ao.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ha,this.pending=null};var Oo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=No(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=mo&&t;r&&this.listeners.push(io());var i=function(){var t=n.current,i=No(n.base);n.current===ha&&i===n._startLocation||n.transitionTo(i,(function(n){r&&ao(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){go(ka(r.base+n.fullPath)),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){vo(ka(r.base+n.fullPath)),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(No(this.base)!==this.current.fullPath){var e=ka(this.base+this.current.fullPath);n?go(e):vo(e)}},e.prototype.getCurrentLocation=function(){return No(this.base)},e}(Ao);function No(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ka(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var $o=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=No(n);if(!/^\/#/.test(e))return window.location.replace(ka(n+"/#"+e)),!0}(this.base)||jo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=mo&&e;t&&this.listeners.push(io());var r=function(){var e=n.current;jo()&&n.transitionTo(Do(),(function(r){t&&ao(n.router,r,e,!0),mo||Mo(r.fullPath)}))},i=mo?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Bo(n.fullPath),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Mo(n.fullPath),ao(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Do()!==e&&(n?Bo(e):Mo(e))},e.prototype.getCurrentLocation=function(){return Do()},e}(Ao);function jo(){var n=Do();return"/"===n.charAt(0)||(Mo("/"+n),!1)}function Do(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Fo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bo(n){mo?go(Fo(n)):window.location.hash=n}function Mo(n){mo?vo(Fo(n)):window.location.replace(Fo(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){To(n,_o.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ao),Go=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ka(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!mo&&!1!==n.fallback,this.fallback&&(e="hash"),Wa||(e="abstract"),this.mode=e,e){case"history":this.history=new Oo(this,n.base);break;case"hash":this.history=new $o(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},qo={currentRoute:{configurable:!0}};Go.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},qo.currentRoute.get=function(){return this.history&&this.history.current},Go.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Oo||t instanceof $o){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;mo&&i&&"fullPath"in n&&ao(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Go.prototype.beforeEach=function(n){return Ho(this.beforeHooks,n)},Go.prototype.beforeResolve=function(n){return Ho(this.resolveHooks,n)},Go.prototype.afterEach=function(n){return Ho(this.afterHooks,n)},Go.prototype.onReady=function(n,e){this.history.onReady(n,e)},Go.prototype.onError=function(n){this.history.onError(n)},Go.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Go.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Go.prototype.go=function(n){this.history.go(n)},Go.prototype.back=function(){this.go(-1)},Go.prototype.forward=function(){this.go(1)},Go.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Go.prototype.resolve=function(n,e,t){var r=Ua(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ka(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},Go.prototype.getRoutes=function(){return this.matcher.getRoutes()},Go.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Go.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Go.prototype,qo);var Vo=Go;function Ho(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Go.install=function n(e){if(!n.installed||Ga!==e){n.installed=!0,Ga=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xa),e.component("RouterLink",Va);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Go.version="3.6.5",Go.isNavigationFailure=To,Go.NavigationFailureType=_o,Go.START_LOCATION=ha,Wa&&window.Vue&&window.Vue.use(Go);t(157),t(22),t(166);t(167),t(46);var Wo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,375)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,374))},Xo={"v-72a9ee7c":()=>t.e(6).then(t.bind(null,376)),"v-c2184f54":()=>t.e(7).then(t.bind(null,377)),"v-4a1eacb6":()=>t.e(8).then(t.bind(null,378)),"v-a032a962":()=>t.e(11).then(t.bind(null,379)),"v-570b2315":()=>t.e(9).then(t.bind(null,380)),"v-4e39d388":()=>t.e(12).then(t.bind(null,381)),"v-fcc3ec3c":()=>t.e(13).then(t.bind(null,382)),"v-65b9d288":()=>t.e(14).then(t.bind(null,383)),"v-53847772":()=>t.e(15).then(t.bind(null,384)),"v-2152ede0":()=>t.e(10).then(t.bind(null,385)),"v-203e451a":()=>t.e(16).then(t.bind(null,386)),"v-ffe450e8":()=>t.e(17).then(t.bind(null,387)),"v-387c983e":()=>t.e(18).then(t.bind(null,388)),"v-ba0f2176":()=>t.e(19).then(t.bind(null,389)),"v-39e8e8bb":()=>t.e(20).then(t.bind(null,390)),"v-6d0e5d0a":()=>t.e(21).then(t.bind(null,391)),"v-358b60c5":()=>t.e(22).then(t.bind(null,392)),"v-10ebe03e":()=>t.e(23).then(t.bind(null,393)),"v-4e27b9b6":()=>t.e(24).then(t.bind(null,394)),"v-22f068d8":()=>t.e(25).then(t.bind(null,395)),"v-c8856c68":()=>t.e(26).then(t.bind(null,396)),"v-6bdd7efc":()=>t.e(27).then(t.bind(null,397)),"v-d0319f4e":()=>t.e(28).then(t.bind(null,398)),"v-075f108a":()=>t.e(29).then(t.bind(null,399)),"v-d263196a":()=>t.e(30).then(t.bind(null,400)),"v-358c318b":()=>t.e(31).then(t.bind(null,401)),"v-123d763a":()=>t.e(32).then(t.bind(null,402)),"v-5a424a08":()=>t.e(33).then(t.bind(null,403)),"v-b3fd1cf4":()=>t.e(34).then(t.bind(null,404)),"v-4735483d":()=>t.e(35).then(t.bind(null,405)),"v-554cdc89":()=>t.e(36).then(t.bind(null,406)),"v-425c0d28":()=>t.e(37).then(t.bind(null,407)),"v-c504442c":()=>t.e(38).then(t.bind(null,408)),"v-6a90bec1":()=>t.e(39).then(t.bind(null,409)),"v-40333d11":()=>t.e(40).then(t.bind(null,410)),"v-5a59dc7c":()=>t.e(41).then(t.bind(null,411)),"v-19267156":()=>t.e(43).then(t.bind(null,412)),"v-e45eb658":()=>t.e(42).then(t.bind(null,413)),"v-7bcfc72d":()=>t.e(44).then(t.bind(null,414)),"v-7bd6065e":()=>t.e(45).then(t.bind(null,415)),"v-2f12763c":()=>t.e(46).then(t.bind(null,416)),"v-02b66869":()=>t.e(47).then(t.bind(null,417)),"v-a2e945e8":()=>t.e(50).then(t.bind(null,418)),"v-f43e611c":()=>t.e(48).then(t.bind(null,419)),"v-3baf18ff":()=>t.e(51).then(t.bind(null,420)),"v-655783a0":()=>t.e(49).then(t.bind(null,421)),"v-dcf90e9e":()=>t.e(52).then(t.bind(null,422)),"v-01b5feb6":()=>t.e(54).then(t.bind(null,423)),"v-51e1c7f6":()=>t.e(53).then(t.bind(null,424)),"v-58b44ebe":()=>t.e(55).then(t.bind(null,425)),"v-c9bd4b28":()=>t.e(56).then(t.bind(null,426))};function Zo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ko=/-(\w)/g,Yo=Zo(n=>n.replace(Ko,(n,e)=>e?e.toUpperCase():"")),Qo=/\B([A-Z])/g,Jo=Zo(n=>n.replace(Qo,"-$1").toLowerCase()),ns=Zo(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Yo(e))):n(ns(e))||n(Jo(e))}const ts=Object.assign({},Wo,Xo),rs=n=>ts[n],is=n=>Xo[n],as=n=>Wo[n],os=n=>Wt.component(n);function ss(n){return es(is,n)}function ls(n){return es(as,n)}function us(n){return es(rs,n)}function cs(n){return es(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&us(n)){const e=await us(n)();Wt.component(n,e.default)}}))}function ps(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}t(181);var fs=t(127),hs=t.n(fs),ms={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${n[t]}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=_s(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,bs)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){_s(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function _s(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function bs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(130);var xs=t(76),ys={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ws=t(45),ks=t.n(ws),Ts={mounted(){ks.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||ks.a.start(),t()}),this.$router.afterEach(()=>{ks.a.done(),this.isSidebarOpen=!1})}};t(279),t(280);class Ss{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Ps={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ss).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},Rs=(t(281),"auto"),Is="zoom-in",Cs="zoom-out",zs="grab",As="move";function Ls(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Es(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Os(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ns(n,e,t){!function(n){var e=$s,t=js;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var $s="transition",js="transform",Ds="transform",Fs="transitionend";var Bs=function(){},Ms={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Bs,onClose:Bs,onGrab:Bs,onMove:Bs,onRelease:Bs,onBeforeOpen:Bs,onBeforeClose:Bs,onBeforeGrab:Bs,onBeforeRelease:Bs,onImageLoading:Bs,onImageLoaded:Bs},Us={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),qs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Gs(n)&&!qs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Gs(n)&&!qs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Gs(n){return 0===n.button}function qs(n){return n.metaKey||n.ctrlKey}var Vs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ns(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ls(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ns(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Hs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ws=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Xs=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Zs={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Os(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?zs:Cs,transition:Ds+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ns(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ns(this.el,{transform:"none"})},grab:function(n,e,t){var r=Ks(),i=r.x-n,a=r.y-e;Ns(this.el,{cursor:As,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Ks(),i=r.x-n,a=r.y-e;Ns(this.el,{transition:Ds,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ns(this.el,this.styleClose)},restoreOpenStyle:function(){Ns(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ks(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Hs(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=Ks(),u={x:l.x-o,y:l.y-s},c=u.x/o,d=u.y/s,p=a+Math.min(c,d);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,m=parseFloat(i)*f/(100*this.rect.width),g=parseFloat(i)*h/(100*this.rect.height);if(p>m||p>g)return{x:m,y:g}}return{x:p,y:p}}};function Ks(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ys(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Ls(n,r,e[r],t)}))}var Qs=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Zs),this.overlay=Object.create(Vs),this.handler=Object.create(Us),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Xs({},Ms,e),this.overlay.init(this),this.handler.init(this)}return Ws(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Is,Ls(n,"click",this.handler.click),this.options.preloadImage&&Es(Os(n)));return this}},{key:"config",value:function(n){return n?(Xs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Es(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ls(document,"scroll",this.handler.scroll),Ls(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ls(window,"resize",this.handler.resizeWindow);var a=function n(){Ls(r,Fs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Ys(document,e.handler,!0),t(r)};return Ls(r,Fs,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Rs,this.overlay.fadeOut(),this.target.zoomOut(),Ls(document,"scroll",this.handler.scroll,!1),Ls(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ls(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Ls(t,Fs,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ys(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ls(t,Fs,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){Ls(i,Fs,n,!1),r(i)};return Ls(i,Fs,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=As,this.target.move(n,e,t);var i=this.target.el,a=function n(){Ls(i,Fs,n,!1),r(i)};return Ls(i,Fs,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Rs,this.target.restoreOpenStyle();var r=function r(){Ls(t,Fs,r,!1),n.lock=!1,n.released=!0,e(t)};return Ls(t,Fs,r),this}}}]),n}();const Js=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nl=Number("500");class el{constructor(){this.instance=new Qs(Js)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=nl){setTimeout(()=>this.update(n),e)}}var tl={watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new el,this.$vuepress.zooming.updateDelay()}},rl=(t(282),t(283),t(284),[ms,ys,Ts,Ps,tl,{}]),il={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ps("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},al=t(2),ol=Object(al.a)(il,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(ol,"mixins",rl);const sl=[{name:"v-72a9ee7c",path:"/pages/Notes/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-72a9ee7c").then(t)}},{path:"/pages/Notes/index.html",redirect:"/pages/Notes/"},{path:"/00.目录页/Notes.html",redirect:"/pages/Notes/"},{name:"v-c2184f54",path:"/pages/Projects/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c2184f54").then(t)}},{path:"/pages/Projects/index.html",redirect:"/pages/Projects/"},{path:"/00.目录页/Projects.html",redirect:"/pages/Projects/"},{name:"v-4a1eacb6",path:"/pages/Teasting/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4a1eacb6").then(t)}},{path:"/pages/Teasting/index.html",redirect:"/pages/Teasting/"},{path:"/00.目录页/Teasting.html",redirect:"/pages/Teasting/"},{name:"v-a032a962",path:"/pages/Verilog_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a032a962").then(t)}},{path:"/pages/Verilog_03/index.html",redirect:"/pages/Verilog_03/"},{path:"/01.Verilog HDL/3.testBench的编写规范.html",redirect:"/pages/Verilog_03/"},{name:"v-570b2315",path:"/pages/Verilog_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-570b2315").then(t)}},{path:"/pages/Verilog_01/index.html",redirect:"/pages/Verilog_01/"},{path:"/01.Verilog HDL/1.Verilog HDL时序电路的基本元件设计.html",redirect:"/pages/Verilog_01/"},{name:"v-4e39d388",path:"/pages/NN_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4e39d388").then(t)}},{path:"/pages/NN_01/index.html",redirect:"/pages/NN_01/"},{path:"/02.Neural Networks/01.About_Linear_NN.html",redirect:"/pages/NN_01/"},{name:"v-fcc3ec3c",path:"/pages/NN_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-fcc3ec3c").then(t)}},{path:"/pages/NN_02/index.html",redirect:"/pages/NN_02/"},{path:"/02.Neural Networks/02.Loss_Functions.html",redirect:"/pages/NN_02/"},{name:"v-65b9d288",path:"/pages/NN_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-65b9d288").then(t)}},{path:"/pages/NN_03/index.html",redirect:"/pages/NN_03/"},{path:"/02.Neural Networks/03.Activate_Function.html",redirect:"/pages/NN_03/"},{name:"v-53847772",path:"/pages/NN_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-53847772").then(t)}},{path:"/pages/NN_04/index.html",redirect:"/pages/NN_04/"},{path:"/02.Neural Networks/04.Conv_Lenet.html",redirect:"/pages/NN_04/"},{name:"v-2152ede0",path:"/pages/Verilog_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-2152ede0").then(t)}},{path:"/pages/Verilog_02/index.html",redirect:"/pages/Verilog_02/"},{path:"/01.Verilog HDL/2.Verilog HDL有限状态机（FSM）设计基础.html",redirect:"/pages/Verilog_02/"},{name:"v-203e451a",path:"/pages/NN_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-203e451a").then(t)}},{path:"/pages/NN_05/index.html",redirect:"/pages/NN_05/"},{path:"/02.Neural Networks/05.AlexNet_blocks.html",redirect:"/pages/NN_05/"},{name:"v-ffe450e8",path:"/pages/NN_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-ffe450e8").then(t)}},{path:"/pages/NN_06/index.html",redirect:"/pages/NN_06/"},{path:"/02.Neural Networks/06.Parallel_Deeper_NN.html",redirect:"/pages/NN_06/"},{name:"v-387c983e",path:"/pages/FPGA_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-387c983e").then(t)}},{path:"/pages/FPGA_01/index.html",redirect:"/pages/FPGA_01/"},{path:"/03.FPGA/01.LED_Light_to_flow.html",redirect:"/pages/FPGA_01/"},{name:"v-ba0f2176",path:"/pages/FPGA_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-ba0f2176").then(t)}},{path:"/pages/FPGA_02/index.html",redirect:"/pages/FPGA_02/"},{path:"/03.FPGA/02.keys.html",redirect:"/pages/FPGA_02/"},{name:"v-39e8e8bb",path:"/pages/FPGA_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-39e8e8bb").then(t)}},{path:"/pages/FPGA_03/index.html",redirect:"/pages/FPGA_03/"},{path:"/03.FPGA/03.PWM.html",redirect:"/pages/FPGA_03/"},{name:"v-6d0e5d0a",path:"/pages/FPGA_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6d0e5d0a").then(t)}},{path:"/pages/FPGA_04/index.html",redirect:"/pages/FPGA_04/"},{path:"/03.FPGA/04.USART.html",redirect:"/pages/FPGA_04/"},{name:"v-358b60c5",path:"/pages/FPGA_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-358b60c5").then(t)}},{path:"/pages/FPGA_05/index.html",redirect:"/pages/FPGA_05/"},{path:"/03.FPGA/05.IP.html",redirect:"/pages/FPGA_05/"},{name:"v-10ebe03e",path:"/pages/FPGA_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-10ebe03e").then(t)}},{path:"/pages/FPGA_06/index.html",redirect:"/pages/FPGA_06/"},{path:"/03.FPGA/06.PLL.html",redirect:"/pages/FPGA_06/"},{name:"v-4e27b9b6",path:"/pages/FPGA_07/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4e27b9b6").then(t)}},{path:"/pages/FPGA_07/index.html",redirect:"/pages/FPGA_07/"},{path:"/03.FPGA/07.FIFO_ROM_RAM.html",redirect:"/pages/FPGA_07/"},{name:"v-22f068d8",path:"/pages/PCB_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-22f068d8").then(t)}},{path:"/pages/PCB_01/index.html",redirect:"/pages/PCB_01/"},{path:"/04.PCB Layout/01.PCB_Layout_Design_Process.html",redirect:"/pages/PCB_01/"},{name:"v-c8856c68",path:"/pages/PCB_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c8856c68").then(t)}},{path:"/pages/PCB_02/index.html",redirect:"/pages/PCB_02/"},{path:"/04.PCB Layout/02.Impedence.html",redirect:"/pages/PCB_02/"},{name:"v-6bdd7efc",path:"/pages/PCB_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6bdd7efc").then(t)}},{path:"/pages/PCB_03/index.html",redirect:"/pages/PCB_03/"},{path:"/04.PCB Layout/03.Design_Specification.html",redirect:"/pages/PCB_03/"},{name:"v-d0319f4e",path:"/pages/Linux_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-d0319f4e").then(t)}},{path:"/pages/Linux_01/index.html",redirect:"/pages/Linux_01/"},{path:"/05.IC-focused Universal Linux/01.Linux_System_Info.html",redirect:"/pages/Linux_01/"},{name:"v-075f108a",path:"/pages/Linux_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-075f108a").then(t)}},{path:"/pages/Linux_02/index.html",redirect:"/pages/Linux_02/"},{path:"/05.IC-focused Universal Linux/02.Linux_systemctl.html",redirect:"/pages/Linux_02/"},{name:"v-d263196a",path:"/pages/Linux_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-d263196a").then(t)}},{path:"/pages/Linux_03/index.html",redirect:"/pages/Linux_03/"},{path:"/05.IC-focused Universal Linux/03.useofshell.html",redirect:"/pages/Linux_03/"},{name:"v-358c318b",path:"/pages/Linux_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-358c318b").then(t)}},{path:"/pages/Linux_04/index.html",redirect:"/pages/Linux_04/"},{path:"/05.IC-focused Universal Linux/04.text_process.html",redirect:"/pages/Linux_04/"},{name:"v-123d763a",path:"/pages/Linux_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-123d763a").then(t)}},{path:"/pages/Linux_05/index.html",redirect:"/pages/Linux_05/"},{path:"/05.IC-focused Universal Linux/05.shell_programming.html",redirect:"/pages/Linux_05/"},{name:"v-5a424a08",path:"/pages/Rust_00/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-5a424a08").then(t)}},{path:"/pages/Rust_00/index.html",redirect:"/pages/Rust_00/"},{path:"/06.Rust/00.Rust的基本素养.html",redirect:"/pages/Rust_00/"},{name:"v-b3fd1cf4",path:"/pages/Rust_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-b3fd1cf4").then(t)}},{path:"/pages/Rust_01/index.html",redirect:"/pages/Rust_01/"},{path:"/06.Rust/01.Rust的变量与可变性.html",redirect:"/pages/Rust_01/"},{name:"v-4735483d",path:"/pages/Rust_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-4735483d").then(t)}},{path:"/pages/Rust_02/index.html",redirect:"/pages/Rust_02/"},{path:"/06.Rust/02.Rust的数据类型.html",redirect:"/pages/Rust_02/"},{name:"v-554cdc89",path:"/pages/Rust_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-554cdc89").then(t)}},{path:"/pages/Rust_03/index.html",redirect:"/pages/Rust_03/"},{path:"/06.Rust/03.Rust的函数和注释.html",redirect:"/pages/Rust_03/"},{name:"v-425c0d28",path:"/pages/Rust_04/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-425c0d28").then(t)}},{path:"/pages/Rust_04/index.html",redirect:"/pages/Rust_04/"},{path:"/06.Rust/04.Rust的控制流.html",redirect:"/pages/Rust_04/"},{name:"v-c504442c",path:"/pages/Rust_05/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c504442c").then(t)}},{path:"/pages/Rust_05/index.html",redirect:"/pages/Rust_05/"},{path:"/06.Rust/05.Rust的所有权概念.html",redirect:"/pages/Rust_05/"},{name:"v-6a90bec1",path:"/pages/Rust_06/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-6a90bec1").then(t)}},{path:"/pages/Rust_06/index.html",redirect:"/pages/Rust_06/"},{path:"/06.Rust/06.Rust的引用和借用.html",redirect:"/pages/Rust_06/"},{name:"v-40333d11",path:"/pages/Rust_07/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-40333d11").then(t)}},{path:"/pages/Rust_07/index.html",redirect:"/pages/Rust_07/"},{path:"/06.Rust/07.Rust的Slice类型.html",redirect:"/pages/Rust_07/"},{name:"v-5a59dc7c",path:"/pages/Rust_08/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-5a59dc7c").then(t)}},{path:"/pages/Rust_08/index.html",redirect:"/pages/Rust_08/"},{path:"/06.Rust/08.Rust的结构体类型.html",redirect:"/pages/Rust_08/"},{name:"v-19267156",path:"/pages/Rust_10/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-19267156").then(t)}},{path:"/pages/Rust_10/index.html",redirect:"/pages/Rust_10/"},{path:"/06.Rust/10.Rust的方法.html",redirect:"/pages/Rust_10/"},{name:"v-e45eb658",path:"/pages/Rust_09/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-e45eb658").then(t)}},{path:"/pages/Rust_09/index.html",redirect:"/pages/Rust_09/"},{path:"/06.Rust/09.Rust的结构体的打印与调试.html",redirect:"/pages/Rust_09/"},{name:"v-7bcfc72d",path:"/pages/Rust_11/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-7bcfc72d").then(t)}},{path:"/pages/Rust_11/index.html",redirect:"/pages/Rust_11/"},{path:"/06.Rust/11.Rust的枚举.html",redirect:"/pages/Rust_11/"},{name:"v-7bd6065e",path:"/pages/Rust_12/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-7bd6065e").then(t)}},{path:"/pages/Rust_12/index.html",redirect:"/pages/Rust_12/"},{path:"/06.Rust/12.Rust的match控制流结构.html",redirect:"/pages/Rust_12/"},{name:"v-2f12763c",path:"/pages/Rust_13/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-2f12763c").then(t)}},{path:"/pages/Rust_13/index.html",redirect:"/pages/Rust_13/"},{path:"/06.Rust/13.Rust的语法糖-iflet.html",redirect:"/pages/Rust_13/"},{name:"v-02b66869",path:"/pages/Rust_14/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-02b66869").then(t)}},{path:"/pages/Rust_14/index.html",redirect:"/pages/Rust_14/"},{path:"/06.Rust/14.Rust的模块系统.html",redirect:"/pages/Rust_14/"},{name:"v-a2e945e8",path:"/pages/Rust_17/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-a2e945e8").then(t)}},{path:"/pages/Rust_17/index.html",redirect:"/pages/Rust_17/"},{path:"/06.Rust/17.Rust的HashMap.html",redirect:"/pages/Rust_17/"},{name:"v-f43e611c",path:"/pages/Rust_15/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-f43e611c").then(t)}},{path:"/pages/Rust_15/index.html",redirect:"/pages/Rust_15/"},{path:"/06.Rust/15.Rust的Vector.html",redirect:"/pages/Rust_15/"},{name:"v-3baf18ff",path:"/pages/Python_01/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-3baf18ff").then(t)}},{path:"/pages/Python_01/index.html",redirect:"/pages/Python_01/"},{path:"/07.python/01.numpy 模块.html",redirect:"/pages/Python_01/"},{name:"v-655783a0",path:"/pages/Rust_16/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-655783a0").then(t)}},{path:"/pages/Rust_16/index.html",redirect:"/pages/Rust_16/"},{path:"/06.Rust/16.Rust的String类型基本原理.html",redirect:"/pages/Rust_16/"},{name:"v-dcf90e9e",path:"/pages/Python_02/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-dcf90e9e").then(t)}},{path:"/pages/Python_02/index.html",redirect:"/pages/Python_02/"},{path:"/07.python/02.pandas 模块.html",redirect:"/pages/Python_02/"},{name:"v-01b5feb6",path:"/archives/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-01b5feb6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-51e1c7f6",path:"/pages/Python_03/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-51e1c7f6").then(t)}},{path:"/pages/Python_03/index.html",redirect:"/pages/Python_03/"},{path:"/07.python/03.matplotlib 模块.html",redirect:"/pages/Python_03/"},{name:"v-58b44ebe",path:"/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-58b44ebe").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-c9bd4b28",path:"/message-board/",component:ol,beforeEnter:(n,e,t)=>{ds("Layout","v-c9bd4b28").then(t)}},{path:"/message-board/index.html",redirect:"/message-board/"},{path:"/message_board/留言板.html",redirect:"/message-board/"},{path:"*",component:ol}],ll={title:"原码纪事",description:"vdoing博客主题模板",base:"/",headTags:[["link",{rel:"icon",href:"/img/base/favicon.ico"}],["meta",{name:"keywords",content:"猎户f,golang,vue,go-web,go-admin,go-ldap-admin"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["script",{language:"javascript",type:"text/javascript",src:"/js/pgmanor-self.js"}],["script",{async:!0,src:"https://www.googletagmanager.com/gtag/js?id=G-LPRG9SPLFF"}],["script",{},"\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n      gtag('config', 'G-LPRG9SPLFF');\n    "]],pages:[{title:"博客笔记",frontmatter:{title:"博客笔记",date:"2025-07-08T11:41:49.000Z",permalink:"/pages/Notes/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Notes.html",relativePath:"00.目录页/Notes.md",key:"v-72a9ee7c",path:"/pages/Notes/",headers:[{level:2,title:"IC-focused Universal Linux",slug:"ic-focused-universal-linux",normalizedTitle:"ic-focused universal linux",charIndex:11},{level:2,title:"Verilog HDL",slug:"verilog-hdl",normalizedTitle:"verilog hdl",charIndex:151},{level:2,title:"FPGA",slug:"fpga",normalizedTitle:"fpga",charIndex:293},{level:2,title:"Neural Networks",slug:"neural-networks",normalizedTitle:"neural networks",charIndex:529},{level:2,title:"PCB Lauout",slug:"pcb-lauout",normalizedTitle:"pcb lauout",charIndex:729},{level:2,title:"Rust",slug:"rust",normalizedTitle:"rust",charIndex:853},{level:2,title:"Advanced Python",slug:"advanced-python",normalizedTitle:"advanced python",charIndex:1226}],headersStr:"IC-focused Universal Linux Verilog HDL FPGA Neural Networks PCB Lauout Rust Advanced Python",content:"# 博客笔记\n\n\n# IC-focused Universal Linux\n\n * 01.Linux运行原理\n * 02.进程管理\n * 03.Shell结构\n * 04.文本处理\n * 05.Shell编程\n\n----------------------------------------\n\n\n# Verilog HDL\n\n * 01.Verilog HDL 时序电路的基本元件设计\n * 02.Verilog HDL有限状态机（FSM）设计基础\n * 03.testBench的编写规范\n\n----------------------------------------\n\n\n# FPGA\n\n * FPGA 01.一次最小的FPGA工程构建-从闪烁到流水\n * FPGA 02.按键不是输入信号，而是一段时间——一次关于消抖的记录\n * FPGA 03.我与 PWM 的爱恨情仇\n * FPGA 04.串口通信\n * FPGA 05.IP 核的基本使用与注意事项\n * FPGA 06.PLL 锁相环的认识\n * FPGA 07.FIFO、ROM、RAM理解\n\n----------------------------------------\n\n\n# Neural Networks\n\n * NN 01. 关于线性网络的研究和记录\n * NN 02.若干损失函数的研究\n * NN 03.若干激活函数的研究\n * NN 04.卷积和LeNet神经网络\n * NN 05.AlexNet 与使用“块”的神经网络\n * NN 06.并行块和深度神经网络的深究解释\n\n----------------------------------------\n\n\n# PCB Lauout\n\n * Layout 01.PCB设计的流程概述\n * Layout 02.阻抗\n * Layout 03.常用模块的PCB绘制要点\n\n----------------------------------------\n\n\n# Rust\n\n * 00.Rust的基本素养\n * 01.Rust的变量与可变性\n * 02.Rust的数据类型\n * 03.Rust的函数和注释\n * 04.Rust的控制流\n * 05.Rust的所有权概念\n * 06.Rust的引用和借用\n * 07.Rust的Slice类型\n * 08.Rust的结构体类型\n * 09.Rust的结构体的打印与调试\n * 10.Rust的方法\n * 11.Rust的枚举\n * 12.Rust的match控制流结构\n * 13.Rust的语法糖-iflet\n * 14.Rust的模块系统\n * 15.Rust的Vector\n * 16.Rust的String类型基本原理\n * 17.Rust的HashMap\n\n----------------------------------------\n\n\n# Advanced Python\n\n * 01.numpy 模块\n * 02.pandas 模块\n * 03.matplotlib 模块\n\n----------------------------------------\n\n留言板",normalizedContent:"# 博客笔记\n\n\n# ic-focused universal linux\n\n * 01.linux运行原理\n * 02.进程管理\n * 03.shell结构\n * 04.文本处理\n * 05.shell编程\n\n----------------------------------------\n\n\n# verilog hdl\n\n * 01.verilog hdl 时序电路的基本元件设计\n * 02.verilog hdl有限状态机（fsm）设计基础\n * 03.testbench的编写规范\n\n----------------------------------------\n\n\n# fpga\n\n * fpga 01.一次最小的fpga工程构建-从闪烁到流水\n * fpga 02.按键不是输入信号，而是一段时间——一次关于消抖的记录\n * fpga 03.我与 pwm 的爱恨情仇\n * fpga 04.串口通信\n * fpga 05.ip 核的基本使用与注意事项\n * fpga 06.pll 锁相环的认识\n * fpga 07.fifo、rom、ram理解\n\n----------------------------------------\n\n\n# neural networks\n\n * nn 01. 关于线性网络的研究和记录\n * nn 02.若干损失函数的研究\n * nn 03.若干激活函数的研究\n * nn 04.卷积和lenet神经网络\n * nn 05.alexnet 与使用“块”的神经网络\n * nn 06.并行块和深度神经网络的深究解释\n\n----------------------------------------\n\n\n# pcb lauout\n\n * layout 01.pcb设计的流程概述\n * layout 02.阻抗\n * layout 03.常用模块的pcb绘制要点\n\n----------------------------------------\n\n\n# rust\n\n * 00.rust的基本素养\n * 01.rust的变量与可变性\n * 02.rust的数据类型\n * 03.rust的函数和注释\n * 04.rust的控制流\n * 05.rust的所有权概念\n * 06.rust的引用和借用\n * 07.rust的slice类型\n * 08.rust的结构体类型\n * 09.rust的结构体的打印与调试\n * 10.rust的方法\n * 11.rust的枚举\n * 12.rust的match控制流结构\n * 13.rust的语法糖-iflet\n * 14.rust的模块系统\n * 15.rust的vector\n * 16.rust的string类型基本原理\n * 17.rust的hashmap\n\n----------------------------------------\n\n\n# advanced python\n\n * 01.numpy 模块\n * 02.pandas 模块\n * 03.matplotlib 模块\n\n----------------------------------------\n\n留言板",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"项目",frontmatter:{title:"项目",date:"2025-07-08T11:41:49.000Z",permalink:"/pages/Projects/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Projects.html",relativePath:"00.目录页/Projects.md",key:"v-c2184f54",path:"/pages/Projects/",headersStr:null,content:"# 项目\n\n留言板",normalizedContent:"# 项目\n\n留言板",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"吐槽",frontmatter:{title:"吐槽",date:"2025-08-17T21:35:00.000Z",permalink:"/pages/Teasting/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/Teasting.html",relativePath:"00.目录页/Teasting.md",key:"v-4a1eacb6",path:"/pages/Teasting/",headersStr:null,content:"# 吐槽\n\n留言板",normalizedContent:"# 吐槽\n\n留言板",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"HDL03.testBench的编写规范",frontmatter:{title:"HDL03.testBench的编写规范",date:"2025-12-06T10:30:00.000Z",permalink:"/pages/Verilog_03/"},regularPath:"/01.Verilog%20HDL/3.testBench%E7%9A%84%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83.html",relativePath:"01.Verilog HDL/3.testBench的编写规范.md",key:"v-a032a962",path:"/pages/Verilog_03/",headers:[{level:2,title:"一、为什么需要 TestBench？",slug:"一、为什么需要-testbench",normalizedTitle:"一、为什么需要 testbench？",charIndex:37},{level:2,title:"1. timescale",slug:"_1-timescale",normalizedTitle:"1. timescale",charIndex:1335},{level:2,title:"2. 信号声明（TestBench 的输入用 reg，输出用 wire）",slug:"_2-信号声明-testbench-的输入用-reg-输出用-wire",normalizedTitle:"2. 信号声明（testbench 的输入用 reg，输出用 wire）",charIndex:1469},{level:2,title:"3. 实例化被测模块（DUT）",slug:"_3-实例化被测模块-dut",normalizedTitle:"3. 实例化被测模块（dut）",charIndex:1691},{level:2,title:"4. 时钟生成",slug:"_4-时钟生成",normalizedTitle:"4. 时钟生成",charIndex:1873},{level:2,title:"5. 激励序列（给输入信号）",slug:"_5-激励序列-给输入信号",normalizedTitle:"5. 激励序列（给输入信号）",charIndex:2035},{level:2,title:"6. 监控打印（可选，但很有用）",slug:"_6-监控打印-可选-但很有用",normalizedTitle:"6. 监控打印（可选，但很有用）",charIndex:2294},{level:2,title:"① 计数器模块（counter4.v）",slug:"_1-计数器模块-counter4-v",normalizedTitle:"① 计数器模块（counter4.v）",charIndex:2566},{level:2,title:"② TestBench（tb_counter4.v）",slug:"_2-testbench-tb-counter4-v",normalizedTitle:"② testbench（tb_counter4.v）",charIndex:2898}],headersStr:"一、为什么需要 TestBench？ 1. timescale 2. 信号声明（TestBench 的输入用 reg，输出用 wire） 3. 实例化被测模块（DUT） 4. 时钟生成 5. 激励序列（给输入信号） 6. 监控打印（可选，但很有用） ① 计数器模块（counter4.v） ② TestBench（tb_counter4.v）",content:'# Verilog TestBench 入门教程（超适合初学者）\n\n\n# 一、为什么需要 TestBench？\n\n在 FPGA/ASIC 的开发流程中，TestBench 就是用来测试你写的 Verilog 模块的“仿真脚本”。 它的任务很简单：\n\n * 给你的模块 输入信号\n * 观察 输出信号\n * 判断模块行为是否正确（用波形或打印）\n\n不用上板，不用烧录，就能提前把 bug 查出来。\n\n只要你写 RTL，就必须会写 TestBench。\n\n----------------------------------------\n\n\n# 二、TestBench 的基本框架\n\n下面是一份最常见、最基础的 TestBench 模板，初学者只要理解这个结构，就能搞定 90% 的仿真需求。\n\n`timescale 1ns/1ps\n\nmodule tb;\n\n    // ========= 1. 声明信号（输入用 reg，输出用 wire） =========\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // ========= 2. 实例化被测模块 (DUT) =========\n    counter4 dut (\n        .clk  (clk),\n        .rst_n(rst_n),\n        .out  (out)\n    );\n\n    // ========= 3. 时钟生成 =========\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;   // 10ns 一周期\n    end\n\n    // ========= 4. 激励任务（给输入信号） =========\n    initial begin\n        rst_n = 0;       // 上电复位\n        #20;\n        rst_n = 1;       // 释放复位\n\n        // ……后续可以加更多测试序列\n\n        #200 $finish;    // 结束仿真\n    end\n\n    // ========= 5. 可选：监控输出 =========\n    initial begin\n        $monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n----------------------------------------\n\n\n# 三、框架各个部分说明\n\n下面我用最简单、最人话的解释，把每一步讲清楚。\n\n----------------------------------------\n\n\n# 1. timescale\n\n`timescale 1ns/1ps\n\n\n1\n\n\n表示：\n\n * 仿真时间单位：1ns\n * 时间精度：1ps（用于延迟取整）\n\n这是仿真必写项。\n\n----------------------------------------\n\n\n# 2. 信号声明（TestBench 的输入用 reg，输出用 wire）\n\nreg clk;\nreg rst_n;\nwire [3:0] out;\n\n\n1\n2\n3\n\n\n为什么输入用 reg？ 因为 TestBench 自己要给这些信号赋值，赋值只能给 reg。\n\n为什么输出用 wire？ 因为输出是 DUT 驱动的，不是 TestBench 驱动。\n\n----------------------------------------\n\n\n# 3. 实例化被测模块（DUT）\n\ncounter4 dut (\n    .clk  (clk),\n    .rst_n(rst_n),\n    .out  (out)\n);\n\n\n1\n2\n3\n4\n5\n\n\nTestBench 最核心的一步： 把你写的模块“放进测试环境里”。\n\n----------------------------------------\n\n\n# 4. 时钟生成\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n\n1\n2\n3\n4\n\n\n这段代码生成一个周期为 10ns 的时钟。 基本是所有同步逻辑仿真必备。\n\n----------------------------------------\n\n\n# 5. 激励序列（给输入信号）\n\ninitial begin\n    rst_n = 0;\n    #20;\n    rst_n = 1;\n    #200 $finish;\nend\n\n\n1\n2\n3\n4\n5\n6\n\n * 设置输入信号\n * 等待一段时间（用 # 延迟）\n * 继续设置下一组输入信号\n * 最后用 $finish 结束仿真\n\n这块就是“TestBench 的灵魂”：你给它什么输入，它就会在波形中跑出对应行为。\n\n----------------------------------------\n\n\n# 6. 监控打印（可选，但很有用）\n\n$monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n\n\n1\n\n\n波形能看得出来，但有时打印更方便。\n\n----------------------------------------\n\n\n# 四、完整示例：4 位同步计数器 + TestBench\n\n下面来一个真正能跑的例子 —— 从 RTL 到 TestBench，初学者一看就懂。\n\n----------------------------------------\n\n\n# ① 计数器模块（counter4.v）\n\nmodule counter4(\n    input clk,\n    input rst_n,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 0;\n        else\n            out <= out + 1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# ② TestBench（tb_counter4.v）\n\n`timescale 1ns/1ps\n\nmodule tb_counter4;\n\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // 实例化DUT\n    counter4 dut(\n        .clk(clk),\n        .rst_n(rst_n),\n        .out(out)\n    );\n\n    // 时钟\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // 激励\n    initial begin\n        rst_n = 0;\n        #20;\n        rst_n = 1;\n\n        // 运行 16 个计数周期\n        #200;\n\n        $finish;\n    end\n\n    // 监控输出\n    initial begin\n        $monitor("time=%0t  clk=%b  rst_n=%b  out=%d", \n                    $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n\n# 五、波形应该长这样（逻辑上）\n\nrst_n:  _____-----------......\nclk  : _-_-_-_-_-_-_-_-_-_....\nout  : 0000 0001 0010 ... 1111 再回到 0000\n\n\n1\n2\n3\n\n\n只要你看到计数正常累加，就说明 DUT 正常。',normalizedContent:'# verilog testbench 入门教程（超适合初学者）\n\n\n# 一、为什么需要 testbench？\n\n在 fpga/asic 的开发流程中，testbench 就是用来测试你写的 verilog 模块的“仿真脚本”。 它的任务很简单：\n\n * 给你的模块 输入信号\n * 观察 输出信号\n * 判断模块行为是否正确（用波形或打印）\n\n不用上板，不用烧录，就能提前把 bug 查出来。\n\n只要你写 rtl，就必须会写 testbench。\n\n----------------------------------------\n\n\n# 二、testbench 的基本框架\n\n下面是一份最常见、最基础的 testbench 模板，初学者只要理解这个结构，就能搞定 90% 的仿真需求。\n\n`timescale 1ns/1ps\n\nmodule tb;\n\n    // ========= 1. 声明信号（输入用 reg，输出用 wire） =========\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // ========= 2. 实例化被测模块 (dut) =========\n    counter4 dut (\n        .clk  (clk),\n        .rst_n(rst_n),\n        .out  (out)\n    );\n\n    // ========= 3. 时钟生成 =========\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;   // 10ns 一周期\n    end\n\n    // ========= 4. 激励任务（给输入信号） =========\n    initial begin\n        rst_n = 0;       // 上电复位\n        #20;\n        rst_n = 1;       // 释放复位\n\n        // ……后续可以加更多测试序列\n\n        #200 $finish;    // 结束仿真\n    end\n\n    // ========= 5. 可选：监控输出 =========\n    initial begin\n        $monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n----------------------------------------\n\n\n# 三、框架各个部分说明\n\n下面我用最简单、最人话的解释，把每一步讲清楚。\n\n----------------------------------------\n\n\n# 1. timescale\n\n`timescale 1ns/1ps\n\n\n1\n\n\n表示：\n\n * 仿真时间单位：1ns\n * 时间精度：1ps（用于延迟取整）\n\n这是仿真必写项。\n\n----------------------------------------\n\n\n# 2. 信号声明（testbench 的输入用 reg，输出用 wire）\n\nreg clk;\nreg rst_n;\nwire [3:0] out;\n\n\n1\n2\n3\n\n\n为什么输入用 reg？ 因为 testbench 自己要给这些信号赋值，赋值只能给 reg。\n\n为什么输出用 wire？ 因为输出是 dut 驱动的，不是 testbench 驱动。\n\n----------------------------------------\n\n\n# 3. 实例化被测模块（dut）\n\ncounter4 dut (\n    .clk  (clk),\n    .rst_n(rst_n),\n    .out  (out)\n);\n\n\n1\n2\n3\n4\n5\n\n\ntestbench 最核心的一步： 把你写的模块“放进测试环境里”。\n\n----------------------------------------\n\n\n# 4. 时钟生成\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n\n1\n2\n3\n4\n\n\n这段代码生成一个周期为 10ns 的时钟。 基本是所有同步逻辑仿真必备。\n\n----------------------------------------\n\n\n# 5. 激励序列（给输入信号）\n\ninitial begin\n    rst_n = 0;\n    #20;\n    rst_n = 1;\n    #200 $finish;\nend\n\n\n1\n2\n3\n4\n5\n6\n\n * 设置输入信号\n * 等待一段时间（用 # 延迟）\n * 继续设置下一组输入信号\n * 最后用 $finish 结束仿真\n\n这块就是“testbench 的灵魂”：你给它什么输入，它就会在波形中跑出对应行为。\n\n----------------------------------------\n\n\n# 6. 监控打印（可选，但很有用）\n\n$monitor("t=%0t clk=%b rst_n=%b out=%d", $time, clk, rst_n, out);\n\n\n1\n\n\n波形能看得出来，但有时打印更方便。\n\n----------------------------------------\n\n\n# 四、完整示例：4 位同步计数器 + testbench\n\n下面来一个真正能跑的例子 —— 从 rtl 到 testbench，初学者一看就懂。\n\n----------------------------------------\n\n\n# ① 计数器模块（counter4.v）\n\nmodule counter4(\n    input clk,\n    input rst_n,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 0;\n        else\n            out <= out + 1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\n\n# ② testbench（tb_counter4.v）\n\n`timescale 1ns/1ps\n\nmodule tb_counter4;\n\n    reg clk;\n    reg rst_n;\n    wire [3:0] out;\n\n    // 实例化dut\n    counter4 dut(\n        .clk(clk),\n        .rst_n(rst_n),\n        .out(out)\n    );\n\n    // 时钟\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // 激励\n    initial begin\n        rst_n = 0;\n        #20;\n        rst_n = 1;\n\n        // 运行 16 个计数周期\n        #200;\n\n        $finish;\n    end\n\n    // 监控输出\n    initial begin\n        $monitor("time=%0t  clk=%b  rst_n=%b  out=%d", \n                    $time, clk, rst_n, out);\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n\n# 五、波形应该长这样（逻辑上）\n\nrst_n:  _____-----------......\nclk  : _-_-_-_-_-_-_-_-_-_....\nout  : 0000 0001 0010 ... 1111 再回到 0000\n\n\n1\n2\n3\n\n\n只要你看到计数正常累加，就说明 dut 正常。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"HDL01.Verilog HDL 时序电路的基本元件设计",frontmatter:{title:"HDL01.Verilog HDL 时序电路的基本元件设计",date:"2025-08-13T16:00:00.000Z",permalink:"/pages/Verilog_01/"},regularPath:"/01.Verilog%20HDL/1.Verilog%20HDL%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6%E8%AE%BE%E8%AE%A1.html",relativePath:"01.Verilog HDL/1.Verilog HDL时序电路的基本元件设计.md",key:"v-570b2315",path:"/pages/Verilog_01/",headers:[{level:2,title:"1. 基本触发器",slug:"_1-基本触发器",normalizedTitle:"1. 基本触发器",charIndex:206},{level:3,title:"1.1 D 触发器（基础版）",slug:"_1-1-d-触发器-基础版",normalizedTitle:"1.1 d 触发器（基础版）",charIndex:219},{level:3,title:"1.2 同步复位与异步复位",slug:"_1-2-同步复位与异步复位",normalizedTitle:"1.2 同步复位与异步复位",charIndex:448},{level:3,title:"1.3 T 触发器",slug:"_1-3-t-触发器",normalizedTitle:"1.3 t 触发器",charIndex:1208},{level:2,title:"2. 计数器",slug:"_2-计数器",normalizedTitle:"2. 计数器",charIndex:1537},{level:3,title:"2.1 一位二进制计数器（分频器）",slug:"_2-1-一位二进制计数器-分频器",normalizedTitle:"2.1 一位二进制计数器（分频器）",charIndex:1580},{level:3,title:"2.2 模 M 计数器",slug:"_2-2-模-m-计数器",normalizedTitle:"2.2 模 m 计数器",charIndex:1764},{level:2,title:"3. 移位寄存器",slug:"_3-移位寄存器",normalizedTitle:"3. 移位寄存器",charIndex:2278},{level:3,title:"3.1 环形（循环）移位寄存器",slug:"_3-1-环形-循环-移位寄存器",normalizedTitle:"3.1 环形（循环）移位寄存器",charIndex:2319},{level:3,title:"3.2 线性反馈移位寄存器（LFSR）",slug:"_3-2-线性反馈移位寄存器-lfsr",normalizedTitle:"3.2 线性反馈移位寄存器（lfsr）",charIndex:2656},{level:2,title:"4. 序列 / 信号发生器",slug:"_4-序列-信号发生器",normalizedTitle:"4. 序列 / 信号发生器",charIndex:3063},{level:3,title:"4.1 移位寄存器型（按位存储并移出）",slug:"_4-1-移位寄存器型-按位存储并移出",normalizedTitle:"4.1 移位寄存器型（按位存储并移出）",charIndex:3133},{level:3,title:"4.2 反馈组合型（以 LFSR 为例）",slug:"_4-2-反馈组合型-以-lfsr-为例",normalizedTitle:"4.2 反馈组合型（以 lfsr 为例）",charIndex:3616},{level:3,title:"4.3 计数器型（查表输出）",slug:"_4-3-计数器型-查表输出",normalizedTitle:"4.3 计数器型（查表输出）",charIndex:3677},{level:2,title:"5. 设计要点小结",slug:"_5-设计要点小结",normalizedTitle:"5. 设计要点小结",charIndex:4529}],headersStr:"1. 基本触发器 1.1 D 触发器（基础版） 1.2 同步复位与异步复位 1.3 T 触发器 2. 计数器 2.1 一位二进制计数器（分频器） 2.2 模 M 计数器 3. 移位寄存器 3.1 环形（循环）移位寄存器 3.2 线性反馈移位寄存器（LFSR） 4. 序列 / 信号发生器 4.1 移位寄存器型（按位存储并移出） 4.2 反馈组合型（以 LFSR 为例） 4.3 计数器型（查表输出） 5. 设计要点小结",content:"# Verilog HDL：时序电路的基本元件设计\n\n本文汇总并整理了常见的时序电路基本元件：触发器（D、T）、计数器、移位寄存器与序列/信号发生器的常用实现与设计要点。目标是给出工程友好的 Verilog 模块模板与设计注意事项，便于快速上手与复用。\n\n关键思想：时序电路 = 组合逻辑 + 存储元件（触发器）。时钟边沿同步所有状态更新，复位策略（同步/异步）与时钟域设计决定可靠性与复杂度。\n\n--\n\n\n# 1. 基本触发器\n\n\n# 1.1 D 触发器（基础版）\n\n最常见的存储单元，时钟边沿把 d 采样到 q 并保持。\n\nmodule d_ff_basic (\n    input  wire clk,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 1.2 同步复位与异步复位\n\n * 同步复位（rst_n 在时钟边沿生效）：复位动作与数据更新对齐，行为更可预测，但需要等时钟。\n * 异步复位（rst_n 立即生效）：快速清零，释放时需做去抖与同步以避免亚稳态。\n\n示例：同步复位与异步复位的 DFF\n\nmodule d_ff_sync_rst (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else\n            q <= data_in;\n    end\nendmodule\n\nmodule d_ff_async_rst (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 设计要点：若使用异步复位，务必在复位释放后将重要信号做同步处理，避免亚稳态传播。\n\n\n# 1.3 T 触发器\n\n用于分频与计数，T=1 时翻转状态，T=0 时保持。\n\nmodule t_ff (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire T,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else if (T)\n            q <= ~q;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n--\n\n\n# 2. 计数器\n\n计数器是最常见的时序控制元件，可用于分频、延时、地址生成等。\n\n\n# 2.1 一位二进制计数器（分频器）\n\nmodule counter_1bit (\n    input  wire clk,\n    output reg  Q\n);\n    always @(posedge clk) begin\n        Q <= ~Q; // 分频 / 翻转\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.2 模 M 计数器\n\n设计步骤：确定需要的位数 N（满足 2N>M2^{N} > M2N>M），计数到 M-1 后清零。\n\nmodule counter_modM #(\n    parameter M = 10\n) (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [$clog2(M)-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == M-1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 注：在综合与时序分析时，避免把大宽度加法或比较放在异步路径上，尽量使用流水或分频级联来减轻组合逻辑负担。\n\n--\n\n\n# 3. 移位寄存器\n\n移位寄存器用于数据延迟、串并转换、序列检测与生成等。\n\n\n# 3.1 环形（循环）移位寄存器\n\nmodule shift_reg_ring (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [3:0] D_init,\n    output reg  [3:0] D\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            D <= D_init;\n        else\n            D <= {D[2:0], D[3]};\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.2 线性反馈移位寄存器（LFSR）\n\nLFSR 是低资源的伪随机序列生成器，反馈函数取决于多项式。用于测试、加扰与随机化。\n\nmodule lfsr_4 (\n    input  wire clk,\n    input  wire rst_n,\n    output reg [3:0] q\n);\n    wire feedback = q[3] ^ q[2]; // 示例反馈，具体多项式按需求选择\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 4'b0001;\n        else\n            q <= {q[2:0], feedback};\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n--\n\n\n# 4. 序列 / 信号发生器\n\n常见实现方式：移位寄存器型、反馈组合型（如 LFSR）、计数器型。选择依据为资源、序列长度与复杂度。\n\n\n# 4.1 移位寄存器型（按位存储并移出）\n\nmodule seq_gen_shift #(\n    parameter N = 8\n) (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [N-1:0] seq_init,\n    output wire seq_out\n);\n    reg [N-1:0] shift_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_reg <= seq_init;\n        else\n            shift_reg <= {shift_reg[N-2:0], shift_reg[N-1]};\n    end\n    assign seq_out = shift_reg[N-1];\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.2 反馈组合型（以 LFSR 为例）\n\n见前面 LFSR 示例。反馈型优点是用很少的触发器可产生很长的序列。\n\n\n# 4.3 计数器型（查表输出）\n\n适用于需要任意、非线性序列时：用计数器做地址，再用 case/ROM 输出序列位。\n\nmodule seq_gen_counter #(\n    parameter M = 8\n) (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  seq_out\n);\n    reg [$clog2(M)-1:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == M-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n    always @(*) begin\n        case (cnt)\n            0: seq_out = 1'b1;\n            1: seq_out = 1'b0;\n            2: seq_out = 1'b1;\n            3: seq_out = 1'b1;\n            4: seq_out = 1'b0;\n            5: seq_out = 1'b0;\n            6: seq_out = 1'b1;\n            7: seq_out = 1'b1;\n            default: seq_out = 1'b0;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n--\n\n\n# 5. 设计要点小结\n\n * 明确复位策略（同步 vs 异步），并对异步复位释放做同步处理。\n * 将复杂的组合逻辑从时钟路径中剥离，必要时做流水或拆分时钟域。\n * 使用参数化（parameter、$clog2）提高模块可复用性。\n * LFSR 与移位寄存器适合低成本序列生成，计数器+查表适合任意序列。",normalizedContent:"# verilog hdl：时序电路的基本元件设计\n\n本文汇总并整理了常见的时序电路基本元件：触发器（d、t）、计数器、移位寄存器与序列/信号发生器的常用实现与设计要点。目标是给出工程友好的 verilog 模块模板与设计注意事项，便于快速上手与复用。\n\n关键思想：时序电路 = 组合逻辑 + 存储元件（触发器）。时钟边沿同步所有状态更新，复位策略（同步/异步）与时钟域设计决定可靠性与复杂度。\n\n--\n\n\n# 1. 基本触发器\n\n\n# 1.1 d 触发器（基础版）\n\n最常见的存储单元，时钟边沿把 d 采样到 q 并保持。\n\nmodule d_ff_basic (\n    input  wire clk,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 1.2 同步复位与异步复位\n\n * 同步复位（rst_n 在时钟边沿生效）：复位动作与数据更新对齐，行为更可预测，但需要等时钟。\n * 异步复位（rst_n 立即生效）：快速清零，释放时需做去抖与同步以避免亚稳态。\n\n示例：同步复位与异步复位的 dff\n\nmodule d_ff_sync_rst (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else\n            q <= data_in;\n    end\nendmodule\n\nmodule d_ff_async_rst (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire data_in,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else\n            q <= data_in;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> 设计要点：若使用异步复位，务必在复位释放后将重要信号做同步处理，避免亚稳态传播。\n\n\n# 1.3 t 触发器\n\n用于分频与计数，t=1 时翻转状态，t=0 时保持。\n\nmodule t_ff (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire t,\n    output reg  q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n--\n\n\n# 2. 计数器\n\n计数器是最常见的时序控制元件，可用于分频、延时、地址生成等。\n\n\n# 2.1 一位二进制计数器（分频器）\n\nmodule counter_1bit (\n    input  wire clk,\n    output reg  q\n);\n    always @(posedge clk) begin\n        q <= ~q; // 分频 / 翻转\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.2 模 m 计数器\n\n设计步骤：确定需要的位数 n（满足 2n>m2^{n} > m2n>m），计数到 m-1 后清零。\n\nmodule counter_modm #(\n    parameter m = 10\n) (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [$clog2(m)-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == m-1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 注：在综合与时序分析时，避免把大宽度加法或比较放在异步路径上，尽量使用流水或分频级联来减轻组合逻辑负担。\n\n--\n\n\n# 3. 移位寄存器\n\n移位寄存器用于数据延迟、串并转换、序列检测与生成等。\n\n\n# 3.1 环形（循环）移位寄存器\n\nmodule shift_reg_ring (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [3:0] d_init,\n    output reg  [3:0] d\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            d <= d_init;\n        else\n            d <= {d[2:0], d[3]};\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.2 线性反馈移位寄存器（lfsr）\n\nlfsr 是低资源的伪随机序列生成器，反馈函数取决于多项式。用于测试、加扰与随机化。\n\nmodule lfsr_4 (\n    input  wire clk,\n    input  wire rst_n,\n    output reg [3:0] q\n);\n    wire feedback = q[3] ^ q[2]; // 示例反馈，具体多项式按需求选择\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 4'b0001;\n        else\n            q <= {q[2:0], feedback};\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n--\n\n\n# 4. 序列 / 信号发生器\n\n常见实现方式：移位寄存器型、反馈组合型（如 lfsr）、计数器型。选择依据为资源、序列长度与复杂度。\n\n\n# 4.1 移位寄存器型（按位存储并移出）\n\nmodule seq_gen_shift #(\n    parameter n = 8\n) (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [n-1:0] seq_init,\n    output wire seq_out\n);\n    reg [n-1:0] shift_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_reg <= seq_init;\n        else\n            shift_reg <= {shift_reg[n-2:0], shift_reg[n-1]};\n    end\n    assign seq_out = shift_reg[n-1];\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4.2 反馈组合型（以 lfsr 为例）\n\n见前面 lfsr 示例。反馈型优点是用很少的触发器可产生很长的序列。\n\n\n# 4.3 计数器型（查表输出）\n\n适用于需要任意、非线性序列时：用计数器做地址，再用 case/rom 输出序列位。\n\nmodule seq_gen_counter #(\n    parameter m = 8\n) (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  seq_out\n);\n    reg [$clog2(m)-1:0] cnt;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (cnt == m-1)\n            cnt <= 0;\n        else\n            cnt <= cnt + 1;\n    end\n    always @(*) begin\n        case (cnt)\n            0: seq_out = 1'b1;\n            1: seq_out = 1'b0;\n            2: seq_out = 1'b1;\n            3: seq_out = 1'b1;\n            4: seq_out = 1'b0;\n            5: seq_out = 1'b0;\n            6: seq_out = 1'b1;\n            7: seq_out = 1'b1;\n            default: seq_out = 1'b0;\n        endcase\n    end\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n--\n\n\n# 5. 设计要点小结\n\n * 明确复位策略（同步 vs 异步），并对异步复位释放做同步处理。\n * 将复杂的组合逻辑从时钟路径中剥离，必要时做流水或拆分时钟域。\n * 使用参数化（parameter、$clog2）提高模块可复用性。\n * lfsr 与移位寄存器适合低成本序列生成，计数器+查表适合任意序列。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 01.关于线性网络的研究和记录",frontmatter:{title:"NN 01.关于线性网络的研究和记录",date:"2026-01-31T22:00:00.000Z",permalink:"/pages/NN_01/"},regularPath:"/02.Neural%20Networks/01.About_Linear_NN.html",relativePath:"02.Neural Networks/01.About_Linear_NN.md",key:"v-4e39d388",path:"/pages/NN_01/",headers:[{level:2,title:"一、前置的基本概念",slug:"一、前置的基本概念",normalizedTitle:"一、前置的基本概念",charIndex:84},{level:3,title:"1. 张量（Tensor）",slug:"_1-张量-tensor",normalizedTitle:"1. 张量（tensor）",charIndex:98},{level:3,title:"2. 向量的方向约定",slug:"_2-向量的方向约定",normalizedTitle:"2. 向量的方向约定",charIndex:227},{level:3,title:"3. 范数（Norm）",slug:"_3-范数-norm",normalizedTitle:"3. 范数（norm）",charIndex:401},{level:3,title:"4. 自动微分（Automatic Differentiation）",slug:"_4-自动微分-automatic-differentiation",normalizedTitle:"4. 自动微分（automatic differentiation）",charIndex:660},{level:3,title:"5. 计算图（Computation Graph）",slug:"_5-计算图-computation-graph",normalizedTitle:"5. 计算图（computation graph）",charIndex:760},{level:3,title:"6. 反向传播（Backpropagation）",slug:"_6-反向传播-backpropagation",normalizedTitle:"6. 反向传播（backpropagation）",charIndex:849},{level:2,title:"二、随机梯度下降",slug:"二、随机梯度下降",normalizedTitle:"二、随机梯度下降",charIndex:940},{level:2,title:"三、线性回归模型",slug:"三、线性回归模型",normalizedTitle:"三、线性回归模型",charIndex:1352},{level:2,title:"四、损失函数",slug:"四、损失函数",normalizedTitle:"四、损失函数",charIndex:1796},{level:3,title:"1. 平方损失函数",slug:"_1-平方损失函数",normalizedTitle:"1. 平方损失函数",charIndex:1807},{level:3,title:"2. 总体损失函数",slug:"_2-总体损失函数",normalizedTitle:"2. 总体损失函数",charIndex:1972}],headersStr:"一、前置的基本概念 1. 张量（Tensor） 2. 向量的方向约定 3. 范数（Norm） 4. 自动微分（Automatic Differentiation） 5. 计算图（Computation Graph） 6. 反向传播（Backpropagation） 二、随机梯度下降 三、线性回归模型 四、损失函数 1. 平方损失函数 2. 总体损失函数",content:"本章节用于记录我在学习《动手学深度学习》（D2L）过程中，对线性神经网络相关内容的理解与整理。\n重点不在复述教材，而在于理清一些容易被忽略或想当然的基础概念。\n\n\n# 一、前置的基本概念\n\n\n# 1. 张量（Tensor）\n\n张量可以理解为由数值组成的多维数组。\n\n * 一维张量称为向量（vector）\n * 二维张量称为矩阵（matrix）\n * 更高维的统称为张量（tensor）\n\n在深度学习中，张量是数据、参数以及梯度的统一表示形式。\n\n\n# 2. 向量的方向约定\n\n在数学与深度学习中，向量默认采用列向量形式，例如：\n\nx=[x1x2]∈R2 \\mathbf{x} = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} \\in \\mathbb{R}^{2} x=[x1 x2 ]∈R2\n\n这一约定会直接影响矩阵乘法是否合法，也是后续公式推导的基础。\n\n\n# 3. 范数（Norm）\n\n范数用于衡量向量或矩阵的大小。\n\n向量的 L2 范数定义为：\n\n∥x∥2=∑i=1nxi2 \\lVert \\mathbf{x} \\rVert_2 = \\sqrt{\\sum_{i=1}^{n} x_i^2} ∥x∥2 =i=1∑n xi2\n\n矩阵的 L2 范数（Frobenius 范数）定义为：\n\n∥X∥F=∑i∑jXij2 \\lVert \\mathbf{X} \\rVert_F = \\sqrt{\\sum_{i}\\sum_{j} X_{ij}^2} ∥X∥F =i∑ j∑ Xij2\n\n\n# 4. 自动微分（Automatic Differentiation）\n\n自动微分是深度学习框架提供的一种机制，用于自动计算梯度。\n它可以避免手动求导带来的错误，并且在复杂网络中依然保持高效。\n\n\n# 5. 计算图（Computation Graph）\n\n计算图是框架在执行正向与反向传播时构建的一种有向图结构。\n\n * 节点表示变量或中间结果\n * 边表示算术运算关系\n\n\n# 6. 反向传播（Backpropagation）\n\n反向传播利用微积分中的链式法则，根据损失函数对参数的梯度来更新模型参数。\n在张量层面，本质上是梯度在计算图中的逐层传递。\n\n\n# 二、随机梯度下降\n\n在实际训练中，通常采用小批量随机梯度下降（Mini-batch SGD）。\n\n参数更新公式为：\n\n(w,b)←(w,b)−η∣B∣∑i∈B∇(w,b) ℓ(i) (\\mathbf{w}, b) \\leftarrow (\\mathbf{w}, b) - \\frac{\\eta}{|\\mathcal{B}|} \\sum_{i \\in \\mathcal{B}} \\nabla_{(\\mathbf{w}, b)} \\, \\ell^{(i)} (w,b)←(w,b)−∣B∣η i∈B∑ ∇(w,b) ℓ(i)\n\n其中：\n\n * B\\mathcal{B}B 表示一个小批量样本集合\n * ∣B∣|\\mathcal{B}|∣B∣ 表示批量大小（batch size）\n * η\\etaη 表示学习率（learning rate）\n * ℓ(i)\\ell^{(i)}ℓ(i) 表示第 iii 个样本对应的损失\n\n\n# 三、线性回归模型\n\n设数据集中共有 nnn 个样本，对于第 iii 个样本，其输入向量表示为：\n\nx(i)=[x1(i)x2(i)]∈R2 \\mathbf{x}^{(i)} = \\begin{bmatrix} x_1^{(i)} \\\\ x_2^{(i)} \\end{bmatrix} \\in \\mathbb{R}^{2} x(i)=[x1(i) x2(i) ]∈R2\n\n对应的标签为标量 y(i)y^{(i)}y(i)。\n\n模型参数定义为：\n\n权重向量：\n\nw=[w1w2]∈R2 \\mathbf{w} = \\begin{bmatrix} w_1 \\\\ w_2 \\end{bmatrix} \\in \\mathbb{R}^{2} w=[w1 w2 ]∈R2\n\n偏置为标量 bbb。\n\n线性回归模型的预测形式为：\n\ny^(i)=w⊤x(i)+b \\hat{y}^{(i)} = \\mathbf{w}^\\top \\mathbf{x}^{(i)} + b y^ (i)=w⊤x(i)+b\n\n\n# 四、损失函数\n\n\n# 1. 平方损失函数\n\n单个样本的平方损失定义为：\n\nℓ(i)(w,b)=12(y^(i)−y(i))2 \\ell^{(i)}(\\mathbf{w}, b) = \\frac{1}{2} \\left( \\hat{y}^{(i)} - y^{(i)} \\right)^2 ℓ(i)(w,b)=21 (y^ (i)−y(i))2\n\n\n# 2. 总体损失函数\n\n整体损失函数定义为：\n\nL(w,b)=1n∑i=1nℓ(i)(w,b) L(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} \\ell^{(i)}(\\mathbf{w}, b) L(w,b)=n1 i=1∑n ℓ(i)(w,b)\n\n训练的目标是找到一组参数 (w,b)(\\mathbf{w}, b)(w,b)，使损失函数 L(w,b)L(\\mathbf{w}, b)L(w,b) 最小。",normalizedContent:"本章节用于记录我在学习《动手学深度学习》（d2l）过程中，对线性神经网络相关内容的理解与整理。\n重点不在复述教材，而在于理清一些容易被忽略或想当然的基础概念。\n\n\n# 一、前置的基本概念\n\n\n# 1. 张量（tensor）\n\n张量可以理解为由数值组成的多维数组。\n\n * 一维张量称为向量（vector）\n * 二维张量称为矩阵（matrix）\n * 更高维的统称为张量（tensor）\n\n在深度学习中，张量是数据、参数以及梯度的统一表示形式。\n\n\n# 2. 向量的方向约定\n\n在数学与深度学习中，向量默认采用列向量形式，例如：\n\nx=[x1x2]∈r2 \\mathbf{x} = \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} \\in \\mathbb{r}^{2} x=[x1 x2 ]∈r2\n\n这一约定会直接影响矩阵乘法是否合法，也是后续公式推导的基础。\n\n\n# 3. 范数（norm）\n\n范数用于衡量向量或矩阵的大小。\n\n向量的 l2 范数定义为：\n\n∥x∥2=∑i=1nxi2 \\lvert \\mathbf{x} \\rvert_2 = \\sqrt{\\sum_{i=1}^{n} x_i^2} ∥x∥2 =i=1∑n xi2\n\n矩阵的 l2 范数（frobenius 范数）定义为：\n\n∥x∥f=∑i∑jxij2 \\lvert \\mathbf{x} \\rvert_f = \\sqrt{\\sum_{i}\\sum_{j} x_{ij}^2} ∥x∥f =i∑ j∑ xij2\n\n\n# 4. 自动微分（automatic differentiation）\n\n自动微分是深度学习框架提供的一种机制，用于自动计算梯度。\n它可以避免手动求导带来的错误，并且在复杂网络中依然保持高效。\n\n\n# 5. 计算图（computation graph）\n\n计算图是框架在执行正向与反向传播时构建的一种有向图结构。\n\n * 节点表示变量或中间结果\n * 边表示算术运算关系\n\n\n# 6. 反向传播（backpropagation）\n\n反向传播利用微积分中的链式法则，根据损失函数对参数的梯度来更新模型参数。\n在张量层面，本质上是梯度在计算图中的逐层传递。\n\n\n# 二、随机梯度下降\n\n在实际训练中，通常采用小批量随机梯度下降（mini-batch sgd）。\n\n参数更新公式为：\n\n(w,b)←(w,b)−η∣b∣∑i∈b∇(w,b) ℓ(i) (\\mathbf{w}, b) \\leftarrow (\\mathbf{w}, b) - \\frac{\\eta}{|\\mathcal{b}|} \\sum_{i \\in \\mathcal{b}} \\nabla_{(\\mathbf{w}, b)} \\, \\ell^{(i)} (w,b)←(w,b)−∣b∣η i∈b∑ ∇(w,b) ℓ(i)\n\n其中：\n\n * b\\mathcal{b}b 表示一个小批量样本集合\n * ∣b∣|\\mathcal{b}|∣b∣ 表示批量大小（batch size）\n * η\\etaη 表示学习率（learning rate）\n * ℓ(i)\\ell^{(i)}ℓ(i) 表示第 iii 个样本对应的损失\n\n\n# 三、线性回归模型\n\n设数据集中共有 nnn 个样本，对于第 iii 个样本，其输入向量表示为：\n\nx(i)=[x1(i)x2(i)]∈r2 \\mathbf{x}^{(i)} = \\begin{bmatrix} x_1^{(i)} \\\\ x_2^{(i)} \\end{bmatrix} \\in \\mathbb{r}^{2} x(i)=[x1(i) x2(i) ]∈r2\n\n对应的标签为标量 y(i)y^{(i)}y(i)。\n\n模型参数定义为：\n\n权重向量：\n\nw=[w1w2]∈r2 \\mathbf{w} = \\begin{bmatrix} w_1 \\\\ w_2 \\end{bmatrix} \\in \\mathbb{r}^{2} w=[w1 w2 ]∈r2\n\n偏置为标量 bbb。\n\n线性回归模型的预测形式为：\n\ny^(i)=w⊤x(i)+b \\hat{y}^{(i)} = \\mathbf{w}^\\top \\mathbf{x}^{(i)} + b y^ (i)=w⊤x(i)+b\n\n\n# 四、损失函数\n\n\n# 1. 平方损失函数\n\n单个样本的平方损失定义为：\n\nℓ(i)(w,b)=12(y^(i)−y(i))2 \\ell^{(i)}(\\mathbf{w}, b) = \\frac{1}{2} \\left( \\hat{y}^{(i)} - y^{(i)} \\right)^2 ℓ(i)(w,b)=21 (y^ (i)−y(i))2\n\n\n# 2. 总体损失函数\n\n整体损失函数定义为：\n\nl(w,b)=1n∑i=1nℓ(i)(w,b) l(\\mathbf{w}, b) = \\frac{1}{n} \\sum_{i=1}^{n} \\ell^{(i)}(\\mathbf{w}, b) l(w,b)=n1 i=1∑n ℓ(i)(w,b)\n\n训练的目标是找到一组参数 (w,b)(\\mathbf{w}, b)(w,b)，使损失函数 l(w,b)l(\\mathbf{w}, b)l(w,b) 最小。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 02.若干损失函数的研究",frontmatter:{title:"NN 02.若干损失函数的研究",date:"2026-01-31T23:00:00.000Z",permalink:"/pages/NN_02/"},regularPath:"/02.Neural%20Networks/02.Loss_Functions.html",relativePath:"02.Neural Networks/02.Loss_Functions.md",key:"v-fcc3ec3c",path:"/pages/NN_02/",headers:[{level:2,title:"一、交叉熵损失函数",slug:"一、交叉熵损失函数",normalizedTitle:"一、交叉熵损失函数",charIndex:73},{level:3,title:"1. 本质理解",slug:"_1-本质理解",normalizedTitle:"1. 本质理解",charIndex:87},{level:3,title:"2. Softmax 函数",slug:"_2-softmax-函数",normalizedTitle:"2. softmax 函数",charIndex:230},{level:3,title:"3. 真实标签的表示方式",slug:"_3-真实标签的表示方式",normalizedTitle:"3. 真实标签的表示方式",charIndex:745},{level:3,title:"4. 交叉熵损失的定义",slug:"_4-交叉熵损失的定义",normalizedTitle:"4. 交叉熵损失的定义",charIndex:1016},{level:3,title:"5. 数值示例",slug:"_5-数值示例",normalizedTitle:"5. 数值示例",charIndex:1253},{level:3,title:"6. 一个直观理解",slug:"_6-一个直观理解",normalizedTitle:"6. 一个直观理解",charIndex:1558}],headersStr:"一、交叉熵损失函数 1. 本质理解 2. Softmax 函数 3. 真实标签的表示方式 4. 交叉熵损失的定义 5. 数值示例 6. 一个直观理解",content:"本博客用于记录我在学习《动手学深度学习》（D2L）过程中，对若干常见损失函数的理解。 本篇先从分类问题中最常用的 交叉熵损失函数 开始。\n\n\n# 一、交叉熵损失函数\n\n\n# 1. 本质理解\n\n交叉熵损失的本质是：\n\n> 衡量模型预测得到的概率分布与真实标签对应的理想分布之间的差异。\n\n在分类问题中，模型并不是直接输出“类别”，而是输出对每个类别的置信程度（概率）。\n\n----------------------------------------\n\n\n# 2. Softmax 函数\n\n设模型对某一个样本的输出为一个向量：\n\nz=[z1,z2,…,zh]⊤ \\mathbf{z} = [z_1, z_2, \\dots, z_h]^\\top z=[z1 ,z2 ,…,zh ]⊤\n\n其中 hhh 表示类别数，z\\mathbf{z}z 中的每一个分量称为 logit。\n\nSoftmax 函数将该向量映射为一个概率分布：\n\npi=exp⁡(zi)∑j=1hexp⁡(zj) p_i = \\frac{\\exp(z_i)}{\\sum_{j=1}^{h} \\exp(z_j)} pi =∑j=1h exp(zj )exp(zi )\n\nSoftmax 输出满足以下性质：\n\n * pi≥0p_i \\ge 0pi ≥0\n * ∑i=1hpi=1\\sum_{i=1}^{h} p_i = 1∑i=1h pi =1\n\n因此，p=[p1,p2,…,ph]⊤\\mathbf{p} = [p_1, p_2, \\dots, p_h]^\\topp=[p1 ,p2 ,…,ph ]⊤ 可以被解释为模型对各个类别的预测概率。\n\n----------------------------------------\n\n\n# 3. 真实标签的表示方式\n\n假设某个样本的真实类别为 yyy，通常将其表示为 one-hot 向量：\n\nyone-hot=[0,…,1,…,0] \\mathbf{y}_{\\text{one-hot}} = [0, \\dots, 1, \\dots, 0] yone-hot =[0,…,1,…,0]\n\n其中第 yyy 个位置为 1，其余位置为 0。\n\n这种表示方式对应一个“理想”的概率分布：\n模型应当对真实类别给出概率 1，对其他类别给出概率 0。\n\n----------------------------------------\n\n\n# 4. 交叉熵损失的定义\n\n对于单个样本，交叉熵损失定义为：\n\nL=−log⁡(py) L = -\\log(p_y) L=−log(py )\n\n其中 pyp_ypy 表示模型对真实类别 yyy 给出的预测概率。\n\n该公式意味着：\n\n * 如果模型对真实类别预测得越自信（pyp_ypy 越大），损失越小\n * 如果模型对真实类别预测得越不确定（pyp_ypy 越小），损失会迅速增大\n\n----------------------------------------\n\n\n# 5. 数值示例\n\n * 当 py=0.9p_y = 0.9py =0.9 时：\n\nL=−log⁡(0.9)≈0.105 L = -\\log(0.9) \\approx 0.105 L=−log(0.9)≈0.105\n\n损失较小，说明模型预测效果较好。\n\n * 当 py=0.1p_y = 0.1py =0.1 时：\n\nL=−log⁡(0.1)≈2.302 L = -\\log(0.1) \\approx 2.302 L=−log(0.1)≈2.302\n\n损失显著增大，说明模型对真实类别的判断非常不自信。\n哦，玛卡巴卡！\n\n----------------------------------------\n\n\n# 6. 一个直观理解\n\n交叉熵损失实际上只关心一件事：\n\n> 模型是否把足够高的概率分配给了真实类别。\n\n至于其他类别的概率如何分配，只会通过归一化间接影响这一结果。",normalizedContent:"本博客用于记录我在学习《动手学深度学习》（d2l）过程中，对若干常见损失函数的理解。 本篇先从分类问题中最常用的 交叉熵损失函数 开始。\n\n\n# 一、交叉熵损失函数\n\n\n# 1. 本质理解\n\n交叉熵损失的本质是：\n\n> 衡量模型预测得到的概率分布与真实标签对应的理想分布之间的差异。\n\n在分类问题中，模型并不是直接输出“类别”，而是输出对每个类别的置信程度（概率）。\n\n----------------------------------------\n\n\n# 2. softmax 函数\n\n设模型对某一个样本的输出为一个向量：\n\nz=[z1,z2,…,zh]⊤ \\mathbf{z} = [z_1, z_2, \\dots, z_h]^\\top z=[z1 ,z2 ,…,zh ]⊤\n\n其中 hhh 表示类别数，z\\mathbf{z}z 中的每一个分量称为 logit。\n\nsoftmax 函数将该向量映射为一个概率分布：\n\npi=exp⁡(zi)∑j=1hexp⁡(zj) p_i = \\frac{\\exp(z_i)}{\\sum_{j=1}^{h} \\exp(z_j)} pi =∑j=1h exp(zj )exp(zi )\n\nsoftmax 输出满足以下性质：\n\n * pi≥0p_i \\ge 0pi ≥0\n * ∑i=1hpi=1\\sum_{i=1}^{h} p_i = 1∑i=1h pi =1\n\n因此，p=[p1,p2,…,ph]⊤\\mathbf{p} = [p_1, p_2, \\dots, p_h]^\\topp=[p1 ,p2 ,…,ph ]⊤ 可以被解释为模型对各个类别的预测概率。\n\n----------------------------------------\n\n\n# 3. 真实标签的表示方式\n\n假设某个样本的真实类别为 yyy，通常将其表示为 one-hot 向量：\n\nyone-hot=[0,…,1,…,0] \\mathbf{y}_{\\text{one-hot}} = [0, \\dots, 1, \\dots, 0] yone-hot =[0,…,1,…,0]\n\n其中第 yyy 个位置为 1，其余位置为 0。\n\n这种表示方式对应一个“理想”的概率分布：\n模型应当对真实类别给出概率 1，对其他类别给出概率 0。\n\n----------------------------------------\n\n\n# 4. 交叉熵损失的定义\n\n对于单个样本，交叉熵损失定义为：\n\nl=−log⁡(py) l = -\\log(p_y) l=−log(py )\n\n其中 pyp_ypy 表示模型对真实类别 yyy 给出的预测概率。\n\n该公式意味着：\n\n * 如果模型对真实类别预测得越自信（pyp_ypy 越大），损失越小\n * 如果模型对真实类别预测得越不确定（pyp_ypy 越小），损失会迅速增大\n\n----------------------------------------\n\n\n# 5. 数值示例\n\n * 当 py=0.9p_y = 0.9py =0.9 时：\n\nl=−log⁡(0.9)≈0.105 l = -\\log(0.9) \\approx 0.105 l=−log(0.9)≈0.105\n\n损失较小，说明模型预测效果较好。\n\n * 当 py=0.1p_y = 0.1py =0.1 时：\n\nl=−log⁡(0.1)≈2.302 l = -\\log(0.1) \\approx 2.302 l=−log(0.1)≈2.302\n\n损失显著增大，说明模型对真实类别的判断非常不自信。\n哦，玛卡巴卡！\n\n----------------------------------------\n\n\n# 6. 一个直观理解\n\n交叉熵损失实际上只关心一件事：\n\n> 模型是否把足够高的概率分配给了真实类别。\n\n至于其他类别的概率如何分配，只会通过归一化间接影响这一结果。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 03.若干激活函数的研究",frontmatter:{title:"NN 03.若干激活函数的研究",date:"2026-01-31T22:30:00.000Z",permalink:"/pages/NN_03/"},regularPath:"/02.Neural%20Networks/03.Activate_Function.html",relativePath:"02.Neural Networks/03.Activate_Function.md",key:"v-65b9d288",path:"/pages/NN_03/",headers:[{level:2,title:"一、ReLU 激活函数",slug:"一、relu-激活函数",normalizedTitle:"一、relu 激活函数",charIndex:63},{level:3,title:"1. 基本定义",slug:"_1-基本定义",normalizedTitle:"1. 基本定义",charIndex:79},{level:3,title:"2. 梯度性质",slug:"_2-梯度性质",normalizedTitle:"2. 梯度性质",charIndex:381},{level:3,title:"3. 反向传播中的作用",slug:"_3-反向传播中的作用",normalizedTitle:"3. 反向传播中的作用",charIndex:711},{level:3,title:"4. ReLU 的线性与非线性",slug:"_4-relu-的线性与非线性",normalizedTitle:"4. relu 的线性与非线性",charIndex:882},{level:3,title:"5. “激活”的直观含义",slug:"_5-激活-的直观含义",normalizedTitle:"5. “激活”的直观含义",charIndex:1055}],headersStr:"一、ReLU 激活函数 1. 基本定义 2. 梯度性质 3. 反向传播中的作用 4. ReLU 的线性与非线性 5. “激活”的直观含义",content:"本文用于记录我在训练神经网络过程中，对常用激活函数的理解。 本篇聚焦于目前使用最广泛的一种激活函数 —— ReLU。\n\n\n# 一、ReLU 激活函数\n\n\n# 1. 基本定义\n\nReLU 的全称是 线性修正单元（Rectified Linear Unit）。\n\n其数学定义为：\n\nReLU(x)=max⁡(0,x) \\text{ReLU}(x) = \\max(0, x) ReLU(x)=max(0,x)\n\n从几何角度看，在二维平面直角坐标系中：\n\n * 当 x≤0x \\le 0x≤0 时，函数输出恒为 0\n * 当 x>0x > 0x>0 时，函数表现为一条斜率为 1 的直线 y=xy = xy=x\n\n也可以理解为：\ny 轴左侧被“压扁”为 0，右侧保持线性增长。\n\n----------------------------------------\n\n\n# 2. 梯度性质\n\nReLU 在不同区间上的导数为：\n\nddx ReLU(x)={1,x>00,x≤0 \\frac{d}{dx}\\,\\text{ReLU}(x) = \\begin{cases} 1, & x > 0 \\\\ 0, & x \\le 0 \\end{cases} dxd ReLU(x)={1,0, x>0x≤0\n\n这一性质带来两个直接结果：\n\n * 当 x>0x > 0x>0 时，梯度恒为 1\n   → 不会出现梯度消失\n * 梯度不会大于 1\n   → 不容易引发梯度爆炸\n\n因此，在深层网络中，ReLU 相比 sigmoid 或 tanh 更容易训练。\n\n----------------------------------------\n\n\n# 3. 反向传播中的作用\n\n在反向传播过程中，ReLU 的梯度行为非常简单：\n\n * 若前向传播时该神经元输出为正，则梯度可以正常向后传递\n * 若前向传播时输出为 0，则梯度被直接截断\n\n从实现角度看，ReLU 本质上只是一个逐元素的条件判断操作。\n\n----------------------------------------\n\n\n# 4. ReLU 的线性与非线性\n\n虽然 ReLU 在每个区间内都是线性的，但它在整体上是一个非线性函数。\n\n其非线性体现在：\n\n> 网络对输入空间进行了基于条件的分段线性映射。\n\n不同神经元在不同输入条件下被激活，使得整个网络可以拟合复杂的非线性关系。\n\n----------------------------------------\n\n\n# 5. “激活”的直观含义\n\n从更直观的角度理解，ReLU 的“激活”可以看作一种信息门控机制：\n\n * 输出为 0：该神经元在当前输入下不参与计算\n * 输出大于 0：该神经元被激活并参与后续计算\n\n因此，ReLU 等价于让神经元在“参与计算 / 不参与计算”之间做出选择。\n\n----------------------------------------",normalizedContent:"本文用于记录我在训练神经网络过程中，对常用激活函数的理解。 本篇聚焦于目前使用最广泛的一种激活函数 —— relu。\n\n\n# 一、relu 激活函数\n\n\n# 1. 基本定义\n\nrelu 的全称是 线性修正单元（rectified linear unit）。\n\n其数学定义为：\n\nrelu(x)=max⁡(0,x) \\text{relu}(x) = \\max(0, x) relu(x)=max(0,x)\n\n从几何角度看，在二维平面直角坐标系中：\n\n * 当 x≤0x \\le 0x≤0 时，函数输出恒为 0\n * 当 x>0x > 0x>0 时，函数表现为一条斜率为 1 的直线 y=xy = xy=x\n\n也可以理解为：\ny 轴左侧被“压扁”为 0，右侧保持线性增长。\n\n----------------------------------------\n\n\n# 2. 梯度性质\n\nrelu 在不同区间上的导数为：\n\nddx relu(x)={1,x>00,x≤0 \\frac{d}{dx}\\,\\text{relu}(x) = \\begin{cases} 1, & x > 0 \\\\ 0, & x \\le 0 \\end{cases} dxd relu(x)={1,0, x>0x≤0\n\n这一性质带来两个直接结果：\n\n * 当 x>0x > 0x>0 时，梯度恒为 1\n   → 不会出现梯度消失\n * 梯度不会大于 1\n   → 不容易引发梯度爆炸\n\n因此，在深层网络中，relu 相比 sigmoid 或 tanh 更容易训练。\n\n----------------------------------------\n\n\n# 3. 反向传播中的作用\n\n在反向传播过程中，relu 的梯度行为非常简单：\n\n * 若前向传播时该神经元输出为正，则梯度可以正常向后传递\n * 若前向传播时输出为 0，则梯度被直接截断\n\n从实现角度看，relu 本质上只是一个逐元素的条件判断操作。\n\n----------------------------------------\n\n\n# 4. relu 的线性与非线性\n\n虽然 relu 在每个区间内都是线性的，但它在整体上是一个非线性函数。\n\n其非线性体现在：\n\n> 网络对输入空间进行了基于条件的分段线性映射。\n\n不同神经元在不同输入条件下被激活，使得整个网络可以拟合复杂的非线性关系。\n\n----------------------------------------\n\n\n# 5. “激活”的直观含义\n\n从更直观的角度理解，relu 的“激活”可以看作一种信息门控机制：\n\n * 输出为 0：该神经元在当前输入下不参与计算\n * 输出大于 0：该神经元被激活并参与后续计算\n\n因此，relu 等价于让神经元在“参与计算 / 不参与计算”之间做出选择。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 04.卷积和LeNet神经网络",frontmatter:{title:"NN 04.卷积和LeNet神经网络",date:"2026-02-01T12:00:00.000Z",permalink:"/pages/NN_04/"},regularPath:"/02.Neural%20Networks/04.Conv_Lenet.html",relativePath:"02.Neural Networks/04.Conv_Lenet.md",key:"v-53847772",path:"/pages/NN_04/",headers:[{level:2,title:"一、卷积相关知识点",slug:"一、卷积相关知识点",normalizedTitle:"一、卷积相关知识点",charIndex:64},{level:3,title:"1. 卷积（Convolution）",slug:"_1-卷积-convolution",normalizedTitle:"1. 卷积（convolution）",charIndex:78},{level:3,title:"2. 填充（Padding）",slug:"_2-填充-padding",normalizedTitle:"2. 填充（padding）",charIndex:281},{level:3,title:"3. 步幅（Stride）",slug:"_3-步幅-stride",normalizedTitle:"3. 步幅（stride）",charIndex:429},{level:3,title:"4. 神经网络中的张量表示",slug:"_4-神经网络中的张量表示",normalizedTitle:"4. 神经网络中的张量表示",charIndex:578},{level:3,title:"5. 池化（Pooling）",slug:"_5-池化-pooling",normalizedTitle:"5. 池化（pooling）",charIndex:904},{level:3,title:"6. 卷积与池化的输出尺寸计算",slug:"_6-卷积与池化的输出尺寸计算",normalizedTitle:"6. 卷积与池化的输出尺寸计算",charIndex:1091},{level:2,title:"二、LeNet 网络结构",slug:"二、lenet-网络结构",normalizedTitle:"二、lenet 网络结构",charIndex:1462}],headersStr:"一、卷积相关知识点 1. 卷积（Convolution） 2. 填充（Padding） 3. 步幅（Stride） 4. 神经网络中的张量表示 5. 池化（Pooling） 6. 卷积与池化的输出尺寸计算 二、LeNet 网络结构",content:"本章用于记录我在学习卷积神经网络（CNN）过程中， 对卷积相关概念以及初代经典 CNN —— LeNet 的结构理解。\n\n\n# 一、卷积相关知识点\n\n\n# 1. 卷积（Convolution）\n\n在深度学习中，卷积运算本质上更接近于互相关（cross-correlation）。\n\n可以形象地理解为：\n一个较小的卷积核（kernel）在一张较大的输入特征图上，从左到右、从上到下滑动， 在每一个位置与局部区域进行加权求和，从而生成新的特征图（feature map）。\n\n----------------------------------------\n\n\n# 2. 填充（Padding）\n\n填充是指在输入特征图的边缘补充若干行或列的像素。\n\n其主要目的包括：\n\n * 控制输出特征图的空间尺寸\n * 保留输入图像边缘的信息\n\n通常用 PPP 表示填充的像素数。\n\n----------------------------------------\n\n\n# 3. 步幅（Stride）\n\n步幅表示卷积核在输入特征图上每次滑动的像素数，通常记为 SSS。\n\n * S=1S = 1S=1：逐像素滑动（最常见）\n * S>1S > 1S>1：下采样效果，输出尺寸减小\n\n----------------------------------------\n\n\n# 4. 神经网络中的张量表示\n\n在卷积神经网络中，输入数据通常表示为一个 四维张量：\n\n(batch_size, channels, height, width) \\texttt{(batch\\_size,\\ channels,\\ height,\\ width)} (batch_size, channels, height, width)\n\n各个维度的含义如下：\n\n * batch_size：批量大小，一次输入网络的样本数量\n * channels：通道数（如灰度图为 1，RGB 图像为 3）\n * height：特征图高度\n * width：特征图宽度\n\n----------------------------------------\n\n\n# 5. 池化（Pooling）\n\n池化操作与卷积类似，同样在局部区域内进行运算，但有以下特点：\n\n * 不改变通道数\n * 主要作用是减小特征图的空间尺寸\n * 提升平移不变性，降低计算量\n\n常见的池化方式包括平均池化（Avg Pooling）和最大池化（Max Pooling）。\n\n----------------------------------------\n\n\n# 6. 卷积与池化的输出尺寸计算\n\n对于卷积或池化操作，其输出特征图的空间尺寸计算公式为：\n\noutput_size=⌊input_size−K+2PS⌋+1 \\text{output\\_size} = \\left\\lfloor \\frac{\\text{input\\_size} - K + 2P}{S} \\right\\rfloor + 1 output_size=⌊Sinput_size−K+2P ⌋+1\n\n其中：\n\n * input_size：输入特征图的高度或宽度\n * K：卷积核（或池化核）的尺寸\n * P：填充大小（padding）\n * S：步幅（stride）\n * ⌊⋅⌋\\lfloor \\cdot \\rfloor⌊⋅⌋：向下取整\n\n----------------------------------------\n\n\n# 二、LeNet 网络结构\n\n下面使用 PyTorch 代码的形式，对经典 CNN —— LeNet 的整体结构进行说明。\n\nnet = nn.Sequential(\n    nn.Conv2d(1, 6, kernel_size=5, padding=2),\n    # 第一层卷积\n    # 输入通道数为 1（灰度图），输出通道数为 6\n    # padding=2，使输出特征图尺寸保持为 28×28\n\n    nn.Sigmoid(),\n    # 激活函数\n    # 将卷积结果映射到 (0, 1) 区间\n\n    nn.AvgPool2d(kernel_size=2, stride=2),\n    # 平均池化层\n    # 不改变通道数，仅将特征图宽高减半：28 -> 14\n\n    nn.Conv2d(6, 16, kernel_size=5),\n    # 第二层卷积\n    # 输入通道数为 6，输出通道数为 16\n    # 特征图尺寸：14 -> 10\n\n    nn.Sigmoid(),\n    # 激活函数\n\n    nn.AvgPool2d(kernel_size=2, stride=2),\n    # 平均池化层\n    # 特征图尺寸：10 -> 5\n\n    nn.Flatten(),\n    # 展平层\n    # 将张量从 (16, 5, 5) 展平成 (400,)\n\n    nn.Linear(400, 120),\n    # 全连接层\n    # 输入维度 400，输出维度 120\n\n    nn.Sigmoid(),\n    # 激活函数\n\n    nn.Linear(120, 84),\n    # 全连接层\n    # 通道数：120 -> 84\n\n    nn.Sigmoid(),\n    # 激活函数\n\n    nn.Linear(84, 10)\n    # 输出层\n    # 输出维度等于类别数\n)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n",normalizedContent:"本章用于记录我在学习卷积神经网络（cnn）过程中， 对卷积相关概念以及初代经典 cnn —— lenet 的结构理解。\n\n\n# 一、卷积相关知识点\n\n\n# 1. 卷积（convolution）\n\n在深度学习中，卷积运算本质上更接近于互相关（cross-correlation）。\n\n可以形象地理解为：\n一个较小的卷积核（kernel）在一张较大的输入特征图上，从左到右、从上到下滑动， 在每一个位置与局部区域进行加权求和，从而生成新的特征图（feature map）。\n\n----------------------------------------\n\n\n# 2. 填充（padding）\n\n填充是指在输入特征图的边缘补充若干行或列的像素。\n\n其主要目的包括：\n\n * 控制输出特征图的空间尺寸\n * 保留输入图像边缘的信息\n\n通常用 ppp 表示填充的像素数。\n\n----------------------------------------\n\n\n# 3. 步幅（stride）\n\n步幅表示卷积核在输入特征图上每次滑动的像素数，通常记为 sss。\n\n * s=1s = 1s=1：逐像素滑动（最常见）\n * s>1s > 1s>1：下采样效果，输出尺寸减小\n\n----------------------------------------\n\n\n# 4. 神经网络中的张量表示\n\n在卷积神经网络中，输入数据通常表示为一个 四维张量：\n\n(batch_size, channels, height, width) \\texttt{(batch\\_size,\\ channels,\\ height,\\ width)} (batch_size, channels, height, width)\n\n各个维度的含义如下：\n\n * batch_size：批量大小，一次输入网络的样本数量\n * channels：通道数（如灰度图为 1，rgb 图像为 3）\n * height：特征图高度\n * width：特征图宽度\n\n----------------------------------------\n\n\n# 5. 池化（pooling）\n\n池化操作与卷积类似，同样在局部区域内进行运算，但有以下特点：\n\n * 不改变通道数\n * 主要作用是减小特征图的空间尺寸\n * 提升平移不变性，降低计算量\n\n常见的池化方式包括平均池化（avg pooling）和最大池化（max pooling）。\n\n----------------------------------------\n\n\n# 6. 卷积与池化的输出尺寸计算\n\n对于卷积或池化操作，其输出特征图的空间尺寸计算公式为：\n\noutput_size=⌊input_size−k+2ps⌋+1 \\text{output\\_size} = \\left\\lfloor \\frac{\\text{input\\_size} - k + 2p}{s} \\right\\rfloor + 1 output_size=⌊sinput_size−k+2p ⌋+1\n\n其中：\n\n * input_size：输入特征图的高度或宽度\n * k：卷积核（或池化核）的尺寸\n * p：填充大小（padding）\n * s：步幅（stride）\n * ⌊⋅⌋\\lfloor \\cdot \\rfloor⌊⋅⌋：向下取整\n\n----------------------------------------\n\n\n# 二、lenet 网络结构\n\n下面使用 pytorch 代码的形式，对经典 cnn —— lenet 的整体结构进行说明。\n\nnet = nn.sequential(\n    nn.conv2d(1, 6, kernel_size=5, padding=2),\n    # 第一层卷积\n    # 输入通道数为 1（灰度图），输出通道数为 6\n    # padding=2，使输出特征图尺寸保持为 28×28\n\n    nn.sigmoid(),\n    # 激活函数\n    # 将卷积结果映射到 (0, 1) 区间\n\n    nn.avgpool2d(kernel_size=2, stride=2),\n    # 平均池化层\n    # 不改变通道数，仅将特征图宽高减半：28 -> 14\n\n    nn.conv2d(6, 16, kernel_size=5),\n    # 第二层卷积\n    # 输入通道数为 6，输出通道数为 16\n    # 特征图尺寸：14 -> 10\n\n    nn.sigmoid(),\n    # 激活函数\n\n    nn.avgpool2d(kernel_size=2, stride=2),\n    # 平均池化层\n    # 特征图尺寸：10 -> 5\n\n    nn.flatten(),\n    # 展平层\n    # 将张量从 (16, 5, 5) 展平成 (400,)\n\n    nn.linear(400, 120),\n    # 全连接层\n    # 输入维度 400，输出维度 120\n\n    nn.sigmoid(),\n    # 激活函数\n\n    nn.linear(120, 84),\n    # 全连接层\n    # 通道数：120 -> 84\n\n    nn.sigmoid(),\n    # 激活函数\n\n    nn.linear(84, 10)\n    # 输出层\n    # 输出维度等于类别数\n)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"HDL02.Verilog HDL有限状态机（FSM）设计基础",frontmatter:{title:"HDL02.Verilog HDL有限状态机（FSM）设计基础",date:"2025-08-13T15:40:00.000Z",permalink:"/pages/Verilog_02/"},regularPath:"/01.Verilog%20HDL/2.Verilog%20HDL%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88FSM%EF%BC%89%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html",relativePath:"01.Verilog HDL/2.Verilog HDL有限状态机（FSM）设计基础.md",key:"v-2152ede0",path:"/pages/Verilog_02/",headers:[{level:2,title:"1. FSM 类型对比",slug:"_1-fsm-类型对比",normalizedTitle:"1. fsm 类型对比",charIndex:27},{level:2,title:"2. 状态编码方式",slug:"_2-状态编码方式",normalizedTitle:"2. 状态编码方式",charIndex:229},{level:2,title:"3. 三段式设计模板",slug:"_3-三段式设计模板",normalizedTitle:"3. 三段式设计模板",charIndex:470},{level:3,title:"Verilog 典型模板示例（Moore机）",slug:"verilog-典型模板示例-moore机",normalizedTitle:"verilog 典型模板示例（moore机）",charIndex:637},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:1641}],headersStr:"1. FSM 类型对比 2. 状态编码方式 3. 三段式设计模板 Verilog 典型模板示例（Moore机） 4. 小结",content:"# 有限状态机（FSM）：数字电路的“大脑”\n\n\n# 1. FSM 类型对比\n\n类型       输出依赖          特点\nMoore机   仅当前状态         输出稳定，无延迟毛刺\nMealy机   当前状态 + 当前输入   响应快，但可能带毛刺（输出跳变）\n\n> Moore机输出只看状态，Mealy机输出对输入敏感，速度快但要注意毛刺问题。\n\n----------------------------------------\n\n\n# 2. 状态编码方式\n\n选择合适的状态编码对面积、速度、设计复杂度影响大：\n\n编码方式   触发器数量     优势\n二进制    log2(N)   占用面积小，资源节约\n独热码    N         速度快，组合逻辑简单\n格雷码    log2(N)   状态切换无毛刺\n\n> 独热码用触发器多，但状态跳变只改变一位，适合高速设计。\n> 格雷码的状态切换避免多位同时跳变，减少毛刺。\n\n----------------------------------------\n\n\n# 3. 三段式设计模板\n\n设计FSM通常分成三步：\n\n 1. 状态寄存器：用时钟更新当前状态。\n 2. 下一状态逻辑：组合逻辑，根据当前状态和输入计算下一状态。\n 3. 输出逻辑：根据当前状态（Moore）或状态+输入（Mealy）产生输出。\n\n----------------------------------------\n\n\n# Verilog 典型模板示例（Moore机）\n\nmodule fsm_example (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    // 状态定义（可用枚举）\n    typedef enum logic [1:0] {\n        S0 = 2'b00,\n        S1 = 2'b01,\n        S2 = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // 1. 状态寄存器更新\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // 2. 下一状态逻辑\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // 3. 输出逻辑（Moore机，输出只和状态相关）\n    always @(*) begin\n        out = 1'b0;\n        if (current_state == S2)\n            out = 1'b1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 小结\n\n * FSM 是数字电路的核心“大脑”，负责状态管理和控制流程。\n * Moore机输出稳定、设计简单；Mealy机响应快，但要注意毛刺。\n * 状态编码选择直接影响设计效率和性能。\n * 三段式设计模板是业界常用的高效设计模式。\n\n> 设计FSM就像搭积木：状态寄存器是基础，下一状态是桥梁，输出逻辑是点睛。",normalizedContent:"# 有限状态机（fsm）：数字电路的“大脑”\n\n\n# 1. fsm 类型对比\n\n类型       输出依赖          特点\nmoore机   仅当前状态         输出稳定，无延迟毛刺\nmealy机   当前状态 + 当前输入   响应快，但可能带毛刺（输出跳变）\n\n> moore机输出只看状态，mealy机输出对输入敏感，速度快但要注意毛刺问题。\n\n----------------------------------------\n\n\n# 2. 状态编码方式\n\n选择合适的状态编码对面积、速度、设计复杂度影响大：\n\n编码方式   触发器数量     优势\n二进制    log2(n)   占用面积小，资源节约\n独热码    n         速度快，组合逻辑简单\n格雷码    log2(n)   状态切换无毛刺\n\n> 独热码用触发器多，但状态跳变只改变一位，适合高速设计。\n> 格雷码的状态切换避免多位同时跳变，减少毛刺。\n\n----------------------------------------\n\n\n# 3. 三段式设计模板\n\n设计fsm通常分成三步：\n\n 1. 状态寄存器：用时钟更新当前状态。\n 2. 下一状态逻辑：组合逻辑，根据当前状态和输入计算下一状态。\n 3. 输出逻辑：根据当前状态（moore）或状态+输入（mealy）产生输出。\n\n----------------------------------------\n\n\n# verilog 典型模板示例（moore机）\n\nmodule fsm_example (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    // 状态定义（可用枚举）\n    typedef enum logic [1:0] {\n        s0 = 2'b00,\n        s1 = 2'b01,\n        s2 = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // 1. 状态寄存器更新\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            current_state <= s0;\n        else\n            current_state <= next_state;\n    end\n\n    // 2. 下一状态逻辑\n    always @(*) begin\n        case (current_state)\n            s0: next_state = in ? s1 : s0;\n            s1: next_state = in ? s2 : s0;\n            s2: next_state = s0;\n            default: next_state = s0;\n        endcase\n    end\n\n    // 3. 输出逻辑（moore机，输出只和状态相关）\n    always @(*) begin\n        out = 1'b0;\n        if (current_state == s2)\n            out = 1'b1;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4. 小结\n\n * fsm 是数字电路的核心“大脑”，负责状态管理和控制流程。\n * moore机输出稳定、设计简单；mealy机响应快，但要注意毛刺。\n * 状态编码选择直接影响设计效率和性能。\n * 三段式设计模板是业界常用的高效设计模式。\n\n> 设计fsm就像搭积木：状态寄存器是基础，下一状态是桥梁，输出逻辑是点睛。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 05.AlexNet 与使用“块”的神经网络",frontmatter:{title:"NN 05.AlexNet 与使用“块”的神经网络",date:"2026-02-01T13:00:00.000Z",permalink:"/pages/NN_05/"},regularPath:"/02.Neural%20Networks/05.AlexNet_blocks.html",relativePath:"02.Neural Networks/05.AlexNet_blocks.md",key:"v-203e451a",path:"/pages/NN_05/",headers:[{level:2,title:"一、AlexNet 网络原理研究",slug:"一、alexnet-网络原理研究",normalizedTitle:"一、alexnet 网络原理研究",charIndex:51},{level:3,title:"1. 网络块的雏形",slug:"_1-网络块的雏形",normalizedTitle:"1. 网络块的雏形",charIndex:215},{level:3,title:"2. 3×3 卷积的连续堆叠",slug:"_2-3×3-卷积的连续堆叠",normalizedTitle:"2. 3×3 卷积的连续堆叠",charIndex:499},{level:3,title:"3. 全连接层与丢弃层",slug:"_3-全连接层与丢弃层",normalizedTitle:"3. 全连接层与丢弃层",charIndex:801},{level:2,title:"二、VGG11 网络架构研究",slug:"二、vgg11-网络架构研究",normalizedTitle:"二、vgg11 网络架构研究",charIndex:1021},{level:3,title:"1. VGG11 的核心设计思想",slug:"_1-vgg11-的核心设计思想",normalizedTitle:"1. vgg11 的核心设计思想",charIndex:1165},{level:3,title:"2. 一个典型的 VGG 块",slug:"_2-一个典型的-vgg-块",normalizedTitle:"2. 一个典型的 vgg 块",charIndex:1354},{level:2,title:"三、网络中的网络：NiN（Network in Network）",slug:"三、网络中的网络-nin-network-in-network",normalizedTitle:"三、网络中的网络：nin（network in network）",charIndex:1633},{level:3,title:"1. NiN 块的定义",slug:"_1-nin-块的定义",normalizedTitle:"1. nin 块的定义",charIndex:1825},{level:3,title:"2. 全局平均池化（GAP）",slug:"_2-全局平均池化-gap",normalizedTitle:"2. 全局平均池化（gap）",charIndex:2100},{level:3,title:"3. 直观理解",slug:"_3-直观理解",normalizedTitle:"3. 直观理解",charIndex:2441}],headersStr:"一、AlexNet 网络原理研究 1. 网络块的雏形 2. 3×3 卷积的连续堆叠 3. 全连接层与丢弃层 二、VGG11 网络架构研究 1. VGG11 的核心设计思想 2. 一个典型的 VGG 块 三、网络中的网络：NiN（Network in Network） 1. NiN 块的定义 2. 全局平均池化（GAP） 3. 直观理解",content:"本博客为研究阐述型博客，不具备教学性质，仅用于记录个人在学习卷积神经网络过程中的理解与思考。\n\n\n# 一、AlexNet 网络原理研究\n\nAlexNet 可以视为 LeNet 的进阶版本。\n\n一方面，它继承了 LeNet 中「卷积 + 池化 + 全连接」的整体架构思想；\n另一方面，它在非线性建模能力与网络深度方面进行了更为激进的尝试。\n\n----------------------------------------\n\n\n# 1. 网络块的雏形\n\nAlexNet 在结构设计上，最显著的特点之一是开始显式使用“块（block）”的思想。\n\n网络最前端采用了两个连续的：\n\n> 卷积层 + 激活函数 + 最大池化层\n\n这样的组合形式，这已经非常接近后续网络中常见的“网络块”概念。\n\n * 第一个网络块使用 11×11 的大卷积核\n   \n   * 目的：快速扩大感受野\n   * 构建「低分辨率、高通道数」的特征表示\n\n * 第二个网络块在此基础上进一步扩大通道数\n   \n   * 提升特征表达能力\n\n----------------------------------------\n\n\n# 2. 3×3 卷积的连续堆叠\n\n在前两层块之后，AlexNet 使用了三层 卷积核大小为 3×3 的卷积层，并在其后接入最大池化层。\n\n以通道数变化为例，可以看到其设计上的巧妙之处：\n\n * 256 → 384\n   将已有特征映射到更高维空间中，增强组合能力\n\n * 384 → 384\n   在保持通道数不变的情况下进行特征重组，加强非线性表达\n\n * 384 → 256\n   在压缩通道数的同时，获得更强的非线性表达能力与更大的有效感受野\n\n这种“扩展—重组—压缩”的通道设计，在后续网络中被大量沿用。\n\n----------------------------------------\n\n\n# 3. 全连接层与丢弃层\n\n在卷积特征提取完成后，AlexNet 使用展平层（Flatten）将特征图转换为向量。\n\n随后，网络采用：\n\n * 两个 “全连接层 + 激活函数 + Dropout（丢弃率 0.5）”\n * 最后一层全连接层作为输出层\n\n其中，引入 Dropout 的主要目的在于：\n\n> 有效缓解深层网络在大规模参数下的过拟合问题。\n\n----------------------------------------\n\n\n# 二、VGG11 网络架构研究\n\nVGG11 属于 VGG 系列模型之一。\n\n其中的 “11” 表示：\n\n> 8 个卷积层 + 3 个全连接层 = 11 个具有可训练参数的层\n> （池化层不计入）\n\n----------------------------------------\n\n\n# 1. VGG11 的核心设计思想\n\nVGG11 的核心特点可以概括为：\n\n * 统一使用 3×3 卷积核\n * 卷积层后统一接 ReLU 激活函数\n * 使用最大池化进行下采样\n * 使用全连接层完成分类任务\n\n本质上，VGG 系列是对 AlexNet 中「块思想」的系统化与规范化。\n\n----------------------------------------\n\n\n# 2. 一个典型的 VGG 块\n\n下面以 VGG11 中的一个典型卷积块为例说明其结构：\n\n层类型         参数说明\nConv2d      kernel size = 3×3, padding = 1\nReLU        非线性激活\nMaxPool2d   kernel size = 2, stride = 2\n\n该结构的特点是：\n\n * 通过 padding 保持卷积前后的空间尺寸\n * 通过池化在块末尾进行统一下采样\n * 结构简单但可重复堆叠\n\n----------------------------------------\n\n\n# 三、网络中的网络：NiN（Network in Network）\n\nNiN 网络在继承 VGG 系列块结构思想的基础上， 对网络的后半部分结构进行了极具突破性的改进。\n\n其核心创新在于：\n\n> 用 全局平均池化（Global Average Pooling, GAP） 替代传统的全连接层。\n\n----------------------------------------\n\n\n# 1. NiN 块的定义\n\n一个典型的 NiN 块由如下结构组成：\n\n层结构                功能说明\nConv(k×k) → ReLU   提取局部空间特征\nConv(1×1) → ReLU   对每个像素位置执行一次带 ReLU 的 MLP 隐层，增强通道间的非线性组合能力\nConv(1×1) → ReLU   进一步提升局部表达能力\n\n其中，1×1 卷积可以被理解为：\n\n> 在每一个像素位置上，对通道维度执行一次多层感知机（MLP）。\n\n----------------------------------------\n\n\n# 2. 全局平均池化（GAP）\n\n在网络的最后，NiN 使用全局平均池化层代替全连接层。\n\n对于第 ccc 个通道，其 GAP 定义为：\n\nGAPc=1H×W∑i=1H∑j=1WXc,i,j \\text{GAP}_c = \\frac{1}{H \\times W} \\sum_{i=1}^{H} \\sum_{j=1}^{W} X_{c,i,j} GAPc =H×W1 i=1∑H j=1∑W Xc,i,j\n\n其中：\n\n * Xc,i,jX_{c,i,j}Xc,i,j 表示第 ccc 个通道在空间位置 (i,j)(i,j)(i,j) 的激活值\n * H,WH, WH,W 为特征图的高度和宽度\n\n----------------------------------------\n\n\n# 3. 直观理解\n\n通过 GAP：\n\n * 每一个通道最终被压缩为一个标量\n * 每一个通道可以被视为对应一个类别的“响应图”\n\n因此，GAP 的含义可以理解为：\n\n> 在整个图像范围内，该类别相关特征的整体证据是否足够强。\n\n这种设计显著减少了参数量，也提升了模型的泛化能力。",normalizedContent:"本博客为研究阐述型博客，不具备教学性质，仅用于记录个人在学习卷积神经网络过程中的理解与思考。\n\n\n# 一、alexnet 网络原理研究\n\nalexnet 可以视为 lenet 的进阶版本。\n\n一方面，它继承了 lenet 中「卷积 + 池化 + 全连接」的整体架构思想；\n另一方面，它在非线性建模能力与网络深度方面进行了更为激进的尝试。\n\n----------------------------------------\n\n\n# 1. 网络块的雏形\n\nalexnet 在结构设计上，最显著的特点之一是开始显式使用“块（block）”的思想。\n\n网络最前端采用了两个连续的：\n\n> 卷积层 + 激活函数 + 最大池化层\n\n这样的组合形式，这已经非常接近后续网络中常见的“网络块”概念。\n\n * 第一个网络块使用 11×11 的大卷积核\n   \n   * 目的：快速扩大感受野\n   * 构建「低分辨率、高通道数」的特征表示\n\n * 第二个网络块在此基础上进一步扩大通道数\n   \n   * 提升特征表达能力\n\n----------------------------------------\n\n\n# 2. 3×3 卷积的连续堆叠\n\n在前两层块之后，alexnet 使用了三层 卷积核大小为 3×3 的卷积层，并在其后接入最大池化层。\n\n以通道数变化为例，可以看到其设计上的巧妙之处：\n\n * 256 → 384\n   将已有特征映射到更高维空间中，增强组合能力\n\n * 384 → 384\n   在保持通道数不变的情况下进行特征重组，加强非线性表达\n\n * 384 → 256\n   在压缩通道数的同时，获得更强的非线性表达能力与更大的有效感受野\n\n这种“扩展—重组—压缩”的通道设计，在后续网络中被大量沿用。\n\n----------------------------------------\n\n\n# 3. 全连接层与丢弃层\n\n在卷积特征提取完成后，alexnet 使用展平层（flatten）将特征图转换为向量。\n\n随后，网络采用：\n\n * 两个 “全连接层 + 激活函数 + dropout（丢弃率 0.5）”\n * 最后一层全连接层作为输出层\n\n其中，引入 dropout 的主要目的在于：\n\n> 有效缓解深层网络在大规模参数下的过拟合问题。\n\n----------------------------------------\n\n\n# 二、vgg11 网络架构研究\n\nvgg11 属于 vgg 系列模型之一。\n\n其中的 “11” 表示：\n\n> 8 个卷积层 + 3 个全连接层 = 11 个具有可训练参数的层\n> （池化层不计入）\n\n----------------------------------------\n\n\n# 1. vgg11 的核心设计思想\n\nvgg11 的核心特点可以概括为：\n\n * 统一使用 3×3 卷积核\n * 卷积层后统一接 relu 激活函数\n * 使用最大池化进行下采样\n * 使用全连接层完成分类任务\n\n本质上，vgg 系列是对 alexnet 中「块思想」的系统化与规范化。\n\n----------------------------------------\n\n\n# 2. 一个典型的 vgg 块\n\n下面以 vgg11 中的一个典型卷积块为例说明其结构：\n\n层类型         参数说明\nconv2d      kernel size = 3×3, padding = 1\nrelu        非线性激活\nmaxpool2d   kernel size = 2, stride = 2\n\n该结构的特点是：\n\n * 通过 padding 保持卷积前后的空间尺寸\n * 通过池化在块末尾进行统一下采样\n * 结构简单但可重复堆叠\n\n----------------------------------------\n\n\n# 三、网络中的网络：nin（network in network）\n\nnin 网络在继承 vgg 系列块结构思想的基础上， 对网络的后半部分结构进行了极具突破性的改进。\n\n其核心创新在于：\n\n> 用 全局平均池化（global average pooling, gap） 替代传统的全连接层。\n\n----------------------------------------\n\n\n# 1. nin 块的定义\n\n一个典型的 nin 块由如下结构组成：\n\n层结构                功能说明\nconv(k×k) → relu   提取局部空间特征\nconv(1×1) → relu   对每个像素位置执行一次带 relu 的 mlp 隐层，增强通道间的非线性组合能力\nconv(1×1) → relu   进一步提升局部表达能力\n\n其中，1×1 卷积可以被理解为：\n\n> 在每一个像素位置上，对通道维度执行一次多层感知机（mlp）。\n\n----------------------------------------\n\n\n# 2. 全局平均池化（gap）\n\n在网络的最后，nin 使用全局平均池化层代替全连接层。\n\n对于第 ccc 个通道，其 gap 定义为：\n\ngapc=1h×w∑i=1h∑j=1wxc,i,j \\text{gap}_c = \\frac{1}{h \\times w} \\sum_{i=1}^{h} \\sum_{j=1}^{w} x_{c,i,j} gapc =h×w1 i=1∑h j=1∑w xc,i,j\n\n其中：\n\n * xc,i,jx_{c,i,j}xc,i,j 表示第 ccc 个通道在空间位置 (i,j)(i,j)(i,j) 的激活值\n * h,wh, wh,w 为特征图的高度和宽度\n\n----------------------------------------\n\n\n# 3. 直观理解\n\n通过 gap：\n\n * 每一个通道最终被压缩为一个标量\n * 每一个通道可以被视为对应一个类别的“响应图”\n\n因此，gap 的含义可以理解为：\n\n> 在整个图像范围内，该类别相关特征的整体证据是否足够强。\n\n这种设计显著减少了参数量，也提升了模型的泛化能力。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"NN 06.并行块和深度神经网络的深究解释",frontmatter:{title:"NN 06.并行块和深度神经网络的深究解释",date:"2026-02-01T14:00:00.000Z",permalink:"/pages/NN_06/"},regularPath:"/02.Neural%20Networks/06.Parallel_Deeper_NN.html",relativePath:"02.Neural Networks/06.Parallel_Deeper_NN.md",key:"v-ffe450e8",path:"/pages/NN_06/",headers:[{level:2,title:"一、GoogLeNet 网络并行化的阐述",slug:"一、googlenet-网络并行化的阐述",normalizedTitle:"一、googlenet 网络并行化的阐述",charIndex:56},{level:2,title:"二、批量规范化（Batch Normalization）",slug:"二、批量规范化-batch-normalization",normalizedTitle:"二、批量规范化（batch normalization）",charIndex:523},{level:2,title:"三、ResNet 的基本思想",slug:"三、resnet-的基本思想",normalizedTitle:"三、resnet 的基本思想",charIndex:1245},{level:2,title:"四、DenseNet 的研究解释",slug:"四、densenet-的研究解释",normalizedTitle:"四、densenet 的研究解释",charIndex:1761},{level:3,title:"稠密块（Dense Block）",slug:"稠密块-dense-block",normalizedTitle:"稠密块（dense block）",charIndex:2049},{level:3,title:"过渡层（Transition Layer）",slug:"过渡层-transition-layer",normalizedTitle:"过渡层（transition layer）",charIndex:2383},{level:3,title:"DenseNet 整体架构",slug:"densenet-整体架构",normalizedTitle:"densenet 整体架构",charIndex:2540}],headersStr:"一、GoogLeNet 网络并行化的阐述 二、批量规范化（Batch Normalization） 三、ResNet 的基本思想 四、DenseNet 的研究解释 稠密块（Dense Block） 过渡层（Transition Layer） DenseNet 整体架构",content:"本篇博客着重于解释自己对于 GoogLeNet 以及深层网络 ResNet、DenseNet 的理解。\n\n\n# 一、GoogLeNet 网络并行化的阐述\n\nGoogLeNet 是一个巨大的进展，它的设计思想是从单纯追求网络深度，转向同时强调网络的宽度。\n\n一个 GoogLeNet 的 Inception 块由四条并行线路组成，它们共享相同的输入通道数，并在输出端进行通道维拼接（concatenate）。\n\n四条路径如下：\n\n路径一：\n\nConv 1×1\n作用：保留空间分辨率，调整通道数，输出结果参与最终拼接。\n\n路径二：\n\nConv 1×1（降维）\n→ Conv 3×3（padding=1）\n作用：在保证空间分辨率不变的前提下，引入中等感受野。\n\n路径三：\n\nConv 1×1（降维）\n→ Conv 5×5（padding=2）\n作用：引入更大的感受野，捕捉更大尺度特征。\n\n路径四：\n\nMaxPool（kernel=3，stride=1，padding=1）\n→ Conv 1×1\n作用：引入池化特征，同时通过 1×1 卷积控制通道数。\n\n并行结构的核心意义在于：\n在同一层级同时观察不同尺度的特征，并将它们在通道维度上整合。\n\n\n# 二、批量规范化（Batch Normalization）\n\n批量规范化是一种在训练神经网络时用于稳定并加速训练过程的技术。\n\n在训练深层网络时，随着网络层数的加深，前面层参数的变化会不断改变后续层接收到的数据分布，这一现象被称为内部协变量转移（Internal Covariate Shift）。\n\nBatch Normalization 的目标是：\n使每一层的输入保持相对稳定的分布，避免激活值过大或过小，从而使梯度下降过程更加稳定、更易收敛。\n\n在每一个小批量（mini-batch）数据送入网络时，BatchNorm 对当前层的每个通道（或神经元）进行两步处理。\n\n第一步：对激活值做标准化（Normalization），计算当前 batch 的均值和标准差，将数据规范化为均值接近 0、标准差接近 1 的分布：\n\nx^=x−μσ \\hat{x} = \\frac{x - \\mu}{\\sigma} x^=σx−μ\n\n第二步：引入可学习的缩放与平移参数：\n\ny=γx^+β y = \\gamma \\hat{x} + \\beta y=γx^+β\n\n其中 γ\\gammaγ 与 β\\betaβ 为可学习参数，使网络能够学习最合适的尺度与偏移，而非被固定为标准正态分布。\n\nBatch Normalization 的意义在于：\n加快训练速度（学习率可以调大）、降低对权重初始化的敏感性，并在一定程度上起到正则化作用（均值与方差存在噪声）。\n\n在使用习惯上，BatchNorm 一般放在激活函数之前；其参数 γ\\gammaγ、β\\betaβ 会参与反向传播；训练模式下使用当前 batch 的均值与方差，推理模式下使用全局移动平均估计值。\n\n\n# 三、ResNet 的基本思想\n\nResNet 的核心思想是残差学习，即让网络块学习输入和输出之间的“差值”，而不是直接学习一个新的映射。\n\n其基本形式为：\n\nY=X+F(X) Y = X + F(X) Y=X+F(X)\n\n一个基本残差块可描述为：\n\nX\n│\n├─ Conv 3×3 → BN → ReLU → Conv 3×3 → BN ──┐\n│                                         │\n└──────────── Conv 1×1（可选）────────────┘\n                      ↓\n                   相加\n                      ↓\n                    ReLU\n                      ↓\n                      Y\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当输入与输出的通道数不一致时，可在捷径分支上使用 Conv 1×1 进行匹配。\n\n残差结构的核心作用在于缓解深层网络的退化问题，使梯度更容易在深层网络中传播。\n\n\n# 四、DenseNet 的研究解释\n\nDenseNet 的设计思想是：每一层都直接连接到之前所有层的特征图（feature map）。\n\nDenseNet 使用的是通道维拼接（concatenate），而非 ResNet 中的逐元素相加。\n\n其形式可表示为：\n\n[X,f1(X),f2([X,f1(X)]),f3([X,f1(X),f2(⋅)])] [X, f_1(X), f_2([X, f_1(X)]), f_3([X, f_1(X), f_2(\\cdot)])] [X,f1 (X),f2 ([X,f1 (X)]),f3 ([X,f1 (X),f2 (⋅)])]\n\n\n# 稠密块（Dense Block）\n\n一个最小计算单元由以下结构组成：\n\nBN → ReLU → Conv 3×3（padding=1）\n\n其输出通道数固定。\n\n核心计算逻辑如下：\n\nfor i in range(num_convs):\n    layer.append(\n        conv_block(num_channels * i + input_channels, num_channels)\n    )\n\n\n1\n2\n3\n4\n\n\n其中，num_channels 为增长率（growth rate）。 第 iii 个卷积块的输入通道数等于原始输入通道数加上前 iii 个卷积块所产生的新通道数。\n\n即：前面所有层的输出，都会作为后面所有层的输入。\n\n\n# 过渡层（Transition Layer）\n\n由于稠密连接会导致通道数快速增长，从而引发计算量和参数规模的膨胀，因此需要在稠密块之间引入过渡层进行控制。\n\n过渡层结构为：\n\nBN → ReLU → Conv 1×1 → AvgPool2d（stride=2）\n\n其作用是压缩通道数并减小特征图的空间尺寸。\n\n\n# DenseNet 整体架构\n\n初始层：Conv → BN → ReLU → MaxPool，用于提取初始特征并降低分辨率。\n\n稠密模块（Dense Block）：多层稠密连接，持续积累特征表示。\n\n过渡层（Transition Layer）：控制通道数量并减小特征图尺寸。\n\n输出阶段（分类部分）：BN → ReLU → 全局平均池化 → 全连接层 → 分类输出。",normalizedContent:"本篇博客着重于解释自己对于 googlenet 以及深层网络 resnet、densenet 的理解。\n\n\n# 一、googlenet 网络并行化的阐述\n\ngooglenet 是一个巨大的进展，它的设计思想是从单纯追求网络深度，转向同时强调网络的宽度。\n\n一个 googlenet 的 inception 块由四条并行线路组成，它们共享相同的输入通道数，并在输出端进行通道维拼接（concatenate）。\n\n四条路径如下：\n\n路径一：\n\nconv 1×1\n作用：保留空间分辨率，调整通道数，输出结果参与最终拼接。\n\n路径二：\n\nconv 1×1（降维）\n→ conv 3×3（padding=1）\n作用：在保证空间分辨率不变的前提下，引入中等感受野。\n\n路径三：\n\nconv 1×1（降维）\n→ conv 5×5（padding=2）\n作用：引入更大的感受野，捕捉更大尺度特征。\n\n路径四：\n\nmaxpool（kernel=3，stride=1，padding=1）\n→ conv 1×1\n作用：引入池化特征，同时通过 1×1 卷积控制通道数。\n\n并行结构的核心意义在于：\n在同一层级同时观察不同尺度的特征，并将它们在通道维度上整合。\n\n\n# 二、批量规范化（batch normalization）\n\n批量规范化是一种在训练神经网络时用于稳定并加速训练过程的技术。\n\n在训练深层网络时，随着网络层数的加深，前面层参数的变化会不断改变后续层接收到的数据分布，这一现象被称为内部协变量转移（internal covariate shift）。\n\nbatch normalization 的目标是：\n使每一层的输入保持相对稳定的分布，避免激活值过大或过小，从而使梯度下降过程更加稳定、更易收敛。\n\n在每一个小批量（mini-batch）数据送入网络时，batchnorm 对当前层的每个通道（或神经元）进行两步处理。\n\n第一步：对激活值做标准化（normalization），计算当前 batch 的均值和标准差，将数据规范化为均值接近 0、标准差接近 1 的分布：\n\nx^=x−μσ \\hat{x} = \\frac{x - \\mu}{\\sigma} x^=σx−μ\n\n第二步：引入可学习的缩放与平移参数：\n\ny=γx^+β y = \\gamma \\hat{x} + \\beta y=γx^+β\n\n其中 γ\\gammaγ 与 β\\betaβ 为可学习参数，使网络能够学习最合适的尺度与偏移，而非被固定为标准正态分布。\n\nbatch normalization 的意义在于：\n加快训练速度（学习率可以调大）、降低对权重初始化的敏感性，并在一定程度上起到正则化作用（均值与方差存在噪声）。\n\n在使用习惯上，batchnorm 一般放在激活函数之前；其参数 γ\\gammaγ、β\\betaβ 会参与反向传播；训练模式下使用当前 batch 的均值与方差，推理模式下使用全局移动平均估计值。\n\n\n# 三、resnet 的基本思想\n\nresnet 的核心思想是残差学习，即让网络块学习输入和输出之间的“差值”，而不是直接学习一个新的映射。\n\n其基本形式为：\n\ny=x+f(x) y = x + f(x) y=x+f(x)\n\n一个基本残差块可描述为：\n\nx\n│\n├─ conv 3×3 → bn → relu → conv 3×3 → bn ──┐\n│                                         │\n└──────────── conv 1×1（可选）────────────┘\n                      ↓\n                   相加\n                      ↓\n                    relu\n                      ↓\n                      y\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当输入与输出的通道数不一致时，可在捷径分支上使用 conv 1×1 进行匹配。\n\n残差结构的核心作用在于缓解深层网络的退化问题，使梯度更容易在深层网络中传播。\n\n\n# 四、densenet 的研究解释\n\ndensenet 的设计思想是：每一层都直接连接到之前所有层的特征图（feature map）。\n\ndensenet 使用的是通道维拼接（concatenate），而非 resnet 中的逐元素相加。\n\n其形式可表示为：\n\n[x,f1(x),f2([x,f1(x)]),f3([x,f1(x),f2(⋅)])] [x, f_1(x), f_2([x, f_1(x)]), f_3([x, f_1(x), f_2(\\cdot)])] [x,f1 (x),f2 ([x,f1 (x)]),f3 ([x,f1 (x),f2 (⋅)])]\n\n\n# 稠密块（dense block）\n\n一个最小计算单元由以下结构组成：\n\nbn → relu → conv 3×3（padding=1）\n\n其输出通道数固定。\n\n核心计算逻辑如下：\n\nfor i in range(num_convs):\n    layer.append(\n        conv_block(num_channels * i + input_channels, num_channels)\n    )\n\n\n1\n2\n3\n4\n\n\n其中，num_channels 为增长率（growth rate）。 第 iii 个卷积块的输入通道数等于原始输入通道数加上前 iii 个卷积块所产生的新通道数。\n\n即：前面所有层的输出，都会作为后面所有层的输入。\n\n\n# 过渡层（transition layer）\n\n由于稠密连接会导致通道数快速增长，从而引发计算量和参数规模的膨胀，因此需要在稠密块之间引入过渡层进行控制。\n\n过渡层结构为：\n\nbn → relu → conv 1×1 → avgpool2d（stride=2）\n\n其作用是压缩通道数并减小特征图的空间尺寸。\n\n\n# densenet 整体架构\n\n初始层：conv → bn → relu → maxpool，用于提取初始特征并降低分辨率。\n\n稠密模块（dense block）：多层稠密连接，持续积累特征表示。\n\n过渡层（transition layer）：控制通道数量并减小特征图尺寸。\n\n输出阶段（分类部分）：bn → relu → 全局平均池化 → 全连接层 → 分类输出。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 01.一次最小的FPGA工程构建-从闪烁到流水",frontmatter:{title:"FPGA 01.一次最小的FPGA工程构建-从闪烁到流水",date:"2026-02-04T14:00:00.000Z",permalink:"/pages/FPGA_01/"},regularPath:"/03.FPGA/01.LED_Light_to_flow.html",relativePath:"03.FPGA/01.LED_Light_to_flow.md",key:"v-387c983e",path:"/pages/FPGA_01/",headers:[{level:2,title:"一、核心认识",slug:"一、核心认识",normalizedTitle:"一、核心认识",charIndex:72},{level:2,title:"二、可复用的代码",slug:"二、可复用的代码",normalizedTitle:"二、可复用的代码",charIndex:302},{level:2,title:"三、工程习惯记述",slug:"三、工程习惯记述",normalizedTitle:"三、工程习惯记述",charIndex:1356},{level:2,title:"四、总结",slug:"四、总结",normalizedTitle:"四、总结",charIndex:1530}],headersStr:"一、核心认识 二、可复用的代码 三、工程习惯记述 四、总结",content:"本文记录了在紫光 PGC4KD FPGA 上，从 LED 闪烁到流水灯的最小工程实践与思考，主要用于个人工程理解的固化，而非教程说明。\n\n\n# 一、核心认识\n\n在FPGA里面，延时≠sleep，而是“计数器+阈值+状态反转”，这意味着，FPGA 中所有“时间行为”最终都会被离散为时钟驱动下的状态变化。\n\nLED的闪烁，本质上是给一个引脚赋值0或者1也可以给一排LED同时赋值0或1\n\n流水灯的本质，其实就是一个循环的移位寄存器，先赋值LED=8b00000001，再进行左移位，当1位于LED[7]处时，下一次它就会出现在LED[0]处，这种表达方式在之后的状态机、数据通路设计中会频繁出现。\n\n\n# 二、可复用的代码\n\n`timescale 1ns / 1ps\n\n// LED循环流水灯（8位、0.5s切换、循环右移）- 可直接复用\nmodule led_flow (\n    input        clk,    // 输入时钟\n    input        rstn,   // 低电平有效复位\n    output [7:0] led     // 8位LED输出\n);\n\n// 可配置参数：适配不同板子时钟/流水间隔\nparameter CLK_FREQ  = 50_000_000;  // 板载时钟频率（50MHz）\nparameter FLOW_DELAY = 25_000_000; // 流水切换间隔计数（对应0.5s = FLOW_DELAY/CLK_FREQ）\n\n// 内部寄存器\nreg [25:0] cnt;        // 分频计数器（满足50MHz/0.5s的计数宽度需求）\nreg [7:0]  led_status; // LED状态寄存器\n\n// 步骤1：分频计数器（计数到FLOW_DELAY-1清零）\nalways @(posedge clk) begin\n    if (!rstn)\n        cnt <= 26'd0;\n    else if (cnt == FLOW_DELAY - 1)\n        cnt <= 26'd0;\n    else\n        cnt <= cnt + 1'b1;\nend\n\n// 步骤2：LED循环流水逻辑（计数满则切换状态，循环右移）\nalways @(posedge clk) begin\n    if (!rstn)\n        led_status <= 8'b0000_0001; // 复位后初始状态：最低位LED亮\n    else if (cnt == FLOW_DELAY - 1)\n        led_status <= {led_status[6:0], led_status[7]}; // 循环右移拼接（低7位移高位，原最高位移最低位）\nend\n\n// 输出赋值\nassign led = led_status;\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 三、工程习惯记述\n\n 1. 一般情况下，模块名需要和文件名称保持一致，这样方便集成环境识别顶层模块\n 2. 文件后缀\".fdc\"是约束文件，里面存储着时钟以及管脚约束等，是图形操作逻辑的底层，如果把一个.fdc文件放到指定位置，那么就不需要再重新约束\n 3. 不要在 FPGA 项目中使用 #1 等仿真延时语句，它们对综合电路没有实际意义\n\n\n# 四、总结\n\n在更高层次抽象下，这类实验并不关心具体外设，而是在练习： 如何在时钟驱动下，对状态进行可控、可预测的转换。",normalizedContent:"本文记录了在紫光 pgc4kd fpga 上，从 led 闪烁到流水灯的最小工程实践与思考，主要用于个人工程理解的固化，而非教程说明。\n\n\n# 一、核心认识\n\n在fpga里面，延时=sleep，而是“计数器+阈值+状态反转”，这意味着，fpga 中所有“时间行为”最终都会被离散为时钟驱动下的状态变化。\n\nled的闪烁，本质上是给一个引脚赋值0或者1也可以给一排led同时赋值0或1\n\n流水灯的本质，其实就是一个循环的移位寄存器，先赋值led=8b00000001，再进行左移位，当1位于led[7]处时，下一次它就会出现在led[0]处，这种表达方式在之后的状态机、数据通路设计中会频繁出现。\n\n\n# 二、可复用的代码\n\n`timescale 1ns / 1ps\n\n// led循环流水灯（8位、0.5s切换、循环右移）- 可直接复用\nmodule led_flow (\n    input        clk,    // 输入时钟\n    input        rstn,   // 低电平有效复位\n    output [7:0] led     // 8位led输出\n);\n\n// 可配置参数：适配不同板子时钟/流水间隔\nparameter clk_freq  = 50_000_000;  // 板载时钟频率（50mhz）\nparameter flow_delay = 25_000_000; // 流水切换间隔计数（对应0.5s = flow_delay/clk_freq）\n\n// 内部寄存器\nreg [25:0] cnt;        // 分频计数器（满足50mhz/0.5s的计数宽度需求）\nreg [7:0]  led_status; // led状态寄存器\n\n// 步骤1：分频计数器（计数到flow_delay-1清零）\nalways @(posedge clk) begin\n    if (!rstn)\n        cnt <= 26'd0;\n    else if (cnt == flow_delay - 1)\n        cnt <= 26'd0;\n    else\n        cnt <= cnt + 1'b1;\nend\n\n// 步骤2：led循环流水逻辑（计数满则切换状态，循环右移）\nalways @(posedge clk) begin\n    if (!rstn)\n        led_status <= 8'b0000_0001; // 复位后初始状态：最低位led亮\n    else if (cnt == flow_delay - 1)\n        led_status <= {led_status[6:0], led_status[7]}; // 循环右移拼接（低7位移高位，原最高位移最低位）\nend\n\n// 输出赋值\nassign led = led_status;\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 三、工程习惯记述\n\n 1. 一般情况下，模块名需要和文件名称保持一致，这样方便集成环境识别顶层模块\n 2. 文件后缀\".fdc\"是约束文件，里面存储着时钟以及管脚约束等，是图形操作逻辑的底层，如果把一个.fdc文件放到指定位置，那么就不需要再重新约束\n 3. 不要在 fpga 项目中使用 #1 等仿真延时语句，它们对综合电路没有实际意义\n\n\n# 四、总结\n\n在更高层次抽象下，这类实验并不关心具体外设，而是在练习： 如何在时钟驱动下，对状态进行可控、可预测的转换。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 02.按键不是输入信号，而是一段时间——一次关于消抖的记录",frontmatter:{title:"FPGA 02.按键不是输入信号，而是一段时间——一次关于消抖的记录",date:"2026-02-04T15:00:00.000Z",permalink:"/pages/FPGA_02/"},regularPath:"/03.FPGA/02.keys.html",relativePath:"03.FPGA/02.keys.md",key:"v-ba0f2176",path:"/pages/FPGA_02/",headers:[{level:2,title:"一、为什么一定要消抖",slug:"一、为什么一定要消抖",normalizedTitle:"一、为什么一定要消抖",charIndex:137},{level:2,title:"二、可以不用怀疑的消抖模型图",slug:"二、可以不用怀疑的消抖模型图",normalizedTitle:"二、可以不用怀疑的消抖模型图",charIndex:338},{level:2,title:"三、可复用的代码",slug:"三、可复用的代码",normalizedTitle:"三、可复用的代码",charIndex:834},{level:2,title:"四、总结",slug:"四、总结",normalizedTitle:"四、总结",charIndex:2641}],headersStr:"一、为什么一定要消抖 二、可以不用怀疑的消抖模型图 三、可复用的代码 四、总结",content:"在 FPGA 里面，按键并不是一个理想的 0 或 1，\n而是一段在时间轴上持续抖动的电平变化。\n\n通常认为，机械按键在按下和松开两个瞬间，\n都会各自产生大约 10ms 左右的抖动。\n\n----------------------------------------\n\n\n# 一、为什么一定要消抖\n\n如果不对按键进行消抖，那么输入信号就会在极短时间内反复变化。\n体现在波形图上，就是 key 那一条线跳得比 clk 还勤快。\n\n如果不消抖，这些变化会被原样送入状态机。\n于是状态机会开始频繁、不可预测地切换状态。\n\n此时如果状态机有嘴，它大概会说一句：\n\n> “哈基键，你这家伙……”\n\n----------------------------------------\n\n\n# 二、可以不用怀疑的消抖模型图\n\n电平\n 1 ────────────────┐      ┌─┐ ┌─┐ ┌──────────────\n                   │      │ │ │ │ │\n                   │      │ │ │ │ │ ← 松开抖动（≈10ms）\n 0                 └──────┘ └─┘ └─┘                      \n                        ← 按下抖动（≈10ms）\n时间 ────────────────────────────────────────────────▶\n                       ↑\n                    按下\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 ASCII 图并不追求美观， 但表达的是同一个事实：\n\n按键在由 1→0（按下）和 0→1（松开）时， 都会经历一段持续数毫秒的抖动区间。\n\n因此，按键更合理的理解方式不是“某一时刻的电平”， 而是“一段时间内是否已经稳定”。\n\n\n# 三、可复用的代码\n\n`timescale 1ns / 1ps\n\n// 多按键通用消抖模块\n// 支持参数化配置按键数量和消抖延时，可直接复用\nmodule btn_deb #(\n    parameter BTN_WIDTH = 1,        // 按键数量（默认 1 个）\n    parameter BTN_DELAY = 800_000   // 消抖延时（clk 计数个数，50MHz 时约 16ms）\n)(\n    input                      clk,      // 系统时钟\n    input  [BTN_WIDTH-1:0]     btn_in,   // 原始按键输入（未消抖）\n    output reg [BTN_WIDTH-1:0] btn_deb   // 消抖后的稳定输出\n);\n\n// 每个按键独立的计数器\nreg [19:0] cnt [BTN_WIDTH-1:0];\n\n// 抖动标志：1 表示当前处于抖动期\nreg [BTN_WIDTH-1:0] jitter_flag;\n\n// 输入打一拍，用于检测电平变化\nreg [BTN_WIDTH-1:0] btn_in_d;\n\n//-----------------------------------------------------\n// 输入同步：捕获前一拍按键电平\nalways @(posedge clk) begin\n    btn_in_d <= btn_in;\nend\n\n//-----------------------------------------------------\n// 为每一个按键生成独立的消抖逻辑\ngenvar i;\ngenerate\n    for (i = 0; i < BTN_WIDTH; i = i + 1) begin : DEB_ONE_KEY\n\n        // 抖动期判断：检测到电平变化则进入抖动期\n        always @(posedge clk) begin\n            if (btn_in_d[i] ^ btn_in[i])\n                jitter_flag[i] <= 1'b1;\n            else if (cnt[i] == BTN_DELAY)\n                jitter_flag[i] <= 1'b0;\n        end\n\n        // 抖动计数器：抖动期计数，稳定期清零\n        always @(posedge clk) begin\n            if (!jitter_flag[i])\n                cnt[i] <= 20'd0;\n            else if (cnt[i] == BTN_DELAY)\n                cnt[i] <= 20'd0;\n            else\n                cnt[i] <= cnt[i] + 1'b1;\n        end\n\n        // 输出逻辑：抖动期保持原值，稳定后更新\n        always @(posedge clk) begin\n            if (!jitter_flag[i])\n                btn_deb[i] <= btn_in[i];\n            else\n                btn_deb[i] <= btn_deb[i];\n        end\n\n    end\nendgenerate\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n----------------------------------------\n\n\n# 四、总结\n\n这一节只记录按键相关内容，与 LED 实验刻意分开。\n\n从工程角度来看，按键消抖逻辑可以粗略理解为两句话：\n\n * 时间还没到，不管你怎么抖，我都不认\n * 时间到了，你现在稳不稳，我就认你现在的状态\n\n本质上，这不是对电平的判断， 而是对时间稳定性的判断。",normalizedContent:"在 fpga 里面，按键并不是一个理想的 0 或 1，\n而是一段在时间轴上持续抖动的电平变化。\n\n通常认为，机械按键在按下和松开两个瞬间，\n都会各自产生大约 10ms 左右的抖动。\n\n----------------------------------------\n\n\n# 一、为什么一定要消抖\n\n如果不对按键进行消抖，那么输入信号就会在极短时间内反复变化。\n体现在波形图上，就是 key 那一条线跳得比 clk 还勤快。\n\n如果不消抖，这些变化会被原样送入状态机。\n于是状态机会开始频繁、不可预测地切换状态。\n\n此时如果状态机有嘴，它大概会说一句：\n\n> “哈基键，你这家伙……”\n\n----------------------------------------\n\n\n# 二、可以不用怀疑的消抖模型图\n\n电平\n 1 ────────────────┐      ┌─┐ ┌─┐ ┌──────────────\n                   │      │ │ │ │ │\n                   │      │ │ │ │ │ ← 松开抖动（≈10ms）\n 0                 └──────┘ └─┘ └─┘                      \n                        ← 按下抖动（≈10ms）\n时间 ────────────────────────────────────────────────▶\n                       ↑\n                    按下\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 ascii 图并不追求美观， 但表达的是同一个事实：\n\n按键在由 1→0（按下）和 0→1（松开）时， 都会经历一段持续数毫秒的抖动区间。\n\n因此，按键更合理的理解方式不是“某一时刻的电平”， 而是“一段时间内是否已经稳定”。\n\n\n# 三、可复用的代码\n\n`timescale 1ns / 1ps\n\n// 多按键通用消抖模块\n// 支持参数化配置按键数量和消抖延时，可直接复用\nmodule btn_deb #(\n    parameter btn_width = 1,        // 按键数量（默认 1 个）\n    parameter btn_delay = 800_000   // 消抖延时（clk 计数个数，50mhz 时约 16ms）\n)(\n    input                      clk,      // 系统时钟\n    input  [btn_width-1:0]     btn_in,   // 原始按键输入（未消抖）\n    output reg [btn_width-1:0] btn_deb   // 消抖后的稳定输出\n);\n\n// 每个按键独立的计数器\nreg [19:0] cnt [btn_width-1:0];\n\n// 抖动标志：1 表示当前处于抖动期\nreg [btn_width-1:0] jitter_flag;\n\n// 输入打一拍，用于检测电平变化\nreg [btn_width-1:0] btn_in_d;\n\n//-----------------------------------------------------\n// 输入同步：捕获前一拍按键电平\nalways @(posedge clk) begin\n    btn_in_d <= btn_in;\nend\n\n//-----------------------------------------------------\n// 为每一个按键生成独立的消抖逻辑\ngenvar i;\ngenerate\n    for (i = 0; i < btn_width; i = i + 1) begin : deb_one_key\n\n        // 抖动期判断：检测到电平变化则进入抖动期\n        always @(posedge clk) begin\n            if (btn_in_d[i] ^ btn_in[i])\n                jitter_flag[i] <= 1'b1;\n            else if (cnt[i] == btn_delay)\n                jitter_flag[i] <= 1'b0;\n        end\n\n        // 抖动计数器：抖动期计数，稳定期清零\n        always @(posedge clk) begin\n            if (!jitter_flag[i])\n                cnt[i] <= 20'd0;\n            else if (cnt[i] == btn_delay)\n                cnt[i] <= 20'd0;\n            else\n                cnt[i] <= cnt[i] + 1'b1;\n        end\n\n        // 输出逻辑：抖动期保持原值，稳定后更新\n        always @(posedge clk) begin\n            if (!jitter_flag[i])\n                btn_deb[i] <= btn_in[i];\n            else\n                btn_deb[i] <= btn_deb[i];\n        end\n\n    end\nendgenerate\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n----------------------------------------\n\n\n# 四、总结\n\n这一节只记录按键相关内容，与 led 实验刻意分开。\n\n从工程角度来看，按键消抖逻辑可以粗略理解为两句话：\n\n * 时间还没到，不管你怎么抖，我都不认\n * 时间到了，你现在稳不稳，我就认你现在的状态\n\n本质上，这不是对电平的判断， 而是对时间稳定性的判断。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 03.我与 PWM 的爱恨情仇",frontmatter:{title:"FPGA 03.我与 PWM 的爱恨情仇",date:"2026-02-05T12:00:00.000Z",permalink:"/pages/FPGA_03/"},regularPath:"/03.FPGA/03.PWM.html",relativePath:"03.FPGA/03.PWM.md",key:"v-39e8e8bb",path:"/pages/FPGA_03/",headers:[{level:2,title:"一、重新认识 PWM",slug:"一、重新认识-pwm",normalizedTitle:"一、重新认识 pwm",charIndex:113},{level:2,title:"二、一个可复用的 PWM 模块",slug:"二、一个可复用的-pwm-模块",normalizedTitle:"二、一个可复用的 pwm 模块",charIndex:576},{level:2,title:"三、踩坑与反思",slug:"三、踩坑与反思",normalizedTitle:"三、踩坑与反思",charIndex:2047}],headersStr:"一、重新认识 PWM 二、一个可复用的 PWM 模块 三、踩坑与反思",content:"本博客用于记录我在 FPGA 上学习、理解并最终“想通” PWM（脉冲宽度调制）的全过程。\n这不是一篇教程，而是一篇阶段性认知总结。\n\n----------------------------------------\n\n\n# 一、重新认识 PWM\n\nPWM，全称 Pulse Width Modulation，中文叫脉冲宽度调制。\n\n如果用一句工程味十足的话来说：\n\n> PWM 本质上不是在“输出一个模拟量”，\n> 而是在用时间比例来表达一个数值。\n\n为了更直观一点，可以想象一个尖叫鸡：\n\n * 按下，它叫；\n * 松手，它不叫。\n\n如果我们把时间尺度拉得非常大，比如 100 秒：\n\n * 按 30 秒、按 70 秒，对人来说几乎没有任何区别。\n\n但如果把时间尺度缩小到 1ms：\n\n * 300us 在叫，700us 不在叫；\n * 和 700us 在叫，300us 不在叫，\n\n那么宏观世界听到的“响度”显然不同。\n\n这就是时间尺度缩小后，脉冲宽度变化带来的“连续效果”。\n声音如此，亮度如此，电机转速也是如此。\n\n当“每个周期内按下的时间比例”缓慢变化时，\n你就会得到一个听起来（或看起来）像“呼吸”的效果——\n这就是所谓的 呼吸灯 / 呼吸鸡。\n\n----------------------------------------\n\n\n# 二、一个可复用的 PWM 模块\n\n在彻底理解官方呼吸灯代码之后，我最终选择把 PWM 抽象成一个干净、可复用的模块。\n\n这个模块只做一件事：\n根据占空比，输出 PWM 波形。\n\n`timescale 1ns/1ns\n\n// 极简、可复用的 PWM 发生器模块\nmodule pwm_gen #(\n    parameter CLK_FREQ = 50_000_000,  // 输入时钟频率（默认 50MHz）\n    parameter PWM_FREQ = 1_000         // PWM 输出频率（默认 1kHz）\n)(\n    input  wire        clk,            // 系统时钟\n    input  wire        rst_n,            // 低电平复位\n    input  wire [9:0]  duty,            // 占空比（0~999，对应 0%~100%）\n    output wire        pwm_out           // PWM 输出信号\n);\n\n    // PWM 周期内的时钟计数最大值\n    localparam PWM_CNT_MAX = CLK_FREQ / PWM_FREQ - 1;\n\n    reg [15:0] cnt;      // 时钟分频计数器\n    reg [9:0]  pwm_cnt;  // PWM 周期内的比较计数器（0~999）\n\n    // Step 1：时钟分频，产生 PWM 周期基准\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 16'd0;\n        else if (cnt == PWM_CNT_MAX)\n            cnt <= 16'd0;\n        else\n            cnt <= cnt + 1'b1;\n    end\n\n    // Step 2：PWM 周期内的计数（0~999）\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            pwm_cnt <= 10'd0;\n        else if (cnt == PWM_CNT_MAX)\n            pwm_cnt <= (pwm_cnt == 10'd999) ? 10'd0 : pwm_cnt + 1'b1;\n    end\n\n    // Step 3：核心逻辑 —— 时间比较生成 PWM\n    assign pwm_out = (pwm_cnt < duty);\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n该模块的特点：\n\n * 默认生成 1kHz PWM\n * duty 为输入，占空比 0~999\n * 与具体“呼吸算法”解耦\n * 可直接复用于 LED、电机、DAC 等场景\n\n在我看来，这种模块更像是一个工具， 而不是某块开发板的“展示性示例”。\n\n\n# 三、踩坑与反思\n\n写对代码，并不意味着实验一定能成功。\n\n在这次实验中，我真实踩到的一个坑是：\n\n> FPGA 不同 IO BANK 的供电电压和 IO 标准是不同的。\n\n例如：\n\n * LVCMOS12 对应 1.2V\n * LVCMOS33 对应 3.3V\n\nLED 能“亮”，并不代表电平标准是正确的。 板子“看起来正常”，很多时候只是硬件足够宽容。\n\n此外，这次也再次验证了一件事：\n\n> 一旦实验现象不对， 就不能无条件相信任何一个模块、任何一段代码， 更不能迷信“看起来没问题”。\n\n逐层验证、逐级拆解，才是 FPGA 最朴素也最可靠的调试方式。",normalizedContent:"本博客用于记录我在 fpga 上学习、理解并最终“想通” pwm（脉冲宽度调制）的全过程。\n这不是一篇教程，而是一篇阶段性认知总结。\n\n----------------------------------------\n\n\n# 一、重新认识 pwm\n\npwm，全称 pulse width modulation，中文叫脉冲宽度调制。\n\n如果用一句工程味十足的话来说：\n\n> pwm 本质上不是在“输出一个模拟量”，\n> 而是在用时间比例来表达一个数值。\n\n为了更直观一点，可以想象一个尖叫鸡：\n\n * 按下，它叫；\n * 松手，它不叫。\n\n如果我们把时间尺度拉得非常大，比如 100 秒：\n\n * 按 30 秒、按 70 秒，对人来说几乎没有任何区别。\n\n但如果把时间尺度缩小到 1ms：\n\n * 300us 在叫，700us 不在叫；\n * 和 700us 在叫，300us 不在叫，\n\n那么宏观世界听到的“响度”显然不同。\n\n这就是时间尺度缩小后，脉冲宽度变化带来的“连续效果”。\n声音如此，亮度如此，电机转速也是如此。\n\n当“每个周期内按下的时间比例”缓慢变化时，\n你就会得到一个听起来（或看起来）像“呼吸”的效果——\n这就是所谓的 呼吸灯 / 呼吸鸡。\n\n----------------------------------------\n\n\n# 二、一个可复用的 pwm 模块\n\n在彻底理解官方呼吸灯代码之后，我最终选择把 pwm 抽象成一个干净、可复用的模块。\n\n这个模块只做一件事：\n根据占空比，输出 pwm 波形。\n\n`timescale 1ns/1ns\n\n// 极简、可复用的 pwm 发生器模块\nmodule pwm_gen #(\n    parameter clk_freq = 50_000_000,  // 输入时钟频率（默认 50mhz）\n    parameter pwm_freq = 1_000         // pwm 输出频率（默认 1khz）\n)(\n    input  wire        clk,            // 系统时钟\n    input  wire        rst_n,            // 低电平复位\n    input  wire [9:0]  duty,            // 占空比（0~999，对应 0%~100%）\n    output wire        pwm_out           // pwm 输出信号\n);\n\n    // pwm 周期内的时钟计数最大值\n    localparam pwm_cnt_max = clk_freq / pwm_freq - 1;\n\n    reg [15:0] cnt;      // 时钟分频计数器\n    reg [9:0]  pwm_cnt;  // pwm 周期内的比较计数器（0~999）\n\n    // step 1：时钟分频，产生 pwm 周期基准\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 16'd0;\n        else if (cnt == pwm_cnt_max)\n            cnt <= 16'd0;\n        else\n            cnt <= cnt + 1'b1;\n    end\n\n    // step 2：pwm 周期内的计数（0~999）\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            pwm_cnt <= 10'd0;\n        else if (cnt == pwm_cnt_max)\n            pwm_cnt <= (pwm_cnt == 10'd999) ? 10'd0 : pwm_cnt + 1'b1;\n    end\n\n    // step 3：核心逻辑 —— 时间比较生成 pwm\n    assign pwm_out = (pwm_cnt < duty);\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n该模块的特点：\n\n * 默认生成 1khz pwm\n * duty 为输入，占空比 0~999\n * 与具体“呼吸算法”解耦\n * 可直接复用于 led、电机、dac 等场景\n\n在我看来，这种模块更像是一个工具， 而不是某块开发板的“展示性示例”。\n\n\n# 三、踩坑与反思\n\n写对代码，并不意味着实验一定能成功。\n\n在这次实验中，我真实踩到的一个坑是：\n\n> fpga 不同 io bank 的供电电压和 io 标准是不同的。\n\n例如：\n\n * lvcmos12 对应 1.2v\n * lvcmos33 对应 3.3v\n\nled 能“亮”，并不代表电平标准是正确的。 板子“看起来正常”，很多时候只是硬件足够宽容。\n\n此外，这次也再次验证了一件事：\n\n> 一旦实验现象不对， 就不能无条件相信任何一个模块、任何一段代码， 更不能迷信“看起来没问题”。\n\n逐层验证、逐级拆解，才是 fpga 最朴素也最可靠的调试方式。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 04.串口通信",frontmatter:{title:"FPGA 04.串口通信",date:"2026-02-06T22:00:00.000Z",permalink:"/pages/FPGA_04/"},regularPath:"/03.FPGA/04.USART.html",relativePath:"03.FPGA/04.USART.md",key:"v-6d0e5d0a",path:"/pages/FPGA_04/",headers:[{level:2,title:"一、串口通信的本质",slug:"一、串口通信的本质",normalizedTitle:"一、串口通信的本质",charIndex:102},{level:3,title:"关键工程事实",slug:"关键工程事实",normalizedTitle:"关键工程事实",charIndex:249},{level:2,title:"二、UART 接收模块（RX）",slug:"二、uart-接收模块-rx",normalizedTitle:"二、uart 接收模块（rx）",charIndex:417},{level:3,title:"设计思路（只保留关键点）",slug:"设计思路-只保留关键点",normalizedTitle:"设计思路（只保留关键点）",charIndex:437},{level:3,title:"最小可复用 RX 模块",slug:"最小可复用-rx-模块",normalizedTitle:"最小可复用 rx 模块",charIndex:557},{level:2,title:"三、UART 发送模块（TX）",slug:"三、uart-发送模块-tx",normalizedTitle:"三、uart 发送模块（tx）",charIndex:2875},{level:3,title:"设计思路",slug:"设计思路",normalizedTitle:"设计思路",charIndex:437},{level:3,title:"最小可复用 TX 模块",slug:"最小可复用-tx-模块",normalizedTitle:"最小可复用 tx 模块",charIndex:2974},{level:2,title:"四、调试经验备注",slug:"四、调试经验备注",normalizedTitle:"四、调试经验备注",charIndex:5201}],headersStr:"一、串口通信的本质 关键工程事实 二、UART 接收模块（RX） 设计思路（只保留关键点） 最小可复用 RX 模块 三、UART 发送模块（TX） 设计思路 最小可复用 TX 模块 四、调试经验备注",content:"本文记录 FPGA 中 UART（串口通信）的最小实现与工程直觉，仅作为个人内化与复用素材，不追求教学完整性。\n\n----------------------------------------\n\n\n# 一、串口通信的本质\n\nUART 的本质非常简单：\n\n * 两根线：TX（发送）、RX（接收）\n * 无共享时钟：完全异步\n * 靠约定好的时间尺度通信（波特率）\n\n最常见的数据帧格式为 10 bit：\n\n> 1 位起始位（低） + 8 位数据位（LSB 先行） + 1 位停止位（高）\n\n\n# 关键工程事实\n\n * 接收端必须处理异步问题\n   * 外部串口信号与 FPGA 系统时钟无关\n   * 必须使用同步/缓冲手段规避亚稳态\n * 发送端不关心对方是否接收到\n   * UART 没有应答机制\n   * 只负责按时序把比特送出去\n\n----------------------------------------\n\n\n# 二、UART 接收模块（RX）\n\n\n# 设计思路（只保留关键点）\n\n * 对 uart_rxd 做 两级同步\n * 检测 起始位下降沿 启动接收\n * 用 波特率计数器 确定采样时刻\n * 在 bit 中点采样 数据，保证稳定\n * 接收完成后给出 1 个周期的完成标志\n\n\n# 最小可复用 RX 模块\n\n/*\n * UART RX 最小实现\n * 8N1，无校验\n * SYS_CLK = 50MHz, UART_BPS = 115200（可参数化）\n */\nmodule uart_rx(\n    input            clk,\n    input            rst_n,\n    input            uart_rxd,\n    output reg       uart_rx_finish,\n    output reg [7:0] uart_rx_data\n);\n\nparameter SYS_CLK_FREQ = 50_000_000;\nparameter UART_BPS     = 115200;\nlocalparam BAUD_CNT_MAX = SYS_CLK_FREQ / UART_BPS;\n\nreg [1:0]  uart_rxd_sync;\nreg        work_en;\nreg [3:0]  rx_bit_cnt;\nreg [15:0] baud_cnt;\nreg [7:0]  rx_data_reg;\n\nwire start_flag = uart_rxd_sync[1] & ~uart_rxd_sync[0] & ~work_en;\n\n// 输入同步\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        uart_rxd_sync <= 2'b11;\n    else\n        uart_rxd_sync <= {uart_rxd_sync[0], uart_rxd};\nend\n\n// 接收使能\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        work_en <= 1'b0;\n    else if(start_flag)\n        work_en <= 1'b1;\n    else if(rx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX/2 - 1)\n        work_en <= 1'b0;\nend\n\n// 波特率计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        baud_cnt <= 0;\n    else if(work_en)\n        baud_cnt <= (baud_cnt < BAUD_CNT_MAX - 1) ? baud_cnt + 1'b1 : 0;\n    else\n        baud_cnt <= 0;\nend\n\n// bit 计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        rx_bit_cnt <= 0;\n    else if(work_en && baud_cnt == BAUD_CNT_MAX - 1)\n        rx_bit_cnt <= rx_bit_cnt + 1'b1;\n    else if(!work_en)\n        rx_bit_cnt <= 0;\nend\n\n// 数据采样\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        rx_data_reg <= 0;\n    else if(work_en && baud_cnt == BAUD_CNT_MAX/2 - 1) begin\n        if(rx_bit_cnt >= 1 && rx_bit_cnt <= 8)\n            rx_data_reg[rx_bit_cnt - 1] <= uart_rxd_sync[1];\n    end\nend\n\n// 输出\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        uart_rx_finish <= 1'b0;\n        uart_rx_data   <= 8'd0;\n    end else if(rx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX/2 - 1) begin\n        uart_rx_finish <= 1'b1;\n        uart_rx_data   <= rx_data_reg;\n    end else\n        uart_rx_finish <= 1'b0;\nend\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 三、UART 发送模块（TX）\n\n\n# 设计思路\n\n * 接收到发送请求后 锁存数据\n * 按 起始位 → 数据位 → 停止位 顺序输出\n * 用 uart_tx_busy 表示发送中状态\n\n\n# 最小可复用 TX 模块\n\n/*\n * UART TX 最小实现\n * 8N1，无校验\n */\nmodule uart_tx(\n    input           clk,\n    input           rst_n,\n    input           uart_tx_req,\n    input  [7:0]    uart_tx_data,\n    output reg      uart_txd,\n    output reg      uart_tx_busy\n);\n\nparameter SYS_CLK_FREQ = 50_000_000;\nparameter UART_BPS     = 115200;\nlocalparam BAUD_CNT_MAX = SYS_CLK_FREQ / UART_BPS;\n\nreg [7:0]  tx_data_reg;\nreg [3:0]  tx_bit_cnt;\nreg [15:0] baud_cnt;\n\n// 发送控制\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        uart_tx_busy <= 1'b0;\n        tx_data_reg  <= 8'd0;\n    end else if(uart_tx_req) begin\n        uart_tx_busy <= 1'b1;\n        tx_data_reg  <= uart_tx_data;\n    end else if(tx_bit_cnt == 4'd9 && baud_cnt == BAUD_CNT_MAX - 1)\n        uart_tx_busy <= 1'b0;\nend\n\n// 波特率计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        baud_cnt <= 0;\n    else if(uart_tx_busy)\n        baud_cnt <= (baud_cnt < BAUD_CNT_MAX - 1) ? baud_cnt + 1'b1 : 0;\n    else\n        baud_cnt <= 0;\nend\n\n// bit 计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        tx_bit_cnt <= 0;\n    else if(uart_tx_busy && baud_cnt == BAUD_CNT_MAX - 1)\n        tx_bit_cnt <= tx_bit_cnt + 1'b1;\n    else if(!uart_tx_busy)\n        tx_bit_cnt <= 0;\nend\n\n// 串行输出\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        uart_txd <= 1'b1;\n    else if(uart_tx_busy) begin\n        case(tx_bit_cnt)\n            4'd0: uart_txd <= 1'b0;\n            4'd1: uart_txd <= tx_data_reg[0];\n            4'd2: uart_txd <= tx_data_reg[1];\n            4'd3: uart_txd <= tx_data_reg[2];\n            4'd4: uart_txd <= tx_data_reg[3];\n            4'd5: uart_txd <= tx_data_reg[4];\n            4'd6: uart_txd <= tx_data_reg[5];\n            4'd7: uart_txd <= tx_data_reg[6];\n            4'd8: uart_txd <= tx_data_reg[7];\n            4'd9: uart_txd <= 1'b1;\n            default: uart_txd <= 1'b1;\n        endcase\n    end else\n        uart_txd <= 1'b1;\nend\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n----------------------------------------\n\n\n# 四、调试经验备注\n\n * 代码没问题，80% 的问题在物理连接\n   * TX / RX 是否交叉\n   * 共地是否可靠\n * 波特率不准时，现象通常是：\n   * 接收乱码\n   * 偶发正确\n\n----------------------------------------\n\n> UART 的难点不在协议，而在 工程时序意识。 到这里，串口已经不再是“通信问题”，而只是一个工具。",normalizedContent:"本文记录 fpga 中 uart（串口通信）的最小实现与工程直觉，仅作为个人内化与复用素材，不追求教学完整性。\n\n----------------------------------------\n\n\n# 一、串口通信的本质\n\nuart 的本质非常简单：\n\n * 两根线：tx（发送）、rx（接收）\n * 无共享时钟：完全异步\n * 靠约定好的时间尺度通信（波特率）\n\n最常见的数据帧格式为 10 bit：\n\n> 1 位起始位（低） + 8 位数据位（lsb 先行） + 1 位停止位（高）\n\n\n# 关键工程事实\n\n * 接收端必须处理异步问题\n   * 外部串口信号与 fpga 系统时钟无关\n   * 必须使用同步/缓冲手段规避亚稳态\n * 发送端不关心对方是否接收到\n   * uart 没有应答机制\n   * 只负责按时序把比特送出去\n\n----------------------------------------\n\n\n# 二、uart 接收模块（rx）\n\n\n# 设计思路（只保留关键点）\n\n * 对 uart_rxd 做 两级同步\n * 检测 起始位下降沿 启动接收\n * 用 波特率计数器 确定采样时刻\n * 在 bit 中点采样 数据，保证稳定\n * 接收完成后给出 1 个周期的完成标志\n\n\n# 最小可复用 rx 模块\n\n/*\n * uart rx 最小实现\n * 8n1，无校验\n * sys_clk = 50mhz, uart_bps = 115200（可参数化）\n */\nmodule uart_rx(\n    input            clk,\n    input            rst_n,\n    input            uart_rxd,\n    output reg       uart_rx_finish,\n    output reg [7:0] uart_rx_data\n);\n\nparameter sys_clk_freq = 50_000_000;\nparameter uart_bps     = 115200;\nlocalparam baud_cnt_max = sys_clk_freq / uart_bps;\n\nreg [1:0]  uart_rxd_sync;\nreg        work_en;\nreg [3:0]  rx_bit_cnt;\nreg [15:0] baud_cnt;\nreg [7:0]  rx_data_reg;\n\nwire start_flag = uart_rxd_sync[1] & ~uart_rxd_sync[0] & ~work_en;\n\n// 输入同步\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        uart_rxd_sync <= 2'b11;\n    else\n        uart_rxd_sync <= {uart_rxd_sync[0], uart_rxd};\nend\n\n// 接收使能\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        work_en <= 1'b0;\n    else if(start_flag)\n        work_en <= 1'b1;\n    else if(rx_bit_cnt == 4'd9 && baud_cnt == baud_cnt_max/2 - 1)\n        work_en <= 1'b0;\nend\n\n// 波特率计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        baud_cnt <= 0;\n    else if(work_en)\n        baud_cnt <= (baud_cnt < baud_cnt_max - 1) ? baud_cnt + 1'b1 : 0;\n    else\n        baud_cnt <= 0;\nend\n\n// bit 计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        rx_bit_cnt <= 0;\n    else if(work_en && baud_cnt == baud_cnt_max - 1)\n        rx_bit_cnt <= rx_bit_cnt + 1'b1;\n    else if(!work_en)\n        rx_bit_cnt <= 0;\nend\n\n// 数据采样\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        rx_data_reg <= 0;\n    else if(work_en && baud_cnt == baud_cnt_max/2 - 1) begin\n        if(rx_bit_cnt >= 1 && rx_bit_cnt <= 8)\n            rx_data_reg[rx_bit_cnt - 1] <= uart_rxd_sync[1];\n    end\nend\n\n// 输出\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        uart_rx_finish <= 1'b0;\n        uart_rx_data   <= 8'd0;\n    end else if(rx_bit_cnt == 4'd9 && baud_cnt == baud_cnt_max/2 - 1) begin\n        uart_rx_finish <= 1'b1;\n        uart_rx_data   <= rx_data_reg;\n    end else\n        uart_rx_finish <= 1'b0;\nend\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 三、uart 发送模块（tx）\n\n\n# 设计思路\n\n * 接收到发送请求后 锁存数据\n * 按 起始位 → 数据位 → 停止位 顺序输出\n * 用 uart_tx_busy 表示发送中状态\n\n\n# 最小可复用 tx 模块\n\n/*\n * uart tx 最小实现\n * 8n1，无校验\n */\nmodule uart_tx(\n    input           clk,\n    input           rst_n,\n    input           uart_tx_req,\n    input  [7:0]    uart_tx_data,\n    output reg      uart_txd,\n    output reg      uart_tx_busy\n);\n\nparameter sys_clk_freq = 50_000_000;\nparameter uart_bps     = 115200;\nlocalparam baud_cnt_max = sys_clk_freq / uart_bps;\n\nreg [7:0]  tx_data_reg;\nreg [3:0]  tx_bit_cnt;\nreg [15:0] baud_cnt;\n\n// 发送控制\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        uart_tx_busy <= 1'b0;\n        tx_data_reg  <= 8'd0;\n    end else if(uart_tx_req) begin\n        uart_tx_busy <= 1'b1;\n        tx_data_reg  <= uart_tx_data;\n    end else if(tx_bit_cnt == 4'd9 && baud_cnt == baud_cnt_max - 1)\n        uart_tx_busy <= 1'b0;\nend\n\n// 波特率计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        baud_cnt <= 0;\n    else if(uart_tx_busy)\n        baud_cnt <= (baud_cnt < baud_cnt_max - 1) ? baud_cnt + 1'b1 : 0;\n    else\n        baud_cnt <= 0;\nend\n\n// bit 计数\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        tx_bit_cnt <= 0;\n    else if(uart_tx_busy && baud_cnt == baud_cnt_max - 1)\n        tx_bit_cnt <= tx_bit_cnt + 1'b1;\n    else if(!uart_tx_busy)\n        tx_bit_cnt <= 0;\nend\n\n// 串行输出\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        uart_txd <= 1'b1;\n    else if(uart_tx_busy) begin\n        case(tx_bit_cnt)\n            4'd0: uart_txd <= 1'b0;\n            4'd1: uart_txd <= tx_data_reg[0];\n            4'd2: uart_txd <= tx_data_reg[1];\n            4'd3: uart_txd <= tx_data_reg[2];\n            4'd4: uart_txd <= tx_data_reg[3];\n            4'd5: uart_txd <= tx_data_reg[4];\n            4'd6: uart_txd <= tx_data_reg[5];\n            4'd7: uart_txd <= tx_data_reg[6];\n            4'd8: uart_txd <= tx_data_reg[7];\n            4'd9: uart_txd <= 1'b1;\n            default: uart_txd <= 1'b1;\n        endcase\n    end else\n        uart_txd <= 1'b1;\nend\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n----------------------------------------\n\n\n# 四、调试经验备注\n\n * 代码没问题，80% 的问题在物理连接\n   * tx / rx 是否交叉\n   * 共地是否可靠\n * 波特率不准时，现象通常是：\n   * 接收乱码\n   * 偶发正确\n\n----------------------------------------\n\n> uart 的难点不在协议，而在 工程时序意识。 到这里，串口已经不再是“通信问题”，而只是一个工具。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 05.IP 核的基本使用与注意事项",frontmatter:{title:"FPGA 05.IP 核的基本使用与注意事项",date:"2026-02-07T12:00:00.000Z",permalink:"/pages/FPGA_05/"},regularPath:"/03.FPGA/05.IP.html",relativePath:"03.FPGA/05.IP.md",key:"v-358b60c5",path:"/pages/FPGA_05/",headers:[{level:2,title:"一、IP 是什么",slug:"一、ip-是什么",normalizedTitle:"一、ip 是什么",charIndex:96},{level:2,title:"二、IP 一般怎么用",slug:"二、ip-一般怎么用",normalizedTitle:"二、ip 一般怎么用",charIndex:335},{level:2,title:"三、IP 使用时要重点关注什么",slug:"三、ip-使用时要重点关注什么",normalizedTitle:"三、ip 使用时要重点关注什么",charIndex:524},{level:3,title:"1️⃣ 参数配置",slug:"_1️⃣-参数配置",normalizedTitle:"1️⃣ 参数配置",charIndex:544},{level:3,title:"2️⃣ 时钟与复位（最容易翻车）",slug:"_2️⃣-时钟与复位-最容易翻车",normalizedTitle:"2️⃣ 时钟与复位（最容易翻车）",charIndex:676},{level:3,title:"3️⃣ 例化方式",slug:"_3️⃣-例化方式",normalizedTitle:"3️⃣ 例化方式",charIndex:818},{level:3,title:"4️⃣ 仿真",slug:"_4️⃣-仿真",normalizedTitle:"4️⃣ 仿真",charIndex:928},{level:2,title:"四、常见误区速记",slug:"四、常见误区速记",normalizedTitle:"四、常见误区速记",charIndex:1031},{level:2,title:"五、一句工程级总结",slug:"五、一句工程级总结",normalizedTitle:"五、一句工程级总结",charIndex:1153}],headersStr:"一、IP 是什么 二、IP 一般怎么用 三、IP 使用时要重点关注什么 1️⃣ 参数配置 2️⃣ 时钟与复位（最容易翻车） 3️⃣ 例化方式 4️⃣ 仿真 四、常见误区速记 五、一句工程级总结",content:"本文用于快速回顾 FPGA 中 IP 核的概念、使用流程以及常见注意点，偏实践记忆，而非教材说明。\n\n----------------------------------------\n\n\n# 一、IP 是什么\n\nIP（Intellectual Property）核本质上是由厂商或第三方提供的、\n已经验证过的功能模块，用于直接调用 FPGA 的底层硬件资源。\n\n常见 IP：\n\n * PLL / Clock\n * FIFO\n * RAM / ROM\n * DDR、AXI 外设等\n\n一句话理解：\n\n> IP 是“功能 + 硬件资源绑定”的模块，不是普通 Verilog 代码。\n\n----------------------------------------\n\n\n# 二、IP 一般怎么用\n\n通用流程（工具无关）：\n\n 1. 选择 IP（根据功能需求）\n 2. 配置参数（位宽、深度、时钟、复位等）\n 3. 生成 IP\n 4. 例化生成的 wrapper 到顶层\n 5. 添加时钟 / 约束\n 6. 仿真或上板验证\n\n核心原则：只用，不改 IP 内部。\n\n----------------------------------------\n\n\n# 三、IP 使用时要重点关注什么\n\n\n# 1️⃣ 参数配置\n\n * 位宽是否匹配系统数据宽度\n * 深度是否满足最坏情况\n * 是否跨时钟域\n * 复位是同步还是异步\n\n👉 所有参数都应“能说清为什么这样配”。\n\n----------------------------------------\n\n\n# 2️⃣ 时钟与复位（最容易翻车）\n\n * IP 的时钟端口不能想当然\n * PLL / Clock IP 一定要写约束\n * 跨时钟 IP 也需要系统层面的设计配合\n * 低有效复位不要接反\n\n----------------------------------------\n\n\n# 3️⃣ 例化方式\n\n * 使用工具生成的 wrapper 模块\n * 不直接修改 IP 源文件\n * 所有端口都要明确连接含义\n\n----------------------------------------\n\n\n# 4️⃣ 仿真\n\n * IP 不是“连上就对”\n * 注意仿真模型是否加入工程\n * 跨时钟、复位问题优先仿真发现\n\n----------------------------------------\n\n\n# 四、常见误区速记\n\n * ❌ 把 IP 当普通 .v 文件\n * ❌ 全默认参数直接生成\n * ❌ 忽略时钟域与约束\n * ❌ IP 能跑 ≠ 已理解\n\n----------------------------------------\n\n\n# 五、一句工程级总结\n\n> IP 负责功能实现，工程设计负责结构与时序。\n\n会用 IP 是入门，\n能正确、稳定地用 IP 才算工程能力。\n\n----------------------------------------",normalizedContent:"本文用于快速回顾 fpga 中 ip 核的概念、使用流程以及常见注意点，偏实践记忆，而非教材说明。\n\n----------------------------------------\n\n\n# 一、ip 是什么\n\nip（intellectual property）核本质上是由厂商或第三方提供的、\n已经验证过的功能模块，用于直接调用 fpga 的底层硬件资源。\n\n常见 ip：\n\n * pll / clock\n * fifo\n * ram / rom\n * ddr、axi 外设等\n\n一句话理解：\n\n> ip 是“功能 + 硬件资源绑定”的模块，不是普通 verilog 代码。\n\n----------------------------------------\n\n\n# 二、ip 一般怎么用\n\n通用流程（工具无关）：\n\n 1. 选择 ip（根据功能需求）\n 2. 配置参数（位宽、深度、时钟、复位等）\n 3. 生成 ip\n 4. 例化生成的 wrapper 到顶层\n 5. 添加时钟 / 约束\n 6. 仿真或上板验证\n\n核心原则：只用，不改 ip 内部。\n\n----------------------------------------\n\n\n# 三、ip 使用时要重点关注什么\n\n\n# 1️⃣ 参数配置\n\n * 位宽是否匹配系统数据宽度\n * 深度是否满足最坏情况\n * 是否跨时钟域\n * 复位是同步还是异步\n\n👉 所有参数都应“能说清为什么这样配”。\n\n----------------------------------------\n\n\n# 2️⃣ 时钟与复位（最容易翻车）\n\n * ip 的时钟端口不能想当然\n * pll / clock ip 一定要写约束\n * 跨时钟 ip 也需要系统层面的设计配合\n * 低有效复位不要接反\n\n----------------------------------------\n\n\n# 3️⃣ 例化方式\n\n * 使用工具生成的 wrapper 模块\n * 不直接修改 ip 源文件\n * 所有端口都要明确连接含义\n\n----------------------------------------\n\n\n# 4️⃣ 仿真\n\n * ip 不是“连上就对”\n * 注意仿真模型是否加入工程\n * 跨时钟、复位问题优先仿真发现\n\n----------------------------------------\n\n\n# 四、常见误区速记\n\n * ❌ 把 ip 当普通 .v 文件\n * ❌ 全默认参数直接生成\n * ❌ 忽略时钟域与约束\n * ❌ ip 能跑 = 已理解\n\n----------------------------------------\n\n\n# 五、一句工程级总结\n\n> ip 负责功能实现，工程设计负责结构与时序。\n\n会用 ip 是入门，\n能正确、稳定地用 ip 才算工程能力。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 06.PLL 锁相环的认识",frontmatter:{title:"FPGA 06.PLL 锁相环的认识",date:"2026-02-07T13:00:00.000Z",permalink:"/pages/FPGA_06/"},regularPath:"/03.FPGA/06.PLL.html",relativePath:"03.FPGA/06.PLL.md",key:"v-10ebe03e",path:"/pages/FPGA_06/",headers:[{level:2,title:"一、PLL 的基本认识",slug:"一、pll-的基本认识",normalizedTitle:"一、pll 的基本认识",charIndex:119},{level:2,title:"二、PLL 的基本工作原理",slug:"二、pll-的基本工作原理",normalizedTitle:"二、pll 的基本工作原理",charIndex:413},{level:2,title:"三、用于理解 PLL 原理的示意代码",slug:"三、用于理解-pll-原理的示意代码",normalizedTitle:"三、用于理解 pll 原理的示意代码",charIndex:654}],headersStr:"一、PLL 的基本认识 二、PLL 的基本工作原理 三、用于理解 PLL 原理的示意代码",content:"本博客用于对 PLL（Phase Locked Loop，锁相环） 进行基础认识，\n内容仅包括：PLL 是什么 + PLL 的基本工作原理示意。\n\n----------------------------------------\n\n\n# 一、PLL 的基本认识\n\nPLL（锁相环）是一种基于反馈控制的时钟系统。\n\n其核心思想是：\n\n> 通过比较“输入参考信号”和“内部产生信号”的相位差，\n> 不断调整内部振荡器的频率，\n> 直到二者在频率上相同、相位保持固定差值。\n\n当系统进入稳定状态时：\n\n * 输出信号能够跟踪输入信号\n * 输入与输出之间的相位关系保持稳定\n * 系统称该状态为 锁定（Locked）\n\n在 FPGA 中，PLL 常用于对外部输入时钟进行：\n\n * 倍频 / 分频\n * 相位调整\n * 输出稳定的系统时钟\n\n----------------------------------------\n\n\n# 二、PLL 的基本工作原理\n\n从原理结构上看，PLL 通常由三部分组成：\n\n 1. 相位比较器（Phase Detector）\n    比较参考信号与反馈信号的相位差\n\n 2. 环路滤波器（Loop Filter）\n    对相位误差信号进行平滑，避免剧烈抖动\n\n 3. 压控振荡器（VCO）\n    根据控制信号调整输出频率\n\n输出信号再经过分频后反馈到输入端，\n形成一个闭环反馈系统。\n\n----------------------------------------\n\n\n# 三、用于理解 PLL 原理的示意代码\n\n需要强调的是：\n\n> 以下代码仅用于理解 PLL 的反馈调节思想，\n> 并不是真实可用的 PLL 实现。\n\n真实 FPGA 中的 PLL 必须通过厂商 IP 核实现。\n\nmodule pll_model (\n    input  wire ref_clk,   // 参考时钟\n    input  wire rst,\n    output reg  vco_clk     // 模拟振荡器输出\n);\n\n    reg [7:0] phase_error;  // 相位误差（示意）\n    reg [7:0] control;      // 控制量（示意）\n\n    // 相位比较（示意）\n    always @(posedge ref_clk or posedge rst) begin\n        if (rst)\n            phase_error <= 0;\n        else\n            phase_error <= phase_error + 1;  // 假想存在相位差\n    end\n\n    // 环路调节（示意）\n    always @(posedge ref_clk or posedge rst) begin\n        if (rst)\n            control <= 8'd100;\n        else\n            control <= control - phase_error;\n    end\n\n    // 振荡器模型（示意）\n    always #(control) begin\n        vco_clk = ~vco_clk;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n该示意模型体现的思想是：\n\n * 输出信号会被反馈并参与比较\n * 比较结果影响振荡器行为\n * 系统目标是让输出逐步“贴近”输入",normalizedContent:"本博客用于对 pll（phase locked loop，锁相环） 进行基础认识，\n内容仅包括：pll 是什么 + pll 的基本工作原理示意。\n\n----------------------------------------\n\n\n# 一、pll 的基本认识\n\npll（锁相环）是一种基于反馈控制的时钟系统。\n\n其核心思想是：\n\n> 通过比较“输入参考信号”和“内部产生信号”的相位差，\n> 不断调整内部振荡器的频率，\n> 直到二者在频率上相同、相位保持固定差值。\n\n当系统进入稳定状态时：\n\n * 输出信号能够跟踪输入信号\n * 输入与输出之间的相位关系保持稳定\n * 系统称该状态为 锁定（locked）\n\n在 fpga 中，pll 常用于对外部输入时钟进行：\n\n * 倍频 / 分频\n * 相位调整\n * 输出稳定的系统时钟\n\n----------------------------------------\n\n\n# 二、pll 的基本工作原理\n\n从原理结构上看，pll 通常由三部分组成：\n\n 1. 相位比较器（phase detector）\n    比较参考信号与反馈信号的相位差\n\n 2. 环路滤波器（loop filter）\n    对相位误差信号进行平滑，避免剧烈抖动\n\n 3. 压控振荡器（vco）\n    根据控制信号调整输出频率\n\n输出信号再经过分频后反馈到输入端，\n形成一个闭环反馈系统。\n\n----------------------------------------\n\n\n# 三、用于理解 pll 原理的示意代码\n\n需要强调的是：\n\n> 以下代码仅用于理解 pll 的反馈调节思想，\n> 并不是真实可用的 pll 实现。\n\n真实 fpga 中的 pll 必须通过厂商 ip 核实现。\n\nmodule pll_model (\n    input  wire ref_clk,   // 参考时钟\n    input  wire rst,\n    output reg  vco_clk     // 模拟振荡器输出\n);\n\n    reg [7:0] phase_error;  // 相位误差（示意）\n    reg [7:0] control;      // 控制量（示意）\n\n    // 相位比较（示意）\n    always @(posedge ref_clk or posedge rst) begin\n        if (rst)\n            phase_error <= 0;\n        else\n            phase_error <= phase_error + 1;  // 假想存在相位差\n    end\n\n    // 环路调节（示意）\n    always @(posedge ref_clk or posedge rst) begin\n        if (rst)\n            control <= 8'd100;\n        else\n            control <= control - phase_error;\n    end\n\n    // 振荡器模型（示意）\n    always #(control) begin\n        vco_clk = ~vco_clk;\n    end\n\nendmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n该示意模型体现的思想是：\n\n * 输出信号会被反馈并参与比较\n * 比较结果影响振荡器行为\n * 系统目标是让输出逐步“贴近”输入",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"FPGA 07.FIFO、ROM、RAM理解",frontmatter:{title:"FPGA 07.FIFO、ROM、RAM理解",date:"2026-02-08T14:00:00.000Z",permalink:"/pages/FPGA_07/"},regularPath:"/03.FPGA/07.FIFO_ROM_RAM.html",relativePath:"03.FPGA/07.FIFO_ROM_RAM.md",key:"v-4e27b9b6",path:"/pages/FPGA_07/",headers:[{level:2,title:"一、FIFO（First In First Out）",slug:"一、fifo-first-in-first-out",normalizedTitle:"一、fifo（first in first out）",charIndex:52},{level:3,title:"1. 核心直觉",slug:"_1-核心直觉",normalizedTitle:"1. 核心直觉",charIndex:83},{level:3,title:"2. 为什么一定要用 IP",slug:"_2-为什么一定要用-ip",normalizedTitle:"2. 为什么一定要用 ip",charIndex:201},{level:3,title:"3. 最小使用示例（同步 FIFO）",slug:"_3-最小使用示例-同步-fifo",normalizedTitle:"3. 最小使用示例（同步 fifo）",charIndex:274},{level:2,title:"二、RAM（Random Access Memory）",slug:"二、ram-random-access-memory",normalizedTitle:"二、ram（random access memory）",charIndex:591},{level:3,title:"1. 核心直觉",slug:"_1-核心直觉-2",normalizedTitle:"1. 核心直觉",charIndex:83},{level:3,title:"2. 两种物理来源（记住就行）",slug:"_2-两种物理来源-记住就行",normalizedTitle:"2. 两种物理来源（记住就行）",charIndex:701},{level:3,title:"3. 最小 RAM 代码（同步写，同步读）",slug:"_3-最小-ram-代码-同步写-同步读",normalizedTitle:"3. 最小 ram 代码（同步写，同步读）",charIndex:805},{level:2,title:"三、ROM（Read Only Memory）",slug:"三、rom-read-only-memory",normalizedTitle:"三、rom（read only memory）",charIndex:1044},{level:3,title:"1. 核心直觉",slug:"_1-核心直觉-3",normalizedTitle:"1. 核心直觉",charIndex:83},{level:3,title:"2. ROM 的本质",slug:"_2-rom-的本质",normalizedTitle:"2. rom 的本质",charIndex:1161},{level:3,title:"3. 最小 ROM 示例（case 形式）",slug:"_3-最小-rom-示例-case-形式",normalizedTitle:"3. 最小 rom 示例（case 形式）",charIndex:1226},{level:2,title:"四、一句话对齐三者",slug:"四、一句话对齐三者",normalizedTitle:"四、一句话对齐三者",charIndex:1509},{level:2,title:"五、给未来自己的备注",slug:"五、给未来自己的备注",normalizedTitle:"五、给未来自己的备注",charIndex:1615}],headersStr:"一、FIFO（First In First Out） 1. 核心直觉 2. 为什么一定要用 IP 3. 最小使用示例（同步 FIFO） 二、RAM（Random Access Memory） 1. 核心直觉 2. 两种物理来源（记住就行） 3. 最小 RAM 代码（同步写，同步读） 三、ROM（Read Only Memory） 1. 核心直觉 2. ROM 的本质 3. 最小 ROM 示例（case 形式） 四、一句话对齐三者 五、给未来自己的备注",content:"> 本文不是教学笔记，而是给未来的自己快速回忆用的最小总结：只保留原理直觉 + 最小可用代码。\n\n\n# 一、FIFO（First In First Out）\n\n\n# 1. 核心直觉\n\nFIFO 本质是：\n\n * 带读写指针的 RAM\n * 解决 不同时序 / 不同速率 的数据传递问题\n\n你不关心内部怎么绕，只关心四个信号：\n\n * wr_en / rd_en\n * full / empty\n\n\n# 2. 为什么一定要用 IP\n\n * 涉及指针回绕、空满判断、跨时钟\n * 手写极易出 bug\n\n👉 工程里 FIFO 基本只用 IP。\n\n\n# 3. 最小使用示例（同步 FIFO）\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wr_en <= 0;\n        rd_en <= 0;\n    end else begin\n        if (!full)  wr_en <= 1;  // 写数据\n        if (!empty) rd_en <= 1;  // 读数据\n    end\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 使用层面：把 FIFO 当成一个“有脾气的缓冲区”即可。\n\n----------------------------------------\n\n\n# 二、RAM（Random Access Memory）\n\n\n# 1. 核心直觉\n\nRAM =\n\n * 地址 → 数据 的映射\n * FPGA 里的 RAM 通常是：\n   * 单口 / 双口\n   * 同步读写\n\n\n# 2. 两种物理来源（记住就行）\n\n * Distributed RAM：LUT 拼的，小而快\n * Block RAM / DRAM：硬件块，大而省资源\n\n区别由工具或 IP 决定，用的时候不用想。\n\n\n# 3. 最小 RAM 代码（同步写，同步读）\n\nreg [7:0] mem [0:255];\n\nalways @(posedge clk) begin\n    if (we)\n        mem[addr] <= din;\n    dout <= mem[addr];\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 实际工程：自己写 RAM 只用于验证或小逻辑，正式设计用 IP。\n\n----------------------------------------\n\n\n# 三、ROM（Read Only Memory）\n\n\n# 1. 核心直觉\n\nROM 就是：\n\n * 内容固定的查表器\n * 本质仍然是 RAM，只是 不写\n\n常见用途：\n\n * 初始化参数\n * 查表（LUT）\n * 固定波形\n\n\n# 2. ROM 的本质\n\n * 仿真时是 case / initial\n * 综合后可能进 Block RAM 或 LUT\n\n\n# 3. 最小 ROM 示例（case 形式）\n\nalways @(*) begin\n    case (addr)\n        8'd0: dout = 8'h11;\n        8'd1: dout = 8'h22;\n        8'd2: dout = 8'h33;\n        default: dout = 8'h00;\n    endcase\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> ROM 的价值在于：把“逻辑判断”变成“数据选择”。\n\n----------------------------------------\n\n\n# 四、一句话对齐三者\n\n * RAM：我随便存、随便取\n * ROM：我只查、不改\n * FIFO：我不看地址，只讲顺序\n\n----------------------------------------\n\n\n# 五、给未来自己的备注\n\n * FIFO / RAM / ROM：会用 IP 即等于掌握\n * 不仿真、不手写 FIFO，完全合理\n * 到这一步，初级 FPGA 已经结束\n\n> 后面的内容，已经不再是“会不会”，而是“值不值得优化”。",normalizedContent:"> 本文不是教学笔记，而是给未来的自己快速回忆用的最小总结：只保留原理直觉 + 最小可用代码。\n\n\n# 一、fifo（first in first out）\n\n\n# 1. 核心直觉\n\nfifo 本质是：\n\n * 带读写指针的 ram\n * 解决 不同时序 / 不同速率 的数据传递问题\n\n你不关心内部怎么绕，只关心四个信号：\n\n * wr_en / rd_en\n * full / empty\n\n\n# 2. 为什么一定要用 ip\n\n * 涉及指针回绕、空满判断、跨时钟\n * 手写极易出 bug\n\n👉 工程里 fifo 基本只用 ip。\n\n\n# 3. 最小使用示例（同步 fifo）\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wr_en <= 0;\n        rd_en <= 0;\n    end else begin\n        if (!full)  wr_en <= 1;  // 写数据\n        if (!empty) rd_en <= 1;  // 读数据\n    end\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 使用层面：把 fifo 当成一个“有脾气的缓冲区”即可。\n\n----------------------------------------\n\n\n# 二、ram（random access memory）\n\n\n# 1. 核心直觉\n\nram =\n\n * 地址 → 数据 的映射\n * fpga 里的 ram 通常是：\n   * 单口 / 双口\n   * 同步读写\n\n\n# 2. 两种物理来源（记住就行）\n\n * distributed ram：lut 拼的，小而快\n * block ram / dram：硬件块，大而省资源\n\n区别由工具或 ip 决定，用的时候不用想。\n\n\n# 3. 最小 ram 代码（同步写，同步读）\n\nreg [7:0] mem [0:255];\n\nalways @(posedge clk) begin\n    if (we)\n        mem[addr] <= din;\n    dout <= mem[addr];\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 实际工程：自己写 ram 只用于验证或小逻辑，正式设计用 ip。\n\n----------------------------------------\n\n\n# 三、rom（read only memory）\n\n\n# 1. 核心直觉\n\nrom 就是：\n\n * 内容固定的查表器\n * 本质仍然是 ram，只是 不写\n\n常见用途：\n\n * 初始化参数\n * 查表（lut）\n * 固定波形\n\n\n# 2. rom 的本质\n\n * 仿真时是 case / initial\n * 综合后可能进 block ram 或 lut\n\n\n# 3. 最小 rom 示例（case 形式）\n\nalways @(*) begin\n    case (addr)\n        8'd0: dout = 8'h11;\n        8'd1: dout = 8'h22;\n        8'd2: dout = 8'h33;\n        default: dout = 8'h00;\n    endcase\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> rom 的价值在于：把“逻辑判断”变成“数据选择”。\n\n----------------------------------------\n\n\n# 四、一句话对齐三者\n\n * ram：我随便存、随便取\n * rom：我只查、不改\n * fifo：我不看地址，只讲顺序\n\n----------------------------------------\n\n\n# 五、给未来自己的备注\n\n * fifo / ram / rom：会用 ip 即等于掌握\n * 不仿真、不手写 fifo，完全合理\n * 到这一步，初级 fpga 已经结束\n\n> 后面的内容，已经不再是“会不会”，而是“值不值得优化”。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"Layout 01.PCB设计的流程概述",frontmatter:{title:"Layout 01.PCB设计的流程概述",date:"2026-02-19T12:00:00.000Z",permalink:"/pages/PCB_01/"},regularPath:"/04.PCB%20Layout/01.PCB_Layout_Design_Process.html",relativePath:"04.PCB Layout/01.PCB_Layout_Design_Process.md",key:"v-22f068d8",path:"/pages/PCB_01/",headers:[{level:3,title:"一、Layout 资料准备",slug:"一、layout-资料准备",normalizedTitle:"一、layout 资料准备",charIndex:2},{level:3,title:"二、网表导入",slug:"二、网表导入",normalizedTitle:"二、网表导入",charIndex:192},{level:3,title:"三、模块规划与按功能规划摆放器件",slug:"三、模块规划与按功能规划摆放器件",normalizedTitle:"三、模块规划与按功能规划摆放器件",charIndex:319},{level:3,title:"四、器件布局与布局优化",slug:"四、器件布局与布局优化",normalizedTitle:"四、器件布局与布局优化",charIndex:416},{level:3,title:"五、 层叠设置",slug:"五、-层叠设置",normalizedTitle:"五、 层叠设置",charIndex:558},{level:3,title:"六、规则设置",slug:"六、规则设置",normalizedTitle:"六、规则设置",charIndex:611},{level:3,title:"七、PCB 走线",slug:"七、pcb-走线",normalizedTitle:"七、pcb 走线",charIndex:730},{level:3,title:"八、PCB 修线",slug:"八、pcb-修线",normalizedTitle:"八、pcb 修线",charIndex:779},{level:3,title:"九、PCB 等长",slug:"九、pcb-等长",normalizedTitle:"九、pcb 等长",charIndex:833},{level:3,title:"十、布线优化",slug:"十、布线优化",normalizedTitle:"十、布线优化",charIndex:887},{level:3,title:"十一、DRC 检查",slug:"十一、drc-检查",normalizedTitle:"十一、drc 检查",charIndex:935},{level:3,title:"十二、丝印处理",slug:"十二、丝印处理",normalizedTitle:"十二、丝印处理",charIndex:1001},{level:3,title:"十三、交付输出",slug:"十三、交付输出",normalizedTitle:"十三、交付输出",charIndex:1059}],headersStr:"一、Layout 资料准备 二、网表导入 三、模块规划与按功能规划摆放器件 四、器件布局与布局优化 五、 层叠设置 六、规则设置 七、PCB 走线 八、PCB 修线 九、PCB 等长 十、布线优化 十一、DRC 检查 十二、丝印处理 十三、交付输出",content:"# 一、Layout 资料准备\n\n * 原理图：设计文件，用于确认信号流向、电源 / 地网络、器件功能。\n * 结构图：DXF 文件，用于确定板框大小、安装孔位置、器件的高度和排布限制。\n * 设计说明：Layout 设计要求，记录关键信号、器件手册、封装实例、以及推荐布局 / 走线参考。\n\n----------------------------------------\n\n\n# 二、网表导入\n\n * 顺序：原理图 → PCB\n * 结构文件导入 PCB：默认单位为 mil，单位为 mm 时需注意换算，1 mil = 0.0254 mm。\n\n----------------------------------------\n\n\n# 三、模块规划与按功能规划摆放器件\n\n * 先确定主控位置或布局，其它模块根据飞线和信号流向进行摆放。\n\n----------------------------------------\n\n\n# 四、器件布局与布局优化\n\n * 布局顺序：结构器件 → 特殊器件 → 主要器件\n\n * 原则：先大后小，主要 IC 器件按飞线流向放置合适位置，滤波器件靠近滤波管脚。\n\n * 优化：器件中心对齐，大器件尽量对齐，相同模块必须一致；注意散热、ESD、静电防护、高压安全距离等。\n\n\n# 五、 层叠设置\n\n * 定义 PCB 层叠结构，每一层对应 叠层名称（如信号层、地层、电源层）。\n\n\n# 六、规则设置\n\n * 线宽 / 线距 / 过孔：根据电流、阻抗、工艺能力设定最小线宽、线距和过孔参数。\n * 整板扇孔：对 BGA 等器件进行整板扇出，确保无走线死角。\n * 电源模块扇孔：对应电源网络，优先处理大电流电源走线。\n\n\n# 七、PCB 走线\n\n * 优先走 重要信号线，重要走线进行过孔地处理，避免电源信号干扰。\n\n\n# 八、PCB 修线\n\n * 布局后进行信号走线，满足阻抗要求，回流路径连续，不存在环形、U 型路径。\n\n\n# 九、PCB 等长\n\n * 高速信号：检查时序、匹配、线长、3W 原则，差分线对差不超过 5mil。\n\n\n# 十、布线优化\n\n * 关键信号：检查关键信号、电源信号载流、路径、过孔数量及处理方式。\n\n\n# 十一、DRC 检查\n\n * 检查是否全部连通，是否存在开路、短路。\n * 检查是否避开禁布区、限高区，确认铣槽、锣铣无误。\n\n\n# 十二、丝印处理\n\n * 丝印方向统一，不跑位、阻焊。\n * 检查丝印是否正确，位号、LOGO 等是否添加。\n\n\n# 十三、交付输出\n\n * ASM：装配图文件。\n * CAM：Gerber 文件，用于制版。\n * SMT：贴片文件表，用于贴片。\n * PRJ：工程文件，源文件。\n * xxx.docx：制版工艺说明文件。",normalizedContent:"# 一、layout 资料准备\n\n * 原理图：设计文件，用于确认信号流向、电源 / 地网络、器件功能。\n * 结构图：dxf 文件，用于确定板框大小、安装孔位置、器件的高度和排布限制。\n * 设计说明：layout 设计要求，记录关键信号、器件手册、封装实例、以及推荐布局 / 走线参考。\n\n----------------------------------------\n\n\n# 二、网表导入\n\n * 顺序：原理图 → pcb\n * 结构文件导入 pcb：默认单位为 mil，单位为 mm 时需注意换算，1 mil = 0.0254 mm。\n\n----------------------------------------\n\n\n# 三、模块规划与按功能规划摆放器件\n\n * 先确定主控位置或布局，其它模块根据飞线和信号流向进行摆放。\n\n----------------------------------------\n\n\n# 四、器件布局与布局优化\n\n * 布局顺序：结构器件 → 特殊器件 → 主要器件\n\n * 原则：先大后小，主要 ic 器件按飞线流向放置合适位置，滤波器件靠近滤波管脚。\n\n * 优化：器件中心对齐，大器件尽量对齐，相同模块必须一致；注意散热、esd、静电防护、高压安全距离等。\n\n\n# 五、 层叠设置\n\n * 定义 pcb 层叠结构，每一层对应 叠层名称（如信号层、地层、电源层）。\n\n\n# 六、规则设置\n\n * 线宽 / 线距 / 过孔：根据电流、阻抗、工艺能力设定最小线宽、线距和过孔参数。\n * 整板扇孔：对 bga 等器件进行整板扇出，确保无走线死角。\n * 电源模块扇孔：对应电源网络，优先处理大电流电源走线。\n\n\n# 七、pcb 走线\n\n * 优先走 重要信号线，重要走线进行过孔地处理，避免电源信号干扰。\n\n\n# 八、pcb 修线\n\n * 布局后进行信号走线，满足阻抗要求，回流路径连续，不存在环形、u 型路径。\n\n\n# 九、pcb 等长\n\n * 高速信号：检查时序、匹配、线长、3w 原则，差分线对差不超过 5mil。\n\n\n# 十、布线优化\n\n * 关键信号：检查关键信号、电源信号载流、路径、过孔数量及处理方式。\n\n\n# 十一、drc 检查\n\n * 检查是否全部连通，是否存在开路、短路。\n * 检查是否避开禁布区、限高区，确认铣槽、锣铣无误。\n\n\n# 十二、丝印处理\n\n * 丝印方向统一，不跑位、阻焊。\n * 检查丝印是否正确，位号、logo 等是否添加。\n\n\n# 十三、交付输出\n\n * asm：装配图文件。\n * cam：gerber 文件，用于制版。\n * smt：贴片文件表，用于贴片。\n * prj：工程文件，源文件。\n * xxx.docx：制版工艺说明文件。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"Layout 02.阻抗",frontmatter:{title:"Layout 02.阻抗",date:"2026-02-19T13:00:00.000Z",permalink:"/pages/PCB_02/"},regularPath:"/04.PCB%20Layout/02.Impedence.html",relativePath:"04.PCB Layout/02.Impedence.md",key:"v-c8856c68",path:"/pages/PCB_02/",headers:[{level:2,title:"一、阻抗",slug:"一、阻抗",normalizedTitle:"一、阻抗",charIndex:2},{level:2,title:"二、为什么要控阻抗？",slug:"二、为什么要控阻抗",normalizedTitle:"二、为什么要控阻抗？",charIndex:161},{level:2,title:"三、应用",slug:"三、应用",normalizedTitle:"三、应用",charIndex:361}],headersStr:"一、阻抗 二、为什么要控阻抗？ 三、应用",content:"# 一、阻抗\n\n具有电阻、电感和电容的电路里，对交流电所起的阻碍作用叫做阻抗，通常用符号 Z 表示。阻抗可以是电阻、电容、电感的任意组合对电流起到的阻碍作用。\n\n由于电容对直流电的阻抗无穷大，而电感对直流电的阻抗是零，因此，阻抗更多用于描述交流电路中对电流的阻碍作用。\n\n高阻抗是指阻抗值大，低阻抗是指阻抗值小。\n\n\n# 二、为什么要控阻抗？\n\n针对目前高频高速的要求，及对信号失真状况越来越高的要求，在设计 PCB 时方波信号在多层板信号线中，其特性阻抗值必须要和电子元件的内置电子阻抗相匹配，才能保证信号的完整的传输。\n\n * 当特性阻抗值超出公差时，所传信号的能量将出现反射、散失、衰减或延误等劣化现象，严重时会出现错误信号。\n * 为了配合电子元器件的电子阻抗，避免信号传输时失真的现象，所以要控制阻抗。\n\n\n# 三、应用\n\nPCB 中的阻抗，本质是传输线的特性阻抗（Z₀），由线宽、介质厚度、介电常数以及结构共同决定。当信号频率高或上升沿很快时，PCB 走线不再是“导线”，而是“传输线”，需要阻抗匹配以避免反射。\n\n常见阻抗数值与应用：\n\n * 50Ω 单端：射频系统、高频时钟、部分高速 IO\n\n * 75Ω 单端：视频与同轴传输\n\n * 90Ω 差分：USB 2.0\n\n * 100Ω 差分：USB 3.x、以太网、LVDS、SerDes\n\n * 85Ω 差分：部分显示接口标准\n\n如果是普通低速数字信号，一般不需要严格阻抗控制。",normalizedContent:"# 一、阻抗\n\n具有电阻、电感和电容的电路里，对交流电所起的阻碍作用叫做阻抗，通常用符号 z 表示。阻抗可以是电阻、电容、电感的任意组合对电流起到的阻碍作用。\n\n由于电容对直流电的阻抗无穷大，而电感对直流电的阻抗是零，因此，阻抗更多用于描述交流电路中对电流的阻碍作用。\n\n高阻抗是指阻抗值大，低阻抗是指阻抗值小。\n\n\n# 二、为什么要控阻抗？\n\n针对目前高频高速的要求，及对信号失真状况越来越高的要求，在设计 pcb 时方波信号在多层板信号线中，其特性阻抗值必须要和电子元件的内置电子阻抗相匹配，才能保证信号的完整的传输。\n\n * 当特性阻抗值超出公差时，所传信号的能量将出现反射、散失、衰减或延误等劣化现象，严重时会出现错误信号。\n * 为了配合电子元器件的电子阻抗，避免信号传输时失真的现象，所以要控制阻抗。\n\n\n# 三、应用\n\npcb 中的阻抗，本质是传输线的特性阻抗（z₀），由线宽、介质厚度、介电常数以及结构共同决定。当信号频率高或上升沿很快时，pcb 走线不再是“导线”，而是“传输线”，需要阻抗匹配以避免反射。\n\n常见阻抗数值与应用：\n\n * 50ω 单端：射频系统、高频时钟、部分高速 io\n\n * 75ω 单端：视频与同轴传输\n\n * 90ω 差分：usb 2.0\n\n * 100ω 差分：usb 3.x、以太网、lvds、serdes\n\n * 85ω 差分：部分显示接口标准\n\n如果是普通低速数字信号，一般不需要严格阻抗控制。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"Layout 03.常用模块的PCB绘制要点",frontmatter:{title:"Layout 03.常用模块的PCB绘制要点",date:"2026-02-19T14:00:00.000Z",permalink:"/pages/PCB_03/"},regularPath:"/04.PCB%20Layout/03.Design_Specification.html",relativePath:"04.PCB Layout/03.Design_Specification.md",key:"v-6bdd7efc",path:"/pages/PCB_03/",headers:[{level:2,title:"一、LDO 电源模块",slug:"一、ldo-电源模块",normalizedTitle:"一、ldo 电源模块",charIndex:2},{level:2,title:"二、USB 接口模块",slug:"二、usb-接口模块",normalizedTitle:"二、usb 接口模块",charIndex:163},{level:2,title:"三、SD/TF 卡模块",slug:"三、sd-tf-卡模块",normalizedTitle:"三、sd/tf 卡模块",charIndex:336},{level:2,title:"四、Audio 音频模块",slug:"四、audio-音频模块",normalizedTitle:"四、audio 音频模块",charIndex:609},{level:3,title:"麦克风部分",slug:"麦克风部分",normalizedTitle:"麦克风部分",charIndex:626},{level:3,title:"功放（喇叭）部分",slug:"功放-喇叭-部分",normalizedTitle:"功放（喇叭）部分",charIndex:756}],headersStr:"一、LDO 电源模块 二、USB 接口模块 三、SD/TF 卡模块 四、Audio 音频模块 麦克风部分 功放（喇叭）部分",content:"# 一、LDO 电源模块\n\n 1. 区分输入、输出主回路，滤波电容按先大后小原则，紧贴电源芯片输入、输出管脚放置。\n 2. 为芯片供电的 LDO 需尽量靠近对应芯片，避免低压输出线过长产生压降。\n 3. 以 LDO 为核心布局，电源滤波器输入、输出端远离布置，防止噪声耦合；元器件整齐紧凑排列，减少、缩短引线与连接。\n\n\n# 二、USB 接口模块\n\n 1. 接口靠近板边放置，便于拔插；ESD 器件紧贴接口，走线需先经过 ESD 器件。\n 2. 布局时尽量缩短差分线路长度，保证差分对内等长，误差控制在 ±5mil。\n 3. 阻抗控制：USB2.0 差分阻抗 90Ω；USB3.0 一般 90Ω，部分场景 100Ω。\n 4. 差分线打孔包地，换层处加屏蔽地过孔。\n\n\n# 三、SD/TF 卡模块\n\n 1. 电源滤波电容按先大后小原则，靠近接口管脚放置；座子靠板边摆放，ESD 器件贴近 TF 卡，走线先经 ESD 器件再接入 SD 卡。\n 2. 单端阻抗控制为 50Ω，无差分线要求。\n 3. 所有信号线走同一层，保证信号一致性；与高频信号隔开，空间充足时单根包地，紧张时整组包地，信号线需有完整参考平面。\n 4. 时钟信号与其他信号线间距保持15-20mil，建议全程包地。\n 5. 信号线总长度控制在 6000mil 内；信号线等长误差 ±100mil，所有信号与 SD CL 等长误差 ±300mil。\n\n\n# 四、Audio 音频模块\n\n\n# 麦克风部分\n\n 1. MIC 靠板边摆放，ESD 器件贴近 MIC，走线先经 ESD 器件再到 MIC 管脚。\n 2. MIC_N/MIC_P 模拟信号按差分处理，避免同层、临层干扰，远离干扰信号 / 元件；差分对包地，走线宽度建议10mil 以上。\n\n\n# 功放（喇叭）部分\n\n 1. 座子靠板边放置，ESD 器件贴近座子；SPEAKER 走线避开敏感信号，不与其他信号 / 电源线隔层 / 同层平行，建议包地，走线宽度15mil 以上。\n 2. 信号输入端用地线屏蔽，且走线尽量短；功放与喇叭间走线短、直、粗，抑制电磁辐射。",normalizedContent:"# 一、ldo 电源模块\n\n 1. 区分输入、输出主回路，滤波电容按先大后小原则，紧贴电源芯片输入、输出管脚放置。\n 2. 为芯片供电的 ldo 需尽量靠近对应芯片，避免低压输出线过长产生压降。\n 3. 以 ldo 为核心布局，电源滤波器输入、输出端远离布置，防止噪声耦合；元器件整齐紧凑排列，减少、缩短引线与连接。\n\n\n# 二、usb 接口模块\n\n 1. 接口靠近板边放置，便于拔插；esd 器件紧贴接口，走线需先经过 esd 器件。\n 2. 布局时尽量缩短差分线路长度，保证差分对内等长，误差控制在 ±5mil。\n 3. 阻抗控制：usb2.0 差分阻抗 90ω；usb3.0 一般 90ω，部分场景 100ω。\n 4. 差分线打孔包地，换层处加屏蔽地过孔。\n\n\n# 三、sd/tf 卡模块\n\n 1. 电源滤波电容按先大后小原则，靠近接口管脚放置；座子靠板边摆放，esd 器件贴近 tf 卡，走线先经 esd 器件再接入 sd 卡。\n 2. 单端阻抗控制为 50ω，无差分线要求。\n 3. 所有信号线走同一层，保证信号一致性；与高频信号隔开，空间充足时单根包地，紧张时整组包地，信号线需有完整参考平面。\n 4. 时钟信号与其他信号线间距保持15-20mil，建议全程包地。\n 5. 信号线总长度控制在 6000mil 内；信号线等长误差 ±100mil，所有信号与 sd cl 等长误差 ±300mil。\n\n\n# 四、audio 音频模块\n\n\n# 麦克风部分\n\n 1. mic 靠板边摆放，esd 器件贴近 mic，走线先经 esd 器件再到 mic 管脚。\n 2. mic_n/mic_p 模拟信号按差分处理，避免同层、临层干扰，远离干扰信号 / 元件；差分对包地，走线宽度建议10mil 以上。\n\n\n# 功放（喇叭）部分\n\n 1. 座子靠板边放置，esd 器件贴近座子；speaker 走线避开敏感信号，不与其他信号 / 电源线隔层 / 同层平行，建议包地，走线宽度15mil 以上。\n 2. 信号输入端用地线屏蔽，且走线尽量短；功放与喇叭间走线短、直、粗，抑制电磁辐射。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"01.Linux运行原理",frontmatter:{title:"01.Linux运行原理",date:"2026-02-19T23:00:00.000Z",permalink:"/pages/Linux_01/"},regularPath:"/05.IC-focused%20Universal%20Linux/01.Linux_System_Info.html",relativePath:"05.IC-focused Universal Linux/01.Linux_System_Info.md",key:"v-d0319f4e",path:"/pages/Linux_01/",headers:[{level:3,title:"一、在不同平台上Linux的启动链路",slug:"一、在不同平台上linux的启动链路",normalizedTitle:"一、在不同平台上linux的启动链路",charIndex:2},{level:3,title:"Linux 文件系统",slug:"linux-文件系统",normalizedTitle:"linux 文件系统",charIndex:732}],headersStr:"一、在不同平台上Linux的启动链路 Linux 文件系统",content:"# 一、在不同平台上Linux的启动链路\n\n# x86_64 Linux 启动链\n\n上电\n↓\nCPU Reset（PC 指向固件入口）\n↓\nUEFI / BIOS（完成 DDR、PCIe、基础硬件初始化）\n↓\nGRUB（加载 vmlinuz + initramfs，传递 cmdline）\n↓\nLinux Kernel（建立页表，初始化调度器，解析 ACPI，初始化驱动）\n↓\n挂载 rootfs（VFS: Mounted root）\n↓\nsystemd / init（PID 1，建立用户空间）\n↓\n用户空间服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n关键特征：\n\n * 固件已完成大部分硬件初始化\n * 使用 ACPI 描述硬件\n * Bootloader 通常为 GRUB\n * 平台驱动型架构\n\n# ARM Linux 启动链\n\n上电\n↓\nCPU Reset（跳转到 SoC 内部 BootROM）\n↓\nBootROM（选择启动介质，加载第一阶段代码）\n↓\nSPL（初始化 DDR 控制器和时钟）\n↓\nU-Boot（加载 kernel + dtb，设置 bootargs）\n↓\nLinux Kernel（建立页表，初始化驱动，解析 Device Tree）\n↓\n挂载 rootfs\n↓\nsystemd / busybox（PID 1）\n↓\n用户空间\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n关键特征：\n\n * BootROM 固化在 SoC 内部\n * DDR 必须由 SPL 初始化\n * 使用 Device Tree 描述硬件\n * 芯片驱动型架构\n\n\n# Linux 文件系统\n\n# 一、Linux 常用目录\n\n/            （根目录，整个文件系统起点）\n/bin         （基础可执行命令，系统最小运行集）  \n/sbin        （系统管理命令）  \n/etc         （系统配置文件）  \n/home        （普通用户目录）  \n/root        （root 用户主目录）  \n/usr         （大部分应用程序与库文件）  \n/var         （可变数据，如日志）  \n/proc        （内核状态映射，虚拟文件系统）  \n/dev         （设备文件接口）  \n/boot        （内核与启动文件）  \n/tmp         （临时文件）  \n/lib /lib64  （基础共享库）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n核心必须记住：\n\n/bin  /etc  /home  /usr  /var  /proc  /dev\n\n\n1\n\n\n----------------------------------------\n\n# 二、命令的基本结构\n\n通用形式：\n\ncommand [options] [arguments]\n\n\n1\n\n\n例如：\n\nls -l /home\n\n\n1\n\n * command → 命令本体\n * options → 选项（控制行为）\n * arguments → 操作对象\n\n----------------------------------------\n\n# 常用文件系统命令\n\npwd              （显示当前路径）\ncd path          （切换目录）\nls -l            （查看文件及权限）\nmkdir dir        （创建目录）\nrm file          （删除文件）\ncp a b           （复制文件）\nmv a b           （移动/重命名文件）\ncat file         （查看文件内容）\nless file        （分页查看文件）\ndf -T            （查看文件系统类型）\nlsblk -f         （查看磁盘与分区类型）\nmount            （查看挂载信息）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n# 三、权限系统\n\nLinux 权限由三组组成：\n\nu  用户\ng  组\no  其他人\n\n\n1\n2\n3\n\n\n每组包含三种权限：\n\nr  读 (4)\nw  写 (2)\nx  执行 (1)\n\n\n1\n2\n3\n\n\n例如：\n\n-rwxr-xr--bash\n\n-      rwx     r-x     r--\n↓       ↓       ↓       ↓\n文件  所有者   组用户   其他人\n\n\n1\n2\n3\n4\n5\n\n\n结构：\n\n[文件类型][u][g][o]\n\n\n1\n\n\n数值表示法：\n\nchmod 755 file\n\n\n1\n\n\n解释：\n\n7 = rwx\n5 = r-x\n5 = r-x\n\n\n1\n2\n3\n\n\n符号方式：\n\nchmod u+x file\nchmod g-w file\n\n\n1\n2\n\n\n修改所有者：\n\nchown user file\nchown user:group file\n\n\n1\n2\n\n\n----------------------------------------\n\n# 四、硬链接与软链接\n\n文件结构本质\n\n文件名 → inode → 数据块\n\n\n1\n\n\ninode 才是数据实体。\n\n硬链接（Hard Link）\n\n本质：\n\n> 多个文件名指向同一个 inode\n\n创建：\n\nln file1 file2\n\n\n1\n\n\n特点：\n\n * 共享 inode\n * 删除一个不影响数据\n * 不能跨文件系统\n\n查看 inode：\n\nls -li\n\n\n1\n\n\n软链接（Symbolic Link）\n\n本质：\n\n> 一个文件保存另一个文件的路径\n\n创建：\n\nln -s file1 link1\n\n\n1\n\n\n特点：\n\n * 类似快捷方式\n * 可以跨文件系统\n * 原文件删除后失效\n\n----------------------------------------\n\n# 五、设备文件 /dev\n\n/dev 目录包含设备文件：\n\n/dev/sda      （硬盘）\n/dev/sda1     （分区）\n/dev/tty      （终端）\n/dev/null     （空设备）\n\n\n1\n2\n3\n4\n\n\n查看类型：\n\nls -l /dev/sda\n\n\n1\n\n\n开头字符说明：\n\nb  块设备（硬盘）\nc  字符设备（串口）\n\n\n1\n2\n\n\n设备文件不是普通数据文件。\n\n它们是：\n\n> 内核驱动的接口节点\n\n当读取设备文件时，本质是在与驱动交互。\n\n----------------------------------------\n\n# 六、为什么 Linux “一切皆文件”\n\nLinux 将以下对象统一抽象为文件：\n\n * 普通数据文件\n * 设备（/dev）\n * 内核状态（/proc）\n * 进程信息（/proc/PID）\n\n这种设计带来统一接口：\n\nopen → read → write → close\n\n\n1\n\n\n无论操作硬盘、串口、进程信息，调用方式一致。\n\n这就是 Linux 文件系统设计的核心哲学。",normalizedContent:"# 一、在不同平台上linux的启动链路\n\n# x86_64 linux 启动链\n\n上电\n↓\ncpu reset（pc 指向固件入口）\n↓\nuefi / bios（完成 ddr、pcie、基础硬件初始化）\n↓\ngrub（加载 vmlinuz + initramfs，传递 cmdline）\n↓\nlinux kernel（建立页表，初始化调度器，解析 acpi，初始化驱动）\n↓\n挂载 rootfs（vfs: mounted root）\n↓\nsystemd / init（pid 1，建立用户空间）\n↓\n用户空间服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n关键特征：\n\n * 固件已完成大部分硬件初始化\n * 使用 acpi 描述硬件\n * bootloader 通常为 grub\n * 平台驱动型架构\n\n# arm linux 启动链\n\n上电\n↓\ncpu reset（跳转到 soc 内部 bootrom）\n↓\nbootrom（选择启动介质，加载第一阶段代码）\n↓\nspl（初始化 ddr 控制器和时钟）\n↓\nu-boot（加载 kernel + dtb，设置 bootargs）\n↓\nlinux kernel（建立页表，初始化驱动，解析 device tree）\n↓\n挂载 rootfs\n↓\nsystemd / busybox（pid 1）\n↓\n用户空间\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n关键特征：\n\n * bootrom 固化在 soc 内部\n * ddr 必须由 spl 初始化\n * 使用 device tree 描述硬件\n * 芯片驱动型架构\n\n\n# linux 文件系统\n\n# 一、linux 常用目录\n\n/            （根目录，整个文件系统起点）\n/bin         （基础可执行命令，系统最小运行集）  \n/sbin        （系统管理命令）  \n/etc         （系统配置文件）  \n/home        （普通用户目录）  \n/root        （root 用户主目录）  \n/usr         （大部分应用程序与库文件）  \n/var         （可变数据，如日志）  \n/proc        （内核状态映射，虚拟文件系统）  \n/dev         （设备文件接口）  \n/boot        （内核与启动文件）  \n/tmp         （临时文件）  \n/lib /lib64  （基础共享库）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n核心必须记住：\n\n/bin  /etc  /home  /usr  /var  /proc  /dev\n\n\n1\n\n\n----------------------------------------\n\n# 二、命令的基本结构\n\n通用形式：\n\ncommand [options] [arguments]\n\n\n1\n\n\n例如：\n\nls -l /home\n\n\n1\n\n * command → 命令本体\n * options → 选项（控制行为）\n * arguments → 操作对象\n\n----------------------------------------\n\n# 常用文件系统命令\n\npwd              （显示当前路径）\ncd path          （切换目录）\nls -l            （查看文件及权限）\nmkdir dir        （创建目录）\nrm file          （删除文件）\ncp a b           （复制文件）\nmv a b           （移动/重命名文件）\ncat file         （查看文件内容）\nless file        （分页查看文件）\ndf -t            （查看文件系统类型）\nlsblk -f         （查看磁盘与分区类型）\nmount            （查看挂载信息）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n# 三、权限系统\n\nlinux 权限由三组组成：\n\nu  用户\ng  组\no  其他人\n\n\n1\n2\n3\n\n\n每组包含三种权限：\n\nr  读 (4)\nw  写 (2)\nx  执行 (1)\n\n\n1\n2\n3\n\n\n例如：\n\n-rwxr-xr--bash\n\n-      rwx     r-x     r--\n↓       ↓       ↓       ↓\n文件  所有者   组用户   其他人\n\n\n1\n2\n3\n4\n5\n\n\n结构：\n\n[文件类型][u][g][o]\n\n\n1\n\n\n数值表示法：\n\nchmod 755 file\n\n\n1\n\n\n解释：\n\n7 = rwx\n5 = r-x\n5 = r-x\n\n\n1\n2\n3\n\n\n符号方式：\n\nchmod u+x file\nchmod g-w file\n\n\n1\n2\n\n\n修改所有者：\n\nchown user file\nchown user:group file\n\n\n1\n2\n\n\n----------------------------------------\n\n# 四、硬链接与软链接\n\n文件结构本质\n\n文件名 → inode → 数据块\n\n\n1\n\n\ninode 才是数据实体。\n\n硬链接（hard link）\n\n本质：\n\n> 多个文件名指向同一个 inode\n\n创建：\n\nln file1 file2\n\n\n1\n\n\n特点：\n\n * 共享 inode\n * 删除一个不影响数据\n * 不能跨文件系统\n\n查看 inode：\n\nls -li\n\n\n1\n\n\n软链接（symbolic link）\n\n本质：\n\n> 一个文件保存另一个文件的路径\n\n创建：\n\nln -s file1 link1\n\n\n1\n\n\n特点：\n\n * 类似快捷方式\n * 可以跨文件系统\n * 原文件删除后失效\n\n----------------------------------------\n\n# 五、设备文件 /dev\n\n/dev 目录包含设备文件：\n\n/dev/sda      （硬盘）\n/dev/sda1     （分区）\n/dev/tty      （终端）\n/dev/null     （空设备）\n\n\n1\n2\n3\n4\n\n\n查看类型：\n\nls -l /dev/sda\n\n\n1\n\n\n开头字符说明：\n\nb  块设备（硬盘）\nc  字符设备（串口）\n\n\n1\n2\n\n\n设备文件不是普通数据文件。\n\n它们是：\n\n> 内核驱动的接口节点\n\n当读取设备文件时，本质是在与驱动交互。\n\n----------------------------------------\n\n# 六、为什么 linux “一切皆文件”\n\nlinux 将以下对象统一抽象为文件：\n\n * 普通数据文件\n * 设备（/dev）\n * 内核状态（/proc）\n * 进程信息（/proc/pid）\n\n这种设计带来统一接口：\n\nopen → read → write → close\n\n\n1\n\n\n无论操作硬盘、串口、进程信息，调用方式一致。\n\n这就是 linux 文件系统设计的核心哲学。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"02.进程管理",frontmatter:{title:"02.进程管理",date:"2026-02-20T23:00:00.000Z",permalink:"/pages/Linux_02/"},regularPath:"/05.IC-focused%20Universal%20Linux/02.Linux_systemctl.html",relativePath:"05.IC-focused Universal Linux/02.Linux_systemctl.md",key:"v-075f108a",path:"/pages/Linux_02/",headers:[{level:2,title:"Linux进程与资源管理",slug:"linux进程与资源管理",normalizedTitle:"linux进程与资源管理",charIndex:2},{level:2,title:"一、进程观察",slug:"一、进程观察",normalizedTitle:"一、进程观察",charIndex:19},{level:2,title:"二、进程状态",slug:"二、进程状态",normalizedTitle:"二、进程状态",charIndex:1409},{level:3,title:"新建一个进程并管理它",slug:"新建一个进程并管理它",normalizedTitle:"新建一个进程并管理它",charIndex:1637},{level:2,title:"三、信号机制",slug:"三、信号机制",normalizedTitle:"三、信号机制",charIndex:2156},{level:2,title:"四、Systemd基础",slug:"四、systemd基础",normalizedTitle:"四、systemd基础",charIndex:2469},{level:3,title:"查看全部服务",slug:"查看全部服务",normalizedTitle:"查看全部服务",charIndex:2485},{level:3,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:3216},{level:3,title:"查看ssh服务",slug:"查看ssh服务",normalizedTitle:"查看ssh服务",charIndex:3565}],headersStr:"Linux进程与资源管理 一、进程观察 二、进程状态 新建一个进程并管理它 三、信号机制 四、Systemd基础 查看全部服务 核心概念 查看ssh服务",content:'# Linux进程与资源管理\n\n\n# 一、进程观察\n\nPID 是什么\n\n * PID = Process ID，进程号\n * 内核给每个运行中的程序分配的唯一身份证号\n * 所有操作进程的命令（kill、top、strace 等）都靠 PID 定位\n\nCPU% 怎么来的？\n\n> 单位时间内，进程占用 CPU 的时间比例\n\n * 比如 100% 就是单核跑满\n * 多核机器可以超过 100%（比如 250% 就是占了 2.5 核）\n * 是动态计算出来的，不是固定值\n\nVIRT vs RES\n\n * VIRT（虚拟内存）\n   \n   进程声称要用的所有内存总和\n   \n   = 物理内存 + 交换分区 + 共享库 + 未分配但申请过的空间\n   \n   → 虚的，参考意义不大\n\n * RES（常驻内存）\n   \n   进程真正正在占用的物理内存\n   \n   → 看这个才准\n\n在命令行中输入：ps aux\n\n会显示如下内容：\n\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  1.6  0.5 166580 11544 ?        Ss   20:56   0:02 /sbin/init au\nroot           2  0.0  0.0      0     0 ?        S    20:56   0:00 [kthreadd]\n\n\n1\n2\n3\n\n\n这一大堆输出中，意义如下：\n\n列名        含义                 举例\nUSER      进程所属用户             root / 你的用户名\nPID       进程 ID（唯一标识）        1 / 1234 / 5678\n%CPU      CPU 占用百分比          0.0 / 1.5 / 10.2\n%MEM      内存占用百分比            0.1 / 2.3\nVSZ       虚拟内存（VIRT），单位 KB   123456\nRSS       常驻内存（RES），单位 KB    67890\nCOMMAND   进程对应的命令            sleep 1000 / bash / systemd\n\n解读重要内容：\n\nPID： PID=1 的进程是 systemd，这是 Linux 的第一个进程（所有进程的爹）；\n\n%CPU：比如有个进程 % CPU=50.0，说明它占了当前单核的 50% 算力（如果是 4 核机器，最大能到 400%）；\n\nVIRT vs RES：比如某进程 VIRT=200000KB，RES=50000KB → 真正占物理内存的是 50000KB，VIRT 是 “宣称要用的总内存”（包含没实际使用的）。\n\n----------------------------------------\n\n如果要实时监控进程，则需要使用top命令：\n\ntop\n\n\n1\n\n\n使用后，自动定时刷新当前进程，可以使用快捷键q退出，也可以\n\n# 按 M 键 - 按内存排序\n# 按 u 后输入用户名 - 查看特定用户进程\n# 按 k 后输入 PID - 终止进程\n\n\n1\n2\n3\n\n\n\n# 二、进程状态\n\n在运行top命令后，在其S(state)列中，可能会出现如下的字符\n\nR = Running\n\n正在运行或在就绪队列排队\n\nS = Sleeping\n\n可中断睡眠（等 IO、等时间、等信号）\n\n大部分进程平时都是 S\n\nZ = Zombie 僵尸进程\n\n子进程死了，但父进程没 “收尸”（没调用 wait）\n\n→ 只占 PID，不占资源，太多会炸\n\n----------------------------------------\n\n\n# 新建一个进程并管理它\n\nsleep 100 &  # & 表示后台运行\n\n\n1\n\n\n终端会返回类似 [1] 12345（12345 是这个 sleep 的 PID）。\n\n切回 top 界面，按 P 排序，找到 PID=12345 的进程，看它的 S 列 → 是 S（睡眠，因为 sleep 在等时间）。\n\n示例：\n\nikun@ubuntu2004:~$ sleep 100 &\n[1] 4134\n\n\n1\n2\n\n\n返回的 4134就是PID\n\n使用jobs命令会显示出当前后台运行的进程\n\nikun@ubuntu2004:~$ jobs\n[1]+  运行中               sleep 100 &\n\n\n1\n2\n\n\n可以分别使用fg和bg命令让进程在前台和后台运行，如\n\nikun@ubuntu2004:~$ fg %1 # 此处的1是指后台进程号，就是在创建进程时返回的数字\nsleep 100\n^Z\t# 通过按下 ^Z 来停止前台进程\n[1]+  已停止               sleep 100\nikun@ubuntu2004:~$ bg %1\n[1]+ sleep 100 &\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 三、信号机制\n\n> 信号 = 内核与进程之间的控制指令\n\nsleep 1000 # 会返回一个PID，可在另一个终端里面退出这个进程\n\t\t  # 在其他进程中也可以通过“ps aux | grap sleep”命令来查看PID\n\n\n1\n2\n\n\nkill -15 PID   # 温柔退出\nkill -9 PID    # 强制杀死\n\n\n1\n2\n\n\n重点理解：\n\n * 15 SIGTERM：\n   \n   告诉进程 “你可以退出了，请自己清理资源”\n   \n   程序可以拒绝、处理、优雅退出\n\n * 9 SIGKILL：\n   \n   内核直接干掉进程，不给程序反应时间\n   \n   无法被捕获、无法被忽略、必杀\n\n\n# 四、Systemd基础\n\n\n# 查看全部服务\n\n在终端中运行命令：\n\nsystemctl list-units --type=service\n\n\n1\n\n\n显示如下：\n\nikun@ubuntu2004:~$ systemctl list-units --type=service\n  UNIT                                                  LOAD   ACTIVE SUB     DESCRIPTION        >\n  accounts-daemon.service                               loaded active running Accounts Service\n  acpid.service                                         loaded active running ACPI event daemon\n  alsa-restore.service                                  loaded active exited  Save/Restore Sound >\n  apparmor.service                                      loaded active exited  Load AppArmor profi>\n  apport.service                                        loaded active exited  LSB: automatic cras>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 核心概念\n\nService（服务）：systemd 定义的 “单元”，本质是配置文件（/etc/systemd/system/），描述如何启动 / 停止一个后台程序；\n\nDaemon（守护进程）：服务对应的后台进程（比如 ssh.service 对应的 sshd 进程），特点是脱离终端、后台持续运行、开机自启；\n\n运行级别替代：\n\n老 Linux 的 0-6 运行级别（比如 3 是字符界面，5 是图形界面），在 systemd 里被Target替代：\n\n * multi-user.target：多用户字符界面（对应老级别 3）；\n\n * graphical.target：图形界面（对应老级别 5）\n   \n   查当前默认 Target：systemctl get-default\n\n\n# 查看ssh服务\n\n运行命令：systemctl status ssh\n\nikun@ubuntu2004:~$ systemctl status ssh\n● ssh.service - OpenBSD Secure Shell server\n     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)\n     Active: active (running) since Fri 2026-02-20 21:23:24 CST; 45min ago\n       Docs: man:sshd(8)\n             man:sshd_config(5)\n   Main PID: 3627 (sshd)\n      Tasks: 1 (limit: 2204)\n     Memory: 1.7M\n        CPU: 13ms\n     CGroup: /system.slice/ssh.service\n             └─3627 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"\n\n2月 20 21:23:24 ubuntu2004 systemd[1]: Starting OpenBSD Secure Shell server...\n2月 20 21:23:24 ubuntu2004 sshd[3627]: Server listening on 0.0.0.0 port 22.\n2月 20 21:23:24 ubuntu2004 sshd[3627]: Server listening on :: port 22.\n2月 20 21:23:24 ubuntu2004 systemd[1]: Started OpenBSD Secure Shell server.\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 核心服务标识行\n   \n   * ●：systemd的状态图标，绿色实心圆代表服务正常运行中，如果是红色×代表服务启动失败，灰色○代表服务已停止\n   * ssh.service：服务的完整单元名称，是systemd中服务的唯一标识符，日常操作时可以用"ssh"简写代替\n   * OpenBSD Secure Shell server：服务的详细描述信息，说明这是OpenBSD团队开发的SSH远程登录服务\n\n * Loaded（加载状态）：这一行告诉你服务的配置文件是否被正确加载，是排查服务启动失败的第一步\n   \n   * loaded：表示配置文件已经成功加载到内存中，如果是"not-found"则说明配置文件丢失\n   * /lib/systemd/system/ssh.service：服务配置文件的完整存放路径，这是systemd服务的核心配置文件所在位置\n   * enabled：表示服务已设置为开机自启动，如果是"disabled"则代表开机不会自动启动SSH服务\n   * vendor preset: enabled：表示Ubuntu系统厂商默认将这个服务设置为开机自启\n\n * Active（运行状态）：这是最核心的状态行，直接告诉你服务当前是否在运行\n   \n   * active (running)：服务处于"活跃(运行中)"状态，如果是"inactive (dead)"代表服务已停止，"failed"代表服务启动失败\n   * since Fri 2026-02-20 21:23:24 CST：服务启动的具体时间点，精确到秒\n   * 45min ago：服务已经稳定运行了45分钟，说明这段时间内没有发生崩溃或重启\n\n * Docs（文档参考）：告诉你如果想深入了解SSH服务的详细信息，可以通过以下命令查看官方文档\n   \n   * man:sshd(8)：在终端输入"man sshd"可以查看SSH守护进程的手册页\n   * man:sshd_config(5)：在终端输入"man sshd_config"可以查看SSH配置文件的详细说明，排查配置问题时特别有用\n\n * 资源占用信息：这些数值可以帮助判断服务是否存在资源异常\n   \n   * Main PID: 3627 (sshd)：SSH服务的主进程ID是3627，虽然可以用kill命令控制，但不建议手动杀死系统服务\n   * Tasks: 1 (limit: 2204)：该服务当前只占用1个任务(进程)，系统允许的最大进程数是2204个\n   * Memory: 1.7M：服务只占用1.7MB物理内存，非常轻量级，如果显示几十GB则说明服务异常\n   * CPU: 13ms：从启动到现在总共消耗了13毫秒的CPU时间，几乎可以忽略不计，如果显示几秒或几分钟则说明服务一直在占用CPU\n\n * CGroup（控制组）：systemd用来限制和管理服务资源的机制\n   \n   * /system.slice/ssh.service：控制组的路径，属于系统级服务(system.slice)\n   * └─3627 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"：主进程的具体运行命令，-D表示以守护进程模式运行，[listener]表示正在监听22端口的连接请求\n\n * 日志部分：这是排查问题的核心依据，记录了服务启动的全过程\n   \n   * 2月 20 21:23:24 ubuntu2004 systemd[1]: Starting OpenBSD Secure Shell server...：systemd开始启动SSH服务\n   * 2月 20 21:23:24 ubuntu2004 sshd[3627]: Server listening on 0.0.0.0 port 22.：SSH服务开始监听所有IPv4地址的22端口\n   * 2月 20 21:23:24 ubuntu2004 sshd[3627]: Server listening on :: port 22.：SSH服务开始监听所有IPv6地址的22端口\n   * 2月 20 21:23:24 ubuntu2004 systemd[1]: Started OpenBSD Secure Shell server.：systemd确认SSH服务启动成功\n   * 如果日志中出现"error"或"failed"关键词，比如"Port 22 already in use"，就能快速定位启动失败的原因\n\n额外实用命令\n\n * 启动 ssh 服务：sudo systemctl start ssh；\n * 停止 ssh 服务：sudo systemctl stop ssh；\n * 设置开机自启：sudo systemctl enable ssh；\n * 重启服务：sudo systemctl restart ssh。',normalizedContent:'# linux进程与资源管理\n\n\n# 一、进程观察\n\npid 是什么\n\n * pid = process id，进程号\n * 内核给每个运行中的程序分配的唯一身份证号\n * 所有操作进程的命令（kill、top、strace 等）都靠 pid 定位\n\ncpu% 怎么来的？\n\n> 单位时间内，进程占用 cpu 的时间比例\n\n * 比如 100% 就是单核跑满\n * 多核机器可以超过 100%（比如 250% 就是占了 2.5 核）\n * 是动态计算出来的，不是固定值\n\nvirt vs res\n\n * virt（虚拟内存）\n   \n   进程声称要用的所有内存总和\n   \n   = 物理内存 + 交换分区 + 共享库 + 未分配但申请过的空间\n   \n   → 虚的，参考意义不大\n\n * res（常驻内存）\n   \n   进程真正正在占用的物理内存\n   \n   → 看这个才准\n\n在命令行中输入：ps aux\n\n会显示如下内容：\n\nuser         pid %cpu %mem    vsz   rss tty      stat start   time command\nroot           1  1.6  0.5 166580 11544 ?        ss   20:56   0:02 /sbin/init au\nroot           2  0.0  0.0      0     0 ?        s    20:56   0:00 [kthreadd]\n\n\n1\n2\n3\n\n\n这一大堆输出中，意义如下：\n\n列名        含义                 举例\nuser      进程所属用户             root / 你的用户名\npid       进程 id（唯一标识）        1 / 1234 / 5678\n%cpu      cpu 占用百分比          0.0 / 1.5 / 10.2\n%mem      内存占用百分比            0.1 / 2.3\nvsz       虚拟内存（virt），单位 kb   123456\nrss       常驻内存（res），单位 kb    67890\ncommand   进程对应的命令            sleep 1000 / bash / systemd\n\n解读重要内容：\n\npid： pid=1 的进程是 systemd，这是 linux 的第一个进程（所有进程的爹）；\n\n%cpu：比如有个进程 % cpu=50.0，说明它占了当前单核的 50% 算力（如果是 4 核机器，最大能到 400%）；\n\nvirt vs res：比如某进程 virt=200000kb，res=50000kb → 真正占物理内存的是 50000kb，virt 是 “宣称要用的总内存”（包含没实际使用的）。\n\n----------------------------------------\n\n如果要实时监控进程，则需要使用top命令：\n\ntop\n\n\n1\n\n\n使用后，自动定时刷新当前进程，可以使用快捷键q退出，也可以\n\n# 按 m 键 - 按内存排序\n# 按 u 后输入用户名 - 查看特定用户进程\n# 按 k 后输入 pid - 终止进程\n\n\n1\n2\n3\n\n\n\n# 二、进程状态\n\n在运行top命令后，在其s(state)列中，可能会出现如下的字符\n\nr = running\n\n正在运行或在就绪队列排队\n\ns = sleeping\n\n可中断睡眠（等 io、等时间、等信号）\n\n大部分进程平时都是 s\n\nz = zombie 僵尸进程\n\n子进程死了，但父进程没 “收尸”（没调用 wait）\n\n→ 只占 pid，不占资源，太多会炸\n\n----------------------------------------\n\n\n# 新建一个进程并管理它\n\nsleep 100 &  # & 表示后台运行\n\n\n1\n\n\n终端会返回类似 [1] 12345（12345 是这个 sleep 的 pid）。\n\n切回 top 界面，按 p 排序，找到 pid=12345 的进程，看它的 s 列 → 是 s（睡眠，因为 sleep 在等时间）。\n\n示例：\n\nikun@ubuntu2004:~$ sleep 100 &\n[1] 4134\n\n\n1\n2\n\n\n返回的 4134就是pid\n\n使用jobs命令会显示出当前后台运行的进程\n\nikun@ubuntu2004:~$ jobs\n[1]+  运行中               sleep 100 &\n\n\n1\n2\n\n\n可以分别使用fg和bg命令让进程在前台和后台运行，如\n\nikun@ubuntu2004:~$ fg %1 # 此处的1是指后台进程号，就是在创建进程时返回的数字\nsleep 100\n^z\t# 通过按下 ^z 来停止前台进程\n[1]+  已停止               sleep 100\nikun@ubuntu2004:~$ bg %1\n[1]+ sleep 100 &\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 三、信号机制\n\n> 信号 = 内核与进程之间的控制指令\n\nsleep 1000 # 会返回一个pid，可在另一个终端里面退出这个进程\n\t\t  # 在其他进程中也可以通过“ps aux | grap sleep”命令来查看pid\n\n\n1\n2\n\n\nkill -15 pid   # 温柔退出\nkill -9 pid    # 强制杀死\n\n\n1\n2\n\n\n重点理解：\n\n * 15 sigterm：\n   \n   告诉进程 “你可以退出了，请自己清理资源”\n   \n   程序可以拒绝、处理、优雅退出\n\n * 9 sigkill：\n   \n   内核直接干掉进程，不给程序反应时间\n   \n   无法被捕获、无法被忽略、必杀\n\n\n# 四、systemd基础\n\n\n# 查看全部服务\n\n在终端中运行命令：\n\nsystemctl list-units --type=service\n\n\n1\n\n\n显示如下：\n\nikun@ubuntu2004:~$ systemctl list-units --type=service\n  unit                                                  load   active sub     description        >\n  accounts-daemon.service                               loaded active running accounts service\n  acpid.service                                         loaded active running acpi event daemon\n  alsa-restore.service                                  loaded active exited  save/restore sound >\n  apparmor.service                                      loaded active exited  load apparmor profi>\n  apport.service                                        loaded active exited  lsb: automatic cras>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 核心概念\n\nservice（服务）：systemd 定义的 “单元”，本质是配置文件（/etc/systemd/system/），描述如何启动 / 停止一个后台程序；\n\ndaemon（守护进程）：服务对应的后台进程（比如 ssh.service 对应的 sshd 进程），特点是脱离终端、后台持续运行、开机自启；\n\n运行级别替代：\n\n老 linux 的 0-6 运行级别（比如 3 是字符界面，5 是图形界面），在 systemd 里被target替代：\n\n * multi-user.target：多用户字符界面（对应老级别 3）；\n\n * graphical.target：图形界面（对应老级别 5）\n   \n   查当前默认 target：systemctl get-default\n\n\n# 查看ssh服务\n\n运行命令：systemctl status ssh\n\nikun@ubuntu2004:~$ systemctl status ssh\n● ssh.service - openbsd secure shell server\n     loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)\n     active: active (running) since fri 2026-02-20 21:23:24 cst; 45min ago\n       docs: man:sshd(8)\n             man:sshd_config(5)\n   main pid: 3627 (sshd)\n      tasks: 1 (limit: 2204)\n     memory: 1.7m\n        cpu: 13ms\n     cgroup: /system.slice/ssh.service\n             └─3627 "sshd: /usr/sbin/sshd -d [listener] 0 of 10-100 startups"\n\n2月 20 21:23:24 ubuntu2004 systemd[1]: starting openbsd secure shell server...\n2月 20 21:23:24 ubuntu2004 sshd[3627]: server listening on 0.0.0.0 port 22.\n2月 20 21:23:24 ubuntu2004 sshd[3627]: server listening on :: port 22.\n2月 20 21:23:24 ubuntu2004 systemd[1]: started openbsd secure shell server.\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 核心服务标识行\n   \n   * ●：systemd的状态图标，绿色实心圆代表服务正常运行中，如果是红色×代表服务启动失败，灰色○代表服务已停止\n   * ssh.service：服务的完整单元名称，是systemd中服务的唯一标识符，日常操作时可以用"ssh"简写代替\n   * openbsd secure shell server：服务的详细描述信息，说明这是openbsd团队开发的ssh远程登录服务\n\n * loaded（加载状态）：这一行告诉你服务的配置文件是否被正确加载，是排查服务启动失败的第一步\n   \n   * loaded：表示配置文件已经成功加载到内存中，如果是"not-found"则说明配置文件丢失\n   * /lib/systemd/system/ssh.service：服务配置文件的完整存放路径，这是systemd服务的核心配置文件所在位置\n   * enabled：表示服务已设置为开机自启动，如果是"disabled"则代表开机不会自动启动ssh服务\n   * vendor preset: enabled：表示ubuntu系统厂商默认将这个服务设置为开机自启\n\n * active（运行状态）：这是最核心的状态行，直接告诉你服务当前是否在运行\n   \n   * active (running)：服务处于"活跃(运行中)"状态，如果是"inactive (dead)"代表服务已停止，"failed"代表服务启动失败\n   * since fri 2026-02-20 21:23:24 cst：服务启动的具体时间点，精确到秒\n   * 45min ago：服务已经稳定运行了45分钟，说明这段时间内没有发生崩溃或重启\n\n * docs（文档参考）：告诉你如果想深入了解ssh服务的详细信息，可以通过以下命令查看官方文档\n   \n   * man:sshd(8)：在终端输入"man sshd"可以查看ssh守护进程的手册页\n   * man:sshd_config(5)：在终端输入"man sshd_config"可以查看ssh配置文件的详细说明，排查配置问题时特别有用\n\n * 资源占用信息：这些数值可以帮助判断服务是否存在资源异常\n   \n   * main pid: 3627 (sshd)：ssh服务的主进程id是3627，虽然可以用kill命令控制，但不建议手动杀死系统服务\n   * tasks: 1 (limit: 2204)：该服务当前只占用1个任务(进程)，系统允许的最大进程数是2204个\n   * memory: 1.7m：服务只占用1.7mb物理内存，非常轻量级，如果显示几十gb则说明服务异常\n   * cpu: 13ms：从启动到现在总共消耗了13毫秒的cpu时间，几乎可以忽略不计，如果显示几秒或几分钟则说明服务一直在占用cpu\n\n * cgroup（控制组）：systemd用来限制和管理服务资源的机制\n   \n   * /system.slice/ssh.service：控制组的路径，属于系统级服务(system.slice)\n   * └─3627 "sshd: /usr/sbin/sshd -d [listener] 0 of 10-100 startups"：主进程的具体运行命令，-d表示以守护进程模式运行，[listener]表示正在监听22端口的连接请求\n\n * 日志部分：这是排查问题的核心依据，记录了服务启动的全过程\n   \n   * 2月 20 21:23:24 ubuntu2004 systemd[1]: starting openbsd secure shell server...：systemd开始启动ssh服务\n   * 2月 20 21:23:24 ubuntu2004 sshd[3627]: server listening on 0.0.0.0 port 22.：ssh服务开始监听所有ipv4地址的22端口\n   * 2月 20 21:23:24 ubuntu2004 sshd[3627]: server listening on :: port 22.：ssh服务开始监听所有ipv6地址的22端口\n   * 2月 20 21:23:24 ubuntu2004 systemd[1]: started openbsd secure shell server.：systemd确认ssh服务启动成功\n   * 如果日志中出现"error"或"failed"关键词，比如"port 22 already in use"，就能快速定位启动失败的原因\n\n额外实用命令\n\n * 启动 ssh 服务：sudo systemctl start ssh；\n * 停止 ssh 服务：sudo systemctl stop ssh；\n * 设置开机自启：sudo systemctl enable ssh；\n * 重启服务：sudo systemctl restart ssh。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"03.Shell结构",frontmatter:{title:"03.Shell结构",date:"2026-02-21T12:00:00.000Z",permalink:"/pages/Linux_03/"},regularPath:"/05.IC-focused%20Universal%20Linux/03.useofshell.html",relativePath:"05.IC-focused Universal Linux/03.useofshell.md",key:"v-d263196a",path:"/pages/Linux_03/",headers:[{level:2,title:"Shell 结构理解",slug:"shell-结构理解",normalizedTitle:"shell 结构理解",charIndex:2},{level:2,title:"一、什么是Shell",slug:"一、什么是shell",normalizedTitle:"一、什么是shell",charIndex:17},{level:2,title:"二、bash基础行为",slug:"二、bash基础行为",normalizedTitle:"二、bash基础行为",charIndex:907},{level:3,title:"命令查找顺序（shell 找命令的优先级）",slug:"命令查找顺序-shell-找命令的优先级",normalizedTitle:"命令查找顺序（shell 找命令的优先级）",charIndex:922},{level:3,title:"参数展开（shell先解析，再输出）",slug:"参数展开-shell先解析-再输出",normalizedTitle:"参数展开（shell先解析，再输出）",charIndex:1330},{level:3,title:"通配符（* ? [])",slug:"通配符",normalizedTitle:"通配符（* ? [])",charIndex:1467},{level:3,title:"引号差异",slug:"引号差异",normalizedTitle:"引号差异",charIndex:1980},{level:2,title:"三、管道符（A | B | C）",slug:"三、管道符-a-b-c",normalizedTitle:"三、管道符（a | b | c）",charIndex:2379},{level:2,title:"四、重定向（IO控制）",slug:"四、重定向-io控制",normalizedTitle:"四、重定向（io控制）",charIndex:3458},{level:2,title:"五、子Shell与作用域",slug:"五、子shell与作用域",normalizedTitle:"五、子shell与作用域",charIndex:4090},{level:3,title:"() 和 {}的区别",slug:"和-的区别",normalizedTitle:"() 和 {}的区别",charIndex:4431},{level:2,title:"六、环境变量（PATH）",slug:"六、环境变量-path",normalizedTitle:"六、环境变量（path）",charIndex:4603}],headersStr:"Shell 结构理解 一、什么是Shell 二、bash基础行为 命令查找顺序（shell 找命令的优先级） 参数展开（shell先解析，再输出） 通配符（* ? []) 引号差异 三、管道符（A | B | C） 四、重定向（IO控制） 五、子Shell与作用域 () 和 {}的区别 六、环境变量（PATH）",content:'# Shell 结构理解\n\n\n# 一、什么是Shell\n\n# 核心认知：Shell ≠ 终端\n\n * 终端（Terminal）：是 “输入输出的窗口”（比如打开的命令行窗口、xterm、gnome-terminal），只负责显示和接收字符；\n\n * Shell：是运行在终端里的 “程序”，核心作用有 3 个：\n   \n   1. 命令解释器：把你敲的ls、cd翻译成内核能懂的指令；\n   2. 进程启动器：创建 / 管理进程（比如sleep 100 &就是 Shell 启动后台进程）；\n   3. 文本处理协调器：把多个命令串起来（管道、重定向），完成复杂文本处理。\n\necho $SHELL命令可以查看当前的shell，也是默认shell\n\nikun@ubuntu2004:~/Desktop$ echo $SHELL\n/bin/bash\n\n\n1\n2\n\n\necho /etc/shells命令可以查看当前所有可用的shell\n\nikun@ubuntu2004:~/Desktop$ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/bash\n/usr/bin/bash\n...\n\n\n1\n2\n3\n4\n5\n6\n\n\necho $PATH命令输出一些目录\n\nikun@ubuntu2004:~/Desktop$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\n\n\n1\n2\n\n\n# $PATH 核心原理：\n\n敲ls时，Shell 会按顺序遍历 $PATH 里的目录，找到第一个名为ls的可执行文件（比如/bin/ls），然后执行它。\n\n如果想验证：敲which ls → 会输出/bin/ls，就是 $PATH 里找到的路径；\n\nikun@ubuntu2004:~/Desktop$ which ls\n/usr/bin/ls\n\n\n1\n2\n\n\n\n# 二、bash基础行为\n\n\n# 命令查找顺序（shell 找命令的优先级）\n\nShell 执行命令时，优先级从高到低：\n\n 1. 别名（alias）→ 比如ll其实是ls -alF的别名；\n 2. 内置命令（builtin）→ 比如cd、echo（属于 Shell 本身，无需找文件）；\n 3. $PATH 里的外部命令 → 比如ls、top（独立可执行文件）。\n\nikun@ubuntu2004:~/Desktop$ type cd\ncd 是 shell 内建\nikun@ubuntu2004:~/Desktop$ type echo\necho 是 shell 内建\nikun@ubuntu2004:~/Desktop$ type ls\nls 是 "ls --color=auto" 的别名\nikun@ubuntu2004:~/Desktop$ type ll\nll 是 "ls -alF" 的别名\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 参数展开（shell先解析，再输出）\n\nShell 执行命令前，会先把变量、通配符等 “展开” 成具体内容，再执行。\n\n# 示例：参数展开\na=10\necho $a+5  # Shell先把 $a 展开成 10，再执行echo → 输出：10+5\n\n\n1\n2\n3\n\n\n\n# 通配符（* ? [])\n\nShell 的 “文件匹配工具”，先匹配文件，再执行命令：\n\n通配符   含义           示例\n*     匹配任意个任意字符    ls *.txt → 所有.txt 文件\n?     匹配 1 个任意字符   ls file?.txt → file1.txt、filea.txt（但不匹配 file10.txt）\n[]    匹配括号内的单个字符   ls file[123].txt → file1.txt、file2.txt、file3.txt\n\nikun@ubuntu2004:~/Desktop$ touch a.txt b.txt ab.txt abc.txt file1 file12 file2\nikun@ubuntu2004:~/Desktop$ ls *.txt\nabc.txt  ab.txt  a.txt  b.txt\nikun@ubuntu2004:~/Desktop$ ls file?\nfile1  file2\nikun@ubuntu2004:~/Desktop$ ls file[12]\nfile1  file2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 引号差异\n\n核心：单引号完全屏蔽 Shell 解析，双引号只屏蔽通配符 / 别名，保留变量展开。\n\n引号类型   特点                示例            输出\n无引号    全解析（变量、通配符、别名）    echo $a *     10 file1.txt file2.txt...\n双引号    解析变量，屏蔽通配符 / 别名   echo "$a *"   10 *\n单引号    完全不解析，原样输出        echo \'$a *\'   $a *\n\nikun@ubuntu2004:~/Desktop$ name=小明\nikun@ubuntu2004:~/Desktop$ echo "我是 $name"\n我是 小明\nikun@ubuntu2004:~/Desktop$ echo \'我是 $name\'\n我是 $name\n\n\n1\n2\n3\n4\n5\n\n\n\n# 三、管道符（A | B | C）\n\n核心理解：管道连接的是「stdout（标准输出）→ stdin（标准输入）」\n\n * 管道|把前一个命令的标准输出，直接传给后一个命令的标准输入；\n * 管道传递的是 “数据流”，不是文件，无需临时保存到硬盘；\n * Unix 哲学：“做一件事，并做到最好”，管道把多个小命令拼成复杂功能。\n\nikun@ubuntu2004:~/Desktop$ ps aux | grep bash # 把ps aux命令的输出过滤出含有bash的部分\nikun        2417  0.0  0.2  14532  5316 pts/0    Ss   10:49   0:00 bash\nikun        2795  0.0  0.1  12192  2544 pts/0    S+   11:03   0:00 grep --color=auto bash\n\n\n1\n2\n3\n\n\n# 3. 多级管道：组合过滤+排序+统计（找CPU占用最高的前5个进程）\nps aux | grep -v root | sort -k3 -r | head -5\n# 解释：\n# grep -v root → 排除root进程\n# sort -k3 -r → 按第3列（%CPU）倒序排序\n# head -5 → 只取前5行\nikun@ubuntu2004:~/Desktop$ ps aux | sort -k 2 -r | head -5\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot          96  0.0  0.0      0     0 ?        I<   10:47   0:00 [kworker/R-scsi_]\nroot          95  0.0  0.0      0     0 ?        S    10:47   0:00 [scsi_eh_1]\nroot          94  0.0  0.0      0     0 ?        I<   10:47   0:00 [kworker/R-scsi_]\nkernoops     933  0.0  0.1  13100  2224 ?        Ss   10:48   0:00 /usr/sbin/kerneloops\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、重定向（IO控制）\n\nLinux每个进程默认打开三个文件描述符\n\n描述符   名称             缩写     默认位置\n0     标准输入（stdin）    <      键盘\n1     标准输出（stdout）   >/>>   终端\n2     标准错误（stderr）   2>     终端\n\n重定向就是 “改变这些数据流的去向”。\n\n# 1. 标准输出重定向（> 覆盖，>> 追加）\nls > file_list.txt  # 把ls的输出（stdout）写入file_list.txt（覆盖原有内容）\necho "新内容" >> file_list.txt  # 追加内容到文件\n\n# 2. 标准错误重定向（2>）：丢弃错误，或保存错误\nls /nonexistent 2> error.log  # 把ls的错误信息（找不到目录）保存到error.log\nls /nonexistent 2> /dev/null  # 丢弃错误（/dev/null是“黑洞”，写入的内容全消失）\n\n# 3. 合并标准输出和标准错误（&> 或 1> file 2>&1）\nls /etc /nonexistent &> all_output.log  # 把正常输出和错误都写入文件\n# 等价于：ls /etc /nonexistent 1> all_output.log 2>&1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 五、子Shell与作用域\n\n当前 Shell：正在操作的 Shell 进程（比如终端窗口）；\n\n子 Shell：由当前 Shell 启动的新 Shell 进程（比如()、管道、脚本执行都会创建子 Shell）。\n\nikun@ubuntu2004:~/Desktop$ a=10\nikun@ubuntu2004:~/Desktop$ (echo 子shell: $a; a=20; echo 子shell改完: $a)\n子shell: 10\n子shell改完: 20\nikun@ubuntu2004:~/Desktop$ echo 父shell: $a\n父shell: 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n子shell中的变量操作不会影响父shell，除非操作的是环境变量\n\n\n# () 和 {}的区别\n\n语法   类型         作用域              语法要求\n()   子 Shell    变量只在子 Shell 生效   括号内命令用；分隔，括号前后可有空格\n{}   当前 Shell   变量在当前 Shell 生效   最后一个命令必须加；，括号前必须有空格（如 {echo 1;}）\n\n\n# 六、环境变量（PATH）\n\n核心区分：环境变量 vs 普通变量\n\n * 普通变量：只在当前 Shell 生效（子 Shell 不可见）；\n * 环境变量：当前 Shell + 所有子 Shell 都可见（export 是关键）。\n\n# Shell 启动时加载了什么？（读懂.bashrc）\n\nUbuntu 的 bash 启动时，会按顺序加载这些文件（影响环境变量 / 别名）：\n\n 1. /etc/profile：系统级全局配置（所有用户）；\n 2. ~/.bash_profile / ~/.bash_login / ~/.profile：用户级登录 Shell 配置；\n 3. ~/.bashrc：用户级非登录 Shell 配置（比如终端窗口默认加载）。\n\n下面通过演示修改~/.bashrc文件来展示环境变量\n\nikun@ubuntu2004:~/Desktop$ gedit ~/.bashrc\n\n# 在 ~/.bashrc中添加如下内容\n# 1. 添加自定义别名（myls 等价于 ls -l，简化命令）\nalias myls=\'ls -l\'\n# 2. 添加永久的环境变量\nexport MY_PATH="/home/ikun/Documents"\n\nikun@ubuntu2004:~/Desktop$ source ~/.bashrc # 执行文件让其立刻生效\n\n#再次执行：可见添加的全局变量生效！\nikun@ubuntu2004:~/Desktop$ myls\n总计 12\n-rw-rw-r-- 1 ikun ikun    0  2月 21 10:58 abc.txt\n...\n-rw-rw-r-- 1 ikun ikun   12  2月 21 11:07 test.txt\n\n\nikun@ubuntu2004:~/Desktop$ echo $MY_PATH\n/home/ikun/Documents\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'# shell 结构理解\n\n\n# 一、什么是shell\n\n# 核心认知：shell = 终端\n\n * 终端（terminal）：是 “输入输出的窗口”（比如打开的命令行窗口、xterm、gnome-terminal），只负责显示和接收字符；\n\n * shell：是运行在终端里的 “程序”，核心作用有 3 个：\n   \n   1. 命令解释器：把你敲的ls、cd翻译成内核能懂的指令；\n   2. 进程启动器：创建 / 管理进程（比如sleep 100 &就是 shell 启动后台进程）；\n   3. 文本处理协调器：把多个命令串起来（管道、重定向），完成复杂文本处理。\n\necho $shell命令可以查看当前的shell，也是默认shell\n\nikun@ubuntu2004:~/desktop$ echo $shell\n/bin/bash\n\n\n1\n2\n\n\necho /etc/shells命令可以查看当前所有可用的shell\n\nikun@ubuntu2004:~/desktop$ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/bash\n/usr/bin/bash\n...\n\n\n1\n2\n3\n4\n5\n6\n\n\necho $path命令输出一些目录\n\nikun@ubuntu2004:~/desktop$ echo $path\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\n\n\n1\n2\n\n\n# $path 核心原理：\n\n敲ls时，shell 会按顺序遍历 $path 里的目录，找到第一个名为ls的可执行文件（比如/bin/ls），然后执行它。\n\n如果想验证：敲which ls → 会输出/bin/ls，就是 $path 里找到的路径；\n\nikun@ubuntu2004:~/desktop$ which ls\n/usr/bin/ls\n\n\n1\n2\n\n\n\n# 二、bash基础行为\n\n\n# 命令查找顺序（shell 找命令的优先级）\n\nshell 执行命令时，优先级从高到低：\n\n 1. 别名（alias）→ 比如ll其实是ls -alf的别名；\n 2. 内置命令（builtin）→ 比如cd、echo（属于 shell 本身，无需找文件）；\n 3. $path 里的外部命令 → 比如ls、top（独立可执行文件）。\n\nikun@ubuntu2004:~/desktop$ type cd\ncd 是 shell 内建\nikun@ubuntu2004:~/desktop$ type echo\necho 是 shell 内建\nikun@ubuntu2004:~/desktop$ type ls\nls 是 "ls --color=auto" 的别名\nikun@ubuntu2004:~/desktop$ type ll\nll 是 "ls -alf" 的别名\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 参数展开（shell先解析，再输出）\n\nshell 执行命令前，会先把变量、通配符等 “展开” 成具体内容，再执行。\n\n# 示例：参数展开\na=10\necho $a+5  # shell先把 $a 展开成 10，再执行echo → 输出：10+5\n\n\n1\n2\n3\n\n\n\n# 通配符（* ? [])\n\nshell 的 “文件匹配工具”，先匹配文件，再执行命令：\n\n通配符   含义           示例\n*     匹配任意个任意字符    ls *.txt → 所有.txt 文件\n?     匹配 1 个任意字符   ls file?.txt → file1.txt、filea.txt（但不匹配 file10.txt）\n[]    匹配括号内的单个字符   ls file[123].txt → file1.txt、file2.txt、file3.txt\n\nikun@ubuntu2004:~/desktop$ touch a.txt b.txt ab.txt abc.txt file1 file12 file2\nikun@ubuntu2004:~/desktop$ ls *.txt\nabc.txt  ab.txt  a.txt  b.txt\nikun@ubuntu2004:~/desktop$ ls file?\nfile1  file2\nikun@ubuntu2004:~/desktop$ ls file[12]\nfile1  file2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 引号差异\n\n核心：单引号完全屏蔽 shell 解析，双引号只屏蔽通配符 / 别名，保留变量展开。\n\n引号类型   特点                示例            输出\n无引号    全解析（变量、通配符、别名）    echo $a *     10 file1.txt file2.txt...\n双引号    解析变量，屏蔽通配符 / 别名   echo "$a *"   10 *\n单引号    完全不解析，原样输出        echo \'$a *\'   $a *\n\nikun@ubuntu2004:~/desktop$ name=小明\nikun@ubuntu2004:~/desktop$ echo "我是 $name"\n我是 小明\nikun@ubuntu2004:~/desktop$ echo \'我是 $name\'\n我是 $name\n\n\n1\n2\n3\n4\n5\n\n\n\n# 三、管道符（a | b | c）\n\n核心理解：管道连接的是「stdout（标准输出）→ stdin（标准输入）」\n\n * 管道|把前一个命令的标准输出，直接传给后一个命令的标准输入；\n * 管道传递的是 “数据流”，不是文件，无需临时保存到硬盘；\n * unix 哲学：“做一件事，并做到最好”，管道把多个小命令拼成复杂功能。\n\nikun@ubuntu2004:~/desktop$ ps aux | grep bash # 把ps aux命令的输出过滤出含有bash的部分\nikun        2417  0.0  0.2  14532  5316 pts/0    ss   10:49   0:00 bash\nikun        2795  0.0  0.1  12192  2544 pts/0    s+   11:03   0:00 grep --color=auto bash\n\n\n1\n2\n3\n\n\n# 3. 多级管道：组合过滤+排序+统计（找cpu占用最高的前5个进程）\nps aux | grep -v root | sort -k3 -r | head -5\n# 解释：\n# grep -v root → 排除root进程\n# sort -k3 -r → 按第3列（%cpu）倒序排序\n# head -5 → 只取前5行\nikun@ubuntu2004:~/desktop$ ps aux | sort -k 2 -r | head -5\nuser         pid %cpu %mem    vsz   rss tty      stat start   time command\nroot          96  0.0  0.0      0     0 ?        i<   10:47   0:00 [kworker/r-scsi_]\nroot          95  0.0  0.0      0     0 ?        s    10:47   0:00 [scsi_eh_1]\nroot          94  0.0  0.0      0     0 ?        i<   10:47   0:00 [kworker/r-scsi_]\nkernoops     933  0.0  0.1  13100  2224 ?        ss   10:48   0:00 /usr/sbin/kerneloops\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、重定向（io控制）\n\nlinux每个进程默认打开三个文件描述符\n\n描述符   名称             缩写     默认位置\n0     标准输入（stdin）    <      键盘\n1     标准输出（stdout）   >/>>   终端\n2     标准错误（stderr）   2>     终端\n\n重定向就是 “改变这些数据流的去向”。\n\n# 1. 标准输出重定向（> 覆盖，>> 追加）\nls > file_list.txt  # 把ls的输出（stdout）写入file_list.txt（覆盖原有内容）\necho "新内容" >> file_list.txt  # 追加内容到文件\n\n# 2. 标准错误重定向（2>）：丢弃错误，或保存错误\nls /nonexistent 2> error.log  # 把ls的错误信息（找不到目录）保存到error.log\nls /nonexistent 2> /dev/null  # 丢弃错误（/dev/null是“黑洞”，写入的内容全消失）\n\n# 3. 合并标准输出和标准错误（&> 或 1> file 2>&1）\nls /etc /nonexistent &> all_output.log  # 把正常输出和错误都写入文件\n# 等价于：ls /etc /nonexistent 1> all_output.log 2>&1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 五、子shell与作用域\n\n当前 shell：正在操作的 shell 进程（比如终端窗口）；\n\n子 shell：由当前 shell 启动的新 shell 进程（比如()、管道、脚本执行都会创建子 shell）。\n\nikun@ubuntu2004:~/desktop$ a=10\nikun@ubuntu2004:~/desktop$ (echo 子shell: $a; a=20; echo 子shell改完: $a)\n子shell: 10\n子shell改完: 20\nikun@ubuntu2004:~/desktop$ echo 父shell: $a\n父shell: 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n子shell中的变量操作不会影响父shell，除非操作的是环境变量\n\n\n# () 和 {}的区别\n\n语法   类型         作用域              语法要求\n()   子 shell    变量只在子 shell 生效   括号内命令用；分隔，括号前后可有空格\n{}   当前 shell   变量在当前 shell 生效   最后一个命令必须加；，括号前必须有空格（如 {echo 1;}）\n\n\n# 六、环境变量（path）\n\n核心区分：环境变量 vs 普通变量\n\n * 普通变量：只在当前 shell 生效（子 shell 不可见）；\n * 环境变量：当前 shell + 所有子 shell 都可见（export 是关键）。\n\n# shell 启动时加载了什么？（读懂.bashrc）\n\nubuntu 的 bash 启动时，会按顺序加载这些文件（影响环境变量 / 别名）：\n\n 1. /etc/profile：系统级全局配置（所有用户）；\n 2. ~/.bash_profile / ~/.bash_login / ~/.profile：用户级登录 shell 配置；\n 3. ~/.bashrc：用户级非登录 shell 配置（比如终端窗口默认加载）。\n\n下面通过演示修改~/.bashrc文件来展示环境变量\n\nikun@ubuntu2004:~/desktop$ gedit ~/.bashrc\n\n# 在 ~/.bashrc中添加如下内容\n# 1. 添加自定义别名（myls 等价于 ls -l，简化命令）\nalias myls=\'ls -l\'\n# 2. 添加永久的环境变量\nexport my_path="/home/ikun/documents"\n\nikun@ubuntu2004:~/desktop$ source ~/.bashrc # 执行文件让其立刻生效\n\n#再次执行：可见添加的全局变量生效！\nikun@ubuntu2004:~/desktop$ myls\n总计 12\n-rw-rw-r-- 1 ikun ikun    0  2月 21 10:58 abc.txt\n...\n-rw-rw-r-- 1 ikun ikun   12  2月 21 11:07 test.txt\n\n\nikun@ubuntu2004:~/desktop$ echo $my_path\n/home/ikun/documents\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"04.文本处理",frontmatter:{title:"04.文本处理",date:"2026-02-21T22:00:00.000Z",permalink:"/pages/Linux_04/"},regularPath:"/05.IC-focused%20Universal%20Linux/04.text_process.html",relativePath:"05.IC-focused Universal Linux/04.text_process.md",key:"v-358c318b",path:"/pages/Linux_04/",headers:[{level:2,title:"Linux 文本处理基础（grep / cut / sort / uniq / awk / sed）",slug:"linux-文本处理基础-grep-cut-sort-uniq-awk-sed",normalizedTitle:"linux 文本处理基础（grep / cut / sort / uniq / awk / sed）",charIndex:2},{level:2,title:"一、grep —— 过滤文本（按模式筛行）",slug:"一、grep-过滤文本-按模式筛行",normalizedTitle:"一、grep —— 过滤文本（按模式筛行）",charIndex:177},{level:3,title:"1. 核心定义",slug:"_1-核心定义",normalizedTitle:"1. 核心定义",charIndex:203},{level:3,title:"2. 核心能力",slug:"_2-核心能力",normalizedTitle:"2. 核心能力",charIndex:354},{level:3,title:"3. 常用参数",slug:"_3-常用参数",normalizedTitle:"3. 常用参数",charIndex:457},{level:3,title:"4. 示例",slug:"_4-示例",normalizedTitle:"4. 示例",charIndex:611},{level:2,title:"二、cut —— 切列（按分隔符 / 字符提取字段）",slug:"二、cut-切列-按分隔符-字符提取字段",normalizedTitle:"二、cut —— 切列（按分隔符 / 字符提取字段）",charIndex:905},{level:3,title:"1. 核心定义",slug:"_1-核心定义-2",normalizedTitle:"1. 核心定义",charIndex:203},{level:3,title:"2. 核心能力",slug:"_2-核心能力-2",normalizedTitle:"2. 核心能力",charIndex:354},{level:3,title:"3. 常用参数",slug:"_3-常用参数-2",normalizedTitle:"3. 常用参数",charIndex:457},{level:3,title:"4. 示例",slug:"_4-示例-2",normalizedTitle:"4. 示例",charIndex:611},{level:2,title:"三、sort / uniq —— 排序与去重（必须成对理解）",slug:"三、sort-uniq-排序与去重-必须成对理解",normalizedTitle:"三、sort / uniq —— 排序与去重（必须成对理解）",charIndex:1450},{level:3,title:"1. 核心定义",slug:"_1-核心定义-3",normalizedTitle:"1. 核心定义",charIndex:203},{level:3,title:"2. 常用参数",slug:"_2-常用参数",normalizedTitle:"2. 常用参数",charIndex:1602},{level:3,title:"3. 示例：统计 IP 访问次数",slug:"_3-示例-统计-ip-访问次数",normalizedTitle:"3. 示例：统计 ip 访问次数",charIndex:1778},{level:2,title:"四、awk —— 按列处理的微型编程语言",slug:"四、awk-按列处理的微型编程语言",normalizedTitle:"四、awk —— 按列处理的微型编程语言",charIndex:2024},{level:3,title:"1. 核心定义",slug:"_1-核心定义-4",normalizedTitle:"1. 核心定义",charIndex:203},{level:3,title:"2. 关键认知",slug:"_2-关键认知",normalizedTitle:"2. 关键认知",charIndex:2163},{level:3,title:"3. 示例",slug:"_3-示例",normalizedTitle:"3. 示例",charIndex:1778},{level:2,title:"五、sed —— 流式文本编辑（非交互）",slug:"五、sed-流式文本编辑-非交互",normalizedTitle:"五、sed —— 流式文本编辑（非交互）",charIndex:2491},{level:3,title:"1. 核心定义",slug:"_1-核心定义-5",normalizedTitle:"1. 核心定义",charIndex:203},{level:3,title:"2. 常见操作",slug:"_2-常见操作",normalizedTitle:"2. 常见操作",charIndex:2611},{level:3,title:"3. 示例",slug:"_3-示例-2",normalizedTitle:"3. 示例",charIndex:1778},{level:2,title:"附：本文使用的测试文本",slug:"附-本文使用的测试文本",normalizedTitle:"附：本文使用的测试文本",charIndex:2928}],headersStr:"Linux 文本处理基础（grep / cut / sort / uniq / awk / sed） 一、grep —— 过滤文本（按模式筛行） 1. 核心定义 2. 核心能力 3. 常用参数 4. 示例 二、cut —— 切列（按分隔符 / 字符提取字段） 1. 核心定义 2. 核心能力 3. 常用参数 4. 示例 三、sort / uniq —— 排序与去重（必须成对理解） 1. 核心定义 2. 常用参数 3. 示例：统计 IP 访问次数 四、awk —— 按列处理的微型编程语言 1. 核心定义 2. 关键认知 3. 示例 五、sed —— 流式文本编辑（非交互） 1. 核心定义 2. 常见操作 3. 示例 附：本文使用的测试文本",content:'# Linux 文本处理基础（grep / cut / sort / uniq / awk / sed）\n\n> 本文基于常见日志文本与结构化分隔文件，梳理 Linux 下最核心的文本处理工具链。\n> \n> 目标不是记参数，而是形成“管道式处理文本”的工程直觉。\n\n----------------------------------------\n\n\n# 一、grep —— 过滤文本（按模式筛行）\n\n\n# 1. 核心定义\n\ngrep = Global Regular Expression Print\n核心作用是：从文本或数据流中筛选出包含指定“模式”的行。\n\n * 模式可以是普通字符串\n * 也可以是正则表达式\n\n----------------------------------------\n\n\n# 2. 核心能力\n\n * 按字符串 / 正则筛选行\n * 反向筛选（排除匹配行）\n * 显示行号、仅输出匹配内容等\n\n----------------------------------------\n\n\n# 3. 常用参数\n\n参数   作用\n-i   忽略大小写\n-v   反向匹配（排除匹配行）\n-n   显示行号\n-E   启用扩展正则（等价于 egrep）\n-F   固定字符串匹配（不解析正则，等价于 fgrep）\n\n----------------------------------------\n\n\n# 4. 示例\n\n# 精确匹配包含 ERROR 的行\ngrep "ERROR" app.log\n\n# 忽略大小写 + 显示行号\ngrep -in "error" app.log\n\n# 排除 INFO 日志\ngrep -v "INFO" app.log\n\n# 使用扩展正则，匹配 WARN 日志行\n# 注：日期中的 \'.\' 是正则字符，这里写成 02.21 依然能匹配\ngrep -E "^2026-02-21.*WARN" app.log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 二、cut —— 切列（按分隔符 / 字符提取字段）\n\n\n# 1. 核心定义\n\ncut 是结构化文本的“列提取器”， 适用于每一行格式稳定、分隔符明确的文本。\n\n----------------------------------------\n\n\n# 2. 核心能力\n\n * 按字符位置提取\n * 按分隔符字段提取\n\n----------------------------------------\n\n\n# 3. 常用参数\n\n参数   作用\n-d   指定分隔符（默认是 \\t）\n-f   指定字段编号\n-c   按字符位置提取\n\n----------------------------------------\n\n\n# 4. 示例\n\n# 以冒号为分隔符，提取第一列\ncut -d ":" -f1 test.csv\n# 从日志中提取 IP 字段\n# 先 grep 过滤，再用 cut 切列\ngrep "IP:" app.log | cut -d " " -f4\n\n\n1\n2\n3\n4\n5\n\n\n> 注： cut 不会自动压缩连续空格， 对“空格不规整的文本”并不友好，这正是后面 awk 更强的原因。\n\n----------------------------------------\n\n\n# 三、sort / uniq —— 排序与去重（必须成对理解）\n\n\n# 1. 核心定义\n\n * sort：对文本行进行排序\n * uniq：仅对相邻重复行生效\n\n> 结论：uniq 几乎永远要配合 sort 使用\n\n----------------------------------------\n\n\n# 2. 常用参数\n\n工具     参数   作用\nsort   -n   数值排序\n       -r   倒序\n       -k   指定排序字段\nuniq   -c   统计次数\n       -d   仅显示重复行\n       -u   仅显示唯一行\n\n----------------------------------------\n\n\n# 3. 示例：统计 IP 访问次数\n\n# 提取 IP 地址并写入文件\ngrep "IP:" app.log | cut -d " " -f4 | cut -d ":" -f2 > ip_list.txt\n\n# 排序并统计出现次数\nsort ip_list.txt | uniq -c\n# 只显示出现过多次的 IP\nsort ip_list.txt | uniq -d\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 四、awk —— 按列处理的微型编程语言\n\n\n# 1. 核心定义\n\nawk 不是“命令”，而是面向行和字段的微型编程语言：\n\n> 逐行读取 → 按分隔符切列 → 条件判断 → 输出结果\n\n----------------------------------------\n\n\n# 2. 关键认知\n\n * $0：整行\n\n * $1 ~ $NF：第 1 列到最后一列\n\n * -F：指定分隔符\n\n * 基本结构：\n   \n   awk \'条件 { 动作 }\'\n   \n   \n   1\n   \n\n----------------------------------------\n\n\n# 3. 示例\n\n# 以冒号为分隔符，提取用户名和 Shell\nawk -F ":" \'{print $1, "的shell是", $4}\' test.csv\n\n\n1\n2\n\n\n> 注： 相比 cut，awk 对空格数量不敏感， 是日志与系统文件处理中最常用的工具。\n\n----------------------------------------\n\n\n# 五、sed —— 流式文本编辑（非交互）\n\n\n# 1. 核心定义\n\nsed = Stream Editor 特点是：不打开文件，直接在文本流上修改\n\n----------------------------------------\n\n\n# 2. 常见操作\n\n * 替换：s/旧/新/\n * 删除：d\n * 插入：a / i\n * 原地修改：-i（⚠️ 谨慎）\n\n----------------------------------------\n\n\n# 3. 示例\n\n# 仅输出替换后的内容，不改文件\nsed \'s/ERROR/FATAL/\' app.log\n# 原地修改，并生成备份文件 app.log.bak\nsed -i.bak \'s/INFO/DEBUG/g\' app.log\n\n\n1\n2\n3\n4\n\n\n> 工程习惯建议： 永远优先带备份扩展名，这是成熟运维与脚本的基本素养。\n\n----------------------------------------\n\n\n# 附：本文使用的测试文本\n\n# 创建日志文件 app.log\ncat > app.log << EOF\n2026-02-21 10:00:00 [INFO] IP:192.168.1.1 访问首页\n2026-02-21 10:01:00 [ERROR] IP:192.168.1.2 登录失败\n2026-02-21 10:02:00 [WARN] IP:192.168.1.1 密码错误\n2026-02-21 10:03:00 [INFO] IP:192.168.1.3 访问商品页\n2026-02-21 10:04:00 [ERROR] IP:192.168.1.2 数据库连接失败\n2026-02-21 10:05:00 [INFO] IP:192.168.1.1 退出登录\nEOF\n\n# 创建结构化测试文件 test.csv\ncat > test.csv << EOF\n用户名:UID:家目录:登录Shell\nroot:0:/root:/bin/bash\nikun:1000:/home/ikun:/bin/bash\ntest:1001:/home/test:/bin/sh\nguest:1002:/home/guest:/bin/bash\nEOF\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# linux 文本处理基础（grep / cut / sort / uniq / awk / sed）\n\n> 本文基于常见日志文本与结构化分隔文件，梳理 linux 下最核心的文本处理工具链。\n> \n> 目标不是记参数，而是形成“管道式处理文本”的工程直觉。\n\n----------------------------------------\n\n\n# 一、grep —— 过滤文本（按模式筛行）\n\n\n# 1. 核心定义\n\ngrep = global regular expression print\n核心作用是：从文本或数据流中筛选出包含指定“模式”的行。\n\n * 模式可以是普通字符串\n * 也可以是正则表达式\n\n----------------------------------------\n\n\n# 2. 核心能力\n\n * 按字符串 / 正则筛选行\n * 反向筛选（排除匹配行）\n * 显示行号、仅输出匹配内容等\n\n----------------------------------------\n\n\n# 3. 常用参数\n\n参数   作用\n-i   忽略大小写\n-v   反向匹配（排除匹配行）\n-n   显示行号\n-e   启用扩展正则（等价于 egrep）\n-f   固定字符串匹配（不解析正则，等价于 fgrep）\n\n----------------------------------------\n\n\n# 4. 示例\n\n# 精确匹配包含 error 的行\ngrep "error" app.log\n\n# 忽略大小写 + 显示行号\ngrep -in "error" app.log\n\n# 排除 info 日志\ngrep -v "info" app.log\n\n# 使用扩展正则，匹配 warn 日志行\n# 注：日期中的 \'.\' 是正则字符，这里写成 02.21 依然能匹配\ngrep -e "^2026-02-21.*warn" app.log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 二、cut —— 切列（按分隔符 / 字符提取字段）\n\n\n# 1. 核心定义\n\ncut 是结构化文本的“列提取器”， 适用于每一行格式稳定、分隔符明确的文本。\n\n----------------------------------------\n\n\n# 2. 核心能力\n\n * 按字符位置提取\n * 按分隔符字段提取\n\n----------------------------------------\n\n\n# 3. 常用参数\n\n参数   作用\n-d   指定分隔符（默认是 \\t）\n-f   指定字段编号\n-c   按字符位置提取\n\n----------------------------------------\n\n\n# 4. 示例\n\n# 以冒号为分隔符，提取第一列\ncut -d ":" -f1 test.csv\n# 从日志中提取 ip 字段\n# 先 grep 过滤，再用 cut 切列\ngrep "ip:" app.log | cut -d " " -f4\n\n\n1\n2\n3\n4\n5\n\n\n> 注： cut 不会自动压缩连续空格， 对“空格不规整的文本”并不友好，这正是后面 awk 更强的原因。\n\n----------------------------------------\n\n\n# 三、sort / uniq —— 排序与去重（必须成对理解）\n\n\n# 1. 核心定义\n\n * sort：对文本行进行排序\n * uniq：仅对相邻重复行生效\n\n> 结论：uniq 几乎永远要配合 sort 使用\n\n----------------------------------------\n\n\n# 2. 常用参数\n\n工具     参数   作用\nsort   -n   数值排序\n       -r   倒序\n       -k   指定排序字段\nuniq   -c   统计次数\n       -d   仅显示重复行\n       -u   仅显示唯一行\n\n----------------------------------------\n\n\n# 3. 示例：统计 ip 访问次数\n\n# 提取 ip 地址并写入文件\ngrep "ip:" app.log | cut -d " " -f4 | cut -d ":" -f2 > ip_list.txt\n\n# 排序并统计出现次数\nsort ip_list.txt | uniq -c\n# 只显示出现过多次的 ip\nsort ip_list.txt | uniq -d\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 四、awk —— 按列处理的微型编程语言\n\n\n# 1. 核心定义\n\nawk 不是“命令”，而是面向行和字段的微型编程语言：\n\n> 逐行读取 → 按分隔符切列 → 条件判断 → 输出结果\n\n----------------------------------------\n\n\n# 2. 关键认知\n\n * $0：整行\n\n * $1 ~ $nf：第 1 列到最后一列\n\n * -f：指定分隔符\n\n * 基本结构：\n   \n   awk \'条件 { 动作 }\'\n   \n   \n   1\n   \n\n----------------------------------------\n\n\n# 3. 示例\n\n# 以冒号为分隔符，提取用户名和 shell\nawk -f ":" \'{print $1, "的shell是", $4}\' test.csv\n\n\n1\n2\n\n\n> 注： 相比 cut，awk 对空格数量不敏感， 是日志与系统文件处理中最常用的工具。\n\n----------------------------------------\n\n\n# 五、sed —— 流式文本编辑（非交互）\n\n\n# 1. 核心定义\n\nsed = stream editor 特点是：不打开文件，直接在文本流上修改\n\n----------------------------------------\n\n\n# 2. 常见操作\n\n * 替换：s/旧/新/\n * 删除：d\n * 插入：a / i\n * 原地修改：-i（⚠️ 谨慎）\n\n----------------------------------------\n\n\n# 3. 示例\n\n# 仅输出替换后的内容，不改文件\nsed \'s/error/fatal/\' app.log\n# 原地修改，并生成备份文件 app.log.bak\nsed -i.bak \'s/info/debug/g\' app.log\n\n\n1\n2\n3\n4\n\n\n> 工程习惯建议： 永远优先带备份扩展名，这是成熟运维与脚本的基本素养。\n\n----------------------------------------\n\n\n# 附：本文使用的测试文本\n\n# 创建日志文件 app.log\ncat > app.log << eof\n2026-02-21 10:00:00 [info] ip:192.168.1.1 访问首页\n2026-02-21 10:01:00 [error] ip:192.168.1.2 登录失败\n2026-02-21 10:02:00 [warn] ip:192.168.1.1 密码错误\n2026-02-21 10:03:00 [info] ip:192.168.1.3 访问商品页\n2026-02-21 10:04:00 [error] ip:192.168.1.2 数据库连接失败\n2026-02-21 10:05:00 [info] ip:192.168.1.1 退出登录\neof\n\n# 创建结构化测试文件 test.csv\ncat > test.csv << eof\n用户名:uid:家目录:登录shell\nroot:0:/root:/bin/bash\nikun:1000:/home/ikun:/bin/bash\ntest:1001:/home/test:/bin/sh\nguest:1002:/home/guest:/bin/bash\neof\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"05.Shell编程",frontmatter:{title:"05.Shell编程",date:"2026-02-22T14:00:00.000Z",permalink:"/pages/Linux_05/"},regularPath:"/05.IC-focused%20Universal%20Linux/05.shell_programming.html",relativePath:"05.IC-focused Universal Linux/05.shell_programming.md",key:"v-123d763a",path:"/pages/Linux_05/",headers:[{level:3,title:"一、 Shell脚本结构",slug:"一、-shell脚本结构",normalizedTitle:"一、 shell脚本结构",charIndex:2},{level:3,title:"二、条件判断(if)",slug:"二、条件判断-if",normalizedTitle:"二、条件判断(if)",charIndex:1329},{level:3,title:"三、循环",slug:"三、循环",normalizedTitle:"三、循环",charIndex:1982},{level:3,title:"四、函数",slug:"四、函数",normalizedTitle:"四、函数",charIndex:2395},{level:3,title:"五、定时任务 cron（时间触发器）",slug:"五、定时任务-cron-时间触发器",normalizedTitle:"五、定时任务 cron（时间触发器）",charIndex:2720}],headersStr:"一、 Shell脚本结构 二、条件判断(if) 三、循环 四、函数 五、定时任务 cron（时间触发器）",content:'# 一、 Shell脚本结构\n\n# 核心三要素：shebang + 执行权限 + 参数传递\n\n# （1）Shebang（脚本的 “身份证”）\n\n * 定义：脚本第一行的 #!/bin/bash（或 #!/bin/sh），告诉系统 “用哪个 Shell 来执行这个脚本”；\n * 必须写在第一行，且 #! 是固定开头（少一个都不行）；\n * 常见写法：\n   * #!/bin/bash：用 bash 执行（Ubuntu 默认，功能最全）；\n   * #!/bin/sh：用系统默认 Shell（Ubuntu 中 sh 是 bash 的软链接）。\n\n# （2）执行权限\n\n * Shell 脚本本质是 “可执行文本文件”，必须赋予执行权限（x） 才能运行；\n * 核心命令：chmod +x 脚本名.sh（给所有用户执行权限）；\n * 执行方式：\n   * ./脚本名.sh：在当前 Shell 子进程中执行（推荐）；\n   * bash 脚本名.sh：强制用 bash 执行（无需执行权限）；\n   * . 脚本名.sh / source 脚本名.sh：在当前 Shell 中执行（会修改当前环境）。\n\n# （3）参数传递（脚本接收外部输入）\n\n脚本运行时，通过位置参数接收外部传入的参数：\n\n * $0：脚本本身的名字；\n * $1：第一个参数，$2：第二个参数，…，$9：第九个参数；\n * $* / $@：所有参数（细节差异：$* 把所有参数当一个字符串，$@ 保留每个参数独立）；\n * $#：参数的个数。\n\n#如下是一个示例，展示在Linux系统中创建一个脚本、赋予执行权限并执行然后输出的过程\n\nnano first_script.sh # 创建脚本文件\n\n# 编辑脚本内容\n#!/bin/bash\n# 这是注释：第一个Shell脚本，接收参数并打印\n# 打印脚本名\necho "脚本名：$0"\n# 打印第一个参数\necho "第一个参数：$1"\n# 打印第二个参数\necho "第二个参数：$2"\n# 打印所有参数\necho "所有参数：$@"\n# 打印参数个数\necho "参数个数：$#"\n\nchmod +x first_script.sh # 赋予执行权限\n\n./first_script.sh hello world # 执行\n\n#输出内容\n脚本名：./first_script.sh\n第一个参数：hello\n第二个参数：world\n所有参数：hello world\n参数个数：2\n\n# 也可以使用以下方式执行\n# 方式1：用bash强制执行（无需执行权限）\nbash first_script.sh test1 test2\n\n# 方式2：在当前Shell执行（会修改当前环境，慎用）\nsource first_script.sh test3 test4\n# 或 . first_script.sh test3 test4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 二、条件判断(if)\n\n# 基本语法\n\n# 单分支\nif 条件; then\n    命令\nfi\n\n# 多分支\nif 条件1; then\n    命令1\nelif 条件2; then\n    命令2\nelse\n    命令3\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 常用例子\n\n 1. 判断命令是否成功（最常用）\n\nif cp a b; then\n    echo "成功"\nelse\n    echo "失败"\nfi\n\n\n1\n2\n3\n4\n5\n\n\n命令返回值：\n\n * 0：成功\n * 非 0：失败\n\n----------------------------------------\n\n 2. 文件判断参数\n\n参数        含义\n-e file   文件存在\n-f file   普通文件\n-d dir    目录\n\n示例：\n\nif [ -d backup ]; then\n    echo "目录存在"\nfi\n\n\n1\n2\n3\n\n\n⚠️ [ ] 前后必须有空格\n\n----------------------------------------\n\n3. 数值 / 字符串比较\n\n\nif [ "$a" -eq 10 ]; then\n    echo "a 等于 10"\nfi\n\n\n1\n2\n3\n\n\n常用参数：\n\n参数    含义\n-eq   等于(数字)\n-ne   不等于\n-gt   大于\n-lt   小于\n==    字符串相等\n!=    字符串不等\n\n\n# 三、循环\n\n# for循环\n\n# 基本语法\n\nfor 变量 in 列表; do\n    命令\ndone\n\n\n1\n2\n3\n\n\n# 常见用法\n\n遍历文件：\n\nfor file in *.txt; do\n    echo "$file"\ndone\n\n\n1\n2\n3\n\n\n遍历数字：\n\nfor i in {1..5}; do\n    echo $i\ndone\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# while 循环\n\n# 基本语法\n\nwhile 条件; do\n    命令\ndone\n\n\n1\n2\n3\n\n\n# 常见用法\n\n无限循环：\n\nwhile true; do\n    sleep 1\ndone\n\n\n1\n2\n3\n\n\n按行读文件：\n\nwhile read line; do\n    echo "$line"\ndone < file.txt\n\n\n1\n2\n3\n\n\n\n# 四、函数\n\n# 基本语法\n\n函数名() {\n    命令\n}\n\n\n1\n2\n3\n\n\n调用：\n\n函数名\n\n\n1\n\n\n----------------------------------------\n\n# 带参数的函数\n\nlog() {\n    echo "$1"\n}\n\n\n1\n2\n3\n\n\n调用：\n\nlog "开始执行"\n\n\n1\n\n\n参数说明：\n\n * $1 $2：第 1、2 个参数\n * $@：所有参数\n\n----------------------------------------\n\n# 返回值（可选）\n\nmyfunc() {\n    return 0\n}\n\n\n1\n2\n3\n\n * 返回范围：0–255\n * 默认返回最后一条命令的结果\n\n\n# 五、定时任务 cron（时间触发器）\n\ncron 是 Linux 内置的定时任务机制，用来在指定时间自动执行命令或脚本。\n本质只有一句话：时间到了 → 执行一条命令。\n\ncron 做的事非常简单：\n\n 1. 读取定时规则\n 2. 到时间\n 3. 执行对应的命令或脚本\n\ncron 不理解脚本逻辑，只负责“按时触发”。\n\n# （1）cron 核心语法（定时规则）\n\n * 规则格式（5 个字段，空格分隔）：分 时 日 月 周 要执行的命令/脚本；\n\n * 字段取值：\n   \n   * 分：0-59；时：0-23；日：1-31；月：1-12；周：0-7（0/7 都是周日）；\n\n * 特殊符号：\n   \n   * *：每一个（比如 * * * * * = 每分钟）；\n   * */5：每隔 5 个（比如 */5 * * * * = 每 5 分钟）；\n   * 1,30：指定多个值（比如 1,30 * * * * = 每小时的 1 分和 30 分）。\n\n# （2）cron 操作命令\n\n * 编辑定时任务：crontab -e（用户级）；/etc/crontab（系统级）；\n * 查看定时任务：crontab -l；\n * 删除定时任务：crontab -r（谨慎！）；\n * 查看 cron 日志：grep cron /var/log/syslog（排查定时任务不执行问题）。\n\n# （3）核心注意事项\n\n * 脚本必须写绝对路径（比如 /home/ikun/backup.sh，而非 ./backup.sh）；\n * 脚本中调用的命令最好写绝对路径（比如 /bin/ls，而非 ls）；\n * 定时任务的输出默认发邮件，可重定向到日志：*/5 * * * * /home/ikun/check.sh >> /home/ikun/check.log 2>&1。',normalizedContent:'# 一、 shell脚本结构\n\n# 核心三要素：shebang + 执行权限 + 参数传递\n\n# （1）shebang（脚本的 “身份证”）\n\n * 定义：脚本第一行的 #!/bin/bash（或 #!/bin/sh），告诉系统 “用哪个 shell 来执行这个脚本”；\n * 必须写在第一行，且 #! 是固定开头（少一个都不行）；\n * 常见写法：\n   * #!/bin/bash：用 bash 执行（ubuntu 默认，功能最全）；\n   * #!/bin/sh：用系统默认 shell（ubuntu 中 sh 是 bash 的软链接）。\n\n# （2）执行权限\n\n * shell 脚本本质是 “可执行文本文件”，必须赋予执行权限（x） 才能运行；\n * 核心命令：chmod +x 脚本名.sh（给所有用户执行权限）；\n * 执行方式：\n   * ./脚本名.sh：在当前 shell 子进程中执行（推荐）；\n   * bash 脚本名.sh：强制用 bash 执行（无需执行权限）；\n   * . 脚本名.sh / source 脚本名.sh：在当前 shell 中执行（会修改当前环境）。\n\n# （3）参数传递（脚本接收外部输入）\n\n脚本运行时，通过位置参数接收外部传入的参数：\n\n * $0：脚本本身的名字；\n * $1：第一个参数，$2：第二个参数，…，$9：第九个参数；\n * $* / $@：所有参数（细节差异：$* 把所有参数当一个字符串，$@ 保留每个参数独立）；\n * $#：参数的个数。\n\n#如下是一个示例，展示在linux系统中创建一个脚本、赋予执行权限并执行然后输出的过程\n\nnano first_script.sh # 创建脚本文件\n\n# 编辑脚本内容\n#!/bin/bash\n# 这是注释：第一个shell脚本，接收参数并打印\n# 打印脚本名\necho "脚本名：$0"\n# 打印第一个参数\necho "第一个参数：$1"\n# 打印第二个参数\necho "第二个参数：$2"\n# 打印所有参数\necho "所有参数：$@"\n# 打印参数个数\necho "参数个数：$#"\n\nchmod +x first_script.sh # 赋予执行权限\n\n./first_script.sh hello world # 执行\n\n#输出内容\n脚本名：./first_script.sh\n第一个参数：hello\n第二个参数：world\n所有参数：hello world\n参数个数：2\n\n# 也可以使用以下方式执行\n# 方式1：用bash强制执行（无需执行权限）\nbash first_script.sh test1 test2\n\n# 方式2：在当前shell执行（会修改当前环境，慎用）\nsource first_script.sh test3 test4\n# 或 . first_script.sh test3 test4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 二、条件判断(if)\n\n# 基本语法\n\n# 单分支\nif 条件; then\n    命令\nfi\n\n# 多分支\nif 条件1; then\n    命令1\nelif 条件2; then\n    命令2\nelse\n    命令3\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 常用例子\n\n 1. 判断命令是否成功（最常用）\n\nif cp a b; then\n    echo "成功"\nelse\n    echo "失败"\nfi\n\n\n1\n2\n3\n4\n5\n\n\n命令返回值：\n\n * 0：成功\n * 非 0：失败\n\n----------------------------------------\n\n 2. 文件判断参数\n\n参数        含义\n-e file   文件存在\n-f file   普通文件\n-d dir    目录\n\n示例：\n\nif [ -d backup ]; then\n    echo "目录存在"\nfi\n\n\n1\n2\n3\n\n\n⚠️ [ ] 前后必须有空格\n\n----------------------------------------\n\n3. 数值 / 字符串比较\n\n\nif [ "$a" -eq 10 ]; then\n    echo "a 等于 10"\nfi\n\n\n1\n2\n3\n\n\n常用参数：\n\n参数    含义\n-eq   等于(数字)\n-ne   不等于\n-gt   大于\n-lt   小于\n==    字符串相等\n!=    字符串不等\n\n\n# 三、循环\n\n# for循环\n\n# 基本语法\n\nfor 变量 in 列表; do\n    命令\ndone\n\n\n1\n2\n3\n\n\n# 常见用法\n\n遍历文件：\n\nfor file in *.txt; do\n    echo "$file"\ndone\n\n\n1\n2\n3\n\n\n遍历数字：\n\nfor i in {1..5}; do\n    echo $i\ndone\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n# while 循环\n\n# 基本语法\n\nwhile 条件; do\n    命令\ndone\n\n\n1\n2\n3\n\n\n# 常见用法\n\n无限循环：\n\nwhile true; do\n    sleep 1\ndone\n\n\n1\n2\n3\n\n\n按行读文件：\n\nwhile read line; do\n    echo "$line"\ndone < file.txt\n\n\n1\n2\n3\n\n\n\n# 四、函数\n\n# 基本语法\n\n函数名() {\n    命令\n}\n\n\n1\n2\n3\n\n\n调用：\n\n函数名\n\n\n1\n\n\n----------------------------------------\n\n# 带参数的函数\n\nlog() {\n    echo "$1"\n}\n\n\n1\n2\n3\n\n\n调用：\n\nlog "开始执行"\n\n\n1\n\n\n参数说明：\n\n * $1 $2：第 1、2 个参数\n * $@：所有参数\n\n----------------------------------------\n\n# 返回值（可选）\n\nmyfunc() {\n    return 0\n}\n\n\n1\n2\n3\n\n * 返回范围：0–255\n * 默认返回最后一条命令的结果\n\n\n# 五、定时任务 cron（时间触发器）\n\ncron 是 linux 内置的定时任务机制，用来在指定时间自动执行命令或脚本。\n本质只有一句话：时间到了 → 执行一条命令。\n\ncron 做的事非常简单：\n\n 1. 读取定时规则\n 2. 到时间\n 3. 执行对应的命令或脚本\n\ncron 不理解脚本逻辑，只负责“按时触发”。\n\n# （1）cron 核心语法（定时规则）\n\n * 规则格式（5 个字段，空格分隔）：分 时 日 月 周 要执行的命令/脚本；\n\n * 字段取值：\n   \n   * 分：0-59；时：0-23；日：1-31；月：1-12；周：0-7（0/7 都是周日）；\n\n * 特殊符号：\n   \n   * *：每一个（比如 * * * * * = 每分钟）；\n   * */5：每隔 5 个（比如 */5 * * * * = 每 5 分钟）；\n   * 1,30：指定多个值（比如 1,30 * * * * = 每小时的 1 分和 30 分）。\n\n# （2）cron 操作命令\n\n * 编辑定时任务：crontab -e（用户级）；/etc/crontab（系统级）；\n * 查看定时任务：crontab -l；\n * 删除定时任务：crontab -r（谨慎！）；\n * 查看 cron 日志：grep cron /var/log/syslog（排查定时任务不执行问题）。\n\n# （3）核心注意事项\n\n * 脚本必须写绝对路径（比如 /home/ikun/backup.sh，而非 ./backup.sh）；\n * 脚本中调用的命令最好写绝对路径（比如 /bin/ls，而非 ls）；\n * 定时任务的输出默认发邮件，可重定向到日志：*/5 * * * * /home/ikun/check.sh >> /home/ikun/check.log 2>&1。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"00.Rust的基本素养",frontmatter:{title:"00.Rust的基本素养",date:"2025-08-17T22:00:00.000Z",permalink:"/pages/Rust_00/"},regularPath:"/06.Rust/00.Rust%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB.html",relativePath:"06.Rust/00.Rust的基本素养.md",key:"v-5a424a08",path:"/pages/Rust_00/",headers:[{level:2,title:"一. 为什么选择 Rust？",slug:"一-为什么选择-rust",normalizedTitle:"一. 为什么选择 rust？",charIndex:22},{level:2,title:"二. 安装与环境准备",slug:"二-安装与环境准备",normalizedTitle:"二. 安装与环境准备",charIndex:322},{level:2,title:"三. Hello, World!",slug:"三-hello-world",normalizedTitle:"三. hello, world!",charIndex:525},{level:2,title:"四. Cargo：Rust 工程的核心",slug:"四-cargo-rust-工程的核心",normalizedTitle:"四. cargo：rust 工程的核心",charIndex:779}],headersStr:"一. 为什么选择 Rust？ 二. 安装与环境准备 三. Hello, World! 四. Cargo：Rust 工程的核心",content:"# Rust：现代系统编程的新基石\n\n\n# 一. 为什么选择 Rust？\n\nRust 是一门兼顾 性能 与 安全性 的系统级语言：\n\n语言       优势                   劣势\nC/C++    性能强大，生态成熟            内存安全问题多\nPython   开发效率高，生态丰富           性能受限，不适合底层开发\nRust     内存安全 + 高性能 + 无需 GC   上手曲线稍陡，生态在成长\n\n> Rust 之于 2025 年的嵌入式开发，就像 20 年前 C 之于单片机：新的起点，新的机会。\n\n----------------------------------------\n\n\n# 二. 安装与环境准备\n\n推荐使用 Rustup，一键安装管理工具链。\n\n安装完成后，常用命令有：\n\nrustc --version   # 查看编译器版本\ncargo --version   # 查看包管理器版本\n\n\n1\n2\n\n\nCargo 是 Rust 的“瑞士军刀”，负责 构建 / 依赖管理 / 打包发布。\n\n----------------------------------------\n\n\n# 三. Hello, World!\n\n创建新项目：\n\ncargo new hello-rust\ncd hello-rust\n\n\n1\n2\n\n\n目录结构：\n\nhello-rust\n ├── Cargo.toml    # 项目配置文件\n └── src\n     └── main.rs   # 主程序入口\n\n\n1\n2\n3\n4\n\n\n运行：\n\ncargo run\n\n\n1\n\n\n输出：\n\nHello, world!\n\n\n1\n\n\n----------------------------------------\n\n\n# 四. Cargo：Rust 工程的核心\n\n常用命令一览：\n\n命令                 功能\ncargo build        构建项目（生成可执行文件）\ncargo run          构建并运行项目\ncargo check        检查语法错误，速度更快\ncargo update       更新依赖版本\ncargo doc --open   生成文档并在浏览器打开",normalizedContent:"# rust：现代系统编程的新基石\n\n\n# 一. 为什么选择 rust？\n\nrust 是一门兼顾 性能 与 安全性 的系统级语言：\n\n语言       优势                   劣势\nc/c++    性能强大，生态成熟            内存安全问题多\npython   开发效率高，生态丰富           性能受限，不适合底层开发\nrust     内存安全 + 高性能 + 无需 gc   上手曲线稍陡，生态在成长\n\n> rust 之于 2025 年的嵌入式开发，就像 20 年前 c 之于单片机：新的起点，新的机会。\n\n----------------------------------------\n\n\n# 二. 安装与环境准备\n\n推荐使用 rustup，一键安装管理工具链。\n\n安装完成后，常用命令有：\n\nrustc --version   # 查看编译器版本\ncargo --version   # 查看包管理器版本\n\n\n1\n2\n\n\ncargo 是 rust 的“瑞士军刀”，负责 构建 / 依赖管理 / 打包发布。\n\n----------------------------------------\n\n\n# 三. hello, world!\n\n创建新项目：\n\ncargo new hello-rust\ncd hello-rust\n\n\n1\n2\n\n\n目录结构：\n\nhello-rust\n ├── cargo.toml    # 项目配置文件\n └── src\n     └── main.rs   # 主程序入口\n\n\n1\n2\n3\n4\n\n\n运行：\n\ncargo run\n\n\n1\n\n\n输出：\n\nhello, world!\n\n\n1\n\n\n----------------------------------------\n\n\n# 四. cargo：rust 工程的核心\n\n常用命令一览：\n\n命令                 功能\ncargo build        构建项目（生成可执行文件）\ncargo run          构建并运行项目\ncargo check        检查语法错误，速度更快\ncargo update       更新依赖版本\ncargo doc --open   生成文档并在浏览器打开",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"01.Rust的变量与可变性",frontmatter:{title:"01.Rust的变量与可变性",date:"2025-08-18T10:55:00.000Z",permalink:"/pages/Rust_01/"},regularPath:"/06.Rust/01.Rust%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7.html",relativePath:"06.Rust/01.Rust的变量与可变性.md",key:"v-b3fd1cf4",path:"/pages/Rust_01/",headers:[{level:2,title:"一. 为什么变量默认不可变？",slug:"一-为什么变量默认不可变",normalizedTitle:"一. 为什么变量默认不可变？",charIndex:146},{level:2,title:"二. 常量：永远静止的一块值",slug:"二-常量-永远静止的一块值",normalizedTitle:"二. 常量：永远静止的一块值",charIndex:616},{level:2,title:"三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量",slug:"三-遮蔽-shadowing-使用同名变量-换壳-而不动原变量",normalizedTitle:"三. 遮蔽（shadowing）：使用同名变量“换壳”而不动原变量",charIndex:787}],headersStr:"一. 为什么变量默认不可变？ 二. 常量：永远静止的一块值 三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量",content:'# Rust 的变量与可变性：设计安全的第一步\n\nRust 与传统语言不同，它默认把所有变量锁住——不许轻易变。这种默认不可变设计帮你挡下 Pointer Bug 和数据竞争，是现代系统语言的本分。\n\n----------------------------------------\n\n\n# 一. 为什么变量默认不可变？\n\n设计选择    优势                说明\n默认不可变   消灭意外修改，代码更安全可推导   Rust 编译器帮你保障“一旦设定，不会悄悄改变”\n                          :contentReference[oaicite:0]{index=0}\n显示可变    写意且受控，修改行为更加明确    必须写 mut，才能修改变量 :contentReference[oaicite:1]{index=1}\n\n比如：\n\nlet x = 1;\nprintln!("x 是 {}", x);\nx = 2; // 编译报错：cannot assign twice to immutable variable `x`\n\n\n1\n2\n3\n\n\n这是因为 x 默认不可变。改用：\n\nlet mut x = 5;\nprintln!("x 是 {}", x);\nx = 6; // OK，编译器允许\n\n\n1\n2\n3\n\n\n把==“可变性”==明确标注出来，方便自己也方便团队理解。\n\n\n# 二. 常量：永远静止的一块值\n\n常量 (const) 与变量类似，但从来不可变，而且必须显式写类型，初始化值也只能是编译期已知的常量表达式：\n\nconst Pi: u32 = 3.1415926;\n\n\n1\n\n * 永久不变，且不可加 mut。\n * 类型必标注，编译时代入计算结果。\n * 在任何作用域都有效，适合定义全局不变参数。\n\n\n# 三. 遮蔽（Shadowing）：使用同名变量“换壳”而不动原变量\n\nRust 允许使用 let 重复定义变量名称，旧的就被“遮蔽”了。这与可变或常量不同，是创造新变量：\n\nlet x = 5;\nlet x = x + 1;         // x 变成 6\n{\n    let x = x * 2;     // 内部作用域里 x 是 12\n    println!("内层 x = {x}");\n}\nprintln!("外层 x = {x}"); // x 回退为 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n遮蔽的好处：\n\n * 不用 mut，还能变值；\n * 支持改变类型，如把字符串变成数值，复用变量名更干净。',normalizedContent:'# rust 的变量与可变性：设计安全的第一步\n\nrust 与传统语言不同，它默认把所有变量锁住——不许轻易变。这种默认不可变设计帮你挡下 pointer bug 和数据竞争，是现代系统语言的本分。\n\n----------------------------------------\n\n\n# 一. 为什么变量默认不可变？\n\n设计选择    优势                说明\n默认不可变   消灭意外修改，代码更安全可推导   rust 编译器帮你保障“一旦设定，不会悄悄改变”\n                          :contentreference[oaicite:0]{index=0}\n显示可变    写意且受控，修改行为更加明确    必须写 mut，才能修改变量 :contentreference[oaicite:1]{index=1}\n\n比如：\n\nlet x = 1;\nprintln!("x 是 {}", x);\nx = 2; // 编译报错：cannot assign twice to immutable variable `x`\n\n\n1\n2\n3\n\n\n这是因为 x 默认不可变。改用：\n\nlet mut x = 5;\nprintln!("x 是 {}", x);\nx = 6; // ok，编译器允许\n\n\n1\n2\n3\n\n\n把==“可变性”==明确标注出来，方便自己也方便团队理解。\n\n\n# 二. 常量：永远静止的一块值\n\n常量 (const) 与变量类似，但从来不可变，而且必须显式写类型，初始化值也只能是编译期已知的常量表达式：\n\nconst pi: u32 = 3.1415926;\n\n\n1\n\n * 永久不变，且不可加 mut。\n * 类型必标注，编译时代入计算结果。\n * 在任何作用域都有效，适合定义全局不变参数。\n\n\n# 三. 遮蔽（shadowing）：使用同名变量“换壳”而不动原变量\n\nrust 允许使用 let 重复定义变量名称，旧的就被“遮蔽”了。这与可变或常量不同，是创造新变量：\n\nlet x = 5;\nlet x = x + 1;         // x 变成 6\n{\n    let x = x * 2;     // 内部作用域里 x 是 12\n    println!("内层 x = {x}");\n}\nprintln!("外层 x = {x}"); // x 回退为 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n遮蔽的好处：\n\n * 不用 mut，还能变值；\n * 支持改变类型，如把字符串变成数值，复用变量名更干净。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"02.Rust的数据类型",frontmatter:{title:"02.Rust的数据类型",date:"2025-08-18T11:12:00.000Z",permalink:"/pages/Rust_02/"},regularPath:"/06.Rust/02.Rust%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"06.Rust/02.Rust的数据类型.md",key:"v-4735483d",path:"/pages/Rust_02/",headers:[{level:2,title:"一. 静态类型与类型推断",slug:"一-静态类型与类型推断",normalizedTitle:"一. 静态类型与类型推断",charIndex:149},{level:2,title:"二. 标量类型（Scalar Types）",slug:"二-标量类型-scalar-types",normalizedTitle:"二. 标量类型（scalar types）",charIndex:327},{level:3,title:"1.整型（Integer）",slug:"_1-整型-integer",normalizedTitle:"1.整型（integer）",charIndex:377},{level:3,title:"2.浮点型（Floating-Point）",slug:"_2-浮点型-floating-point",normalizedTitle:"2.浮点型（floating-point）",charIndex:854},{level:3,title:"3.布尔型（Boolean）",slug:"_3-布尔型-boolean",normalizedTitle:"3.布尔型（boolean）",charIndex:1005},{level:3,title:"4.字符型（Character）",slug:"_4-字符型-character",normalizedTitle:"4.字符型（character）",charIndex:1128},{level:3,title:"5.数值运算（Computing）",slug:"_5-数值运算-computing",normalizedTitle:"5.数值运算（computing）",charIndex:1423},{level:2,title:"三、复合类型（Compound Types）",slug:"三、复合类型-compound-types",normalizedTitle:"三、复合类型（compound types）",charIndex:1725},{level:3,title:"2. 数组（Array）",slug:"_2-数组-array",normalizedTitle:"2. 数组（array）",charIndex:2610}],headersStr:"一. 静态类型与类型推断 二. 标量类型（Scalar Types） 1.整型（Integer） 2.浮点型（Floating-Point） 3.布尔型（Boolean） 4.字符型（Character） 5.数值运算（Computing） 三、复合类型（Compound Types） 2. 数组（Array）",content:"# Rust 的数据类型：给每个值找个“身份”\n\n在 Rust 中，每一个值都带着标签——类型（data type），告诉编译器怎么处理它。\n\n这就是 Rust 的静态类型特性，让错误在编译期被挡在门外。\n\n----------------------------------------\n\n\n# 一. 静态类型与类型推断\n\nRust 是静态类型语言，意味着所有变量的类型必须在 编译时知道。但你通常不用写在代码里，Rust 编译器会自动推断出来：\n\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n\n\n1\n\n\n如果不写 : u32，编译器会报错说无法推断类型，需要你给个明示才行。\n\n\n# 二. 标量类型（Scalar Types）\n\n标量类型代表单一数值或字符。\n\n主要有四类：\n\n\n# 1.整型（Integer）\n\nRust 支持多种整型，每种定大小、有符号或无符号，含 i8, u8, …, i128, u128, 还有根据平台决定大小的 isize / usize。\n\n长度              有符号     无符号\n8-bit           i8      u8\n16-bit          i16     u16\n32-bit          i32     u32\n64-bit          i64     u64\n128-bit         i128    u128\n架构相关(x86/x64)   isize   usize\n\n各种字面值的示例：\n\n数字字面值                 例子\nDecimal (十进制)         54_188\nHex (十六进制)            0xff\nOctal (八进制)           0o77\nBinary (二进制)          0b1010_0101\nByte (单字节字符)(仅限于u8)   b'A'\n\n\n# 2.浮点型（Floating-Point）\n\nRust 有 f32 和 f64，默认的是 f64，因为现代 CPU 上运算速度差不离，但精度更高。\n\nlet x = 2.0;          // f64\nlet y: f32 = 3.0;     // f32，必须显式标注\n\n\n1\n2\n\n\n\n# 3.布尔型（Boolean）\n\n只有两个值：true / false，类型是 bool，占一个字节，与其他语言一样，用于控制流中的==条件表达式==。\n\nlet t = true;\nlet f: bool = false;\n\n\n1\n2\n\n\n\n# 4.字符型（Character）\n\nRust的字符型是非常^6^的，因为它使用的是Unicode编码，类型的大小为四个字节 (four bytes)，而不是传统的阿斯克码，所以，它可以表示任何字符，任何语言的字符！\n\n我们用单引号声明 char 字面值，而与之相反的是，使用双引号声明字符串字面值。\n\n// 以下字符型变量全是合法的, 只有你想不到，没有我R*哥表示不到😉\nlet c = 'c';\nlet z: char = 'ℤ'; \nlet wink = '😉';\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 5.数值运算（Computing）\n\nRust的所有类型数据都支持运算，整数的运算一般会有取舍。\n\nlet sum = 5 + 10;\t// 加法\nlet difference = 95.5 - 4.3;\t// 减法 \nlet product = 4 * 30;\t// 乘法\nlet quotient = 56.7 / 32.2;\t// 正常除法\nlet truncated = -5 / 3; // 整除，结果为 -1\nlet remainder = 43 % 5;\t// 取余\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、复合类型（Compound Types）\n\nRust 有两个原生的复合类型：元组（tuple）和数组（array）。\n\n * 元组（Tuple）：类型可以不同，长度固定，用 (a, b) 定义，访问靠 .0, .1。\n * 数组（Array）：类型相同，长度固定，用 [T; N] 定义，访问靠索引。\n\n它们是构建更复杂结构的基础，适合包裹多个相关值。\n\n# 1. 元组（Tuple）\n\n定义：元组把多种类型的若干值打包成一个整体，长度固定、元素可异构（各元素类型可不同）。\n\n# 创建与类型标注\n\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet mixed = (\"ok\", 3.14, true);\nlet single = (42,);     // 单元素元组：注意结尾的逗号\nlet not_tuple = (42);   // 这只是 42 本身，不是元组\n\n\n1\n2\n3\n4\n\n\n> 要点：单元素元组必须带逗号 (42,)，否则就是普通值。\n\n# 解构（Destructuring）\n\nlet (x, y, z) = tup;  // 模式匹配式解构\nprintln!(\"{x}, {y}, {z}\");\n\n\n1\n2\n\n * 解构会“按位”绑定新变量，仍然整体所有权转移（或拷贝，取决于元素是否 Copy）。\n\n# 索引访问\n\nlet a = tup.0;  // 500\nlet b = tup.1;  // 6.4\n\n\n1\n2\n\n * 编译期检查索引是否在范围内（超界直接编译失败）。\n\n# 单位类型（Unit Type）()\n\n * () 是一个特殊的 0 长度元组，读作 unit。\n\n * 含义：“没有有意义的值”，常见于函数不返回值的情况（返回 ()），或语句表达式的值。\n   \n   let x = ();        // x 的类型是 ()\n   fn log() { }       // 等价 fn log() -> () { }\n   \n   \n   1\n   2\n   \n\n\n# 2. 数组（Array）\n\n定义：数组是同类型元素、长度固定、在栈上连续存储的序列，类型写作 [T; N]。\n\n> 要点：长度 N 是类型的一部分——[u8; 3] 与 [u8; 4] 是不同的类型。\n\n# 创建与类型标注\n\nlet a = [1, 2, 3, 4, 5];               // 推断为 [i32; 5]\nlet b: [i32; 3] = [10, 20, 30];        // 显式类型\nlet c = [0; 8];                         // 重复语法：等价 [0,0,0,0,0,0,0,0]\nlet empty: [u8; 0] = [];                // 零长数组也合法\n\n\n1\n2\n3\n4\n\n\n# 索引与边界检查\n\nlet first = a[0];\nlet last  = a[a.len() - 1];\n\n// 越界会在**运行时 panic**\n// let x = a[999]; // 运行时触发 “index out of bounds”\n\n\n1\n2\n3\n4\n5\n\n * Rust 对数组索引运行时检查，避免越界 UB（未定义行为）。",normalizedContent:"# rust 的数据类型：给每个值找个“身份”\n\n在 rust 中，每一个值都带着标签——类型（data type），告诉编译器怎么处理它。\n\n这就是 rust 的静态类型特性，让错误在编译期被挡在门外。\n\n----------------------------------------\n\n\n# 一. 静态类型与类型推断\n\nrust 是静态类型语言，意味着所有变量的类型必须在 编译时知道。但你通常不用写在代码里，rust 编译器会自动推断出来：\n\nlet guess: u32 = \"42\".parse().expect(\"not a number!\");\n\n\n1\n\n\n如果不写 : u32，编译器会报错说无法推断类型，需要你给个明示才行。\n\n\n# 二. 标量类型（scalar types）\n\n标量类型代表单一数值或字符。\n\n主要有四类：\n\n\n# 1.整型（integer）\n\nrust 支持多种整型，每种定大小、有符号或无符号，含 i8, u8, …, i128, u128, 还有根据平台决定大小的 isize / usize。\n\n长度              有符号     无符号\n8-bit           i8      u8\n16-bit          i16     u16\n32-bit          i32     u32\n64-bit          i64     u64\n128-bit         i128    u128\n架构相关(x86/x64)   isize   usize\n\n各种字面值的示例：\n\n数字字面值                 例子\ndecimal (十进制)         54_188\nhex (十六进制)            0xff\noctal (八进制)           0o77\nbinary (二进制)          0b1010_0101\nbyte (单字节字符)(仅限于u8)   b'a'\n\n\n# 2.浮点型（floating-point）\n\nrust 有 f32 和 f64，默认的是 f64，因为现代 cpu 上运算速度差不离，但精度更高。\n\nlet x = 2.0;          // f64\nlet y: f32 = 3.0;     // f32，必须显式标注\n\n\n1\n2\n\n\n\n# 3.布尔型（boolean）\n\n只有两个值：true / false，类型是 bool，占一个字节，与其他语言一样，用于控制流中的==条件表达式==。\n\nlet t = true;\nlet f: bool = false;\n\n\n1\n2\n\n\n\n# 4.字符型（character）\n\nrust的字符型是非常^6^的，因为它使用的是unicode编码，类型的大小为四个字节 (four bytes)，而不是传统的阿斯克码，所以，它可以表示任何字符，任何语言的字符！\n\n我们用单引号声明 char 字面值，而与之相反的是，使用双引号声明字符串字面值。\n\n// 以下字符型变量全是合法的, 只有你想不到，没有我r*哥表示不到😉\nlet c = 'c';\nlet z: char = 'ℤ'; \nlet wink = '😉';\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 5.数值运算（computing）\n\nrust的所有类型数据都支持运算，整数的运算一般会有取舍。\n\nlet sum = 5 + 10;\t// 加法\nlet difference = 95.5 - 4.3;\t// 减法 \nlet product = 4 * 30;\t// 乘法\nlet quotient = 56.7 / 32.2;\t// 正常除法\nlet truncated = -5 / 3; // 整除，结果为 -1\nlet remainder = 43 % 5;\t// 取余\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、复合类型（compound types）\n\nrust 有两个原生的复合类型：元组（tuple）和数组（array）。\n\n * 元组（tuple）：类型可以不同，长度固定，用 (a, b) 定义，访问靠 .0, .1。\n * 数组（array）：类型相同，长度固定，用 [t; n] 定义，访问靠索引。\n\n它们是构建更复杂结构的基础，适合包裹多个相关值。\n\n# 1. 元组（tuple）\n\n定义：元组把多种类型的若干值打包成一个整体，长度固定、元素可异构（各元素类型可不同）。\n\n# 创建与类型标注\n\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet mixed = (\"ok\", 3.14, true);\nlet single = (42,);     // 单元素元组：注意结尾的逗号\nlet not_tuple = (42);   // 这只是 42 本身，不是元组\n\n\n1\n2\n3\n4\n\n\n> 要点：单元素元组必须带逗号 (42,)，否则就是普通值。\n\n# 解构（destructuring）\n\nlet (x, y, z) = tup;  // 模式匹配式解构\nprintln!(\"{x}, {y}, {z}\");\n\n\n1\n2\n\n * 解构会“按位”绑定新变量，仍然整体所有权转移（或拷贝，取决于元素是否 copy）。\n\n# 索引访问\n\nlet a = tup.0;  // 500\nlet b = tup.1;  // 6.4\n\n\n1\n2\n\n * 编译期检查索引是否在范围内（超界直接编译失败）。\n\n# 单位类型（unit type）()\n\n * () 是一个特殊的 0 长度元组，读作 unit。\n\n * 含义：“没有有意义的值”，常见于函数不返回值的情况（返回 ()），或语句表达式的值。\n   \n   let x = ();        // x 的类型是 ()\n   fn log() { }       // 等价 fn log() -> () { }\n   \n   \n   1\n   2\n   \n\n\n# 2. 数组（array）\n\n定义：数组是同类型元素、长度固定、在栈上连续存储的序列，类型写作 [t; n]。\n\n> 要点：长度 n 是类型的一部分——[u8; 3] 与 [u8; 4] 是不同的类型。\n\n# 创建与类型标注\n\nlet a = [1, 2, 3, 4, 5];               // 推断为 [i32; 5]\nlet b: [i32; 3] = [10, 20, 30];        // 显式类型\nlet c = [0; 8];                         // 重复语法：等价 [0,0,0,0,0,0,0,0]\nlet empty: [u8; 0] = [];                // 零长数组也合法\n\n\n1\n2\n3\n4\n\n\n# 索引与边界检查\n\nlet first = a[0];\nlet last  = a[a.len() - 1];\n\n// 越界会在**运行时 panic**\n// let x = a[999]; // 运行时触发 “index out of bounds”\n\n\n1\n2\n3\n4\n5\n\n * rust 对数组索引运行时检查，避免越界 ub（未定义行为）。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"03.Rust的函数与注释",frontmatter:{title:"03.Rust的函数与注释",date:"2025-08-19T10:00:00.000Z",permalink:"/pages/Rust_03/"},regularPath:"/06.Rust/03.Rust%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%B3%A8%E9%87%8A.html",relativePath:"06.Rust/03.Rust的函数和注释.md",key:"v-554cdc89",path:"/pages/Rust_03/",headers:[{level:2,title:"一、函数的基本结构",slug:"一、函数的基本结构",normalizedTitle:"一、函数的基本结构",charIndex:116},{level:2,title:"二、参数与返回值",slug:"二、参数与返回值",normalizedTitle:"二、参数与返回值",charIndex:311},{level:2,title:"三、分号与返回值",slug:"三、分号与返回值",normalizedTitle:"三、分号与返回值",charIndex:614},{level:2,title:"四、注释的写法",slug:"四、注释的写法",normalizedTitle:"四、注释的写法",charIndex:819}],headersStr:"一、函数的基本结构 二、参数与返回值 三、分号与返回值 四、注释的写法",content:'# Rust 的函数与注释\n\n在 Rust 中，函数是组织代码的基本单元，注释则是对代码意图的说明。理解这两点，可以让程序既清晰又易维护。\n\n----------------------------------------\n\n\n# 一、函数的基本结构\n\n最小化的函数形式如下：\n\nfn main() {\n    println!("Hello from Rust!");\n}\n\n\n1\n2\n3\n\n * fn 表示函数定义。\n * main 是程序入口。\n * 括号 () 表示参数列表，这里为空。\n * 花括号 {} 包裹函数体。\n\n----------------------------------------\n\n\n# 二、参数与返回值\n\nfn sum(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nfn main() {\n    let result = sum(5, 7);\n    println!("5 + 7 = {result}");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 参数写作 名称: 类型，多个参数用逗号分隔。\n * 返回值通过 -> 类型 声明。\n * 最后一行表达式自动成为返回值。\n\n如果需要显式返回，可以使用 return：\n\nreturn x + y;\n\n\n1\n\n\n----------------------------------------\n\n\n# 三、分号与返回值\n\nfn five() -> i32 {\n    5\n}\n\nfn five_wrong() -> i32 {\n    5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 没有分号：表达式的值就是返回值。\n * 有分号：变成语句，不会返回值，类型是 ()。\n\n这体现了 Rust 区分语句与表达式的方式。\n\n----------------------------------------\n\n\n# 四、注释的写法\n\nRust 支持两种常见注释：\n\n 1. 单行注释：\n    \n    // 打印一句话\n    println!("hi");\n    \n    \n    1\n    2\n    \n\n 2. 文档注释：\n    \n    /// 计算两数之和\n    fn sum(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n文档注释不仅能说明函数用途，还能通过 cargo doc --open 生成文档。',normalizedContent:'# rust 的函数与注释\n\n在 rust 中，函数是组织代码的基本单元，注释则是对代码意图的说明。理解这两点，可以让程序既清晰又易维护。\n\n----------------------------------------\n\n\n# 一、函数的基本结构\n\n最小化的函数形式如下：\n\nfn main() {\n    println!("hello from rust!");\n}\n\n\n1\n2\n3\n\n * fn 表示函数定义。\n * main 是程序入口。\n * 括号 () 表示参数列表，这里为空。\n * 花括号 {} 包裹函数体。\n\n----------------------------------------\n\n\n# 二、参数与返回值\n\nfn sum(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nfn main() {\n    let result = sum(5, 7);\n    println!("5 + 7 = {result}");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 参数写作 名称: 类型，多个参数用逗号分隔。\n * 返回值通过 -> 类型 声明。\n * 最后一行表达式自动成为返回值。\n\n如果需要显式返回，可以使用 return：\n\nreturn x + y;\n\n\n1\n\n\n----------------------------------------\n\n\n# 三、分号与返回值\n\nfn five() -> i32 {\n    5\n}\n\nfn five_wrong() -> i32 {\n    5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 没有分号：表达式的值就是返回值。\n * 有分号：变成语句，不会返回值，类型是 ()。\n\n这体现了 rust 区分语句与表达式的方式。\n\n----------------------------------------\n\n\n# 四、注释的写法\n\nrust 支持两种常见注释：\n\n 1. 单行注释：\n    \n    // 打印一句话\n    println!("hi");\n    \n    \n    1\n    2\n    \n\n 2. 文档注释：\n    \n    /// 计算两数之和\n    fn sum(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n文档注释不仅能说明函数用途，还能通过 cargo doc --open 生成文档。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"04.Rust的控制流",frontmatter:{title:"04.Rust的控制流",date:"2025-08-19T11:00:00.000Z",permalink:"/pages/Rust_04/"},regularPath:"/06.Rust/04.Rust%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81.html",relativePath:"06.Rust/04.Rust的控制流.md",key:"v-425c0d28",path:"/pages/Rust_04/",headers:[{level:2,title:"一、if 表达式",slug:"一、if-表达式",normalizedTitle:"一、if 表达式",charIndex:115},{level:2,title:"二、loop 循环",slug:"二、loop-循环",normalizedTitle:"二、loop 循环",charIndex:442},{level:2,title:"三、while 循环",slug:"三、while-循环",normalizedTitle:"三、while 循环",charIndex:872},{level:2,title:"四、for 循环",slug:"四、for-循环",normalizedTitle:"四、for 循环",charIndex:1112}],headersStr:"一、if 表达式 二、loop 循环 三、while 循环 四、for 循环",content:'# Rust 的控制流\n\n控制流指的是程序根据条件和循环来决定执行路径。Rust 提供了清晰的条件分支和循环语句，让代码逻辑更容易表达。\n\n----------------------------------------\n\n\n# 一、if 表达式\n\nfn main() {\n    let n = 7;\n\n    if n < 5 {\n        println!("小于5");\n    } else if n == 5 {\n        println!("等于5");\n    } else {\n        println!("大于5");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * if 后跟布尔表达式。\n * 分支可以有多个，用 else if。\n * else 是可选的。\n\n在 Rust 中，if 是一个 表达式，所以可以直接赋值：\n\nlet x = if n > 0 { 1 } else { -1 };\n\n\n1\n\n\n\n# 二、loop 循环\n\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count += 1;\n        if count == 3 {\n            println!("跳出循环");\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * loop 会无限执行，除非遇到 break。\n * 使用 continue 可以跳过当前这次循环，直接进入下一轮。\n\n循环还可以返回值：\n\nlet result = loop {\n    count += 1;\n    if count == 10 {\n        break count * 2; // 返回 20\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、while 循环\n\nfn main() {\n    let mut n = 3;\n\n    while n > 0 {\n        println!("{n}");\n        n -= 1;\n    }\n    println!("起飞！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 在每轮循环前检查条件。\n * 条件为 false 时循环终止。\n\n----------------------------------------\n\n\n# 四、for 循环\n\nfn main() {\n    let arr = [10, 20, 30];\n\n    for val in arr {\n        println!("值: {val}");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * for 能遍历数组、切片或迭代器。\n * 更常见的写法是使用区间：\n\nfor i in 1..=5 {\n    println!("{i}");\n}\n\n\n1\n2\n3\n\n\n这里 1..=5 表示从 1 到 5（包含 5）。如果写作 1..5，则不包含 5。',normalizedContent:'# rust 的控制流\n\n控制流指的是程序根据条件和循环来决定执行路径。rust 提供了清晰的条件分支和循环语句，让代码逻辑更容易表达。\n\n----------------------------------------\n\n\n# 一、if 表达式\n\nfn main() {\n    let n = 7;\n\n    if n < 5 {\n        println!("小于5");\n    } else if n == 5 {\n        println!("等于5");\n    } else {\n        println!("大于5");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * if 后跟布尔表达式。\n * 分支可以有多个，用 else if。\n * else 是可选的。\n\n在 rust 中，if 是一个 表达式，所以可以直接赋值：\n\nlet x = if n > 0 { 1 } else { -1 };\n\n\n1\n\n\n\n# 二、loop 循环\n\nfn main() {\n    let mut count = 0;\n\n    loop {\n        count += 1;\n        if count == 3 {\n            println!("跳出循环");\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * loop 会无限执行，除非遇到 break。\n * 使用 continue 可以跳过当前这次循环，直接进入下一轮。\n\n循环还可以返回值：\n\nlet result = loop {\n    count += 1;\n    if count == 10 {\n        break count * 2; // 返回 20\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\n\n# 三、while 循环\n\nfn main() {\n    let mut n = 3;\n\n    while n > 0 {\n        println!("{n}");\n        n -= 1;\n    }\n    println!("起飞！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 在每轮循环前检查条件。\n * 条件为 false 时循环终止。\n\n----------------------------------------\n\n\n# 四、for 循环\n\nfn main() {\n    let arr = [10, 20, 30];\n\n    for val in arr {\n        println!("值: {val}");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * for 能遍历数组、切片或迭代器。\n * 更常见的写法是使用区间：\n\nfor i in 1..=5 {\n    println!("{i}");\n}\n\n\n1\n2\n3\n\n\n这里 1..=5 表示从 1 到 5（包含 5）。如果写作 1..5，则不包含 5。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"05.Rust的所有权概念",frontmatter:{title:"05.Rust的所有权概念",date:"2025-08-19T12:00:00.000Z",permalink:"/pages/Rust_05/"},regularPath:"/06.Rust/05.Rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%A6%82%E5%BF%B5.html",relativePath:"06.Rust/05.Rust的所有权概念.md",key:"v-c504442c",path:"/pages/Rust_05/",headers:[{level:2,title:"一、栈与堆的区别",slug:"一、栈与堆的区别",normalizedTitle:"一、栈与堆的区别",charIndex:148},{level:2,title:"二、所有权三原则",slug:"二、所有权三原则",normalizedTitle:"二、所有权三原则",charIndex:723},{level:2,title:"三、作用域与资源自动释放",slug:"三、作用域与资源自动释放",normalizedTitle:"三、作用域与资源自动释放",charIndex:889},{level:2,title:"四、String类型",slug:"四、string类型",normalizedTitle:"四、string类型",charIndex:1091}],headersStr:"一、栈与堆的区别 二、所有权三原则 三、作用域与资源自动释放 四、String类型",content:'# Rust 的所有权概念\n\nRust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 Rust 安全性与效率关键的一步。\n\n----------------------------------------\n\n\n# 一、栈与堆的区别\n\n要理解所有权机制，需要先理解 栈（stack）和堆（heap） 的内存管理方式。\n\n * 栈（Stack）\n   * 特点：存取速度快，后进先出（LIFO）。\n   * 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。\n   * 生命周期：作用域结束自动弹出，无需手动管理。\n * 堆（Heap）\n   * 特点：存取灵活，但分配和回收开销更大。\n   * 存放：大小未知或运行期才确定的数据，例如 String、Vec。\n   * 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 Rust 自动释放。\n\n对比示例：\n\nlet x = 10;                  // 存在栈上\nlet s = String::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据\n\n\n1\n2\n\n\n这里的关键点：\n\n * x 是整数，直接放在栈上，访问快，作用域结束就弹出。\n * s 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 "hi" 字符串内容在堆上，释放时 Rust 会自动清理堆内存。\n\n因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。\n\n----------------------------------------\n\n\n# 二、所有权三原则\n\nRust 的所有权机制围绕三条核心规则：\n\n 1. 每一个值都有一个“==所有者==”(owner)。\n 2. 在同一时间，值只有一个所有者。\n 3. 当所有者离开作用域，值会被丢弃或者说==自动释放==（drop）。\n\n----------------------------------------\n\n\n# 三、作用域与资源自动释放\n\n作用域决定变量何时“消失”，从而决定资源何时释放，例如：\n\n{\n    let s = "hello";\n    // s 在此作用域内有效\n}\n// 出了作用域，s 被 drop，内存自动释放\n\n\n1\n2\n3\n4\n5\n\n\n这一行为像是给变量包了自动回收机制，无需显式调用释放函数。\n\n----------------------------------------\n\n\n# 四、String类型\n\n我们可以通过如下的代码创建一个String。\n\nlet mut s = String::from("hello, world!");\n\n\n1\n\n\n通常情况下，计算机不允许一个在运行之前不知道值或者在运行之后值会改变的变量被放到二进制文件之中，所以，我们使用==String==类型。\n\n对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：\n\n * 必须在运行时向内存分配器（memory allocator）请求内存。\n * 需要一个当我们处理完 String 时将内存返回给分配器的方法。\n\n前一个部分由程序员自己完成，而后面一个部分，Rust会自己动，就比如：\n\n{\n\tlet s = String::from("hello");\n\t// 这里s有效    \n}\n// 这里s就失效了，因为作用域已经结束\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# rust 的所有权概念\n\nrust 使用“所有权”来管理内存，而不是依赖垃圾回收。这套规则由编译器在编译阶段严格检查，并不会影响运行时性能。正确掌握所有权，是掌握 rust 安全性与效率关键的一步。\n\n----------------------------------------\n\n\n# 一、栈与堆的区别\n\n要理解所有权机制，需要先理解 栈（stack）和堆（heap） 的内存管理方式。\n\n * 栈（stack）\n   * 特点：存取速度快，后进先出（lifo）。\n   * 存放：已知大小、固定长度的数据，例如整型、浮点型、布尔值等。\n   * 生命周期：作用域结束自动弹出，无需手动管理。\n * 堆（heap）\n   * 特点：存取灵活，但分配和回收开销更大。\n   * 存放：大小未知或运行期才确定的数据，例如 string、vec。\n   * 生命周期：必须由某个变量持有指针，当所有者离开作用域时，由 rust 自动释放。\n\n对比示例：\n\nlet x = 10;                  // 存在栈上\nlet s = string::from("hi");  // s 本身在栈上，但它指向堆中的字符串数据\n\n\n1\n2\n\n\n这里的关键点：\n\n * x 是整数，直接放在栈上，访问快，作用域结束就弹出。\n * s 是一个三部分组成的结构（指针、长度、容量），它在栈上，但实际的 "hi" 字符串内容在堆上，释放时 rust 会自动清理堆内存。\n\n因此，所有权规则的设计，本质上是为了安全管理堆数据，防止重复释放或悬空指针。\n\n----------------------------------------\n\n\n# 二、所有权三原则\n\nrust 的所有权机制围绕三条核心规则：\n\n 1. 每一个值都有一个“==所有者==”(owner)。\n 2. 在同一时间，值只有一个所有者。\n 3. 当所有者离开作用域，值会被丢弃或者说==自动释放==（drop）。\n\n----------------------------------------\n\n\n# 三、作用域与资源自动释放\n\n作用域决定变量何时“消失”，从而决定资源何时释放，例如：\n\n{\n    let s = "hello";\n    // s 在此作用域内有效\n}\n// 出了作用域，s 被 drop，内存自动释放\n\n\n1\n2\n3\n4\n5\n\n\n这一行为像是给变量包了自动回收机制，无需显式调用释放函数。\n\n----------------------------------------\n\n\n# 四、string类型\n\n我们可以通过如下的代码创建一个string。\n\nlet mut s = string::from("hello, world!");\n\n\n1\n\n\n通常情况下，计算机不允许一个在运行之前不知道值或者在运行之后值会改变的变量被放到二进制文件之中，所以，我们使用==string==类型。\n\n对于 string 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：\n\n * 必须在运行时向内存分配器（memory allocator）请求内存。\n * 需要一个当我们处理完 string 时将内存返回给分配器的方法。\n\n前一个部分由程序员自己完成，而后面一个部分，rust会自己动，就比如：\n\n{\n\tlet s = string::from("hello");\n\t// 这里s有效    \n}\n// 这里s就失效了，因为作用域已经结束\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"06.Rust的引用和借用",frontmatter:{title:"06.Rust的引用和借用",date:"2025-08-20T21:00:00.000Z",permalink:"/pages/Rust_06/"},regularPath:"/06.Rust/06.Rust%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8.html",relativePath:"06.Rust/06.Rust的引用和借用.md",key:"v-6a90bec1",path:"/pages/Rust_06/",headers:[{level:2,title:"一、引用和借用的基本阐述",slug:"一、引用和借用的基本阐述",normalizedTitle:"一、引用和借用的基本阐述",charIndex:18},{level:2,title:"二、可变引用",slug:"二、可变引用",normalizedTitle:"二、可变引用",charIndex:650},{level:2,title:"三、悬垂引用（Dangling References）",slug:"三、悬垂引用-dangling-references",normalizedTitle:"三、悬垂引用（dangling references）",charIndex:1404}],headersStr:"一、引用和借用的基本阐述 二、可变引用 三、悬垂引用（Dangling References）",content:'# Rust 的引用和借用\n\n\n# 一、引用和借用的基本阐述\n\n引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。\n\n定义并使用一个calculate_length` 函数，它以一个对象的引用作为参数而不是获取值的所有权：\n\nfn main() {\n    let s1 = String::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("The length of \'{s1}\' is {len}.");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面的代码中， & 符号就是 引用，它们允许你使用值但不获取其所有权。\n\n&s1 语法让我们创建一个指向值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。\n\n----------------------------------------\n\n我们将创建一个引用的行为称为 借用（borrowing），正如在日常生活中，我们借别人一样东西，迟早是要还的，因为我们没有那件物品的所有权。\n\n同时需要注意，我们不能去修改借用的变量，那样不合法，也不道德。\n\n\n# 二、可变引用\n\n我们可以通过添加 mut 关键字的方式来让引用变得“可变”，修改一下代码：\n\nfn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样就可以实现可变了！\n\n----------------------------------------\n\n不过，可变引用有一个很大的缺点，就是同一时间不能存在多个可变引用，或者不能存在可变引用和引用同时存在的情况。\n\n这里，先阐述一下，引用的规则：\n\n * 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。\n * 引用必须总是有效的。\n\n正如此，下面的两种情况不合法：\n\n    let mut s = String::from("hello");\n\n    let r1 = &mut s;\t// 两次可变引用，答煤油！\n    let r2 = &mut s;\n\n    println!("{}, {}", r1, r2);\n\n\n1\n2\n3\n4\n5\n6\n\n\n let mut s = String::from("hello");\n\n    let r1 = &s; // 没问题\t\t\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题，鱼与熊掌不可兼得\n\n    println!("{}, {}, and {}", r1, r2, r3);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、悬垂引用（Dangling References）\n\n在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针（dangling pointer）—— 指向可能已被分配给其他用途的内存位置的指针。\n\n相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n\n简而言之，就是不能返回一个孤寡老人，下面的代码可以帮助理解：\n\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from("hello");\n\n    &s\t// s的生命周期结束，但是这个函数返回了s的指针？ 显然，十分有十一分的不合法！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# rust 的引用和借用\n\n\n# 一、引用和借用的基本阐述\n\n引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。\n\n定义并使用一个calculate_length` 函数，它以一个对象的引用作为参数而不是获取值的所有权：\n\nfn main() {\n    let s1 = string::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("the length of \'{s1}\' is {len}.");\n}\n\nfn calculate_length(s: &string) -> usize {\n    s.len()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面的代码中， & 符号就是 引用，它们允许你使用值但不获取其所有权。\n\n&s1 语法让我们创建一个指向值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。\n\n----------------------------------------\n\n我们将创建一个引用的行为称为 借用（borrowing），正如在日常生活中，我们借别人一样东西，迟早是要还的，因为我们没有那件物品的所有权。\n\n同时需要注意，我们不能去修改借用的变量，那样不合法，也不道德。\n\n\n# 二、可变引用\n\n我们可以通过添加 mut 关键字的方式来让引用变得“可变”，修改一下代码：\n\nfn main() {\n    let mut s = string::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut string) {\n    some_string.push_str(", world");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样就可以实现可变了！\n\n----------------------------------------\n\n不过，可变引用有一个很大的缺点，就是同一时间不能存在多个可变引用，或者不能存在可变引用和引用同时存在的情况。\n\n这里，先阐述一下，引用的规则：\n\n * 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。\n * 引用必须总是有效的。\n\n正如此，下面的两种情况不合法：\n\n    let mut s = string::from("hello");\n\n    let r1 = &mut s;\t// 两次可变引用，答煤油！\n    let r2 = &mut s;\n\n    println!("{}, {}", r1, r2);\n\n\n1\n2\n3\n4\n5\n6\n\n\n let mut s = string::from("hello");\n\n    let r1 = &s; // 没问题\t\t\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题，鱼与熊掌不可兼得\n\n    println!("{}, {}, and {}", r1, r2, r3);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、悬垂引用（dangling references）\n\n在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂指针（dangling pointer）—— 指向可能已被分配给其他用途的内存位置的指针。\n\n相比之下，在 rust 中编译器确保引用永远也不会变成悬垂引用：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。\n\n简而言之，就是不能返回一个孤寡老人，下面的代码可以帮助理解：\n\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &string {\n    let s = string::from("hello");\n\n    &s\t// s的生命周期结束，但是这个函数返回了s的指针？ 显然，十分有十一分的不合法！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"07.Rust的切片（Slice）",frontmatter:{title:"07.Rust的切片（Slice）",date:"2025-08-21T10:00:00.000Z",permalink:"/pages/Rust_07/"},regularPath:"/06.Rust/07.Rust%E7%9A%84Slice%E7%B1%BB%E5%9E%8B.html",relativePath:"06.Rust/07.Rust的Slice类型.md",key:"v-40333d11",path:"/pages/Rust_07/",headers:[{level:2,title:"一、切片是什么？",slug:"一、切片是什么",normalizedTitle:"一、切片是什么？",charIndex:22},{level:2,title:"二、切片的简写方式",slug:"二、切片的简写方式",normalizedTitle:"二、切片的简写方式",charIndex:497},{level:2,title:"三、切片和字符串字面值",slug:"三、切片和字符串字面值",normalizedTitle:"三、切片和字符串字面值",charIndex:867},{level:2,title:"四、切片的威力：first_word 函数",slug:"四、切片的威力-first-word-函数",normalizedTitle:"四、切片的威力：first_word 函数",charIndex:1215},{level:2,title:"五、小心使用切片",slug:"五、小心使用切片",normalizedTitle:"五、小心使用切片",charIndex:1834}],headersStr:"一、切片是什么？ 二、切片的简写方式 三、切片和字符串字面值 四、切片的威力：first_word 函数 五、小心使用切片",content:'# Rust 的切片（Slice）\n\n\n# 一、切片是什么？\n\n切片（Slice）可以理解为：对集合中某一部分连续元素的引用。\n比如你有一个大西瓜 🍉，切片就是“我只想要中间那几块”。你不会把整个西瓜搬走，而只是指明：“从第几刀到第几刀之间的那块，给我留着”。\n\n在 Rust 中，切片往往出现在字符串或者数组这种顺序存储的数据结构里。\n\n一个例子：\n\nfn main() {\n    let s = String::from("hello world");\n\n    let hello = &s[0..5];   // 从索引0到5（不包含5）\n    let world = &s[6..11];  // 从索引6到11（不包含11）\n\n    println!("{}, {}", hello, world);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 &s[0..5] 和 &s[6..11] 就是切片。 注意，切片不是拷贝数据，而是“借”了一部分区域的引用，经济又实惠。\n\n----------------------------------------\n\n\n# 二、切片的简写方式\n\n切片的语法其实很直观：[起始..结束]，但是 Rust 很贴心，提供了多种写法：\n\nlet s = String::from("hello");\n\n// 从头到 2\nlet slice1 = &s[..2];\n\n// 从 3 到结尾\nlet slice2 = &s[3..];\n\n// 整个字符串\nlet slice3 = &s[..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就好比点菜时：\n\n * [..2] = “我要从头上切两片”；\n * [3..] = “我要从第三片开始到最后”；\n * [..] = “整个大盘子我都要”。\n\n是不是瞬间有画面感了？(回答：有的，兄弟，有的，这样的画面还有八个！)\n\n----------------------------------------\n\n\n# 三、切片和字符串字面值\n\n在 Rust 里，字符串字面值（比如 "hello world"）其实就是一个切片。 这也是为什么你看到它的类型是 &str，而不是 String。\n\nString 是堆上分配的可变字符串，而 &str 更轻量，本质上是对某段 UTF-8 数据的切片。\n\nfn main() {\n    let s: &str = "hello world";  // s 是一个切片\n    println!("{}", s);\n}\n\n\n1\n2\n3\n4\n\n\n这就好比：\n\n * String = 买下一整个蛋糕 🎂，想怎么切怎么切；\n * &str = 已经切好的蛋糕片 🍰，你直接吃。\n\n----------------------------------------\n\n\n# 四、切片的威力：first_word 函数\n\n假设我们要写一个函数，返回一句话中的第一个单词。 如果不用切片，可能会陷入各种复制粘贴麻烦。 但切片就很优雅：\n\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let s = String::from("hello world");\n\n    let word = first_word(&s);\n\n    println!("第一个单词是: {}", word);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n思路很简单：\n\n * 把字符串转成字节数组 as_bytes()；\n * 一边遍历，一边找空格的位置；\n * 找到后，直接返回从头到空格之前的那一片切片。\n\n结果就是：hello。 这里切片帮我们避免了数据的拷贝，直接“划块即用”。\n\n----------------------------------------\n\n\n# 五、小心使用切片\n\n切片很好用，但要记住一点：切片只是借用，不拥有数据。 所以：\n\n * 切片的生命周期不能超过原始数据；\n * 切片和原始数据之间要保持一致，不然会出大问题。\n\n换句话说，你不能一边切着吃蛋糕，一边把蛋糕扔了，这样切片就没东西指向了。',normalizedContent:'# rust 的切片（slice）\n\n\n# 一、切片是什么？\n\n切片（slice）可以理解为：对集合中某一部分连续元素的引用。\n比如你有一个大西瓜 🍉，切片就是“我只想要中间那几块”。你不会把整个西瓜搬走，而只是指明：“从第几刀到第几刀之间的那块，给我留着”。\n\n在 rust 中，切片往往出现在字符串或者数组这种顺序存储的数据结构里。\n\n一个例子：\n\nfn main() {\n    let s = string::from("hello world");\n\n    let hello = &s[0..5];   // 从索引0到5（不包含5）\n    let world = &s[6..11];  // 从索引6到11（不包含11）\n\n    println!("{}, {}", hello, world);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的 &s[0..5] 和 &s[6..11] 就是切片。 注意，切片不是拷贝数据，而是“借”了一部分区域的引用，经济又实惠。\n\n----------------------------------------\n\n\n# 二、切片的简写方式\n\n切片的语法其实很直观：[起始..结束]，但是 rust 很贴心，提供了多种写法：\n\nlet s = string::from("hello");\n\n// 从头到 2\nlet slice1 = &s[..2];\n\n// 从 3 到结尾\nlet slice2 = &s[3..];\n\n// 整个字符串\nlet slice3 = &s[..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就好比点菜时：\n\n * [..2] = “我要从头上切两片”；\n * [3..] = “我要从第三片开始到最后”；\n * [..] = “整个大盘子我都要”。\n\n是不是瞬间有画面感了？(回答：有的，兄弟，有的，这样的画面还有八个！)\n\n----------------------------------------\n\n\n# 三、切片和字符串字面值\n\n在 rust 里，字符串字面值（比如 "hello world"）其实就是一个切片。 这也是为什么你看到它的类型是 &str，而不是 string。\n\nstring 是堆上分配的可变字符串，而 &str 更轻量，本质上是对某段 utf-8 数据的切片。\n\nfn main() {\n    let s: &str = "hello world";  // s 是一个切片\n    println!("{}", s);\n}\n\n\n1\n2\n3\n4\n\n\n这就好比：\n\n * string = 买下一整个蛋糕 🎂，想怎么切怎么切；\n * &str = 已经切好的蛋糕片 🍰，你直接吃。\n\n----------------------------------------\n\n\n# 四、切片的威力：first_word 函数\n\n假设我们要写一个函数，返回一句话中的第一个单词。 如果不用切片，可能会陷入各种复制粘贴麻烦。 但切片就很优雅：\n\nfn first_word(s: &string) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let s = string::from("hello world");\n\n    let word = first_word(&s);\n\n    println!("第一个单词是: {}", word);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n思路很简单：\n\n * 把字符串转成字节数组 as_bytes()；\n * 一边遍历，一边找空格的位置；\n * 找到后，直接返回从头到空格之前的那一片切片。\n\n结果就是：hello。 这里切片帮我们避免了数据的拷贝，直接“划块即用”。\n\n----------------------------------------\n\n\n# 五、小心使用切片\n\n切片很好用，但要记住一点：切片只是借用，不拥有数据。 所以：\n\n * 切片的生命周期不能超过原始数据；\n * 切片和原始数据之间要保持一致，不然会出大问题。\n\n换句话说，你不能一边切着吃蛋糕，一边把蛋糕扔了，这样切片就没东西指向了。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"08.Rust的结构体类型",frontmatter:{title:"08.Rust的结构体类型",date:"2025-08-22T15:00:00.000Z",permalink:"/pages/Rust_08/"},regularPath:"/06.Rust/08.Rust%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.html",relativePath:"06.Rust/08.Rust的结构体类型.md",key:"v-5a59dc7c",path:"/pages/Rust_08/",headers:[{level:2,title:"一、为什么要用结构体（Struct）",slug:"一、为什么要用结构体-struct",normalizedTitle:"一、为什么要用结构体（struct）",charIndex:157},{level:2,title:"二、如何定义与使用结构体",slug:"二、如何定义与使用结构体",normalizedTitle:"二、如何定义与使用结构体",charIndex:462},{level:3,title:"定义结构体",slug:"定义结构体",normalizedTitle:"定义结构体",charIndex:479},{level:3,title:"实例化结构体",slug:"实例化结构体",normalizedTitle:"实例化结构体",charIndex:624},{level:3,title:"修改字段",slug:"修改字段",normalizedTitle:"修改字段",charIndex:862},{level:2,title:"三、还有其他结构体变体？元组 struct、单元 struct",slug:"三、还有其他结构体变体-元组-struct、单元-struct",normalizedTitle:"三、还有其他结构体变体？元组 struct、单元 struct",charIndex:1018},{level:3,title:"元组结构体（Tuple Struct）",slug:"元组结构体-tuple-struct",normalizedTitle:"元组结构体（tuple struct）",charIndex:1072},{level:3,title:"单元结构体（Unit-like Struct）",slug:"单元结构体-unit-like-struct",normalizedTitle:"单元结构体（unit-like struct）",charIndex:1296},{level:2,title:"四、结构体在真实代码里的样子：计算矩形面积",slug:"四、结构体在真实代码里的样子-计算矩形面积",normalizedTitle:"四、结构体在真实代码里的样子：计算矩形面积",charIndex:1479},{level:2,title:"五、结构体进阶操作：复用已有实例",slug:"五、结构体进阶操作-复用已有实例",normalizedTitle:"五、结构体进阶操作：复用已有实例",charIndex:1878}],headersStr:"一、为什么要用结构体（Struct） 二、如何定义与使用结构体 定义结构体 实例化结构体 修改字段 三、还有其他结构体变体？元组 struct、单元 struct 元组结构体（Tuple Struct） 单元结构体（Unit-like Struct） 四、结构体在真实代码里的样子：计算矩形面积 五、结构体进阶操作：复用已有实例",content:'# Rust 的结构体类型：给数据贴标签让它长得像人样\n\nRust 里的结构体（struct）是你拿来把数据组织得更有意义的工具。它的作用就像给一堆数据贴上名字标签，当你再用的时候，根本不用记顺序，只要看名字就知道搞啥。\n\n----------------------------------------\n\n\n# 一、为什么要用结构体（Struct）\n\n结构体比元组更“友好”，因为你可以给每个字段起名字，不再靠位置记是什么。比如我们有一个代表用户信息的数据组：\n\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样以后你访问字段就很清楚：\n\nlet u = User { ... };\nprintln!("{}", u.email);  // 一看就知道在搞邮箱\n\n\n1\n2\n\n\n结构体就是为了让数据“有脸有名”——比元组靠谱。\n\n\n# 二、如何定义与使用结构体\n\n\n# 定义结构体\n\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n你定义的是一个模板，跟工厂图纸一样。\n\n\n# 实例化结构体\n\nlet mut user1 = User {\n    email: String::from("a@ex.com"),\n    username: String::from("alice"),\n    active: true,\n    sign_in_count: 1,\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：\n\n * 字段顺序可随意（不像元组必须按定义顺序填）\n * 要想改字段必须让整个实例是 mut（Rust 不允许只给字段加 mut）\n\n\n# 修改字段\n\nuser1.email = String::from("alice@new.com");\n\n\n1\n\n\n整个实例可变才行。\n\n— 来源参考：“定义结构体”与“实例化结构体”、修改字段 都是 Rust 基础操作\n\n----------------------------------------\n\n\n# 三、还有其他结构体变体？元组 struct、单元 struct\n\nRust 还支持其他几种结构体：\n\n\n# 元组结构体（Tuple Struct）\n\n像元组但有类型名，适合只想“命名类型”而不想写字段名的情况：\n\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\n\n1\n2\n3\n4\n5\n\n\n尽管字段类型一样，但 Color 和 Point 是不同类型，互不兼容。\n\n\n# 单元结构体（Unit-like Struct）\n\n啥都没有，就是个名字，常用于特殊场景（比如作为 trait 的实现标记）：\n\nstruct AlwaysEqual;\n\nlet x = AlwaysEqual;\n\n\n1\n2\n3\n\n\n给个名字空壳体，有啥用呢？以后你会用到。\n\n----------------------------------------\n\n\n# 四、结构体在真实代码里的样子：计算矩形面积\n\n假设你要计算矩形面积，用结构体比多个变量更清晰：\n\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn area(rect: &Rectangle) -> u32 {\n    rect.width * rect.height\n}\n\nfn main() {\n    let rect = Rectangle { width: 30, height: 50 };\n    println!("面积是 {} 像素²", area(&rect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n让人看代码时瞬间明白：这是一个矩形，有宽有高，用 area 函数算面积。太直观。\n\n----------------------------------------\n\n\n# 五、结构体进阶操作：复用已有实例\n\n如果你想在新实例里复用老实例的大部分字段，可以写：\n\nlet user2 = User {\n    email: String::from("new@ex.com"),\n    ..user1\n};\n\n\n1\n2\n3\n4\n\n\n这会把 user1 里除了 email 之外的字段直接搬过来。但要注意，不会 Copy 的字段会被 move， user1 中那些被 move 掉的字段就不能再用。',normalizedContent:'# rust 的结构体类型：给数据贴标签让它长得像人样\n\nrust 里的结构体（struct）是你拿来把数据组织得更有意义的工具。它的作用就像给一堆数据贴上名字标签，当你再用的时候，根本不用记顺序，只要看名字就知道搞啥。\n\n----------------------------------------\n\n\n# 一、为什么要用结构体（struct）\n\n结构体比元组更“友好”，因为你可以给每个字段起名字，不再靠位置记是什么。比如我们有一个代表用户信息的数据组：\n\nstruct user {\n    active: bool,\n    username: string,\n    email: string,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样以后你访问字段就很清楚：\n\nlet u = user { ... };\nprintln!("{}", u.email);  // 一看就知道在搞邮箱\n\n\n1\n2\n\n\n结构体就是为了让数据“有脸有名”——比元组靠谱。\n\n\n# 二、如何定义与使用结构体\n\n\n# 定义结构体\n\nstruct user {\n    active: bool,\n    username: string,\n    email: string,\n    sign_in_count: u64,\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n你定义的是一个模板，跟工厂图纸一样。\n\n\n# 实例化结构体\n\nlet mut user1 = user {\n    email: string::from("a@ex.com"),\n    username: string::from("alice"),\n    active: true,\n    sign_in_count: 1,\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：\n\n * 字段顺序可随意（不像元组必须按定义顺序填）\n * 要想改字段必须让整个实例是 mut（rust 不允许只给字段加 mut）\n\n\n# 修改字段\n\nuser1.email = string::from("alice@new.com");\n\n\n1\n\n\n整个实例可变才行。\n\n— 来源参考：“定义结构体”与“实例化结构体”、修改字段 都是 rust 基础操作\n\n----------------------------------------\n\n\n# 三、还有其他结构体变体？元组 struct、单元 struct\n\nrust 还支持其他几种结构体：\n\n\n# 元组结构体（tuple struct）\n\n像元组但有类型名，适合只想“命名类型”而不想写字段名的情况：\n\nstruct color(i32, i32, i32);\nstruct point(i32, i32, i32);\n\nlet black = color(0, 0, 0);\nlet origin = point(0, 0, 0);\n\n\n1\n2\n3\n4\n5\n\n\n尽管字段类型一样，但 color 和 point 是不同类型，互不兼容。\n\n\n# 单元结构体（unit-like struct）\n\n啥都没有，就是个名字，常用于特殊场景（比如作为 trait 的实现标记）：\n\nstruct alwaysequal;\n\nlet x = alwaysequal;\n\n\n1\n2\n3\n\n\n给个名字空壳体，有啥用呢？以后你会用到。\n\n----------------------------------------\n\n\n# 四、结构体在真实代码里的样子：计算矩形面积\n\n假设你要计算矩形面积，用结构体比多个变量更清晰：\n\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn area(rect: &rectangle) -> u32 {\n    rect.width * rect.height\n}\n\nfn main() {\n    let rect = rectangle { width: 30, height: 50 };\n    println!("面积是 {} 像素²", area(&rect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n让人看代码时瞬间明白：这是一个矩形，有宽有高，用 area 函数算面积。太直观。\n\n----------------------------------------\n\n\n# 五、结构体进阶操作：复用已有实例\n\n如果你想在新实例里复用老实例的大部分字段，可以写：\n\nlet user2 = user {\n    email: string::from("new@ex.com"),\n    ..user1\n};\n\n\n1\n2\n3\n4\n\n\n这会把 user1 里除了 email 之外的字段直接搬过来。但要注意，不会 copy 的字段会被 move， user1 中那些被 move 掉的字段就不能再用。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"10.Rust的方法",frontmatter:{title:"10.Rust的方法",date:"2025-08-23T11:00:00.000Z",permalink:"/pages/Rust_10/"},regularPath:"/06.Rust/10.Rust%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"06.Rust/10.Rust的方法.md",key:"v-19267156",path:"/pages/Rust_10/",headers:[{level:2,title:"一、方法是什么？",slug:"一、方法是什么",normalizedTitle:"一、方法是什么？",charIndex:141},{level:2,title:"二、示例场景：点灯的 LED",slug:"二、示例场景-点灯的-led",normalizedTitle:"二、示例场景：点灯的 led",charIndex:492},{level:2,title:"三、方法与函数区别？",slug:"三、方法与函数区别",normalizedTitle:"三、方法与函数区别？",charIndex:1278},{level:2,title:"四、方法签名细节",slug:"四、方法签名细节",normalizedTitle:"四、方法签名细节",charIndex:1467},{level:2,title:"五、关联函数（Associated Functions）：看起来像静态方法",slug:"五、关联函数-associated-functions-看起来像静态方法",normalizedTitle:"五、关联函数（associated functions）：看起来像静态方法",charIndex:1796}],headersStr:"一、方法是什么？ 二、示例场景：点灯的 LED 三、方法与函数区别？ 四、方法签名细节 五、关联函数（Associated Functions）：看起来像静态方法",content:'# Rust 的方法：让结构体会“做事”\n\nRust 的方法（methods）就像给结构体装上“功夫技能包”。我们把这些技能写在 impl 块里，让实例自己能“点名调用”，逻辑清晰又好用。\n\n----------------------------------------\n\n\n# 一、方法是什么？\n\n * 方法看起来像函数，但定义在结构体（或枚举、trait）里。\n * 它们的第一个参数总是 self（能是值、引用或可变引用）。\n * 这样你可以通过 instance.my_method() 直接调用，就像让结构体自己做事。\n\n源码里是这么写的：定义在 impl 块里，方法签名像这样：\n\nimpl TypeName {\n    fn method_name(&self, other_arg: T) -> U { ... }\n}\n\n\n1\n2\n3\n\n\n调用方式是：\n\nmy_instance.method_name(arg);\n\n\n1\n\n\n这比每次传 my_instance 更省心。\n\n----------------------------------------\n\n\n# 二、示例场景：点灯的 LED\n\n假设我们有一个 Led 结构体，代表一盏 LED 灯：\n\nstruct Led { state: bool }\n\nimpl Led {\n    /// 打开 LED\n    fn turn_on(&mut self) {\n        self.state = true;\n        println!("LED is now ON");\n    }\n\n    /// 关闭 LED\n    fn turn_off(&mut self) {\n        self.state = false;\n        println!("LED is now OFF");\n    }\n\n    /// 检查 LED 是否处于开启状态\n    fn is_on(&self) -> bool {\n        self.state\n    }\n}\n\nfn main() {\n    let mut led = Led { state: false };\n    led.turn_on();\n    println!("LED 当前状态：{}", led.is_on());\n    led.turn_off();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里有几个要点：\n\n * turn_on 和 turn_off 使用 &mut self，因为它们改变了自己的状态。\n * is_on 用 &self，只是读取，不动结构体内容。\n * 调用方式统一用 led.method()，语义贴近人类语言：“让 led 做某事”。\n\n----------------------------------------\n\n\n# 三、方法与函数区别？\n\n * 函数：通常写在外面，需要明确传参，比如 fn area(rect: &Rectangle) -> u32。\n * 方法：写在 impl 里，有 self 参数，调用更自然，组织也更清晰。\n\n这让代码逻辑像“面向对象”风格：先定义结构体，再赋能一系列方法。\n\n----------------------------------------\n\n\n# 四、方法签名细节\n\n方法有三种常见签名方式：\n\n 1. fn foo(&self) —— 不改变结构体，只读取内部内容。\n 2. fn foo(&mut self) —— 可改变结构体内部状态。\n 3. fn foo(self) —— 消费结构体本身（少见），常用于把自己转成别的类型。\n\n例如：\n\nimpl Led {\n    fn destroy(self) {\n        println!("LED destroyed, state was {}", self.state);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用后 led 就不能再用了。\n\n----------------------------------------\n\n\n# 五、关联函数（Associated Functions）：看起来像静态方法\n\n如果不加 self，它就不是方法，而是“结构体自己的函数”（常用于创建新实例）：\n\nimpl Led {\n    fn new_on() -> Self {\n        Led { state: true }\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n调用方式：\n\nlet led2 = Led::new_on();\n\n\n1\n\n\n像工厂函数，总在结构体里但不作用于实例。',normalizedContent:'# rust 的方法：让结构体会“做事”\n\nrust 的方法（methods）就像给结构体装上“功夫技能包”。我们把这些技能写在 impl 块里，让实例自己能“点名调用”，逻辑清晰又好用。\n\n----------------------------------------\n\n\n# 一、方法是什么？\n\n * 方法看起来像函数，但定义在结构体（或枚举、trait）里。\n * 它们的第一个参数总是 self（能是值、引用或可变引用）。\n * 这样你可以通过 instance.my_method() 直接调用，就像让结构体自己做事。\n\n源码里是这么写的：定义在 impl 块里，方法签名像这样：\n\nimpl typename {\n    fn method_name(&self, other_arg: t) -> u { ... }\n}\n\n\n1\n2\n3\n\n\n调用方式是：\n\nmy_instance.method_name(arg);\n\n\n1\n\n\n这比每次传 my_instance 更省心。\n\n----------------------------------------\n\n\n# 二、示例场景：点灯的 led\n\n假设我们有一个 led 结构体，代表一盏 led 灯：\n\nstruct led { state: bool }\n\nimpl led {\n    /// 打开 led\n    fn turn_on(&mut self) {\n        self.state = true;\n        println!("led is now on");\n    }\n\n    /// 关闭 led\n    fn turn_off(&mut self) {\n        self.state = false;\n        println!("led is now off");\n    }\n\n    /// 检查 led 是否处于开启状态\n    fn is_on(&self) -> bool {\n        self.state\n    }\n}\n\nfn main() {\n    let mut led = led { state: false };\n    led.turn_on();\n    println!("led 当前状态：{}", led.is_on());\n    led.turn_off();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里有几个要点：\n\n * turn_on 和 turn_off 使用 &mut self，因为它们改变了自己的状态。\n * is_on 用 &self，只是读取，不动结构体内容。\n * 调用方式统一用 led.method()，语义贴近人类语言：“让 led 做某事”。\n\n----------------------------------------\n\n\n# 三、方法与函数区别？\n\n * 函数：通常写在外面，需要明确传参，比如 fn area(rect: &rectangle) -> u32。\n * 方法：写在 impl 里，有 self 参数，调用更自然，组织也更清晰。\n\n这让代码逻辑像“面向对象”风格：先定义结构体，再赋能一系列方法。\n\n----------------------------------------\n\n\n# 四、方法签名细节\n\n方法有三种常见签名方式：\n\n 1. fn foo(&self) —— 不改变结构体，只读取内部内容。\n 2. fn foo(&mut self) —— 可改变结构体内部状态。\n 3. fn foo(self) —— 消费结构体本身（少见），常用于把自己转成别的类型。\n\n例如：\n\nimpl led {\n    fn destroy(self) {\n        println!("led destroyed, state was {}", self.state);\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用后 led 就不能再用了。\n\n----------------------------------------\n\n\n# 五、关联函数（associated functions）：看起来像静态方法\n\n如果不加 self，它就不是方法，而是“结构体自己的函数”（常用于创建新实例）：\n\nimpl led {\n    fn new_on() -> self {\n        led { state: true }\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n调用方式：\n\nlet led2 = led::new_on();\n\n\n1\n\n\n像工厂函数，总在结构体里但不作用于实例。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"09.Rust的结构体的打印与调试",frontmatter:{title:"09.Rust的结构体的打印与调试",date:"2025-08-22T20:00:00.000Z",permalink:"/pages/Rust_09/"},regularPath:"/06.Rust/09.Rust%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%89%93%E5%8D%B0%E4%B8%8E%E8%B0%83%E8%AF%95.html",relativePath:"06.Rust/09.Rust的结构体的打印与调试.md",key:"v-e45eb658",path:"/pages/Rust_09/",headers:[{level:2,title:"一、使用 {:?} 或 {:#?}",slug:"一、使用-或",normalizedTitle:"一、使用 {:?} 或 {:#?}",charIndex:506},{level:2,title:"二、[dbg! 宏]",slug:"二、-dbg-宏",normalizedTitle:"二、[dbg! 宏]",charIndex:695}],headersStr:"一、使用 {:?} 或 {:#?} 二、[dbg! 宏]",content:'# Rust的结构体的 println 该如何办？\n\n当我们写了如下代码，\n\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect = Rectangle {\n        width: 20,\n        height: 40,\n    };\n\n    println!("rect is {}", rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且尝试 cargo run时，编译器通常会抱怨：\n\nerror[E0277]: `Rectangle` doesn\'t implement `std::fmt::Display`\n\n\n1\n\n\n显然是不能这样玩的，因为编译器并不知道要用什么样的形式把它打印出来。就比如你去汉武大学的图书馆借书，你要是光跟管理员同志说一句借书，显然这位同志只会认为来的是一个糟糕的人。\n\n----------------------------------------\n\n同理，我们用 Debug 来优雅地打印出结构体。\n\n\n# 一、使用 {:?} 或 {:#?}\n\n首先，我们在程序开头添加：\n\n#[derive(Debug)]\n\n\n1\n\n\n然后，把 println! 宏改成类似于\n\nprintln!("rect1 is {rect:?}");\n\n\n1\n\n\n或者\n\nprintln!("rect1 is {rect1:#?}");\n\n\n1\n\n\n两种结果的输出是有点差异的，读者可以自己调试一哈。\n\n\n# 二、[dbg! 宏]\n\n没错，还是如下的代码：\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 4;\n    let rect = Rectangle {\n        width: dbg!(20 * scale),\n        height: 40,\n    };\n\n    dbg!(&rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样子，在cargo run之后，就会是如下的结果：\n\n[src/main.rs:10:16] 20 * scale = 80\n[src/main.rs:14:5] &rect1 = Rectangle {\n    width: 80,\n    height: 40,\n}\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# rust的结构体的 println 该如何办？\n\n当我们写了如下代码，\n\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect = rectangle {\n        width: 20,\n        height: 40,\n    };\n\n    println!("rect is {}", rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且尝试 cargo run时，编译器通常会抱怨：\n\nerror[e0277]: `rectangle` doesn\'t implement `std::fmt::display`\n\n\n1\n\n\n显然是不能这样玩的，因为编译器并不知道要用什么样的形式把它打印出来。就比如你去汉武大学的图书馆借书，你要是光跟管理员同志说一句借书，显然这位同志只会认为来的是一个糟糕的人。\n\n----------------------------------------\n\n同理，我们用 debug 来优雅地打印出结构体。\n\n\n# 一、使用 {:?} 或 {:#?}\n\n首先，我们在程序开头添加：\n\n#[derive(debug)]\n\n\n1\n\n\n然后，把 println! 宏改成类似于\n\nprintln!("rect1 is {rect:?}");\n\n\n1\n\n\n或者\n\nprintln!("rect1 is {rect1:#?}");\n\n\n1\n\n\n两种结果的输出是有点差异的，读者可以自己调试一哈。\n\n\n# 二、[dbg! 宏]\n\n没错，还是如下的代码：\n\n#[derive(debug)]\nstruct rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 4;\n    let rect = rectangle {\n        width: dbg!(20 * scale),\n        height: 40,\n    };\n\n    dbg!(&rect);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样子，在cargo run之后，就会是如下的结果：\n\n[src/main.rs:10:16] 20 * scale = 80\n[src/main.rs:14:5] &rect1 = rectangle {\n    width: 80,\n    height: 40,\n}\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"11.Rust的枚举",frontmatter:{title:"11.Rust的枚举",date:"2025-08-23T20:00:00.000Z",permalink:"/pages/Rust_11/"},regularPath:"/06.Rust/11.Rust%E7%9A%84%E6%9E%9A%E4%B8%BE.html",relativePath:"06.Rust/11.Rust的枚举.md",key:"v-7bcfc72d",path:"/pages/Rust_11/",headers:[{level:2,title:"一、枚举（Enum）是啥？",slug:"一、枚举-enum-是啥",normalizedTitle:"一、枚举（enum）是啥？",charIndex:173},{level:2,title:"二、枚举还能带点“行李”",slug:"二、枚举还能带点-行李",normalizedTitle:"二、枚举还能带点“行李”",charIndex:417},{level:2,title:"三、Rust 内置的明星枚举：Option",slug:"三、rust-内置的明星枚举-option",normalizedTitle:"三、rust 内置的明星枚举：option",charIndex:795},{level:2,title:"四、为什么 Option 比 null 更靠谱？",slug:"四、为什么-option-比-null-更靠谱",normalizedTitle:"四、为什么 option 比 null 更靠谱？",charIndex:1210}],headersStr:"一、枚举（Enum）是啥？ 二、枚举还能带点“行李” 三、Rust 内置的明星枚举：Option 四、为什么 Option 比 null 更靠谱？",content:'# Rust 的枚举（Enum）与 Option：给数据贴标签的艺术\n\n在编程世界里，有时候我们希望数据不只是个值，还要有个“身份”或“状态”。\nRust 里就有一种强力武器：枚举（Enum）。它能把有限的几种可能性收拢起来，编译器帮你保证不会出岔子。\n\n----------------------------------------\n\n\n# 一、枚举（Enum）是啥？\n\n枚举就是一类“只能在有限选项中挑一个”的数据类型。\n想象一下，你有个状态机：红灯、绿灯、黄灯。我们可以这样写：\n\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\n\n1\n2\n3\n4\n5\n\n\n当我们定义一个变量：\n\nlet light = TrafficLight::Red;\n\n\n1\n\n\n这就表示当前信号灯是“红色”。 优势是什么？——它不可能变成什么 "blue" 之类莫名其妙的状态。\n\n\n# 二、枚举还能带点“行李”\n\n枚举不仅能表示“是哪一类”，还可以顺便带上额外数据。 举个例子：我们做一个消息系统，有三种可能：\n\n * 空消息\n * 文本消息\n * 坐标消息\n\n在 Rust 里可以这么写：\n\nenum Message {\n    Empty,\n    Text(String),\n    Position(i32, i32),\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用的时候：\n\nlet m1 = Message::Empty;\nlet m2 = Message::Text(String::from("Hello!"));\nlet m3 = Message::Position(10, 20);\n\n\n1\n2\n3\n\n\n这样数据和分类合体，逻辑更清楚。\n\n----------------------------------------\n\n\n# 三、Rust 内置的明星枚举：Option\n\n在别的语言里，如果某个值“可能没有”，通常会用 null。 但是 Rust 没有 null，而是用 Option 来表达“有或没有”。\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n\n1\n2\n3\n4\n\n\n这就是 Rust 标准库里 Option 的定义。\n\n * Some(T)：表示里面有一个值 T；\n * None：表示啥也没有。\n\n用例子感受一下：\n\nlet some_number = Some(5);\nlet some_text = Some("Hello");\nlet no_value: Option<i32> = None;\n\n\n1\n2\n3\n\n\n这里的 some_number 就是“有值 5”，no_value 就是“啥都没有”。\n\n----------------------------------------\n\n\n# 四、为什么 Option 比 null 更靠谱？\n\n * 在 Rust 里，Option 是一个显式的类型，你在写代码时必须处理“有值”和“没值”的情况；\n * 它避免了像其他语言那样，一不小心解引用 null 就崩溃的尴尬。\n\n比如说： 你写了一个函数，它要么找到某个元素返回它，要么啥也找不到。 返回 Option<T> 就再合适不过。\n\nfn find_index(arr: &[i32], target: i32) -> Option<usize> {\n    for (i, &item) in arr.iter().enumerate() {\n        if item == target {\n            return Some(i);\n        }\n    }\n    None\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样调用：\n\nlet nums = vec![10, 20, 30];\nlet pos = find_index(&nums, 20);\n\n\n1\n2\n\n\n这里 pos 的类型是 Option<usize>，要么 Some(1)，要么 None。',normalizedContent:'# rust 的枚举（enum）与 option：给数据贴标签的艺术\n\n在编程世界里，有时候我们希望数据不只是个值，还要有个“身份”或“状态”。\nrust 里就有一种强力武器：枚举（enum）。它能把有限的几种可能性收拢起来，编译器帮你保证不会出岔子。\n\n----------------------------------------\n\n\n# 一、枚举（enum）是啥？\n\n枚举就是一类“只能在有限选项中挑一个”的数据类型。\n想象一下，你有个状态机：红灯、绿灯、黄灯。我们可以这样写：\n\nenum trafficlight {\n    red,\n    yellow,\n    green,\n}\n\n\n1\n2\n3\n4\n5\n\n\n当我们定义一个变量：\n\nlet light = trafficlight::red;\n\n\n1\n\n\n这就表示当前信号灯是“红色”。 优势是什么？——它不可能变成什么 "blue" 之类莫名其妙的状态。\n\n\n# 二、枚举还能带点“行李”\n\n枚举不仅能表示“是哪一类”，还可以顺便带上额外数据。 举个例子：我们做一个消息系统，有三种可能：\n\n * 空消息\n * 文本消息\n * 坐标消息\n\n在 rust 里可以这么写：\n\nenum message {\n    empty,\n    text(string),\n    position(i32, i32),\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用的时候：\n\nlet m1 = message::empty;\nlet m2 = message::text(string::from("hello!"));\nlet m3 = message::position(10, 20);\n\n\n1\n2\n3\n\n\n这样数据和分类合体，逻辑更清楚。\n\n----------------------------------------\n\n\n# 三、rust 内置的明星枚举：option\n\n在别的语言里，如果某个值“可能没有”，通常会用 null。 但是 rust 没有 null，而是用 option 来表达“有或没有”。\n\nenum option<t> {\n    some(t),\n    none,\n}\n\n\n1\n2\n3\n4\n\n\n这就是 rust 标准库里 option 的定义。\n\n * some(t)：表示里面有一个值 t；\n * none：表示啥也没有。\n\n用例子感受一下：\n\nlet some_number = some(5);\nlet some_text = some("hello");\nlet no_value: option<i32> = none;\n\n\n1\n2\n3\n\n\n这里的 some_number 就是“有值 5”，no_value 就是“啥都没有”。\n\n----------------------------------------\n\n\n# 四、为什么 option 比 null 更靠谱？\n\n * 在 rust 里，option 是一个显式的类型，你在写代码时必须处理“有值”和“没值”的情况；\n * 它避免了像其他语言那样，一不小心解引用 null 就崩溃的尴尬。\n\n比如说： 你写了一个函数，它要么找到某个元素返回它，要么啥也找不到。 返回 option<t> 就再合适不过。\n\nfn find_index(arr: &[i32], target: i32) -> option<usize> {\n    for (i, &item) in arr.iter().enumerate() {\n        if item == target {\n            return some(i);\n        }\n    }\n    none\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这样调用：\n\nlet nums = vec![10, 20, 30];\nlet pos = find_index(&nums, 20);\n\n\n1\n2\n\n\n这里 pos 的类型是 option<usize>，要么 some(1)，要么 none。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"12.Rust的match控制流结构",frontmatter:{title:"12.Rust的match控制流结构",date:"2025-08-24T06:00:00.000Z",permalink:"/pages/Rust_12/"},regularPath:"/06.Rust/12.Rust%E7%9A%84match%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84.html",relativePath:"06.Rust/12.Rust的match控制流结构.md",key:"v-7bd6065e",path:"/pages/Rust_12/",headers:[{level:2,title:"一、match 是什么",slug:"一、match-是什么",normalizedTitle:"一、match 是什么",charIndex:219},{level:2,title:"二、基础示例：枚举 + match",slug:"二、基础示例-枚举-match",normalizedTitle:"二、基础示例：枚举 + match",charIndex:399},{level:2,title:"三、多行分支写法",slug:"三、多行分支写法",normalizedTitle:"三、多行分支写法",charIndex:846},{level:2,title:"四、为什么 match 更靠谱？",slug:"四、为什么-match-更靠谱",normalizedTitle:"四、为什么 match 更靠谱？",charIndex:1309},{level:2,title:"五、换个例子：辨识数字范围",slug:"五、换个例子-辨识数字范围",normalizedTitle:"五、换个例子：辨识数字范围",charIndex:1488}],headersStr:"一、match 是什么 二、基础示例：枚举 + match 三、多行分支写法 四、为什么 match 更靠谱？ 五、换个例子：辨识数字范围",content:'# Rust 的 match 控制流结构：比 if/else 更“走心”的分支写法\n\n在 Rust 里，match 就像一台「值分类机」：它依次检查每个标签（模式），一旦“刚好合适”，就自动跳进对应处理逻辑里。比起 if/else，它更安全、更严谨，也让代码结构更清晰:contentReference[oaicite:0]{index=0}。\n\n----------------------------------------\n\n\n# 一、match 是什么\n\nmatch 可以拿任意类型（尤其是枚举）来做分支判断，不局限于布尔值。用 match 能让编译器帮你确保每一种情况都写到了，不会漏。\n\n形象比喻：想象你在自动分拣中心——每个分支是一个洞，值或数据“滑”过去，正好合适哪个洞，就进入哪个分支。\n\n----------------------------------------\n\n\n# 二、基础示例：枚举 + match\n\n假设你有一套“宠物”分类：\n\nenum Pet {\n    Cat,\n    Dog,\n    Rabbit,\n}\n\nfn describe(p: Pet) -> &\'static str {\n    match p {\n        Pet::Cat => "你抓到了一只喵喵～",\n        Pet::Dog => "汪汪！一只G狗！",\n        Pet::Rabbit => "蹦蹦的兔兔在这里~",\n    }\n}\n\nfn main() {\n    let p = Pet::Rabbit;\n    println!("{}", describe(p));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match p 把 p 的状态拿来对比标签；\n * 每个 => 后是该分支的处理结果；\n * 你必须写全 Cat、Dog、Rabbit 三种，否则编译不通过。\n\n\n# 三、多行分支写法\n\n有时候分支逻辑不止一个动作，比如还要打印日志：\n\nfn count_pet(p: Pet) -> u32 {\n    match p {\n        Pet::Cat => {\n            println!("统计：捕获了一只猫咪");\n            4\n        }\n        Pet::Dog => {\n            println!("统计：捕获了一只狗狗");\n            3\n        }\n        Pet::Rabbit => {\n            println!("统计：兔兔跑得快");\n            2\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 分支代码块里可以写一堆逻辑；\n * 最后一行是被 return 的“值”。\n\n----------------------------------------\n\n\n# 四、为什么 match 更靠谱？\n\n * 必须覆盖所有可能值（穷尽检查），少了一个分支直接编译报错。\n * 结构清晰，各个分支整齐排列，读着更舒服。\n * 灵活表达，以后你会看到它能和复杂模式结合使用——简直是流程控制的王牌工具doc.rust-lang.org。\n\n----------------------------------------\n\n\n# 五、换个例子：辨识数字范围\n\n假如你写个函数，根据数字区间给出评价：\n\nfn rate(num: i32) -> &\'static str {\n    match num {\n        0 => "零，不动弹",\n        1..=5 => "小于等于五",\n        6..=10 => "介于六和十之间",\n        _ => "大于十",\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 1..=5 表示从 1 到 5（包含 5）；\n * _ 是“通配符”，匹配所有剩下的数。\n\n这也体现了 match 的强大：区间、默认值一并搞定，写起来简洁又醒目。',normalizedContent:'# rust 的 match 控制流结构：比 if/else 更“走心”的分支写法\n\n在 rust 里，match 就像一台「值分类机」：它依次检查每个标签（模式），一旦“刚好合适”，就自动跳进对应处理逻辑里。比起 if/else，它更安全、更严谨，也让代码结构更清晰:contentreference[oaicite:0]{index=0}。\n\n----------------------------------------\n\n\n# 一、match 是什么\n\nmatch 可以拿任意类型（尤其是枚举）来做分支判断，不局限于布尔值。用 match 能让编译器帮你确保每一种情况都写到了，不会漏。\n\n形象比喻：想象你在自动分拣中心——每个分支是一个洞，值或数据“滑”过去，正好合适哪个洞，就进入哪个分支。\n\n----------------------------------------\n\n\n# 二、基础示例：枚举 + match\n\n假设你有一套“宠物”分类：\n\nenum pet {\n    cat,\n    dog,\n    rabbit,\n}\n\nfn describe(p: pet) -> &\'static str {\n    match p {\n        pet::cat => "你抓到了一只喵喵～",\n        pet::dog => "汪汪！一只g狗！",\n        pet::rabbit => "蹦蹦的兔兔在这里~",\n    }\n}\n\nfn main() {\n    let p = pet::rabbit;\n    println!("{}", describe(p));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match p 把 p 的状态拿来对比标签；\n * 每个 => 后是该分支的处理结果；\n * 你必须写全 cat、dog、rabbit 三种，否则编译不通过。\n\n\n# 三、多行分支写法\n\n有时候分支逻辑不止一个动作，比如还要打印日志：\n\nfn count_pet(p: pet) -> u32 {\n    match p {\n        pet::cat => {\n            println!("统计：捕获了一只猫咪");\n            4\n        }\n        pet::dog => {\n            println!("统计：捕获了一只狗狗");\n            3\n        }\n        pet::rabbit => {\n            println!("统计：兔兔跑得快");\n            2\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 分支代码块里可以写一堆逻辑；\n * 最后一行是被 return 的“值”。\n\n----------------------------------------\n\n\n# 四、为什么 match 更靠谱？\n\n * 必须覆盖所有可能值（穷尽检查），少了一个分支直接编译报错。\n * 结构清晰，各个分支整齐排列，读着更舒服。\n * 灵活表达，以后你会看到它能和复杂模式结合使用——简直是流程控制的王牌工具doc.rust-lang.org。\n\n----------------------------------------\n\n\n# 五、换个例子：辨识数字范围\n\n假如你写个函数，根据数字区间给出评价：\n\nfn rate(num: i32) -> &\'static str {\n    match num {\n        0 => "零，不动弹",\n        1..=5 => "小于等于五",\n        6..=10 => "介于六和十之间",\n        _ => "大于十",\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 1..=5 表示从 1 到 5（包含 5）；\n * _ 是“通配符”，匹配所有剩下的数。\n\n这也体现了 match 的强大：区间、默认值一并搞定，写起来简洁又醒目。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"13.Rust 的语法糖 - if let",frontmatter:{title:"13.Rust 的语法糖 - if let",date:"2025-08-25T21:00:00.000Z",permalink:"/pages/Rust_13/"},regularPath:"/06.Rust/13.Rust%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96-iflet.html",relativePath:"06.Rust/13.Rust的语法糖-iflet.md",key:"v-2f12763c",path:"/pages/Rust_13/",headers:[{level:2,title:"一、if let 是个啥？",slug:"一、if-let-是个啥",normalizedTitle:"一、if let 是个啥？",charIndex:25},{level:2,title:"二、举个例子：盒子开宝藏",slug:"二、举个例子-盒子开宝藏",normalizedTitle:"二、举个例子：盒子开宝藏",charIndex:204},{level:2,title:"三、Option 与 if let",slug:"三、option-与-if-let",normalizedTitle:"三、option 与 if let",charIndex:673},{level:2,title:"四、还能配合 else",slug:"四、还能配合-else",normalizedTitle:"四、还能配合 else",charIndex:990},{level:2,title:"五、什么时候用 if let，什么时候用 match？",slug:"五、什么时候用-if-let-什么时候用-match",normalizedTitle:"五、什么时候用 if let，什么时候用 match？",charIndex:1277},{level:2,title:"六、脑洞一下",slug:"六、脑洞一下",normalizedTitle:"六、脑洞一下",charIndex:1458}],headersStr:"一、if let 是个啥？ 二、举个例子：盒子开宝藏 三、Option 与 if let 四、还能配合 else 五、什么时候用 if let，什么时候用 match？ 六、脑洞一下",content:'# Rust 的语法糖 - if let\n\n\n# 一、if let 是个啥？\n\n在学习 match 的时候，你可能觉得它有点啰嗦：\n有时候我只关心一个分支，结果写一大堆 _ => ()，又长又丑。\n\n这时候，Rust 贴心地给你塞了一个小糖果：if let。\n它其实就是 “只关注一个模式的 match” 的缩写。\n\n----------------------------------------\n\n\n# 二、举个例子：盒子开宝藏\n\n假设我们有个神秘的盒子，它可能藏着一个数字宝藏，也可能什么都没有：\n\nenum Boxed {\n    Treasure(i32),\n    Empty,\n}\n\nfn main() {\n    let my_box = Boxed::Treasure(42);\n\n    // 只关心有宝藏的情况\n    if let Boxed::Treasure(v) = my_box {\n        println!("我发现了宝藏，价值 {}!", v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果写成 match 的话呢？\n\nmatch my_box {\n    Boxed::Treasure(v) => println!("我发现了宝藏，价值 {}!", v),\n    _ => (),\n}\n\n\n1\n2\n3\n4\n\n\n看出来没？if let 就是上面这坨的简洁版。\n\n----------------------------------------\n\n\n# 三、Option 与 if let\n\nOption 是 Rust 里常见的枚举，代表“可能有值，可能没有值”。 假设我们想要在有值的时候处理一下：\n\nfn main() {\n    let maybe_num = Some(10);\n\n    if let Some(x) = maybe_num {\n        println!("有数字！它是 {}", x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n相当于只关心 Some，而对 None 不想管。 如果用 match，就得多写一行 None => ()，显得很啰嗦。\n\n----------------------------------------\n\n\n# 四、还能配合 else\n\nif let 还能带个 else，就像普通 if 一样：\n\nfn main() {\n    let maybe_name = None;\n\n    if let Some(name) = maybe_name {\n        println!("你好, {}", name);\n    } else {\n        println!("没有名字，只能叫你匿名侠了！");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是不是很优雅？\n\n----------------------------------------\n\n\n# 五、什么时候用 if let，什么时候用 match？\n\n * 如果你只关心一种情况，if let 更简洁。\n * 如果你需要覆盖所有可能，必须用 match，这样编译器能帮你检查穷举。\n\n一句话总结：\n\n> if let 是 match 的快捷写法，适合偷懒的时候。\n\n----------------------------------------\n\n\n# 六、脑洞一下\n\n你可以把 if let 理解为一种“有条件的解锁”：\n\n * 如果钥匙对得上（模式匹配成功），就开门干活；\n * 如果钥匙不对（匹配失败），就悄悄走开，不打扰别人。\n\n这，就是 Rust 给我们的小小语法糖。',normalizedContent:'# rust 的语法糖 - if let\n\n\n# 一、if let 是个啥？\n\n在学习 match 的时候，你可能觉得它有点啰嗦：\n有时候我只关心一个分支，结果写一大堆 _ => ()，又长又丑。\n\n这时候，rust 贴心地给你塞了一个小糖果：if let。\n它其实就是 “只关注一个模式的 match” 的缩写。\n\n----------------------------------------\n\n\n# 二、举个例子：盒子开宝藏\n\n假设我们有个神秘的盒子，它可能藏着一个数字宝藏，也可能什么都没有：\n\nenum boxed {\n    treasure(i32),\n    empty,\n}\n\nfn main() {\n    let my_box = boxed::treasure(42);\n\n    // 只关心有宝藏的情况\n    if let boxed::treasure(v) = my_box {\n        println!("我发现了宝藏，价值 {}!", v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果写成 match 的话呢？\n\nmatch my_box {\n    boxed::treasure(v) => println!("我发现了宝藏，价值 {}!", v),\n    _ => (),\n}\n\n\n1\n2\n3\n4\n\n\n看出来没？if let 就是上面这坨的简洁版。\n\n----------------------------------------\n\n\n# 三、option 与 if let\n\noption 是 rust 里常见的枚举，代表“可能有值，可能没有值”。 假设我们想要在有值的时候处理一下：\n\nfn main() {\n    let maybe_num = some(10);\n\n    if let some(x) = maybe_num {\n        println!("有数字！它是 {}", x);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n相当于只关心 some，而对 none 不想管。 如果用 match，就得多写一行 none => ()，显得很啰嗦。\n\n----------------------------------------\n\n\n# 四、还能配合 else\n\nif let 还能带个 else，就像普通 if 一样：\n\nfn main() {\n    let maybe_name = none;\n\n    if let some(name) = maybe_name {\n        println!("你好, {}", name);\n    } else {\n        println!("没有名字，只能叫你匿名侠了！");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n是不是很优雅？\n\n----------------------------------------\n\n\n# 五、什么时候用 if let，什么时候用 match？\n\n * 如果你只关心一种情况，if let 更简洁。\n * 如果你需要覆盖所有可能，必须用 match，这样编译器能帮你检查穷举。\n\n一句话总结：\n\n> if let 是 match 的快捷写法，适合偷懒的时候。\n\n----------------------------------------\n\n\n# 六、脑洞一下\n\n你可以把 if let 理解为一种“有条件的解锁”：\n\n * 如果钥匙对得上（模式匹配成功），就开门干活；\n * 如果钥匙不对（匹配失败），就悄悄走开，不打扰别人。\n\n这，就是 rust 给我们的小小语法糖。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"14.Rust的模块系统",frontmatter:{title:"14.Rust的模块系统",date:"2025-08-27T22:00:00.000Z",permalink:"/pages/Rust_14/"},regularPath:"/06.Rust/14.Rust%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F.html",relativePath:"06.Rust/14.Rust的模块系统.md",key:"v-02b66869",path:"/pages/Rust_14/",headers:[{level:2,title:"一、包（Package）和 Crate",slug:"一、包-package-和-crate",normalizedTitle:"一、包（package）和 crate",charIndex:253},{level:2,title:"二、模块（mod）和可见性",slug:"二、模块-mod-和可见性",normalizedTitle:"二、模块（mod）和可见性",charIndex:645},{level:2,title:"三、路径（Path）",slug:"三、路径-path",normalizedTitle:"三、路径（path）",charIndex:1030},{level:2,title:"四、use 简化路径",slug:"四、use-简化路径",normalizedTitle:"四、use 简化路径",charIndex:1382},{level:2,title:"五、模块拆分到文件",slug:"五、模块拆分到文件",normalizedTitle:"五、模块拆分到文件",charIndex:1749}],headersStr:"一、包（Package）和 Crate 二、模块（mod）和可见性 三、路径（Path） 四、use 简化路径 五、模块拆分到文件",content:'# Rust 的模块系统\n\n在 Rust 里，项目不可能一直放在一个文件里，越写越多肯定会乱套。 所以语言本身提供了一整套“组织工具”来帮你：\n\n * 包（Package）和 Crate：整体的管理和构建单位\n * 模块（Module）：代码的逻辑分块\n * 路径（Path）：告诉编译器去哪儿找你写的东西\n * use：给路径起别名、简化访问\n * 分文件管理：让文件夹结构和模块结构对齐\n\n下面我们逐一来看。\n\n----------------------------------------\n\n\n# 一、包（Package）和 Crate\n\n * Crate 就是 Rust 的最小编译单元。\n   * 如果有 main 函数，它就是 二进制 Crate，能直接运行。\n   * 如果没有 main，只是提供功能，那就是 库 Crate，只能被别人引用。\n * Package 是一个或多个 Crate 的集合，它里面有 Cargo.toml 文件来说明怎么构建。\n   * 一个包最多只能有 一个库 Crate。\n   * 但可以有多个二进制 Crate（放在 src/bin/ 目录里）。\n\n👉 举个栗子：\n\nmy_project/\n ├─ Cargo.toml   # 包的配置\n └─ src/\n     └─ main.rs  # 默认的二进制 crate\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 二、模块（mod）和可见性\n\n随着项目增长，我们会用 模块（module）把代码分块。 写法是这样的：\n\nmod network {\n    fn connect() {\n        println!("connected!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里的 network 就是一个模块。 要注意，模块里的东西默认是私有的，外面用不了。\n\n想让外面能用，就要加 pub：\n\nmod network {\n    pub fn connect() {\n        println!("connected!");\n    }\n}\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 三、路径（Path）\n\n如果模块越来越多，就要学会用路径来访问。路径分两种：\n\n * 绝对路径：从 crate 根开始，比如 crate::network::connect\n * 相对路径：从当前位置开始，比如 super:: 往上，self:: 当前模块\n\nmod network {\n    pub fn connect() {}\n}\n\nfn main() {\n    // 绝对路径\n    crate::network::connect();\n\n    // 相对路径（在 main.rs 顶层）\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 四、use 简化路径\n\n如果你老是写 crate::network::connect，会很烦。 这时可以用 use：\n\nmod network {\n    pub fn connect() {}\n}\n\nuse crate::network::connect;\n\nfn main() {\n    connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以给名字起别名：\n\nuse crate::network::connect as net_connect;\n\nfn main() {\n    net_connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\n要让别人也能用这个简化路径，可以写 pub use。这叫“重导出”。\n\n----------------------------------------\n\n\n# 五、模块拆分到文件\n\n当模块越来越大，可以把它们分到不同的文件。\n\n假设你写了 mod network;，Rust 会去找：\n\n 1. network.rs 文件\n 2. 或者 network/mod.rs 文件\n\n比如目录长这样：\n\nsrc/\n ├─ main.rs\n └─ network.rs\n\n\n1\n2\n3\n\n\nmain.rs 里写：\n\nmod network;\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\nnetwork.rs 文件里写：\n\npub fn connect() {\n    println!("connected!");\n}\n\n\n1\n2\n3\n\n\n这样，模块和文件夹结构就能对上了，阅读起来很清晰。',normalizedContent:'# rust 的模块系统\n\n在 rust 里，项目不可能一直放在一个文件里，越写越多肯定会乱套。 所以语言本身提供了一整套“组织工具”来帮你：\n\n * 包（package）和 crate：整体的管理和构建单位\n * 模块（module）：代码的逻辑分块\n * 路径（path）：告诉编译器去哪儿找你写的东西\n * use：给路径起别名、简化访问\n * 分文件管理：让文件夹结构和模块结构对齐\n\n下面我们逐一来看。\n\n----------------------------------------\n\n\n# 一、包（package）和 crate\n\n * crate 就是 rust 的最小编译单元。\n   * 如果有 main 函数，它就是 二进制 crate，能直接运行。\n   * 如果没有 main，只是提供功能，那就是 库 crate，只能被别人引用。\n * package 是一个或多个 crate 的集合，它里面有 cargo.toml 文件来说明怎么构建。\n   * 一个包最多只能有 一个库 crate。\n   * 但可以有多个二进制 crate（放在 src/bin/ 目录里）。\n\n👉 举个栗子：\n\nmy_project/\n ├─ cargo.toml   # 包的配置\n └─ src/\n     └─ main.rs  # 默认的二进制 crate\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 二、模块（mod）和可见性\n\n随着项目增长，我们会用 模块（module）把代码分块。 写法是这样的：\n\nmod network {\n    fn connect() {\n        println!("connected!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里的 network 就是一个模块。 要注意，模块里的东西默认是私有的，外面用不了。\n\n想让外面能用，就要加 pub：\n\nmod network {\n    pub fn connect() {\n        println!("connected!");\n    }\n}\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 三、路径（path）\n\n如果模块越来越多，就要学会用路径来访问。路径分两种：\n\n * 绝对路径：从 crate 根开始，比如 crate::network::connect\n * 相对路径：从当前位置开始，比如 super:: 往上，self:: 当前模块\n\nmod network {\n    pub fn connect() {}\n}\n\nfn main() {\n    // 绝对路径\n    crate::network::connect();\n\n    // 相对路径（在 main.rs 顶层）\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 四、use 简化路径\n\n如果你老是写 crate::network::connect，会很烦。 这时可以用 use：\n\nmod network {\n    pub fn connect() {}\n}\n\nuse crate::network::connect;\n\nfn main() {\n    connect();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以给名字起别名：\n\nuse crate::network::connect as net_connect;\n\nfn main() {\n    net_connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\n要让别人也能用这个简化路径，可以写 pub use。这叫“重导出”。\n\n----------------------------------------\n\n\n# 五、模块拆分到文件\n\n当模块越来越大，可以把它们分到不同的文件。\n\n假设你写了 mod network;，rust 会去找：\n\n 1. network.rs 文件\n 2. 或者 network/mod.rs 文件\n\n比如目录长这样：\n\nsrc/\n ├─ main.rs\n └─ network.rs\n\n\n1\n2\n3\n\n\nmain.rs 里写：\n\nmod network;\n\nfn main() {\n    network::connect();\n}\n\n\n1\n2\n3\n4\n5\n\n\nnetwork.rs 文件里写：\n\npub fn connect() {\n    println!("connected!");\n}\n\n\n1\n2\n3\n\n\n这样，模块和文件夹结构就能对上了，阅读起来很清晰。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"17.Rust的HashMap",frontmatter:{title:"17.Rust的HashMap",date:"2025-08-28T23:30:00.000Z",permalink:"/pages/Rust_17/"},regularPath:"/06.Rust/17.Rust%E7%9A%84HashMap.html",relativePath:"06.Rust/17.Rust的HashMap.md",key:"v-a2e945e8",path:"/pages/Rust_17/",headers:[{level:2,title:"一、什么是 HashMap？",slug:"一、什么是-hashmap",normalizedTitle:"一、什么是 hashmap？",charIndex:145},{level:2,title:"二、取值和遍历",slug:"二、取值和遍历",normalizedTitle:"二、取值和遍历",charIndex:486},{level:2,title:"三、更新 HashMap",slug:"三、更新-hashmap",normalizedTitle:"三、更新 hashmap",charIndex:806},{level:3,title:"1. 直接覆盖",slug:"_1-直接覆盖",normalizedTitle:"1. 直接覆盖",charIndex:850},{level:3,title:"2. 只在键不存在时插入",slug:"_2-只在键不存在时插入",normalizedTitle:"2. 只在键不存在时插入",charIndex:924},{level:3,title:"3. 根据旧值更新",slug:"_3-根据旧值更新",normalizedTitle:"3. 根据旧值更新",charIndex:1044},{level:2,title:"四、关于所有权的细节",slug:"四、关于所有权的细节",normalizedTitle:"四、关于所有权的细节",charIndex:1414},{level:2,title:"五、总结",slug:"五、总结",normalizedTitle:"五、总结",charIndex:1784}],headersStr:"一、什么是 HashMap？ 二、取值和遍历 三、更新 HashMap 1. 直接覆盖 2. 只在键不存在时插入 3. 根据旧值更新 四、关于所有权的细节 五、总结",content:'# Rust 的 HashMap：键值对的老管家\n\nRust 的集合里，Vec 像是有序列表，String 是字符串专家，而 HashMap 就是大管家：负责把键和对应的值捆在一起，方便快速查找。\n\n----------------------------------------\n\n\n# 一、什么是 HashMap？\n\n * 本质：一个存储 键–值对 的集合。\n * 键（Key）：可以是任何实现了 Eq 和 Hash 的类型（整数、字符串常用）。\n * 值（Value）：可以是任意类型。\n * 查找效率：理论上 O(1)，也就是非常快。\n\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    scores.insert(String::from("Blue"), 10);\n    scores.insert(String::from("Red"), 50);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这段代码就建了一个球队分数表。\n\n\n# 二、取值和遍历\n\n你可以通过 get 来获取：\n\nlet team_name = String::from("Blue");\nlet score = scores.get(&team_name);\nprintln!("{:?}", score); // Some(10)\n\n\n1\n2\n3\n\n\nget 返回的是 Option<&V>，所以要么是 Some(值)，要么是 None。\n\n遍历所有键值对：\n\nfor (key, value) in &scores {\n    println!("{key}: {value}");\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 三、更新 HashMap\n\nHashMap 里的值可以覆盖，也可以按规则插入。\n\n\n# 1. 直接覆盖\n\nscores.insert(String::from("Blue"), 25); // 原来 10 变成 25\n\n\n1\n\n\n\n# 2. 只在键不存在时插入\n\n用 .entry() 方法：\n\nscores.entry(String::from("Yellow")).or_insert(30);\n\n\n1\n\n\n如果 Yellow 已经有分数，不会动；没有才会插入。\n\n\n# 3. 根据旧值更新\n\nlet text = "hello world wonderful world";\n\nlet mut map = HashMap::new();\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nprintln!("{map:?}");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个例子就是 统计词频：\n\n * entry(word) 先查看 key 是否存在；\n * .or_insert(0) 表示如果不存在就插入 0；\n * 然后 *count += 1 更新。\n\n----------------------------------------\n\n\n# 四、关于所有权的细节\n\n * 如果你把 String 当作 key 或 value 插入 HashMap，它的所有权会被移动进 Map。\n * 如果你只想借用，就要用引用类型。\n\nlet field_name = String::from("Favorite color");\nlet field_value = String::from("Blue");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n\n// field_name, field_value 已经失效\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以要么用 .clone()，要么一开始就存引用。\n\n----------------------------------------\n\n\n# 五、总结\n\n * HashMap 用来存 键值对，快速查找，查不到返回 None。\n * 常用操作：insert、get、entry().or_insert()。\n * 注意所有权问题，插进去就不能再直接用了。\n * 适合做配置表、统计、缓存等。\n\nRust 的集合三兄弟，到这儿算齐活了：\n\n * Vec 管列表，\n * String 管文本，\n * HashMap 管键值关系。',normalizedContent:'# rust 的 hashmap：键值对的老管家\n\nrust 的集合里，vec 像是有序列表，string 是字符串专家，而 hashmap 就是大管家：负责把键和对应的值捆在一起，方便快速查找。\n\n----------------------------------------\n\n\n# 一、什么是 hashmap？\n\n * 本质：一个存储 键–值对 的集合。\n * 键（key）：可以是任何实现了 eq 和 hash 的类型（整数、字符串常用）。\n * 值（value）：可以是任意类型。\n * 查找效率：理论上 o(1)，也就是非常快。\n\nuse std::collections::hashmap;\n\nfn main() {\n    let mut scores = hashmap::new();\n    scores.insert(string::from("blue"), 10);\n    scores.insert(string::from("red"), 50);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这段代码就建了一个球队分数表。\n\n\n# 二、取值和遍历\n\n你可以通过 get 来获取：\n\nlet team_name = string::from("blue");\nlet score = scores.get(&team_name);\nprintln!("{:?}", score); // some(10)\n\n\n1\n2\n3\n\n\nget 返回的是 option<&v>，所以要么是 some(值)，要么是 none。\n\n遍历所有键值对：\n\nfor (key, value) in &scores {\n    println!("{key}: {value}");\n}\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n\n# 三、更新 hashmap\n\nhashmap 里的值可以覆盖，也可以按规则插入。\n\n\n# 1. 直接覆盖\n\nscores.insert(string::from("blue"), 25); // 原来 10 变成 25\n\n\n1\n\n\n\n# 2. 只在键不存在时插入\n\n用 .entry() 方法：\n\nscores.entry(string::from("yellow")).or_insert(30);\n\n\n1\n\n\n如果 yellow 已经有分数，不会动；没有才会插入。\n\n\n# 3. 根据旧值更新\n\nlet text = "hello world wonderful world";\n\nlet mut map = hashmap::new();\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nprintln!("{map:?}");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个例子就是 统计词频：\n\n * entry(word) 先查看 key 是否存在；\n * .or_insert(0) 表示如果不存在就插入 0；\n * 然后 *count += 1 更新。\n\n----------------------------------------\n\n\n# 四、关于所有权的细节\n\n * 如果你把 string 当作 key 或 value 插入 hashmap，它的所有权会被移动进 map。\n * 如果你只想借用，就要用引用类型。\n\nlet field_name = string::from("favorite color");\nlet field_value = string::from("blue");\n\nlet mut map = hashmap::new();\nmap.insert(field_name, field_value);\n\n// field_name, field_value 已经失效\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以要么用 .clone()，要么一开始就存引用。\n\n----------------------------------------\n\n\n# 五、总结\n\n * hashmap 用来存 键值对，快速查找，查不到返回 none。\n * 常用操作：insert、get、entry().or_insert()。\n * 注意所有权问题，插进去就不能再直接用了。\n * 适合做配置表、统计、缓存等。\n\nrust 的集合三兄弟，到这儿算齐活了：\n\n * vec 管列表，\n * string 管文本，\n * hashmap 管键值关系。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"15.Rust的Vector",frontmatter:{title:"15.Rust的Vector",date:"2025-08-28T22:00:00.000Z",permalink:"/pages/Rust_15/"},regularPath:"/06.Rust/15.Rust%E7%9A%84Vector.html",relativePath:"06.Rust/15.Rust的Vector.md",key:"v-f43e611c",path:"/pages/Rust_15/",headers:[{level:2,title:"一、定义向量",slug:"一、定义向量",normalizedTitle:"一、定义向量",charIndex:114},{level:2,title:"二、向量的修改",slug:"二、向量的修改",normalizedTitle:"二、向量的修改",charIndex:355},{level:2,title:"三、访问元素",slug:"三、访问元素",normalizedTitle:"三、访问元素",charIndex:566},{level:2,title:"四、遍历向量",slug:"四、遍历向量",normalizedTitle:"四、遍历向量",charIndex:939},{level:2,title:"五、向量和枚举",slug:"五、向量和枚举",normalizedTitle:"五、向量和枚举",charIndex:1248},{level:2,title:"六、Vector 的释放",slug:"六、vector-的释放",normalizedTitle:"六、vector 的释放",charIndex:1519}],headersStr:"一、定义向量 二、向量的修改 三、访问元素 四、遍历向量 五、向量和枚举 六、Vector 的释放",content:'# Rust的Vector\n\n在 Rust 里，如果要存放一系列同类型的元素，最常用的就是 向量（Vector），对应的类型是 Vec<T>。它和 C 语言里的数组不同，不仅能存放数据，还能根据需要动态扩展，非常灵活。\n\n\n# 一、定义向量\n\n定义向量有几种方式：\n\n// 创建一个空的 i32 类型向量\nlet mut v: Vec<i32> = Vec::new();\n\n// 使用宏直接创建并初始化\nlet v = vec![1, 2, 3];\n\n\n1\n2\n3\n4\n5\n\n\n第一种方法需要显式声明类型，因为 Vec::new() 里没有数据，编译器推不出类型。 第二种方法更常见，用 vec![] 宏直接生成。\n\n----------------------------------------\n\n\n# 二、向量的修改\n\n向量是可以动态扩展的，常见操作有：\n\nlet mut numbers = Vec::new();\nnumbers.push(10);\nnumbers.push(20);\nnumbers.push(30);\n\n\n1\n2\n3\n4\n\n\n这里用 push 往里添加元素。 需要注意：要想修改，就得把向量定义成 mut。\n\n----------------------------------------\n\n\n# 三、访问元素\n\n访问向量里的值有两种方式：\n\nlet v = vec![1, 2, 3, 4];\n\n// 下标访问，直接取值\nlet third = &v[2];\nprintln!("第三个元素是 {}", third);\n\n// get 方法，更安全\nmatch v.get(2) {\n    Some(value) => println!("第三个元素是 {}", value),\n    None => println!("没有这个元素"),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n区别在于：\n\n * v[2] 如果越界会直接 panic（程序崩溃）。\n * v.get(2) 返回一个 Option，能优雅地处理越界情况。\n\n----------------------------------------\n\n\n# 四、遍历向量\n\n向量里通常要用循环读取数据：\n\nlet v = vec![100, 200, 300];\n\n// 不可变借用\nfor i in &v {\n    println!("{}", i);\n}\n\n// 可变借用，可以修改里面的值\nlet mut v = vec![1, 2, 3];\nfor i in &mut v {\n    *i += 10;\n}\nprintln!("{:?}", v);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里的 *i 是解引用，把借用拿到的值修改后写回去。\n\n----------------------------------------\n\n\n# 五、向量和枚举\n\n向量要求所有元素类型相同，如果想在一个向量里存不同类型，可以借助枚举：\n\nenum Cell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    Cell::Int(42),\n    Cell::Text(String::from("hello")),\n    Cell::Float(3.14),\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样就能在一个 Vec<Cell> 里存放不同形式的数据。\n\n\n# 六、Vector 的释放\n\nRust 的所有权机制会在向量离开作用域时自动释放内存，包括它里面的元素，不需要手动释放。这就是 Rust 带来的安全性。',normalizedContent:'# rust的vector\n\n在 rust 里，如果要存放一系列同类型的元素，最常用的就是 向量（vector），对应的类型是 vec<t>。它和 c 语言里的数组不同，不仅能存放数据，还能根据需要动态扩展，非常灵活。\n\n\n# 一、定义向量\n\n定义向量有几种方式：\n\n// 创建一个空的 i32 类型向量\nlet mut v: vec<i32> = vec::new();\n\n// 使用宏直接创建并初始化\nlet v = vec![1, 2, 3];\n\n\n1\n2\n3\n4\n5\n\n\n第一种方法需要显式声明类型，因为 vec::new() 里没有数据，编译器推不出类型。 第二种方法更常见，用 vec![] 宏直接生成。\n\n----------------------------------------\n\n\n# 二、向量的修改\n\n向量是可以动态扩展的，常见操作有：\n\nlet mut numbers = vec::new();\nnumbers.push(10);\nnumbers.push(20);\nnumbers.push(30);\n\n\n1\n2\n3\n4\n\n\n这里用 push 往里添加元素。 需要注意：要想修改，就得把向量定义成 mut。\n\n----------------------------------------\n\n\n# 三、访问元素\n\n访问向量里的值有两种方式：\n\nlet v = vec![1, 2, 3, 4];\n\n// 下标访问，直接取值\nlet third = &v[2];\nprintln!("第三个元素是 {}", third);\n\n// get 方法，更安全\nmatch v.get(2) {\n    some(value) => println!("第三个元素是 {}", value),\n    none => println!("没有这个元素"),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n区别在于：\n\n * v[2] 如果越界会直接 panic（程序崩溃）。\n * v.get(2) 返回一个 option，能优雅地处理越界情况。\n\n----------------------------------------\n\n\n# 四、遍历向量\n\n向量里通常要用循环读取数据：\n\nlet v = vec![100, 200, 300];\n\n// 不可变借用\nfor i in &v {\n    println!("{}", i);\n}\n\n// 可变借用，可以修改里面的值\nlet mut v = vec![1, 2, 3];\nfor i in &mut v {\n    *i += 10;\n}\nprintln!("{:?}", v);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这里的 *i 是解引用，把借用拿到的值修改后写回去。\n\n----------------------------------------\n\n\n# 五、向量和枚举\n\n向量要求所有元素类型相同，如果想在一个向量里存不同类型，可以借助枚举：\n\nenum cell {\n    int(i32),\n    float(f64),\n    text(string),\n}\n\nlet row = vec![\n    cell::int(42),\n    cell::text(string::from("hello")),\n    cell::float(3.14),\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样就能在一个 vec<cell> 里存放不同形式的数据。\n\n\n# 六、vector 的释放\n\nrust 的所有权机制会在向量离开作用域时自动释放内存，包括它里面的元素，不需要手动释放。这就是 rust 带来的安全性。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"01.numpy 模块",frontmatter:{title:"01.numpy 模块",date:"2025-09-26T22:00:00.000Z",permalink:"/pages/Python_01/"},regularPath:"/07.python/01.numpy%20%E6%A8%A1%E5%9D%97.html",relativePath:"07.python/01.numpy 模块.md",key:"v-3baf18ff",path:"/pages/Python_01/",headers:[{level:2,title:"NumPy简介",slug:"numpy简介",normalizedTitle:"numpy简介",charIndex:15},{level:2,title:"📌 NumPy 常用方法（方法签名 + 参数解释）",slug:"📌-numpy-常用方法-方法签名-参数解释",normalizedTitle:"📌 numpy 常用方法（方法签名 + 参数解释）",charIndex:348},{level:3,title:"数组创建",slug:"数组创建",normalizedTitle:"数组创建",charIndex:379},{level:3,title:"数组属性",slug:"数组属性",normalizedTitle:"数组属性",charIndex:1034},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:1182},{level:3,title:"索引与切片",slug:"索引与切片",normalizedTitle:"索引与切片",charIndex:1483},{level:3,title:"运算",slug:"运算",normalizedTitle:"运算",charIndex:111},{level:3,title:"统计函数",slug:"统计函数",normalizedTitle:"统计函数",charIndex:119},{level:3,title:"线性代数",slug:"线性代数",normalizedTitle:"线性代数",charIndex:114},{level:3,title:"文件读写",slug:"文件读写",normalizedTitle:"文件读写",charIndex:2444},{level:2,title:"主要方法与功能示例",slug:"主要方法与功能示例",normalizedTitle:"主要方法与功能示例",charIndex:2696},{level:3,title:"1. 数组的创建方式",slug:"_1-数组的创建方式",normalizedTitle:"1. 数组的创建方式",charIndex:2820},{level:3,title:"2. 数组属性查看 / 维度操作",slug:"_2-数组属性查看-维度操作",normalizedTitle:"2. 数组属性查看 / 维度操作",charIndex:3717},{level:3,title:"3. 数组运算（元素级运算）",slug:"_3-数组运算-元素级运算",normalizedTitle:"3. 数组运算（元素级运算）",charIndex:4289},{level:3,title:"4. 数据统计函数",slug:"_4-数据统计函数",normalizedTitle:"4. 数据统计函数",charIndex:4468},{level:3,title:"5. 索引与切片",slug:"_5-索引与切片",normalizedTitle:"5. 索引与切片",charIndex:4863},{level:3,title:"6. 数组堆叠 / 拆分",slug:"_6-数组堆叠-拆分",normalizedTitle:"6. 数组堆叠 / 拆分",charIndex:5202},{level:3,title:"7. 保存 / 加载数组",slug:"_7-保存-加载数组",normalizedTitle:"7. 保存 / 加载数组",charIndex:5496}],headersStr:"NumPy简介 📌 NumPy 常用方法（方法签名 + 参数解释） 数组创建 数组属性 基本操作 索引与切片 运算 统计函数 线性代数 文件读写 主要方法与功能示例 1. 数组的创建方式 2. 数组属性查看 / 维度操作 3. 数组运算（元素级运算） 4. 数据统计函数 5. 索引与切片 6. 数组堆叠 / 拆分 7. 保存 / 加载数组",content:"# numpy 模块\n\n\n# NumPy简介\n\nNumPy（Numerical Python 的简称）是 Python 中用于高效数值计算的基础库。它提供了一个核心类型 ndarray（多维数组），并在其上封装了大量向量化运算、线性代数、统计函数、广播机制、索引切片、随机数生成等功能。它在科学计算、机器学习、信号处理等领域都非常关键。\n\n特点包括：\n\n * 高效：底层用 C 实现，运算速度比纯 Python 的 list 快很多\n * 支持多维数组（向量、矩阵、张量）\n * 广播机制（不同形状数组做运算时自动对齐维度）\n * 与其他数据科学库（Pandas、SciPy、Matplotlib）兼容\n\n----------------------------------------\n\n\n# 📌 NumPy 常用方法（方法签名 + 参数解释）\n\n\n# 数组创建\n\n * np.array(object, dtype=None, copy=True, ndmin=0) → 从列表/元组/嵌套结构创建数组。\n   * dtype：数据类型\n   * copy：是否复制数据\n   * ndmin：最小维度\n * np.zeros(shape, dtype=float) → 创建全 0 数组。\n * np.ones(shape, dtype=float) → 创建全 1 数组。\n * np.full(shape, fill_value, dtype=None) → 创建指定值数组。\n * np.eye(N, M=None, k=0, dtype=float) → 创建单位矩阵（对角线上为1）。\n   * N：行数\n   * M：列数（默认等于 N）\n   * k：对角线偏移\n * np.arange([start, ]stop, step=1, dtype=None) → 类似 Python range，生成等差序列。\n * np.linspace(start, stop, num=50, endpoint=True, dtype=None) → 生成等间距序列。\n * np.random.rand(d0, d1, …) → 生成 [0,1) 区间的均匀分布随机数。\n * np.random.randn(d0, d1, …) → 生成标准正态分布随机数。\n\n----------------------------------------\n\n\n# 数组属性\n\n * arr.shape → 返回数组形状 (tuple)。\n * arr.ndim → 返回数组维度。\n * arr.size → 元素总数。\n * arr.dtype → 元素数据类型。\n\n----------------------------------------\n\n\n# 基本操作\n\n * np.reshape(arr, newshape, order='C') → 改变数组形状。\n * np.transpose(arr, axes=None) / arr.T → 转置数组。\n * np.concatenate((a1, a2, ...), axis=0) → 拼接数组。\n * np.split(ary, indices_or_sections, axis=0) → 拆分数组。\n * np.hstack(tup) / np.vstack(tup) → 水平 / 垂直拼接。\n\n----------------------------------------\n\n\n# 索引与切片\n\n * arr[start:stop:step] → 一维切片。\n * arr[rows, cols] → 二维索引（行，列）。\n * arr[...] → 使用 ... 表示剩余所有维度。\n * arr[arr > 0] → 布尔索引。\n\n----------------------------------------\n\n\n# 运算\n\n * np.add(x1, x2) / x1 + x2\n * np.subtract(x1, x2) / x1 - x2\n * np.multiply(x1, x2) / x1 * x2\n * np.divide(x1, x2) / x1 / x2\n * np.power(x1, x2) / x1 ** x2\n * np.mod(x1, x2) / x1 % x2\n\n→ 向量化计算，按元素执行。\n\n----------------------------------------\n\n\n# 统计函数\n\n * np.sum(a, axis=None) → 求和。\n * np.mean(a, axis=None) → 均值。\n * np.median(a, axis=None) → 中位数。\n * np.std(a, axis=None) → 标准差。\n * np.var(a, axis=None) → 方差。\n * np.max(a, axis=None) / np.min(a, axis=None) → 最大/最小值。\n * np.argmax(a, axis=None) / np.argmin(a, axis=None) → 最大/最小值索引。\n\n----------------------------------------\n\n\n# 线性代数\n\n * np.dot(a, b) → 矩阵乘法 / 点积。\n * np.matmul(a, b) / a @ b → 矩阵乘法（推荐写法）。\n * np.linalg.inv(a) → 矩阵求逆。\n * np.linalg.det(a) → 行列式。\n * np.linalg.eig(a) → 特征值与特征向量。\n\n----------------------------------------\n\n\n# 文件读写\n\n * np.loadtxt(fname, dtype=float, delimiter=None, skiprows=0) → 从文本加载数据。\n * np.savetxt(fname, X, fmt='%.18e', delimiter=' ') → 保存为文本文件。\n * np.save(file, arr, allow_pickle=True) → 保存为 .npy 文件。\n * np.load(file, allow_pickle=True) → 加载 .npy 文件。\n\n\n# 主要方法与功能示例\n\n下面是文章中提到（或涵盖）的几个重要方法 / 功能。我给出代码 + 注释说明输出。\n\nimport numpy as np\n\n\n1\n\n\n----------------------------------------\n\n\n# 1. 数组的创建方式\n\n# 1.1 np.array\n\na = np.array([1, 2, 3, 4])\nprint(a)  \n# 输出： [1 2 3 4]\n\nb = np.array([[1, 2, 3, 4], [4, 5, 6, 7]])\nprint(b)\n# 输出： \n# [[1 2 3 4]\n#  [4 5 6 7]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 1.2 全零 / 全一 / 空数组\n\nz = np.zeros((3, 4))\nprint(z)\n# 输出：\n# [[0. 0. 0. 0.]\n#  [0. 0. 0. 0.]\n#  [0. 0. 0. 0.]]\n\no = np.ones((2, 5))\nprint(o)\n# 输出：\n# [[1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]]\n\ne = np.empty((2, 3))\nprint(e)\n# 输出：内容未被初始化，可能是随机值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1.3 arange 与 linspace\n\nr = np.arange(10, 16, 2)\nprint(r)\n# 输出： [10 12 14]\n\nls = np.linspace(1, 10, 5)\nprint(ls)\n# 输出： [ 1.     3.25   5.5    7.75  10.   ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 1.4 随机数组\n\nrand = np.random.rand(3, 4)\nprint(rand)\n# 输出：3×4 的浮点随机数数组，例如：\n# [[0.567 0.123 ...]\n#  ...]\n\nri = np.random.randint(2, 5, size=(4, 5))\nprint(ri)\n# 输出：4×5 的整数数组，值在 [2,5) 区间内\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 2. 数组属性查看 / 维度操作\n\na = np.array([1, 2, 3, 4])\nprint(a.ndim)      # 维度（轴数） → 输出：1\nprint(a.shape)     # 形状 → 输出：(4,)\nprint(a.size)      # 元素总数 → 输出：4\nprint(a.dtype)     # 元素类型 → 输出：dtype('int64') 或类似类型\n\n# reshape 重塑形状\nb = np.array([[1,2,3],[4,5,6]])\nprint(b.shape)     # (2,3)\nc = b.reshape((3,2))\nprint(c.shape, c)\n# 输出：\n# (3, 2) [[1 2]\n#        [3 4]\n#        [5 6]]\n\n# 转置\nd = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(d.T)\n# 输出：\n# [[1 4 7]\n#  [2 5 8]\n#  [3 6 9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 数组运算（元素级运算）\n\nx = np.array([1,2,3])\ny = np.array([4,5,6])\nprint(x + y)     # 输出：[5 7 9]\nprint(x * y)     # 输出：[4 10 18]\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 4. 数据统计函数\n\narr = np.array([1, 5, 6, 9])\nprint(np.mean(arr))     # 平均值 → 5.25\nprint(np.median(arr))   # 中位数 → 5.5（视具体数据而定）\nprint(np.std(arr))      # 标准差\nprint(np.var(arr))      # 方差\nprint(np.min(arr), np.max(arr))  # 最小值、最大值\nprint(np.sum(arr))      # 总和\nprint(np.prod(arr))     # 所有元素乘积\nprint(np.cumsum(arr))   # 累积和（prefix sum）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 5. 索引与切片\n\narr = np.array([1,2,3,4,5])\nprint(arr[1:4])           # 输出 [2 3 4]\n\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(m[0:2, 1:3])\n# 输出：\n# [[2 3]\n#  [5 6]]\n\n# 多维切片示例：假设一个三维数组 data\ndata = np.arange(2*3*4).reshape((2,3,4))\nprint(data[:, :, 0:2])  # 取最后一维的前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 6. 数组堆叠 / 拆分\n\na = np.array([[1,2],[3,4]])\nb = np.array([[5,6],[7,8]])\nv = np.vstack((a, b))\nprint(v)\n# 输出：\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n\nh = np.hstack((a, b))\nprint(h)\n# 输出：\n# [[1 2 5 6]\n#  [3 4 7 8]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 7. 保存 / 加载数组\n\nnp.save('my_array.npy', a)          # 保存到 .npy 文件\nloaded = np.load('my_array.npy')\nprint(loaded)                        # 输出：与 a 相同的数组\n\n\n1\n2\n3\n",normalizedContent:"# numpy 模块\n\n\n# numpy简介\n\nnumpy（numerical python 的简称）是 python 中用于高效数值计算的基础库。它提供了一个核心类型 ndarray（多维数组），并在其上封装了大量向量化运算、线性代数、统计函数、广播机制、索引切片、随机数生成等功能。它在科学计算、机器学习、信号处理等领域都非常关键。\n\n特点包括：\n\n * 高效：底层用 c 实现，运算速度比纯 python 的 list 快很多\n * 支持多维数组（向量、矩阵、张量）\n * 广播机制（不同形状数组做运算时自动对齐维度）\n * 与其他数据科学库（pandas、scipy、matplotlib）兼容\n\n----------------------------------------\n\n\n# 📌 numpy 常用方法（方法签名 + 参数解释）\n\n\n# 数组创建\n\n * np.array(object, dtype=none, copy=true, ndmin=0) → 从列表/元组/嵌套结构创建数组。\n   * dtype：数据类型\n   * copy：是否复制数据\n   * ndmin：最小维度\n * np.zeros(shape, dtype=float) → 创建全 0 数组。\n * np.ones(shape, dtype=float) → 创建全 1 数组。\n * np.full(shape, fill_value, dtype=none) → 创建指定值数组。\n * np.eye(n, m=none, k=0, dtype=float) → 创建单位矩阵（对角线上为1）。\n   * n：行数\n   * m：列数（默认等于 n）\n   * k：对角线偏移\n * np.arange([start, ]stop, step=1, dtype=none) → 类似 python range，生成等差序列。\n * np.linspace(start, stop, num=50, endpoint=true, dtype=none) → 生成等间距序列。\n * np.random.rand(d0, d1, …) → 生成 [0,1) 区间的均匀分布随机数。\n * np.random.randn(d0, d1, …) → 生成标准正态分布随机数。\n\n----------------------------------------\n\n\n# 数组属性\n\n * arr.shape → 返回数组形状 (tuple)。\n * arr.ndim → 返回数组维度。\n * arr.size → 元素总数。\n * arr.dtype → 元素数据类型。\n\n----------------------------------------\n\n\n# 基本操作\n\n * np.reshape(arr, newshape, order='c') → 改变数组形状。\n * np.transpose(arr, axes=none) / arr.t → 转置数组。\n * np.concatenate((a1, a2, ...), axis=0) → 拼接数组。\n * np.split(ary, indices_or_sections, axis=0) → 拆分数组。\n * np.hstack(tup) / np.vstack(tup) → 水平 / 垂直拼接。\n\n----------------------------------------\n\n\n# 索引与切片\n\n * arr[start:stop:step] → 一维切片。\n * arr[rows, cols] → 二维索引（行，列）。\n * arr[...] → 使用 ... 表示剩余所有维度。\n * arr[arr > 0] → 布尔索引。\n\n----------------------------------------\n\n\n# 运算\n\n * np.add(x1, x2) / x1 + x2\n * np.subtract(x1, x2) / x1 - x2\n * np.multiply(x1, x2) / x1 * x2\n * np.divide(x1, x2) / x1 / x2\n * np.power(x1, x2) / x1 ** x2\n * np.mod(x1, x2) / x1 % x2\n\n→ 向量化计算，按元素执行。\n\n----------------------------------------\n\n\n# 统计函数\n\n * np.sum(a, axis=none) → 求和。\n * np.mean(a, axis=none) → 均值。\n * np.median(a, axis=none) → 中位数。\n * np.std(a, axis=none) → 标准差。\n * np.var(a, axis=none) → 方差。\n * np.max(a, axis=none) / np.min(a, axis=none) → 最大/最小值。\n * np.argmax(a, axis=none) / np.argmin(a, axis=none) → 最大/最小值索引。\n\n----------------------------------------\n\n\n# 线性代数\n\n * np.dot(a, b) → 矩阵乘法 / 点积。\n * np.matmul(a, b) / a @ b → 矩阵乘法（推荐写法）。\n * np.linalg.inv(a) → 矩阵求逆。\n * np.linalg.det(a) → 行列式。\n * np.linalg.eig(a) → 特征值与特征向量。\n\n----------------------------------------\n\n\n# 文件读写\n\n * np.loadtxt(fname, dtype=float, delimiter=none, skiprows=0) → 从文本加载数据。\n * np.savetxt(fname, x, fmt='%.18e', delimiter=' ') → 保存为文本文件。\n * np.save(file, arr, allow_pickle=true) → 保存为 .npy 文件。\n * np.load(file, allow_pickle=true) → 加载 .npy 文件。\n\n\n# 主要方法与功能示例\n\n下面是文章中提到（或涵盖）的几个重要方法 / 功能。我给出代码 + 注释说明输出。\n\nimport numpy as np\n\n\n1\n\n\n----------------------------------------\n\n\n# 1. 数组的创建方式\n\n# 1.1 np.array\n\na = np.array([1, 2, 3, 4])\nprint(a)  \n# 输出： [1 2 3 4]\n\nb = np.array([[1, 2, 3, 4], [4, 5, 6, 7]])\nprint(b)\n# 输出： \n# [[1 2 3 4]\n#  [4 5 6 7]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 1.2 全零 / 全一 / 空数组\n\nz = np.zeros((3, 4))\nprint(z)\n# 输出：\n# [[0. 0. 0. 0.]\n#  [0. 0. 0. 0.]\n#  [0. 0. 0. 0.]]\n\no = np.ones((2, 5))\nprint(o)\n# 输出：\n# [[1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]]\n\ne = np.empty((2, 3))\nprint(e)\n# 输出：内容未被初始化，可能是随机值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 1.3 arange 与 linspace\n\nr = np.arange(10, 16, 2)\nprint(r)\n# 输出： [10 12 14]\n\nls = np.linspace(1, 10, 5)\nprint(ls)\n# 输出： [ 1.     3.25   5.5    7.75  10.   ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 1.4 随机数组\n\nrand = np.random.rand(3, 4)\nprint(rand)\n# 输出：3×4 的浮点随机数数组，例如：\n# [[0.567 0.123 ...]\n#  ...]\n\nri = np.random.randint(2, 5, size=(4, 5))\nprint(ri)\n# 输出：4×5 的整数数组，值在 [2,5) 区间内\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 2. 数组属性查看 / 维度操作\n\na = np.array([1, 2, 3, 4])\nprint(a.ndim)      # 维度（轴数） → 输出：1\nprint(a.shape)     # 形状 → 输出：(4,)\nprint(a.size)      # 元素总数 → 输出：4\nprint(a.dtype)     # 元素类型 → 输出：dtype('int64') 或类似类型\n\n# reshape 重塑形状\nb = np.array([[1,2,3],[4,5,6]])\nprint(b.shape)     # (2,3)\nc = b.reshape((3,2))\nprint(c.shape, c)\n# 输出：\n# (3, 2) [[1 2]\n#        [3 4]\n#        [5 6]]\n\n# 转置\nd = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(d.t)\n# 输出：\n# [[1 4 7]\n#  [2 5 8]\n#  [3 6 9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 数组运算（元素级运算）\n\nx = np.array([1,2,3])\ny = np.array([4,5,6])\nprint(x + y)     # 输出：[5 7 9]\nprint(x * y)     # 输出：[4 10 18]\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 4. 数据统计函数\n\narr = np.array([1, 5, 6, 9])\nprint(np.mean(arr))     # 平均值 → 5.25\nprint(np.median(arr))   # 中位数 → 5.5（视具体数据而定）\nprint(np.std(arr))      # 标准差\nprint(np.var(arr))      # 方差\nprint(np.min(arr), np.max(arr))  # 最小值、最大值\nprint(np.sum(arr))      # 总和\nprint(np.prod(arr))     # 所有元素乘积\nprint(np.cumsum(arr))   # 累积和（prefix sum）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# 5. 索引与切片\n\narr = np.array([1,2,3,4,5])\nprint(arr[1:4])           # 输出 [2 3 4]\n\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint(m[0:2, 1:3])\n# 输出：\n# [[2 3]\n#  [5 6]]\n\n# 多维切片示例：假设一个三维数组 data\ndata = np.arange(2*3*4).reshape((2,3,4))\nprint(data[:, :, 0:2])  # 取最后一维的前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n\n# 6. 数组堆叠 / 拆分\n\na = np.array([[1,2],[3,4]])\nb = np.array([[5,6],[7,8]])\nv = np.vstack((a, b))\nprint(v)\n# 输出：\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n\nh = np.hstack((a, b))\nprint(h)\n# 输出：\n# [[1 2 5 6]\n#  [3 4 7 8]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 7. 保存 / 加载数组\n\nnp.save('my_array.npy', a)          # 保存到 .npy 文件\nloaded = np.load('my_array.npy')\nprint(loaded)                        # 输出：与 a 相同的数组\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"16.Rust的String类型基本原理",frontmatter:{title:"16.Rust的String类型基本原理",date:"2025-08-28T23:00:00.000Z",permalink:"/pages/Rust_16/"},regularPath:"/06.Rust/16.Rust%E7%9A%84String%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"06.Rust/16.Rust的String类型基本原理.md",key:"v-655783a0",path:"/pages/Rust_16/",headers:[{level:2,title:"一、String 是什么？",slug:"一、string-是什么",normalizedTitle:"一、string 是什么？",charIndex:178},{level:2,title:"二、怎么创建 String？",slug:"二、怎么创建-string",normalizedTitle:"二、怎么创建 string？",charIndex:378},{level:2,title:"三、如何更新 String？",slug:"三、如何更新-string",normalizedTitle:"三、如何更新 string？",charIndex:572},{level:2,title:"四、拼接要当心",slug:"四、拼接要当心",normalizedTitle:"四、拼接要当心",charIndex:793},{level:2,title:"五、为什么不能像索引数组那样索引 String？",slug:"五、为什么不能像索引数组那样索引-string",normalizedTitle:"五、为什么不能像索引数组那样索引 string？",charIndex:1130},{level:2,title:"六、如果你真的想访问字符怎么办？",slug:"六、如果你真的想访问字符怎么办",normalizedTitle:"六、如果你真的想访问字符怎么办？",charIndex:1397}],headersStr:"一、String 是什么？ 二、怎么创建 String？ 三、如何更新 String？ 四、拼接要当心 五、为什么不能像索引数组那样索引 String？ 六、如果你真的想访问字符怎么办？",content:'# Rust 的 String 类型基础：为什么它既强大又狡猾？\n\nRust 的 String 可变又可增长，背后是 UTF-8，加上 Rust 注重安全，这玩意看似简单实则复杂。掌握它，你就能像撸 cursor 一样骄傲地“管住”自己的字符串，工程师体验极佳。\n\n----------------------------------------\n\n\n# 一、String 是什么？\n\n * 核心语言只有一种“字符串 slice”类型：str，只能以 &str 的形式出现。\n * String 是标准库提供的动态、可变、拥有所有权的 UTF-8 字符串，底层其实就是一个 Vec<u8>。\n * 换句话说：String = 动态字节数组 + UTF-8 智能。\n\n----------------------------------------\n\n\n# 二、怎么创建 String？\n\nlet mut s = String::new(); // 空字符串\n\nlet s = "hello".to_string();            // 从 &str 转换\nlet s = String::from("hello, world");   // 一样的效果\n\n\n\n1\n2\n3\n4\n5\n\n\n这两种方式功能相同，喜欢风格选一种就好。\n\n\n# 三、如何更新 String？\n\n你想给它加内容，可以这么干：\n\nlet mut s = String::from("foo");\ns.push_str("bar");  // 加字符串 slice\ns.push(\'!\');        // 加一个字符\n\n\n1\n2\n3\n\n\n你看这是在操作 Vec<u8>，只有你想追加时才真的改底层，效率杠杠的。\n\n----------------------------------------\n\n\n# 四、拼接要当心\n\n拼字符串挺常见，但写得不小心就容易踩坑：\n\nlet a = String::from("Hello, ");\nlet b = String::from("world!");\nlet c = a + &b; // a 被移动掉，之后不能再用 a 了\n\n\n1\n2\n3\n\n\n别忘了加 &b，Rust 会把 &String 自动转成 &str（叫 deref coercion），但 a 会被消费掉 —— 这是效率和所有权设计的结果。\n\n写得更清晰的方法是：\n\nlet c = format!("{a}-{b}-{a2}");\n\n\n1\n\n\n这样既不会动所有权，也更直观。\n\n----------------------------------------\n\n\n# 五、为什么不能像索引数组那样索引 String？\n\n尝试下面代码，你会碰壁：\n\nlet s = String::from("你好");\nlet c = s[0]; // 直接索引会编译报错\n\n\n1\n2\n\n\n原因在于：\n\n * 字符不是整齐排列的，每个字符在 UTF-8 下字节长度不定；\n * Rust 的索引期望 O(1) 访问，但为了找到一个字符，必须遍历到相应字节 —— 没法保证常数时间；\n * 为防出 bug，索引被禁止写入内核。\n\n----------------------------------------\n\n\n# 六、如果你真的想访问字符怎么办？\n\n明确告诉 Rust：我是按字符访问：\n\nfor c in "你好".chars() {\n    println!("{c}");\n}\n\n\n1\n2\n3\n\n\n如果你想看字节值：\n\nfor b in "你好".bytes() {\n    println!("{b}");\n}\n\n\n1\n2\n3\n\n\n两种表达方式清晰又安全。',normalizedContent:'# rust 的 string 类型基础：为什么它既强大又狡猾？\n\nrust 的 string 可变又可增长，背后是 utf-8，加上 rust 注重安全，这玩意看似简单实则复杂。掌握它，你就能像撸 cursor 一样骄傲地“管住”自己的字符串，工程师体验极佳。\n\n----------------------------------------\n\n\n# 一、string 是什么？\n\n * 核心语言只有一种“字符串 slice”类型：str，只能以 &str 的形式出现。\n * string 是标准库提供的动态、可变、拥有所有权的 utf-8 字符串，底层其实就是一个 vec<u8>。\n * 换句话说：string = 动态字节数组 + utf-8 智能。\n\n----------------------------------------\n\n\n# 二、怎么创建 string？\n\nlet mut s = string::new(); // 空字符串\n\nlet s = "hello".to_string();            // 从 &str 转换\nlet s = string::from("hello, world");   // 一样的效果\n\n\n\n1\n2\n3\n4\n5\n\n\n这两种方式功能相同，喜欢风格选一种就好。\n\n\n# 三、如何更新 string？\n\n你想给它加内容，可以这么干：\n\nlet mut s = string::from("foo");\ns.push_str("bar");  // 加字符串 slice\ns.push(\'!\');        // 加一个字符\n\n\n1\n2\n3\n\n\n你看这是在操作 vec<u8>，只有你想追加时才真的改底层，效率杠杠的。\n\n----------------------------------------\n\n\n# 四、拼接要当心\n\n拼字符串挺常见，但写得不小心就容易踩坑：\n\nlet a = string::from("hello, ");\nlet b = string::from("world!");\nlet c = a + &b; // a 被移动掉，之后不能再用 a 了\n\n\n1\n2\n3\n\n\n别忘了加 &b，rust 会把 &string 自动转成 &str（叫 deref coercion），但 a 会被消费掉 —— 这是效率和所有权设计的结果。\n\n写得更清晰的方法是：\n\nlet c = format!("{a}-{b}-{a2}");\n\n\n1\n\n\n这样既不会动所有权，也更直观。\n\n----------------------------------------\n\n\n# 五、为什么不能像索引数组那样索引 string？\n\n尝试下面代码，你会碰壁：\n\nlet s = string::from("你好");\nlet c = s[0]; // 直接索引会编译报错\n\n\n1\n2\n\n\n原因在于：\n\n * 字符不是整齐排列的，每个字符在 utf-8 下字节长度不定；\n * rust 的索引期望 o(1) 访问，但为了找到一个字符，必须遍历到相应字节 —— 没法保证常数时间；\n * 为防出 bug，索引被禁止写入内核。\n\n----------------------------------------\n\n\n# 六、如果你真的想访问字符怎么办？\n\n明确告诉 rust：我是按字符访问：\n\nfor c in "你好".chars() {\n    println!("{c}");\n}\n\n\n1\n2\n3\n\n\n如果你想看字节值：\n\nfor b in "你好".bytes() {\n    println!("{b}");\n}\n\n\n1\n2\n3\n\n\n两种表达方式清晰又安全。',charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"02.pandas 模块",frontmatter:{title:"02.pandas 模块",date:"2025-09-26T22:30:00.000Z",permalink:"/pages/Python_02/"},regularPath:"/07.python/02.pandas%20%E6%A8%A1%E5%9D%97.html",relativePath:"07.python/02.pandas 模块.md",key:"v-dcf90e9e",path:"/pages/Python_02/",headers:[{level:2,title:"Pandas 简介",slug:"pandas-简介",normalizedTitle:"pandas 简介",charIndex:16},{level:2,title:"📌 Pandas 常用方法（方法签名 + 参数解释）",slug:"📌-pandas-常用方法-方法签名-参数解释",normalizedTitle:"📌 pandas 常用方法（方法签名 + 参数解释）",charIndex:512},{level:3,title:"创建对象",slug:"创建对象",normalizedTitle:"创建对象",charIndex:544},{level:3,title:"查看信息",slug:"查看信息",normalizedTitle:"查看信息",charIndex:949},{level:3,title:"选择与切片",slug:"选择与切片",normalizedTitle:"选择与切片",charIndex:1256},{level:3,title:"增删改",slug:"增删改",normalizedTitle:"增删改",charIndex:1524},{level:3,title:"缺失值处理",slug:"缺失值处理",normalizedTitle:"缺失值处理",charIndex:388},{level:3,title:"重复值处理",slug:"重复值处理",normalizedTitle:"重复值处理",charIndex:2182},{level:3,title:"分组与聚合",slug:"分组与聚合",normalizedTitle:"分组与聚合",charIndex:2436},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:2637},{level:3,title:"合并拼接",slug:"合并拼接",normalizedTitle:"合并拼接",charIndex:2853},{level:3,title:"输入输出",slug:"输入输出",normalizedTitle:"输入输出",charIndex:3165},{level:2,title:"pandas 主要方法与功能示例",slug:"pandas-主要方法与功能示例",normalizedTitle:"pandas 主要方法与功能示例",charIndex:3447},{level:3,title:"1. pandas 认识：Series 与 DataFrame",slug:"_1-pandas-认识-series-与-dataframe",normalizedTitle:"1. pandas 认识：series 与 dataframe",charIndex:3583},{level:3,title:"2. DataFrame",slug:"_2-dataframe",normalizedTitle:"2. dataframe",charIndex:4317},{level:3,title:"3. 基本操作：增、删、改、查",slug:"_3-基本操作-增、删、改、查",normalizedTitle:"3. 基本操作：增、删、改、查",charIndex:5051},{level:3,title:"4. 缺失值 & 重复值处理",slug:"_4-缺失值-重复值处理",normalizedTitle:"4. 缺失值 &amp; 重复值处理",charIndex:null},{level:3,title:"5. 分组与聚合（GroupBy）",slug:"_5-分组与聚合-groupby",normalizedTitle:"5. 分组与聚合（groupby）",charIndex:5792},{level:3,title:"6. 合并 / 连接 / 拼接",slug:"_6-合并-连接-拼接",normalizedTitle:"6. 合并 / 连接 / 拼接",charIndex:6152},{level:3,title:"7. 时间序列操作（简要）",slug:"_7-时间序列操作-简要",normalizedTitle:"7. 时间序列操作（简要）",charIndex:6689},{level:3,title:"8. 读取 / 存储数据",slug:"_8-读取-存储数据",normalizedTitle:"8. 读取 / 存储数据",charIndex:7070}],headersStr:"Pandas 简介 📌 Pandas 常用方法（方法签名 + 参数解释） 创建对象 查看信息 选择与切片 增删改 缺失值处理 重复值处理 分组与聚合 排序 合并拼接 输入输出 pandas 主要方法与功能示例 1. pandas 认识：Series 与 DataFrame 2. DataFrame 3. 基本操作：增、删、改、查 4. 缺失值 & 重复值处理 5. 分组与聚合（GroupBy） 6. 合并 / 连接 / 拼接 7. 时间序列操作（简要） 8. 读取 / 存储数据",content:"# pandas 模块\n\n\n# Pandas 简介\n\nPandas（来源于 Panel Data）是基于 NumPy 的一个强大数据分析与处理库。它提供了两个核心数据结构：\n\n * Series：一维带标签的数组（类似带索引的一列数据）\n * DataFrame：二维表格型数据（类似 Excel 表格 / SQL 表）\n\nPandas 在数据清洗、分析、特征工程、金融建模等领域应用广泛，是 Python 数据科学与机器学习的核心库之一。\n\n特点包括：\n\n * 高效的数据结构：Series 和 DataFrame 基于 NumPy，支持高效存储与计算\n * 灵活的数据索引与切片：支持按标签（label）、位置（position）访问数据\n * 丰富的数据操作：分组（groupby）、聚合（aggregate）、透视表（pivot_table）等\n * 数据清洗与处理：缺失值处理、数据类型转换、字符串与时间序列处理\n * 文件读写能力：支持 CSV、Excel、SQL、JSON 等多种格式的高效读写\n * 与其他科学计算库兼容：可与 NumPy、Matplotlib、Scikit-learn 等无缝结合\n\n\n# 📌 Pandas 常用方法（方法签名 + 参数解释）\n\n\n# 创建对象\n\n * pd.Series(data=None, index=None, dtype=None, name=None, copy=False) → 创建一维数组结构。\n   * data：数据，可为list/ndarray/dict等\n   * index：索引标签\n   * dtype：数据类型\n   * name：Series 名称\n   * copy：是否复制数据\n * pd.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) → 创建二维表格结构。\n   * data：二维数据（dict/ndarray等）\n   * index：行索引\n   * columns：列索引\n   * dtype：数据类型\n\n----------------------------------------\n\n\n# 查看信息\n\n * df.head(n=5) → 返回前 n 行。\n * df.tail(n=5) → 返回后 n 行。\n * df.info(verbose=None, buf=None, max_cols=None, memory_usage=None, show_counts=None) → 显示数据表概况。\n * df.describe(percentiles=None, include=None, exclude=None, datetime_is_numeric=False) → 生成数值型列的统计信息。\n\n----------------------------------------\n\n\n# 选择与切片\n\n * df.loc[row_indexer, col_indexer] → 按 标签 选择数据。\n * df.iloc[row_indexer, col_indexer] → 按 位置 选择数据。\n * df.query(expr, inplace=False, **kwargs) → 用表达式筛选数据。\n   * expr：字符串表达式（如 \"col > 3 & col < 10\"）\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 增删改\n\n * df.drop(labels=None, axis=0, index=None, columns=None, inplace=False) → 删除行或列。\n   * labels：要删除的行/列名\n   * axis：0=行, 1=列\n   * inplace：是否原地修改\n * df.rename(mapper=None, index=None, columns=None, inplace=False) → 重命名行/列。\n   * columns：字典，旧列名→新列名\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 缺失值处理\n\n * df.isnull() → 返回布尔值 DataFrame，标记缺失值。\n * df.fillna(value=None, method=None, inplace=False, limit=None) → 填充缺失值。\n   * value：填充值\n   * method：填充方式（'ffill' 向前填充, 'bfill' 向后填充）\n * df.dropna(axis=0, how='any', inplace=False) → 删除含缺失值的行/列。\n   * axis：0=行, 1=列\n   * how：'any'=任意NaN删除, 'all'=全NaN删除\n\n----------------------------------------\n\n\n# 重复值处理\n\n * df.duplicated(subset=None, keep='first') → 返回布尔Series，标记重复行。\n * df.drop_duplicates(subset=None, keep='first', inplace=False) → 删除重复行。\n   * subset：指定检查的列\n   * keep：保留哪一个（'first' / 'last' / False 全删）\n\n----------------------------------------\n\n\n# 分组与聚合\n\n * df.groupby(by=None, axis=0, as_index=True) → 分组对象。\n   * by：列名/函数/数组\n   * as_index：是否返回索引为分组键\n * grouped.agg(func=None, *args, **kwargs) → 多函数聚合。\n\n----------------------------------------\n\n\n# 排序\n\n * df.sort_values(by, axis=0, ascending=True, inplace=False) → 按列值排序。\n   * by：列名\n   * ascending：是否升序\n * df.sort_index(axis=0, ascending=True, inplace=False) → 按索引排序。\n\n----------------------------------------\n\n\n# 合并拼接\n\n * pd.concat(objs, axis=0, join='outer', ignore_index=False) → 沿某维拼接对象。\n   * objs：列表/字典\n   * axis：0=纵向, 1=横向\n * pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None) → 类似SQL join的合并。\n   * how：'inner' / 'outer' / 'left' / 'right'\n   * on：公共列\n\n----------------------------------------\n\n\n# 输入输出\n\n * pd.read_csv(filepath, sep=',', header='infer', encoding=None) → 从 CSV 文件读取数据。\n * df.to_csv(path, sep=',', index=True, encoding='utf-8') → 保存为 CSV。\n * pd.read_excel(io, sheet_name=0) → 读取 Excel。\n * df.to_excel(excel_writer, sheet_name='Sheet1', index=True) → 保存为 Excel。\n\n\n# pandas 主要方法与功能示例\n\n在使用pandas之前，需要确保已经import\n\nimport numpy as np\nimport pandas as pd\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 1. pandas 认识：Series 与 DataFrame\n\n# 1.1 Series\n\n# 用列表创建 Series（带默认索引 0,1,2...）\ns = pd.Series([10, 20, 30, 40])\nprint(s)\n# 输出：\n# 0    10\n# 1    20\n# 2    30\n# 3    40\n# dtype: int64\n\n# 用自定义索引\ns2 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\nprint(s2['a'])  # 输出：1\nprint(s2.loc['b'])  # 输出：2\nprint(s2.iloc[1])  # 输出：2\n\n# 从 numpy 数组创建 Series（共享底层数据）\narr = np.array([5, 6, 7])\ns3 = pd.Series(arr)\nprint(s3)\n# 修改原数组也影响 Series\narr[1] = 100\nprint(s3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 1.2 用字典创建 Series\n\nd = {'name': '张三', 'age': 18, 'sex': '男'}\ns_dict = pd.Series(d)\nprint(s_dict)\n# 输出：\n# name    张三\n# age       18\n# sex       男\n# dtype: object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n\n# 2. DataFrame\n\n# 用字典创建 DataFrame（每个键对应一列）\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'score': [88.5, 92.0, 85.0]\n})\nprint(df)\n# 输出：\n#       name  age  score\n# 0    Alice   25   88.5\n# 1      Bob   30   92.0\n# 2  Charlie   35   85.0\n\n# 查看属性\nprint(df.shape)       # 输出：(3, 3)\nprint(df.columns)     # 输出：Index(['name', 'age', 'score'], dtype='object')\nprint(df.index)       # 输出：RangeIndex(start=0, stop=3, step=1)\nprint(df.dtypes)      # 输出每列的数据类型\n\n# 访问列与行\nprint(df['name'])        # 这会返回一个 Series\nprint(df.loc[1])         # 第 1 行数据（标签位置）\nprint(df.iloc[0:2, 0:2])  # 用位置切片：前两行，前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 基本操作：增、删、改、查\n\n# 新增列\ndf['newcol'] = df['age'] * 2\nprint(df)\n\n# 删除列\ndf2 = df.drop(columns=['newcol'])\nprint(df2)\n\n# 修改值\ndf.at[1, 'age'] = 31\nprint(df.loc[1])\n\n# 条件过滤 / 布尔索引\ndf_filtered = df[df['score'] > 90]\nprint(df_filtered)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 缺失值 & 重复值处理\n\n# 构造带 NaN 的 DataFrame\ndf_missing = pd.DataFrame({\n    'A': [1, np.nan, 3],\n    'B': [4, 5, np.nan]\n})\nprint(df_missing)\n\n# 检查缺失值\nprint(df_missing.isnull())\nprint(df_missing.isnull().sum())\n\n# 填充缺失值\ndf_fill0 = df_missing.fillna(0)\nprint(df_fill0)\n\n# 删除含缺失值的行/列\ndf_drop = df_missing.dropna(axis=0)  # 删除行\nprint(df_drop)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 5. 分组与聚合（GroupBy）\n\n# 示例 DataFrame\ndf3 = pd.DataFrame({\n    'key': ['A', 'B', 'A', 'B'],\n    'value': [10, 20, 15, 25]\n})\n\ngrouped = df3.groupby('key')\nprint(grouped.sum())\n# 输出：\n#      value\n# key       \n# A        25\n# B        45\n\nprint(grouped['value'].mean())\n# 输出平均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 6. 合并 / 连接 / 拼接\n\ndf1 = pd.DataFrame({'id': [1,2,3], 'x': ['a','b','c']})\ndf2 = pd.DataFrame({'id': [2,3,4], 'y': [20, 30, 40]})\n\n# 内连接（类似 SQL 的 inner join）\ndf_join = pd.merge(df1, df2, on='id', how='inner')\nprint(df_join)\n\n# 外连接\ndf_outer = pd.merge(df1, df2, on='id', how='outer')\nprint(df_outer)\n\n# 拼接（上下 / 左右方向）\ndf_vert = pd.concat([df1, df2], axis=0, ignore_index=True)\nprint(df_vert)\n\ndf_horiz = pd.concat([df1, df2], axis=1)\nprint(df_horiz)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 7. 时间序列操作（简要）\n\ndates = pd.date_range('2025-01-01', periods=6, freq='D')\ndf_ts = pd.DataFrame({\n    'date': dates,\n    'value': [10, 12, 11, 15, 14, 13]\n})\ndf_ts = df_ts.set_index('date')\nprint(df_ts)\n\n# 重采样 / 滚动窗口\nprint(df_ts.resample('2D').mean())   # 每两天取平均\nprint(df_ts.rolling(window=3).mean())  # 滑动窗口均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 8. 读取 / 存储数据\n\n# 读取 CSV\ndf_csv = pd.read_csv('data.csv')\n# 写入 CSV\ndf_csv.to_csv('out.csv', index=False)\n\n# 读取 Excel\n# df_excel = pd.read_excel('data.xlsx', sheet_name='Sheet1')\n# 写入 Excel\n# df_excel.to_excel('out.xlsx', index=False)\n\n# 读取 / 写入 JSON\n# df_json = pd.read_json('data.json')\n# df_csv.to_json('out.json')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",normalizedContent:"# pandas 模块\n\n\n# pandas 简介\n\npandas（来源于 panel data）是基于 numpy 的一个强大数据分析与处理库。它提供了两个核心数据结构：\n\n * series：一维带标签的数组（类似带索引的一列数据）\n * dataframe：二维表格型数据（类似 excel 表格 / sql 表）\n\npandas 在数据清洗、分析、特征工程、金融建模等领域应用广泛，是 python 数据科学与机器学习的核心库之一。\n\n特点包括：\n\n * 高效的数据结构：series 和 dataframe 基于 numpy，支持高效存储与计算\n * 灵活的数据索引与切片：支持按标签（label）、位置（position）访问数据\n * 丰富的数据操作：分组（groupby）、聚合（aggregate）、透视表（pivot_table）等\n * 数据清洗与处理：缺失值处理、数据类型转换、字符串与时间序列处理\n * 文件读写能力：支持 csv、excel、sql、json 等多种格式的高效读写\n * 与其他科学计算库兼容：可与 numpy、matplotlib、scikit-learn 等无缝结合\n\n\n# 📌 pandas 常用方法（方法签名 + 参数解释）\n\n\n# 创建对象\n\n * pd.series(data=none, index=none, dtype=none, name=none, copy=false) → 创建一维数组结构。\n   * data：数据，可为list/ndarray/dict等\n   * index：索引标签\n   * dtype：数据类型\n   * name：series 名称\n   * copy：是否复制数据\n * pd.dataframe(data=none, index=none, columns=none, dtype=none, copy=false) → 创建二维表格结构。\n   * data：二维数据（dict/ndarray等）\n   * index：行索引\n   * columns：列索引\n   * dtype：数据类型\n\n----------------------------------------\n\n\n# 查看信息\n\n * df.head(n=5) → 返回前 n 行。\n * df.tail(n=5) → 返回后 n 行。\n * df.info(verbose=none, buf=none, max_cols=none, memory_usage=none, show_counts=none) → 显示数据表概况。\n * df.describe(percentiles=none, include=none, exclude=none, datetime_is_numeric=false) → 生成数值型列的统计信息。\n\n----------------------------------------\n\n\n# 选择与切片\n\n * df.loc[row_indexer, col_indexer] → 按 标签 选择数据。\n * df.iloc[row_indexer, col_indexer] → 按 位置 选择数据。\n * df.query(expr, inplace=false, **kwargs) → 用表达式筛选数据。\n   * expr：字符串表达式（如 \"col > 3 & col < 10\"）\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 增删改\n\n * df.drop(labels=none, axis=0, index=none, columns=none, inplace=false) → 删除行或列。\n   * labels：要删除的行/列名\n   * axis：0=行, 1=列\n   * inplace：是否原地修改\n * df.rename(mapper=none, index=none, columns=none, inplace=false) → 重命名行/列。\n   * columns：字典，旧列名→新列名\n   * inplace：是否原地修改\n\n----------------------------------------\n\n\n# 缺失值处理\n\n * df.isnull() → 返回布尔值 dataframe，标记缺失值。\n * df.fillna(value=none, method=none, inplace=false, limit=none) → 填充缺失值。\n   * value：填充值\n   * method：填充方式（'ffill' 向前填充, 'bfill' 向后填充）\n * df.dropna(axis=0, how='any', inplace=false) → 删除含缺失值的行/列。\n   * axis：0=行, 1=列\n   * how：'any'=任意nan删除, 'all'=全nan删除\n\n----------------------------------------\n\n\n# 重复值处理\n\n * df.duplicated(subset=none, keep='first') → 返回布尔series，标记重复行。\n * df.drop_duplicates(subset=none, keep='first', inplace=false) → 删除重复行。\n   * subset：指定检查的列\n   * keep：保留哪一个（'first' / 'last' / false 全删）\n\n----------------------------------------\n\n\n# 分组与聚合\n\n * df.groupby(by=none, axis=0, as_index=true) → 分组对象。\n   * by：列名/函数/数组\n   * as_index：是否返回索引为分组键\n * grouped.agg(func=none, *args, **kwargs) → 多函数聚合。\n\n----------------------------------------\n\n\n# 排序\n\n * df.sort_values(by, axis=0, ascending=true, inplace=false) → 按列值排序。\n   * by：列名\n   * ascending：是否升序\n * df.sort_index(axis=0, ascending=true, inplace=false) → 按索引排序。\n\n----------------------------------------\n\n\n# 合并拼接\n\n * pd.concat(objs, axis=0, join='outer', ignore_index=false) → 沿某维拼接对象。\n   * objs：列表/字典\n   * axis：0=纵向, 1=横向\n * pd.merge(left, right, how='inner', on=none, left_on=none, right_on=none) → 类似sql join的合并。\n   * how：'inner' / 'outer' / 'left' / 'right'\n   * on：公共列\n\n----------------------------------------\n\n\n# 输入输出\n\n * pd.read_csv(filepath, sep=',', header='infer', encoding=none) → 从 csv 文件读取数据。\n * df.to_csv(path, sep=',', index=true, encoding='utf-8') → 保存为 csv。\n * pd.read_excel(io, sheet_name=0) → 读取 excel。\n * df.to_excel(excel_writer, sheet_name='sheet1', index=true) → 保存为 excel。\n\n\n# pandas 主要方法与功能示例\n\n在使用pandas之前，需要确保已经import\n\nimport numpy as np\nimport pandas as pd\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 1. pandas 认识：series 与 dataframe\n\n# 1.1 series\n\n# 用列表创建 series（带默认索引 0,1,2...）\ns = pd.series([10, 20, 30, 40])\nprint(s)\n# 输出：\n# 0    10\n# 1    20\n# 2    30\n# 3    40\n# dtype: int64\n\n# 用自定义索引\ns2 = pd.series([1, 2, 3], index=['a', 'b', 'c'])\nprint(s2['a'])  # 输出：1\nprint(s2.loc['b'])  # 输出：2\nprint(s2.iloc[1])  # 输出：2\n\n# 从 numpy 数组创建 series（共享底层数据）\narr = np.array([5, 6, 7])\ns3 = pd.series(arr)\nprint(s3)\n# 修改原数组也影响 series\narr[1] = 100\nprint(s3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 1.2 用字典创建 series\n\nd = {'name': '张三', 'age': 18, 'sex': '男'}\ns_dict = pd.series(d)\nprint(s_dict)\n# 输出：\n# name    张三\n# age       18\n# sex       男\n# dtype: object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n\n# 2. dataframe\n\n# 用字典创建 dataframe（每个键对应一列）\ndf = pd.dataframe({\n    'name': ['alice', 'bob', 'charlie'],\n    'age': [25, 30, 35],\n    'score': [88.5, 92.0, 85.0]\n})\nprint(df)\n# 输出：\n#       name  age  score\n# 0    alice   25   88.5\n# 1      bob   30   92.0\n# 2  charlie   35   85.0\n\n# 查看属性\nprint(df.shape)       # 输出：(3, 3)\nprint(df.columns)     # 输出：index(['name', 'age', 'score'], dtype='object')\nprint(df.index)       # 输出：rangeindex(start=0, stop=3, step=1)\nprint(df.dtypes)      # 输出每列的数据类型\n\n# 访问列与行\nprint(df['name'])        # 这会返回一个 series\nprint(df.loc[1])         # 第 1 行数据（标签位置）\nprint(df.iloc[0:2, 0:2])  # 用位置切片：前两行，前两列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\n\n# 3. 基本操作：增、删、改、查\n\n# 新增列\ndf['newcol'] = df['age'] * 2\nprint(df)\n\n# 删除列\ndf2 = df.drop(columns=['newcol'])\nprint(df2)\n\n# 修改值\ndf.at[1, 'age'] = 31\nprint(df.loc[1])\n\n# 条件过滤 / 布尔索引\ndf_filtered = df[df['score'] > 90]\nprint(df_filtered)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\n\n# 4. 缺失值 & 重复值处理\n\n# 构造带 nan 的 dataframe\ndf_missing = pd.dataframe({\n    'a': [1, np.nan, 3],\n    'b': [4, 5, np.nan]\n})\nprint(df_missing)\n\n# 检查缺失值\nprint(df_missing.isnull())\nprint(df_missing.isnull().sum())\n\n# 填充缺失值\ndf_fill0 = df_missing.fillna(0)\nprint(df_fill0)\n\n# 删除含缺失值的行/列\ndf_drop = df_missing.dropna(axis=0)  # 删除行\nprint(df_drop)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n----------------------------------------\n\n\n# 5. 分组与聚合（groupby）\n\n# 示例 dataframe\ndf3 = pd.dataframe({\n    'key': ['a', 'b', 'a', 'b'],\n    'value': [10, 20, 15, 25]\n})\n\ngrouped = df3.groupby('key')\nprint(grouped.sum())\n# 输出：\n#      value\n# key       \n# a        25\n# b        45\n\nprint(grouped['value'].mean())\n# 输出平均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 6. 合并 / 连接 / 拼接\n\ndf1 = pd.dataframe({'id': [1,2,3], 'x': ['a','b','c']})\ndf2 = pd.dataframe({'id': [2,3,4], 'y': [20, 30, 40]})\n\n# 内连接（类似 sql 的 inner join）\ndf_join = pd.merge(df1, df2, on='id', how='inner')\nprint(df_join)\n\n# 外连接\ndf_outer = pd.merge(df1, df2, on='id', how='outer')\nprint(df_outer)\n\n# 拼接（上下 / 左右方向）\ndf_vert = pd.concat([df1, df2], axis=0, ignore_index=true)\nprint(df_vert)\n\ndf_horiz = pd.concat([df1, df2], axis=1)\nprint(df_horiz)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 7. 时间序列操作（简要）\n\ndates = pd.date_range('2025-01-01', periods=6, freq='d')\ndf_ts = pd.dataframe({\n    'date': dates,\n    'value': [10, 12, 11, 15, 14, 13]\n})\ndf_ts = df_ts.set_index('date')\nprint(df_ts)\n\n# 重采样 / 滚动窗口\nprint(df_ts.resample('2d').mean())   # 每两天取平均\nprint(df_ts.rolling(window=3).mean())  # 滑动窗口均值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n----------------------------------------\n\n\n# 8. 读取 / 存储数据\n\n# 读取 csv\ndf_csv = pd.read_csv('data.csv')\n# 写入 csv\ndf_csv.to_csv('out.csv', index=false)\n\n# 读取 excel\n# df_excel = pd.read_excel('data.xlsx', sheet_name='sheet1')\n# 写入 excel\n# df_excel.to_excel('out.xlsx', index=false)\n\n# 读取 / 写入 json\n# df_json = pd.read_json('data.json')\n# df_csv.to_json('out.json')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-01b5feb6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2026/02/22, 21:14:18"},{title:"03.matplotlib 模块",frontmatter:{title:"03.matplotlib 模块",date:"2025-09-27T14:30:00.000Z",permalink:"/pages/Python_03/"},regularPath:"/07.python/03.matplotlib%20%E6%A8%A1%E5%9D%97.html",relativePath:"07.python/03.matplotlib 模块.md",key:"v-51e1c7f6",path:"/pages/Python_03/",headers:[{level:2,title:"Matplotlib 简介",slug:"matplotlib-简介",normalizedTitle:"matplotlib 简介",charIndex:20},{level:2,title:"一、绘图基础",slug:"一、绘图基础",normalizedTitle:"一、绘图基础",charIndex:392},{level:3,title:"1.1 导入与接口风格",slug:"_1-1-导入与接口风格",normalizedTitle:"1.1 导入与接口风格",charIndex:403},{level:3,title:"1.2 Figure / Axes / Axis 概念",slug:"_1-2-figure-axes-axis-概念",normalizedTitle:"1.2 figure / axes / axis 概念",charIndex:675},{level:3,title:"1.3 显示与保存",slug:"_1-3-显示与保存",normalizedTitle:"1.3 显示与保存",charIndex:1025},{level:2,title:"二、常见图表（函数归纳 + 示例）",slug:"二、常见图表-函数归纳-示例",normalizedTitle:"二、常见图表（函数归纳 + 示例）",charIndex:1281},{level:3,title:"2.1 折线图（Line Plot）",slug:"_2-1-折线图-line-plot",normalizedTitle:"2.1 折线图（line plot）",charIndex:1324},{level:3,title:"2.2 散点图（Scatter）",slug:"_2-2-散点图-scatter",normalizedTitle:"2.2 散点图（scatter）",charIndex:1682},{level:3,title:"2.3 柱状图（Bar）",slug:"_2-3-柱状图-bar",normalizedTitle:"2.3 柱状图（bar）",charIndex:2030},{level:3,title:"2.4 直方图（Histogram）",slug:"_2-4-直方图-histogram",normalizedTitle:"2.4 直方图（histogram）",charIndex:2535},{level:3,title:"2.5 饼图（Pie）",slug:"_2-5-饼图-pie",normalizedTitle:"2.5 饼图（pie）",charIndex:2826},{level:3,title:"2.6 箱型图（Boxplot）",slug:"_2-6-箱型图-boxplot",normalizedTitle:"2.6 箱型图（boxplot）",charIndex:3116},{level:3,title:"2.7 小提琴图（Violinplot）",slug:"_2-7-小提琴图-violinplot",normalizedTitle:"2.7 小提琴图（violinplot）",charIndex:3341},{level:2,title:"三、进阶绘图",slug:"三、进阶绘图",normalizedTitle:"三、进阶绘图",charIndex:3620},{level:3,title:"3.1 双轴（twinx / twiny）",slug:"_3-1-双轴-twinx-twiny",normalizedTitle:"3.1 双轴（twinx / twiny）",charIndex:3631},{level:3,title:"3.2 多子图与布局控制",slug:"_3-2-多子图与布局控制",normalizedTitle:"3.2 多子图与布局控制",charIndex:3829},{level:3,title:"3.3 等高线（Contour）与热力图（Heatmap）",slug:"_3-3-等高线-contour-与热力图-heatmap",normalizedTitle:"3.3 等高线（contour）与热力图（heatmap）",charIndex:4180},{level:3,title:"3.4 向量场（Quiver）",slug:"_3-4-向量场-quiver",normalizedTitle:"3.4 向量场（quiver）",charIndex:4519},{level:3,title:"3.5 3D 绘图（简要）",slug:"_3-5-3d-绘图-简要",normalizedTitle:"3.5 3d 绘图（简要）",charIndex:4721},{level:2,title:"四、美化与增强（提高可读性与出版级图表）",slug:"四、美化与增强-提高可读性与出版级图表",normalizedTitle:"四、美化与增强（提高可读性与出版级图表）",charIndex:5005},{level:3,title:"4.1 坐标轴与刻度控制",slug:"_4-1-坐标轴与刻度控制",normalizedTitle:"4.1 坐标轴与刻度控制",charIndex:5030},{level:3,title:"4.2 边框（Spines）与坐标比例",slug:"_4-2-边框-spines-与坐标比例",normalizedTitle:"4.2 边框（spines）与坐标比例",charIndex:5278},{level:3,title:"4.3 图例（Legend）",slug:"_4-3-图例-legend",normalizedTitle:"4.3 图例（legend）",charIndex:5409},{level:3,title:"4.4 文本与注释（text / annotate）",slug:"_4-4-文本与注释-text-annotate",normalizedTitle:"4.4 文本与注释（text / annotate）",charIndex:5671},{level:3,title:"4.5 数学公式（MathText）",slug:"_4-5-数学公式-mathtext",normalizedTitle:"4.5 数学公式（mathtext）",charIndex:5933},{level:3,title:"4.6 颜色与色图（colormap）",slug:"_4-6-颜色与色图-colormap",normalizedTitle:"4.6 颜色与色图（colormap）",charIndex:6053},{level:3,title:"4.7 图像读写（imread / imsave / imshow）",slug:"_4-7-图像读写-imread-imsave-imshow",normalizedTitle:"4.7 图像读写（imread / imsave / imshow）",charIndex:6270},{level:3,title:"4.8 坐标转换（Transforms）",slug:"_4-8-坐标转换-transforms",normalizedTitle:"4.8 坐标转换（transforms）",charIndex:6444}],headersStr:"Matplotlib 简介 一、绘图基础 1.1 导入与接口风格 1.2 Figure / Axes / Axis 概念 1.3 显示与保存 二、常见图表（函数归纳 + 示例） 2.1 折线图（Line Plot） 2.2 散点图（Scatter） 2.3 柱状图（Bar） 2.4 直方图（Histogram） 2.5 饼图（Pie） 2.6 箱型图（Boxplot） 2.7 小提琴图（Violinplot） 三、进阶绘图 3.1 双轴（twinx / twiny） 3.2 多子图与布局控制 3.3 等高线（Contour）与热力图（Heatmap） 3.4 向量场（Quiver） 3.5 3D 绘图（简要） 四、美化与增强（提高可读性与出版级图表） 4.1 坐标轴与刻度控制 4.2 边框（Spines）与坐标比例 4.3 图例（Legend） 4.4 文本与注释（text / annotate） 4.5 数学公式（MathText） 4.6 颜色与色图（colormap） 4.7 图像读写（imread / imsave / imshow） 4.8 坐标转换（Transforms）",content:"# Matplotlib 模块\n\n\n# Matplotlib 简介\n\nMatplotlib 是 Python 中最常用的可视化库之一，尤其是其中的 pyplot 模块， 提供了类似 Matlab 的绘图接口。它适合快速绘制折线图、散点图、柱状图、直方图、饼图等， 并且可以对图像进行灵活的修饰（标题、坐标轴、图例、网格、子图等）。\n\n特点：\n\n * 功能全面：支持常见 2D 图表和部分 3D 图表\n * 使用灵活：可以快捷调用 pyplot 画图，也可以精细控制 Figure 和 Axes\n * 与 NumPy / Pandas / SciPy 无缝结合\n * 丰富的自定义：颜色、线型、标记、布局等均可调整\n\n通常的下载方法：\n\npip install matplotlib\n\n\n1\n\n\n----------------------------------------\n\n\n# 一、绘图基础\n\n\n# 1.1 导入与接口风格\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n1\n2\n\n\nMatplotlib 常见有两种接口风格：\n\n * Pyplot（状态机）接口：plt.plot(...)，快捷，适合交互与一次性小图。类似 MATLAB 风格。\n * 面向对象（OO）接口：先创建 Figure / Axes，然后在 Axes 上调用方法（如 ax.plot(...)）。更灵活、适合复杂布局和脚本化绘图。\n\n建议以 OO 接口为主，必要时在交互中使用 plt 快捷方法。\n\n\n# 1.2 Figure / Axes / Axis 概念\n\n * Figure：整个图像（画布）。\n * Axes：绘图区域（包含坐标轴、刻度、标题、图例等）。一个 Figure 可包含多个 Axes。\n * Axis：坐标轴（x、y、z），负责刻度和刻度标签。\n\n创建方式：\n\nfig, ax = plt.subplots(figsize=(8,5), dpi=100)\n# 多子图\nfig, axes = plt.subplots(2, 2, figsize=(10,8))\n\n\n1\n2\n3\n\n\nfigsize 单位为英寸 (inch)，图像像素大小 = figsize * dpi。tight_layout() 或 constrained_layout=True 用于自动调整子图间距。\n\n\n# 1.3 显示与保存\n\nplt.show()  # 在交互式环境显示\nfig.savefig('out.png', dpi=300, bbox_inches='tight', transparent=False)\n\n\n1\n2\n\n\n常用 savefig 参数：\n\n * dpi：分辨率\n * bbox_inches='tight'：紧凑边界，避免标签被截断\n * transparent=True：透明背景（适合嵌入网页）\n\n----------------------------------------\n\n\n# 二、常见图表（函数归纳 + 示例）\n\n> 每个小节都给出常用参数与最小示例。\n\n\n# 2.1 折线图（Line Plot）\n\n函数：ax.plot(x, y, **kwargs)\n\n常用参数：color/c、linestyle/ls、linewidth/lw、marker、markersize/ms、label\n\nx = np.linspace(0, 2*np.pi, 200)\ny = np.sin(x)\nfig, ax = plt.subplots()\nax.plot(x, y, label=r'$y=\\sin x$', lw=2, ls='-', marker=None)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n备注：可绘多条线，常与 ax.fill_between（区域填充）配合。\n\n\n# 2.2 散点图（Scatter）\n\n函数：ax.scatter(x, y, c=None, s=None, marker=None, cmap=None, alpha=None)\n\n * c：颜色或数值数组（配合 cmap）\n * s：点大小（或数组）\n * alpha：透明度\n\nx = np.random.rand(100)\ny = np.random.rand(100)\ns = 50 * np.random.rand(100)\nfig, ax = plt.subplots()\nax.scatter(x, y, c=y, s=s, cmap='viridis', alpha=0.8)\nax.set_title('Scatter example')\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 柱状图（Bar）\n\n函数：ax.bar(x, height, width=0.8, bottom=None, align='center', **kwargs) 或 ax.barh（水平柱状）\n\n * 分组条形图：移动 x 的偏移量；堆叠条形图：使用 bottom 指定下边界\n\nlabels = ['A','B','C']\nval1 = [10, 15, 7]\nval2 = [5, 8, 3]\nind = np.arange(len(labels))\nwidth = 0.35\nfig, ax = plt.subplots()\nax.bar(ind - width/2, val1, width, label='G1')\nax.bar(ind + width/2, val2, width, label='G2')\nax.set_xticks(ind)\nax.set_xticklabels(labels)\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n堆叠示例：ax.bar(x, val1); ax.bar(x, val2, bottom=val1)\n\n\n# 2.4 直方图（Histogram）\n\n函数：ax.hist(data, bins=10, range=None, density=False, histtype='bar', alpha=0.7)\n\n * density=True 将 y 转为概率密度\n * bins 可为整数或序列（自定义切分区间）\n\ndata = np.random.normal(loc=0, scale=1, size=1000)\nfig, ax = plt.subplots()\nax.hist(data, bins=30, density=True, alpha=0.6)\n\n\n1\n2\n3\n\n\n\n# 2.5 饼图（Pie）\n\n函数：ax.pie(sizes, labels=None, autopct=None, startangle=0, explode=None)\n\n * autopct='%.1f%%' 自动显示百分比\n\nsizes = [30, 45, 25]\nlabels = ['A','B','C']\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%.1f%%', startangle=90)\nax.axis('equal')  # 使饼图为圆形\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.6 箱型图（Boxplot）\n\n函数：ax.boxplot(data, notch=False, patch_artist=False)\n\n * 展示中位数、四分位、异常值\n\ndata = [np.random.normal(i, 1, 200) for i in range(3)]\nfig, ax = plt.subplots()\nax.boxplot(data, labels=['G1','G2','G3'])\n\n\n1\n2\n3\n\n\n\n# 2.7 小提琴图（Violinplot）\n\n函数：ax.violinplot(dataset, showmeans=False, showmedians=True)\n\n * 能显示数据分布的核密度估计，比箱型图更直观地展现分布形态\n\nfig, ax = plt.subplots()\nax.violinplot(data)\nax.set_xticks([1,2,3])\nax.set_xticklabels(['G1','G2','G3'])\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 三、进阶绘图\n\n\n# 3.1 双轴（twinx / twiny）\n\n> 用于 x 轴共享但 y 轴单位不同的情况。\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax1.plot(x, y1, 'g-', label='y1')\nax2.plot(x, y2, 'b--', label='y2')\n\n\n1\n2\n3\n4\n\n\n要注意图例可分别处理或手动合并图例条目。\n\n\n# 3.2 多子图与布局控制\n\n * plt.subplots(nrows, ncols, figsize=...)\n * GridSpec / plt.subplot2grid：更灵活的网格控制\n * constrained_layout=True 或 fig.tight_layout()：自动收紧布局\n\nfrom matplotlib.gridspec import GridSpec\nfig = plt.figure(figsize=(8,6))\ngs = GridSpec(3, 3, figure=fig)\nax_main = fig.add_subplot(gs[0:2, :])\nax_bottom = fig.add_subplot(gs[2, :])\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 等高线（Contour）与热力图（Heatmap）\n\nX = np.linspace(-3, 3, 200)\nY = np.linspace(-3, 3, 200)\nX, Y = np.meshgrid(X, Y)\nZ = np.sin(np.sqrt(X**2 + Y**2))\nfig, ax = plt.subplots()\ncf = ax.contourf(X, Y, Z, levels=40, cmap='viridis')\nfig.colorbar(cf, ax=ax)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n热力图（imshow）适合规则网格数据或图像显示：ax.imshow(array, origin='lower', cmap='hot')\n\n\n# 3.4 向量场（Quiver）\n\nx = np.linspace(0, 2*np.pi, 20)\ny = np.linspace(0, 2*np.pi, 20)\nX, Y = np.meshgrid(x, y)\nU = np.cos(X)\nV = np.sin(Y)\nfig, ax = plt.subplots()\nax.quiver(X, Y, U, V)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.5 3D 绘图（简要）\n\n启用 3D 投影：ax = fig.add_subplot(111, projection='3d')，然后使用 plot3D、scatter3D、plot_surface 等。\n\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot3D(x, y, z)\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 四、美化与增强（提高可读性与出版级图表）\n\n\n# 4.1 坐标轴与刻度控制\n\nax.set_xlim(0, 10)\nax.set_ylim(-1.5, 1.5)\nax.set_xticks([0, 2, 4, 6, 8, 10])\nax.set_xticklabels(['0','2','4','6','8','10'], rotation=45)\n\n\n1\n2\n3\n4\n\n\n进阶：使用 matplotlib.ticker 中的 MaxNLocator, AutoMinorLocator, FuncFormatter 来精细控制刻度。\n\n\n# 4.2 边框（Spines）与坐标比例\n\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.set_aspect('equal')\n\n\n1\n2\n3\n\n\n\n# 4.3 图例（Legend）\n\nax.legend(loc='best', fontsize=10, frameon=False)\n# 合并多个 axes 的 legend 示例\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines + lines2, labels + labels2, loc='best')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4 文本与注释（text / annotate）\n\nax.text(0.1, 0.9, '注释示例', transform=ax.transAxes)\nax.annotate('峰值', xy=(x0,y0), xytext=(x0+0.5,y0+0.5),\n            arrowprops=dict(arrowstyle='->', lw=1.5))\n\n\n1\n2\n3\n\n\n注意 transform：可使用 ax.transAxes（以轴为坐标，0-1）或 ax.transData（数据坐标）。\n\n\n# 4.5 数学公式（MathText）\n\n使用 $...$ 包裹 LaTeX 风格表达式：\n\nax.set_title(r'$E=mc^2$')\nax.set_ylabel(r'$\\alpha + \\beta x$')\n\n\n1\n2\n\n\n\n# 4.6 颜色与色图（colormap）\n\n * 常用 colormap：viridis, plasma, inferno, magma, cividis, coolwarm 等。\n * plt.cm.get_cmap('viridis') 获取 colormap 对象。\n\nsc = ax.scatter(x, y, c=vals, cmap='plasma')\nfig.colorbar(sc, ax=ax)\n\n\n1\n2\n\n\n\n# 4.7 图像读写（imread / imsave / imshow）\n\nimport matplotlib.image as mpimg\nimg = mpimg.imread('image.png')\nax.imshow(img, origin='lower')\nplt.imsave('out.png', img)\n\n\n1\n2\n3\n4\n\n\n\n# 4.8 坐标转换（Transforms）\n\n常用变换对象：\n\n * ax.transData（数据坐标）\n * ax.transAxes（轴坐标，范围 0-1）\n * fig.transFigure（图形坐标）\n\n使用例子：在轴内比例位置添加文本 ax.text(0.5, 0.1, 'foo', transform=ax.transAxes)。",normalizedContent:"# matplotlib 模块\n\n\n# matplotlib 简介\n\nmatplotlib 是 python 中最常用的可视化库之一，尤其是其中的 pyplot 模块， 提供了类似 matlab 的绘图接口。它适合快速绘制折线图、散点图、柱状图、直方图、饼图等， 并且可以对图像进行灵活的修饰（标题、坐标轴、图例、网格、子图等）。\n\n特点：\n\n * 功能全面：支持常见 2d 图表和部分 3d 图表\n * 使用灵活：可以快捷调用 pyplot 画图，也可以精细控制 figure 和 axes\n * 与 numpy / pandas / scipy 无缝结合\n * 丰富的自定义：颜色、线型、标记、布局等均可调整\n\n通常的下载方法：\n\npip install matplotlib\n\n\n1\n\n\n----------------------------------------\n\n\n# 一、绘图基础\n\n\n# 1.1 导入与接口风格\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n1\n2\n\n\nmatplotlib 常见有两种接口风格：\n\n * pyplot（状态机）接口：plt.plot(...)，快捷，适合交互与一次性小图。类似 matlab 风格。\n * 面向对象（oo）接口：先创建 figure / axes，然后在 axes 上调用方法（如 ax.plot(...)）。更灵活、适合复杂布局和脚本化绘图。\n\n建议以 oo 接口为主，必要时在交互中使用 plt 快捷方法。\n\n\n# 1.2 figure / axes / axis 概念\n\n * figure：整个图像（画布）。\n * axes：绘图区域（包含坐标轴、刻度、标题、图例等）。一个 figure 可包含多个 axes。\n * axis：坐标轴（x、y、z），负责刻度和刻度标签。\n\n创建方式：\n\nfig, ax = plt.subplots(figsize=(8,5), dpi=100)\n# 多子图\nfig, axes = plt.subplots(2, 2, figsize=(10,8))\n\n\n1\n2\n3\n\n\nfigsize 单位为英寸 (inch)，图像像素大小 = figsize * dpi。tight_layout() 或 constrained_layout=true 用于自动调整子图间距。\n\n\n# 1.3 显示与保存\n\nplt.show()  # 在交互式环境显示\nfig.savefig('out.png', dpi=300, bbox_inches='tight', transparent=false)\n\n\n1\n2\n\n\n常用 savefig 参数：\n\n * dpi：分辨率\n * bbox_inches='tight'：紧凑边界，避免标签被截断\n * transparent=true：透明背景（适合嵌入网页）\n\n----------------------------------------\n\n\n# 二、常见图表（函数归纳 + 示例）\n\n> 每个小节都给出常用参数与最小示例。\n\n\n# 2.1 折线图（line plot）\n\n函数：ax.plot(x, y, **kwargs)\n\n常用参数：color/c、linestyle/ls、linewidth/lw、marker、markersize/ms、label\n\nx = np.linspace(0, 2*np.pi, 200)\ny = np.sin(x)\nfig, ax = plt.subplots()\nax.plot(x, y, label=r'$y=\\sin x$', lw=2, ls='-', marker=none)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n备注：可绘多条线，常与 ax.fill_between（区域填充）配合。\n\n\n# 2.2 散点图（scatter）\n\n函数：ax.scatter(x, y, c=none, s=none, marker=none, cmap=none, alpha=none)\n\n * c：颜色或数值数组（配合 cmap）\n * s：点大小（或数组）\n * alpha：透明度\n\nx = np.random.rand(100)\ny = np.random.rand(100)\ns = 50 * np.random.rand(100)\nfig, ax = plt.subplots()\nax.scatter(x, y, c=y, s=s, cmap='viridis', alpha=0.8)\nax.set_title('scatter example')\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 柱状图（bar）\n\n函数：ax.bar(x, height, width=0.8, bottom=none, align='center', **kwargs) 或 ax.barh（水平柱状）\n\n * 分组条形图：移动 x 的偏移量；堆叠条形图：使用 bottom 指定下边界\n\nlabels = ['a','b','c']\nval1 = [10, 15, 7]\nval2 = [5, 8, 3]\nind = np.arange(len(labels))\nwidth = 0.35\nfig, ax = plt.subplots()\nax.bar(ind - width/2, val1, width, label='g1')\nax.bar(ind + width/2, val2, width, label='g2')\nax.set_xticks(ind)\nax.set_xticklabels(labels)\nax.legend()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n堆叠示例：ax.bar(x, val1); ax.bar(x, val2, bottom=val1)\n\n\n# 2.4 直方图（histogram）\n\n函数：ax.hist(data, bins=10, range=none, density=false, histtype='bar', alpha=0.7)\n\n * density=true 将 y 转为概率密度\n * bins 可为整数或序列（自定义切分区间）\n\ndata = np.random.normal(loc=0, scale=1, size=1000)\nfig, ax = plt.subplots()\nax.hist(data, bins=30, density=true, alpha=0.6)\n\n\n1\n2\n3\n\n\n\n# 2.5 饼图（pie）\n\n函数：ax.pie(sizes, labels=none, autopct=none, startangle=0, explode=none)\n\n * autopct='%.1f%%' 自动显示百分比\n\nsizes = [30, 45, 25]\nlabels = ['a','b','c']\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%.1f%%', startangle=90)\nax.axis('equal')  # 使饼图为圆形\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.6 箱型图（boxplot）\n\n函数：ax.boxplot(data, notch=false, patch_artist=false)\n\n * 展示中位数、四分位、异常值\n\ndata = [np.random.normal(i, 1, 200) for i in range(3)]\nfig, ax = plt.subplots()\nax.boxplot(data, labels=['g1','g2','g3'])\n\n\n1\n2\n3\n\n\n\n# 2.7 小提琴图（violinplot）\n\n函数：ax.violinplot(dataset, showmeans=false, showmedians=true)\n\n * 能显示数据分布的核密度估计，比箱型图更直观地展现分布形态\n\nfig, ax = plt.subplots()\nax.violinplot(data)\nax.set_xticks([1,2,3])\nax.set_xticklabels(['g1','g2','g3'])\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 三、进阶绘图\n\n\n# 3.1 双轴（twinx / twiny）\n\n> 用于 x 轴共享但 y 轴单位不同的情况。\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax1.plot(x, y1, 'g-', label='y1')\nax2.plot(x, y2, 'b--', label='y2')\n\n\n1\n2\n3\n4\n\n\n要注意图例可分别处理或手动合并图例条目。\n\n\n# 3.2 多子图与布局控制\n\n * plt.subplots(nrows, ncols, figsize=...)\n * gridspec / plt.subplot2grid：更灵活的网格控制\n * constrained_layout=true 或 fig.tight_layout()：自动收紧布局\n\nfrom matplotlib.gridspec import gridspec\nfig = plt.figure(figsize=(8,6))\ngs = gridspec(3, 3, figure=fig)\nax_main = fig.add_subplot(gs[0:2, :])\nax_bottom = fig.add_subplot(gs[2, :])\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.3 等高线（contour）与热力图（heatmap）\n\nx = np.linspace(-3, 3, 200)\ny = np.linspace(-3, 3, 200)\nx, y = np.meshgrid(x, y)\nz = np.sin(np.sqrt(x**2 + y**2))\nfig, ax = plt.subplots()\ncf = ax.contourf(x, y, z, levels=40, cmap='viridis')\nfig.colorbar(cf, ax=ax)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n热力图（imshow）适合规则网格数据或图像显示：ax.imshow(array, origin='lower', cmap='hot')\n\n\n# 3.4 向量场（quiver）\n\nx = np.linspace(0, 2*np.pi, 20)\ny = np.linspace(0, 2*np.pi, 20)\nx, y = np.meshgrid(x, y)\nu = np.cos(x)\nv = np.sin(y)\nfig, ax = plt.subplots()\nax.quiver(x, y, u, v)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.5 3d 绘图（简要）\n\n启用 3d 投影：ax = fig.add_subplot(111, projection='3d')，然后使用 plot3d、scatter3d、plot_surface 等。\n\nfrom mpl_toolkits.mplot3d import axes3d\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot3d(x, y, z)\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 四、美化与增强（提高可读性与出版级图表）\n\n\n# 4.1 坐标轴与刻度控制\n\nax.set_xlim(0, 10)\nax.set_ylim(-1.5, 1.5)\nax.set_xticks([0, 2, 4, 6, 8, 10])\nax.set_xticklabels(['0','2','4','6','8','10'], rotation=45)\n\n\n1\n2\n3\n4\n\n\n进阶：使用 matplotlib.ticker 中的 maxnlocator, autominorlocator, funcformatter 来精细控制刻度。\n\n\n# 4.2 边框（spines）与坐标比例\n\nax.spines['top'].set_visible(false)\nax.spines['right'].set_visible(false)\nax.set_aspect('equal')\n\n\n1\n2\n3\n\n\n\n# 4.3 图例（legend）\n\nax.legend(loc='best', fontsize=10, frameon=false)\n# 合并多个 axes 的 legend 示例\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines + lines2, labels + labels2, loc='best')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.4 文本与注释（text / annotate）\n\nax.text(0.1, 0.9, '注释示例', transform=ax.transaxes)\nax.annotate('峰值', xy=(x0,y0), xytext=(x0+0.5,y0+0.5),\n            arrowprops=dict(arrowstyle='->', lw=1.5))\n\n\n1\n2\n3\n\n\n注意 transform：可使用 ax.transaxes（以轴为坐标，0-1）或 ax.transdata（数据坐标）。\n\n\n# 4.5 数学公式（mathtext）\n\n使用 $...$ 包裹 latex 风格表达式：\n\nax.set_title(r'$e=mc^2$')\nax.set_ylabel(r'$\\alpha + \\beta x$')\n\n\n1\n2\n\n\n\n# 4.6 颜色与色图（colormap）\n\n * 常用 colormap：viridis, plasma, inferno, magma, cividis, coolwarm 等。\n * plt.cm.get_cmap('viridis') 获取 colormap 对象。\n\nsc = ax.scatter(x, y, c=vals, cmap='plasma')\nfig.colorbar(sc, ax=ax)\n\n\n1\n2\n\n\n\n# 4.7 图像读写（imread / imsave / imshow）\n\nimport matplotlib.image as mpimg\nimg = mpimg.imread('image.png')\nax.imshow(img, origin='lower')\nplt.imsave('out.png', img)\n\n\n1\n2\n3\n4\n\n\n\n# 4.8 坐标转换（transforms）\n\n常用变换对象：\n\n * ax.transdata（数据坐标）\n * ax.transaxes（轴坐标，范围 0-1）\n * fig.transfigure（图形坐标）\n\n使用例子：在轴内比例位置添加文本 ax.text(0.5, 0.1, 'foo', transform=ax.transaxes)。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"},{title:"Home",frontmatter:{home:!0,heroImage:"/img/base/LOGO.png",tagline:"以工程视角览之技术。",heroText:"原码纪事",actionText:"开始浏览 →",actionLink:"/pages/Notes/",bannerBg:"none",postList:"simple",features:[{title:"博客笔记",details:"带来不一样的你",link:"/pages/Notes/"},{title:"项目",details:"工程速览",link:"/pages/Projects/"},{title:"吐槽",details:"世上本来没有吐槽，只因吐的人多了...",link:"/pages/Teasting/"}]},regularPath:"/",relativePath:"index.md",key:"v-58b44ebe",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2026/02/22, 21:14:18"},{title:"留言板",frontmatter:{title:"留言板",date:"2025-05-25T18:38:46.000Z",permalink:"/message-board"},regularPath:"/message_board/%E7%95%99%E8%A8%80%E6%9D%BF.html",relativePath:"message_board/留言板.md",key:"v-c9bd4b28",path:"/message-board/",headersStr:null,content:"你可以在这里留下想说的内容。",normalizedContent:"你可以在这里留下想说的内容。",charsets:{cjk:!0},lastUpdated:"2026/02/22, 21:14:18"}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"博客笔记",link:"/pages/Notes/"},{text:"工程",link:"/pages/Projects/"},{text:"吐槽",link:"/pages/Teasting/"},{text:"留言板",link:"/message-board/"},{text:"我的博客",link:"https://blog.yuanmajishi.top/"}],sidebarDepth:2,logo:"/img/base/bar.png",searchMaxSuggestions:10,lastUpdated:"上次更新",editLinks:!0,docsDir:"docs",docsBranch:"main",editLinkText:"帮助我们改善此页面",searchPlaceholder:"按下 𝑺 搜索",comment:!1,category:!1,tag:!1,sidebar:{"/01.Verilog HDL/":[["1.Verilog HDL时序电路的基本元件设计.md","HDL01.Verilog HDL 时序电路的基本元件设计","/pages/Verilog_01/"],["2.Verilog HDL有限状态机（FSM）设计基础.md","HDL02.Verilog HDL有限状态机（FSM）设计基础","/pages/Verilog_02/"],["3.testBench的编写规范.md","HDL03.testBench的编写规范","/pages/Verilog_03/"]],catalogue:{},"/02.Neural Networks/":[["01.About_Linear_NN.md","NN 01.关于线性网络的研究和记录","/pages/NN_01/"],["02.Loss_Functions.md","NN 02.若干损失函数的研究","/pages/NN_02/"],["03.Activate_Function.md","NN 03.若干激活函数的研究","/pages/NN_03/"],["04.Conv_Lenet.md","NN 04.卷积和LeNet神经网络","/pages/NN_04/"],["05.AlexNet_blocks.md","NN 05.AlexNet 与使用“块”的神经网络","/pages/NN_05/"],["06.Parallel_Deeper_NN.md","NN 06.并行块和深度神经网络的深究解释","/pages/NN_06/"]],"/03.FPGA/":[["01.LED_Light_to_flow.md","FPGA 01.一次最小的FPGA工程构建-从闪烁到流水","/pages/FPGA_01/"],["02.keys.md","FPGA 02.按键不是输入信号，而是一段时间——一次关于消抖的记录","/pages/FPGA_02/"],["03.PWM.md","FPGA 03.我与 PWM 的爱恨情仇","/pages/FPGA_03/"],["04.USART.md","FPGA 04.串口通信","/pages/FPGA_04/"],["05.IP.md","FPGA 05.IP 核的基本使用与注意事项","/pages/FPGA_05/"],["06.PLL.md","FPGA 06.PLL 锁相环的认识","/pages/FPGA_06/"],["07.FIFO_ROM_RAM.md","FPGA 07.FIFO、ROM、RAM理解","/pages/FPGA_07/"]],"/04.PCB Layout/":[["01.PCB_Layout_Design_Process.md","Layout 01.PCB设计的流程概述","/pages/PCB_01/"],["02.Impedence.md","Layout 02.阻抗","/pages/PCB_02/"],["03.Design_Specification.md","Layout 03.常用模块的PCB绘制要点","/pages/PCB_03/"]],"/05.IC-focused Universal Linux/":[["01.Linux_System_Info.md","01.Linux运行原理","/pages/Linux_01/"],["02.Linux_systemctl.md","02.进程管理","/pages/Linux_02/"],["03.useofshell.md","03.Shell结构","/pages/Linux_03/"],["04.text_process.md","04.文本处理","/pages/Linux_04/"],["05.shell_programming.md","05.Shell编程","/pages/Linux_05/"]],"/06.Rust/":[["00.Rust的基本素养.md","00.Rust的基本素养","/pages/Rust_00/"],["01.Rust的变量与可变性.md","01.Rust的变量与可变性","/pages/Rust_01/"],["02.Rust的数据类型.md","02.Rust的数据类型","/pages/Rust_02/"],["03.Rust的函数和注释.md","03.Rust的函数与注释","/pages/Rust_03/"],["04.Rust的控制流.md","04.Rust的控制流","/pages/Rust_04/"],["05.Rust的所有权概念.md","05.Rust的所有权概念","/pages/Rust_05/"],["06.Rust的引用和借用.md","06.Rust的引用和借用","/pages/Rust_06/"],["07.Rust的Slice类型.md","07.Rust的切片（Slice）","/pages/Rust_07/"],["08.Rust的结构体类型.md","08.Rust的结构体类型","/pages/Rust_08/"],["09.Rust的结构体的打印与调试.md","09.Rust的结构体的打印与调试","/pages/Rust_09/"],["10.Rust的方法.md","10.Rust的方法","/pages/Rust_10/"],["11.Rust的枚举.md","11.Rust的枚举","/pages/Rust_11/"],["12.Rust的match控制流结构.md","12.Rust的match控制流结构","/pages/Rust_12/"],["13.Rust的语法糖-iflet.md","13.Rust 的语法糖 - if let","/pages/Rust_13/"],["14.Rust的模块系统.md","14.Rust的模块系统","/pages/Rust_14/"],["15.Rust的Vector.md","15.Rust的Vector","/pages/Rust_15/"],["16.Rust的String类型基本原理.md","16.Rust的String类型基本原理","/pages/Rust_16/"],["17.Rust的HashMap.md","17.Rust的HashMap","/pages/Rust_17/"]],"/07.python/":[["01.numpy 模块.md","01.numpy 模块","/pages/Python_01/"],["02.pandas 模块.md","02.pandas 模块","/pages/Python_02/"],["03.matplotlib 模块.md","03.matplotlib 模块","/pages/Python_03/"]]},pageStyle:"line",updateBar:{showToArticle:!1},author:{name:"猎户f",link:"https://github.com/liehuf/"},social:{icons:[{iconClass:"icon-github",title:"GitHub",link:"https://github.com/liehuf"},{iconClass:"icon-youjian",title:"发邮件",link:"mailto:17715076182@163.com"},{iconClass:"icon-csdn",title:"CSDN",link:"https://blog.csdn.net/liehuf"},{iconClass:"icon-zhihu",title:"知乎",link:"https://www.zhihu.com/people/44-97-46-49"}]},footer:{createYear:2025,copyrightInfo:'liehuf | <a href="https://github.com/liehuf/liehuf-notes/blob/main/LICENSE" target="_blank">MIT License</a>'}}};var ul=t(72),cl=t(128),dl=t(129),pl=t(20);var fl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(pl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(pl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(pl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(pl.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(pl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Wt.component(cl.default),Wt.component(dl.default);function hl(n){return n.toString().padStart(2,"0")}t(288);Wt.component("FloatingSocialIcons",()=>Promise.resolve().then(t.bind(null,72))),Wt.component("GiscusComment",()=>t.e(5).then(t.bind(null,427))),Wt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,428))),Wt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,128))),Wt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,129)));t(289);var ml={props:{color:{required:!1,default:"rgb(66, 185, 131)"}}},gl=(t(290),Object(al.a)(ml,(function(){return(0,this._self._c)("div",{staticClass:"spinner",style:{background:this.color}})}),[],!1,null,"1bbcb91a",null).exports);const vl={name:"Mermaid",props:{id:{type:String,required:!1,default:()=>"diagram_"+Date.now()},graph:{type:String,required:!1}},data:()=>({svg:void 0}),computed:{graphData(){return this.graph?this.graph:this.$slots.default[0].text}},render(n){return void 0===this.svg?n("Loading"):n("div",{class:["mermaid-diagram"],domProps:{innerHTML:this.svg,style:"width: 100%"}})},mounted(){t.e(57).then(t.t.bind(null,373,7)).then(n=>{n.initialize({startOnLoad:!0}),n.render(this.id,this.graphData,n=>{this.svg=n})})},components:{Loading:gl}};var _l={name:"Eqn"},bl=Object(al.a)(_l,(function(){return(0,this._self._c)("div",{staticClass:"vuepress-eqn"},[this._t("default")],2)}),[],!1,null,null,null).exports,xl={name:"Eq"},yl=Object(al.a)(xl,(function(){return(0,this._self._c)("span",{staticClass:"vuepress-eq"},[this._t("default")],2)}),[],!1,null,null,null).exports,wl=[({Vue:n,options:e,router:t,siteData:r})=>{n.component("FloatingSocialIcons",ul.default),n.mixin({mounted(){"undefined"!=typeof window&&this.$nextTick(()=>{this.addFloatingSocialIcons()})},methods:{addFloatingSocialIcons(){if(document.querySelector(".floating-social-icons"))return;const e=document.createElement("div");e.id="floating-social-container";const t=new(n.extend(ul.default));t.$mount(),e.appendChild(t.$el),document.body.appendChild(e)}}})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${hl(n.getUTCMonth()+1)}-${hl(n.getUTCDate())} ${hl(n.getUTCHours())}:${hl(n.getUTCMinutes())}:${hl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(fl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n})=>{n.component(vl.name,vl)},({Vue:n})=>{n.component("Eqn",bl),n.component("Eq",yl)}],kl=[];class Tl extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Tl.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:us,getVueComponent:cs});var Sl={install(n){const e=new Tl;n.$vuepress=e,n.prototype.$vuepress=e}};function Pl(n,e){return n.options.routes.filter(n=>n.path.toLowerCase()===e.toLowerCase()).length>0}var Rl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ps("pageKey",e),Wt.component(e)||Wt.component(e,ss(e)),Wt.component(e)?n(e):n("")}},Il={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Cl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},zl=(t(291),t(292),Object(al.a)(Cl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Al={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(Vo),Wt.use(Sl),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ll)),Wt.component("Content",Rl),Wt.component("ContentSlotsDistributor",Il),Wt.component("OutboundLink",zl),Wt.component("ClientOnly",Al),Wt.component("Layout",ls("Layout")),Wt.component("NotFound",ls("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.0",hash:"ea17910"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ll.routerBase||ll.base,t=new Vo({base:e,mode:"history",fallback:!1,routes:sl,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Pl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Pl(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";Pl(n,i)?r(i):Pl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(wl.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:ll,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},kl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);